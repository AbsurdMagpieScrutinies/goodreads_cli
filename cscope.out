cscope 15 /bench/github_local/gr -c 0001786031
	@./env/lib/python3.7/site-packages/pkg_resources/py31compat.py

1 import 
	~os

2 import 
	~errno

3 import 
	~sys

5 from . 
	~extern
 import 
six

8 def 
	$_makedirs_31
 ( 
path
 , 
exist_ok
 = False ) :

10 
os
 . 
makedirs
 ( 
path
 )

11 except 
OSError
 as 
exc
 :

12 if not 
exist_ok
 or 
exc
 . 
errno
 != 
errno
 . 
EEXIST
 :

13 raise 
	}

19 
needs_makedirs
 = (

20 
six
 . 
PY2
 or

21 ( 3 , 4 ) <= 
sys
 . 
version_info
 < ( 3 , 4 , 1 )

23 
makedirs
 = 
_makedirs_31
 if 
needs_makedirs
 else 
os
 . 
makedirs


	@./env/lib/python3.7/site-packages/pkg_resources/__init__.py

18 from 
	~__future__
 import 
absolute_import

20 import 
	~sys

21 import 
	~os

22 import 
	~io

23 import 
	~time

24 import 
	~re

25 import 
	~types

26 import 
	~zipfile

27 import 
	~zipimport

28 import 
	~warnings

29 import 
	~stat

30 import 
	~functools

31 import 
	~pkgutil

32 import 
	~operator

33 import 
	~platform

34 import 
	~collections

35 import 
	~plistlib

36 import 
	~email.parser

37 import 
	~errno

38 import 
	~tempfile

39 import 
	~textwrap

40 import 
	~itertools

41 import 
	~inspect

42 import 
	~ntpath

43 import 
	~posixpath

44 from 
	~pkgutil
 import 
get_importer

47 import 
	~_imp

48 except 
ImportError
 :

50 import 
	~imp
 as 
_imp

53 
FileExistsError

54 except 
NameError
 :

55 
FileExistsError
 = 
OSError

57 from 
	~pkg_resources.extern
 import 
six

58 from 
	~pkg_resources.extern.six.moves
 import 
urllib
 , 
map
 , 
filter

61 from 
	~os
 import 
utime

63 from 
	~os
 import 
mkdir
 , 
rename
 , 
unlink

64 
WRITE_SUPPORT
 = True

65 except 
ImportError
 :

67 
WRITE_SUPPORT
 = False

69 from 
	~os
 import 
open
 as 
os_open

70 from 
	~os.path
 import 
isdir
 , 
split

73 import 
	~importlib.machinery
 as 
importlib_machinery

75 
importlib_machinery
 . 
__name__

76 except 
ImportError
 :

77 
importlib_machinery
 = None

79 from . import 
py31compat

80 from 
	~pkg_resources.extern
 import 
appdirs

81 from 
	~pkg_resources.extern
 import 
packaging

82 
__import__
 ( 'pkg_resources.extern.packaging.version' )

83 
__import__
 ( 'pkg_resources.extern.packaging.specifiers' )

84 
__import__
 ( 'pkg_resources.extern.packaging.requirements' )

85 
__import__
 ( 'pkg_resources.extern.packaging.markers' )

88 
__metaclass__
 = 
type

91 if ( 3 , 0 ) < 
sys
 . 
version_info
 < ( 3 , 4 ) :

92 raise 
RuntimeError
 ( "Python 3.4 or later is required" )

94 if 
six
 . 
PY2
 :

96 
PermissionError
 = None

97 
NotADirectoryError
 = None

101 
require
 = None

102 
working_set
 = None

103 
add_activation_listener
 = None

104 
resources_stream
 = None

105 
cleanup_resources
 = None

106 
resource_dir
 = None

107 
resource_stream
 = None

108 
set_extraction_path
 = None

109 
resource_isdir
 = None

110 
resource_string
 = None

111 
iter_entry_points
 = None

112 
resource_listdir
 = None

113 
resource_filename
 = None

114 
resource_exists
 = None

115 
_distribution_finders
 = None

116 
_namespace_handlers
 = None

117 
_namespace_packages
 = None

120 class 
	cPEP440Warning
 ( 
RuntimeWarning
 ) :

127 def 
	$parse_version
 ( 
v
 ) :

129 return 
packaging
 . 
version
 . 
Version
 ( 
v
 )

130 except 
packaging
 . 
version
 . 
InvalidVersion
 :

131 return 
packaging
 . 
version
 . 
LegacyVersion
 ( 
v
 ) 
	}

134 
_state_vars
 = { }

137 def 
	$_declare_state
 ( 
vartype
 , ** 
kw
 ) :

138 
globals
 ( ) . 
update
 ( 
kw
 )

139 
_state_vars
 . 
update
 ( 
dict
 . 
fromkeys
 ( 
kw
 , 
vartype
 ) ) 
	}

142 def 
	$__getstate__
 ( ) :

143 
state
 = { }

144 
g
 = 
globals
 ( )

145 for 
k
 , 
v
 in 
_state_vars
 . 
items
 ( ) :

146 
state
 [ 
k
 ] = 
g
 [ '_sget_' + 
v
 ] ( 
g
 [ 
k
 ] )

147 return 
state
 
	}

150 def 
	$__setstate__
 ( 
state
 ) :

151 
g
 = 
globals
 ( )

152 for 
k
 , 
v
 in 
state
 . 
items
 ( ) :

153 
g
 [ '_sset_' + 
_state_vars
 [ 
k
 ] ] ( 
k
 , 
g
 [ 
k
 ] , 
v
 )

154 return 
state
 
	}

157 def 
	$_sget_dict
 ( 
val
 ) :

158 return 
val
 . 
copy
 ( ) 
	}

161 def 
	$_sset_dict
 ( 
key
 , 
ob
 , 
state
 ) :

162 
ob
 . 
clear
 ( )

163 
ob
 . 
update
 ( 
state
 ) 
	}

166 def 
	$_sget_object
 ( 
val
 ) :

167 return 
val
 . 
__getstate__
 ( ) 
	}

170 def 
	$_sset_object
 ( 
key
 , 
ob
 , 
state
 ) :

171 
ob
 . 
__setstate__
 ( 
state
 ) 
	}

174 
_sget_none
 = 
_sset_none
 = lambda * 
args
 : None

177 def 
	$get_supported_platform
 ( ) :

190 
plat
 = 
get_build_platform
 ( )

191 
m
 = 
macosVersionString
 . 
match
 ( 
plat
 )

192 if 
m
 is not None and 
sys
 . 
platform
 == "darwin" :

194 
plat
 = 'macosx-%s-%s' % ( '.' . 
join
 ( 
_macosx_vers
 ( ) [ : 2 ] ) , 
m
 . 
group
 ( 3 ) )

195 except 
ValueError
 :

198 return 
plat
 
	}

201 
__all__
 = [ 'require'

251 class 
	cResolutionError
 ( 
Exception
 ) :

254 def 
	$__repr__
 ( 
self
 ) :

255 return 
self
 . 
__class__
 . 
__name__
 + 
repr
 ( 
self
 . 
args
 ) 
	}

258 class 
	cVersionConflict
 ( 
ResolutionError
 ) :

266 
_template
 = "{self.dist} is installed but {self.req} is required"

268 @ 
property

269 def 
	$dist
 ( 
self
 ) :

270 return 
self
 . 
args
 [ 0 ] 
	}

272 @ 
property

273 def 
	$req
 ( 
self
 ) :

274 return 
self
 . 
args
 [ 1 ] 
	}

276 def 
	$report
 ( 
self
 ) :

277 return 
self
 . 
_template
 . 
format
 ( ** 
locals
 ( ) ) 
	}

279 def 
	$with_context
 ( 
self
 , 
required_by
 ) :

284 if not 
required_by
 :

285 return 
self

286 
args
 = 
self
 . 
args
 + ( 
required_by
 , )

287 return 
ContextualVersionConflict
 ( * 
args
 ) 
	}

290 class 
	cContextualVersionConflict
 ( 
VersionConflict
 ) :

296 
_template
 = 
VersionConflict
 . 
_template
 + ' by {self.required_by}'

298 @ 
property

299 def 
	$required_by
 ( 
self
 ) :

300 return 
self
 . 
args
 [ 2 ] 
	}

303 class 
	cDistributionNotFound
 ( 
ResolutionError
 ) :

306 
_template
 = ( "The '{self.req}' distribution was not found " "and is required by {self.requirers_str}"

309 @ 
property

310 def 
	$req
 ( 
self
 ) :

311 return 
self
 . 
args
 [ 0 ] 
	}

313 @ 
property

314 def 
	$requirers
 ( 
self
 ) :

315 return 
self
 . 
args
 [ 1 ] 
	}

317 @ 
property

318 def 
	$requirers_str
 ( 
self
 ) :

319 if not 
self
 . 
requirers
 :

321 return ', ' . 
join
 ( 
self
 . 
requirers
 ) 
	}

323 def 
	$report
 ( 
self
 ) :

324 return 
self
 . 
_template
 . 
format
 ( ** 
locals
 ( ) ) 
	}

326 def 
	$__str__
 ( 
self
 ) :

327 return 
self
 . 
report
 ( ) 
	}

330 class 
	cUnknownExtra
 ( 
ResolutionError
 ) :

334 
_provider_factories
 = { }

336 
PY_MAJOR
 = 
sys
 . 
version
 [ : 3 ]

337 
EGG_DIST
 = 3

338 
BINARY_DIST
 = 2

339 
SOURCE_DIST
 = 1

340 
CHECKOUT_DIST
 = 0

341 
DEVELOP_DIST
 = - 1

344 def 
	$register_loader_type
 ( 
loader_type
 , 
provider_factory
 ) :

351 
_provider_factories
 [ 
loader_type
 ] = 
provider_factory
 
	}

354 def 
	$get_provider
 ( 
moduleOrReq
 ) :

356 if 
isinstance
 ( 
moduleOrReq
 , 
Requirement
 ) :

357 return 
working_set
 . 
find
 ( 
moduleOrReq
 ) or 
require
 ( 
str
 ( 
moduleOrReq
 ) ) [ 0 ]

359 
module
 = 
sys
 . 
modules
 [ 
moduleOrReq
 ]

360 except 
KeyError
 :

361 
__import__
 ( 
moduleOrReq
 )

362 
module
 = 
sys
 . 
modules
 [ 
moduleOrReq
 ]

363 
loader
 = 
getattr
 ( 
module
 , '__loader__' , None )

364 return 
_find_adapter
 ( 
_provider_factories
 , 
loader
 ) ( 
module
 ) 
	}

367 def 
	$_macosx_vers
 ( 
_cache
 = [ ] ) :

368 if not 
_cache
 :

369 
version
 = 
platform
 . 
mac_ver
 ( ) [ 0 ]

371 if 
version
 == '' :

372 
plist
 = '/System/Library/CoreServices/SystemVersion.plist'

373 if 
os
 . 
path
 . 
exists
 ( 
plist
 ) :

374 if 
hasattr
 ( 
plistlib
 , 'readPlist' ) :

375 
plist_content
 = 
plistlib
 . 
readPlist
 ( 
plist
 )

376 if 'ProductVersion' in 
plist_content
 :

377 
version
 = 
plist_content
 [ 'ProductVersion' ]

379 
_cache
 . 
append
 ( 
version
 . 
split
 ( '.' ) )

380 return 
_cache
 [ 0 ] 
	}

383 def 
	$_macosx_arch
 ( 
machine
 ) :

384 return { 'PowerPC' : 'ppc' , 'Power_Macintosh' : 'ppc' } . 
get
 ( 
machine
 , 
machine
 ) 
	}

387 def 
	$get_build_platform
 ( ) :

393 from 
	~sysconfig
 import 
get_platform

395 
plat
 = 
get_platform
 ( )

396 if 
sys
 . 
platform
 == "darwin" and not 
plat
 . 
startswith
 ( 'macosx-' ) :

398 
version
 = 
_macosx_vers
 ( )

399 
machine
 = 
os
 . 
uname
 ( ) [ 4 ] . 
replace
 ( " " , "_" )

401 
int
 ( 
version
 [ 0 ] ) , 
int
 ( 
version
 [ 1 ] ) ,

402 
_macosx_arch
 ( 
machine
 ) ,

404 except 
ValueError
 :

408 return 
plat
 
	}

411 
macosVersionString
 = 
re
 . 
compile
 ( r"macosx-(\d+)\.(\d+)-(.*)" )

412 
darwinVersionString
 = 
re
 . 
compile
 ( r"darwin-(\d+)\.(\d+)\.(\d+)-(.*)" )

414 
get_platform
 = 
get_build_platform

417 def 
	$compatible_platforms
 ( 
provided
 , 
required
 ) :

424 if 
provided
 is None or 
required
 is None or 
provided
 == 
required
 :

429 
reqMac
 = 
macosVersionString
 . 
match
 ( 
required
 )

430 if 
reqMac
 :

431 
provMac
 = 
macosVersionString
 . 
match
 ( 
provided
 )

434 if not 
provMac
 :

438 
provDarwin
 = 
darwinVersionString
 . 
match
 ( 
provided
 )

439 if 
provDarwin
 :

440 
dversion
 = 
int
 ( 
provDarwin
 . 
group
 ( 1 ) )

441 
macosversion
 = "%s.%s" % ( 
reqMac
 . 
group
 ( 1 ) , 
reqMac
 . 
group
 ( 2 ) )

442 if 
dversion
 == 7 and 
macosversion
 >= "10.3" or

443 
dversion
 == 8 and 
macosversion
 >= "10.4" :

449 if 
provMac
 . 
group
 ( 1 ) != 
reqMac
 . 
group
 ( 1 ) or

450 
provMac
 . 
group
 ( 3 ) != 
reqMac
 . 
group
 ( 3 ) :

454 if 
int
 ( 
provMac
 . 
group
 ( 2 ) ) > 
int
 ( 
reqMac
 . 
group
 ( 2 ) ) :

460 return False 
	}

463 def 
	$run_script
 ( 
dist_spec
 , 
script_name
 ) :

465 
ns
 = 
sys
 . 
_getframe
 ( 1 ) . 
f_globals

466 
name
 = 
ns
 [ '__name__' ]

467 
ns
 . 
clear
 ( )

468 
ns
 [ '__name__' ] = 
name

469 
require
 ( 
dist_spec
 ) [ 0 ] . 
run_script
 ( 
script_name
 , 
ns
 ) 
	}

473 
run_main
 = 
run_script

476 def 
	$get_distribution
 ( 
dist
 ) :

478 if 
isinstance
 ( 
dist
 , 
six
 . 
string_types
 ) :

479 
dist
 = 
Requirement
 . 
parse
 ( 
dist
 )

480 if 
isinstance
 ( 
dist
 , 
Requirement
 ) :

481 
dist
 = 
get_provider
 ( 
dist
 )

482 if not 
isinstance
 ( 
dist
 , 
Distribution
 ) :

483 raise 
TypeError
 ( "Expected string, Requirement, or Distribution" , 
dist
 )

484 return 
dist
 
	}

487 def 
	$load_entry_point
 ( 
dist
 , 
group
 , 
name
 ) :

489 return 
get_distribution
 ( 
dist
 ) . 
load_entry_point
 ( 
group
 , 
name
 ) 
	}

492 def 
	$get_entry_map
 ( 
dist
 , 
group
 = None ) :

494 return 
get_distribution
 ( 
dist
 ) . 
get_entry_map
 ( 
group
 ) 
	}

497 def 
	$get_entry_info
 ( 
dist
 , 
group
 , 
name
 ) :

499 return 
get_distribution
 ( 
dist
 ) . 
get_entry_info
 ( 
group
 , 
name
 ) 
	}

502 class 
	cIMetadataProvider
 :

503 def 
	$has_metadata
 ( 
name
 ) :

504 """Does the package's distribution contain the named metadata?""" 
	}

506 def 
	$get_metadata
 ( 
name
 ) :

507 """The named metadata resource as a string""" 
	}

509 def 
	$get_metadata_lines
 ( 
name
 ) :

513 
	}

515 def 
	$metadata_isdir
 ( 
name
 ) :

516 """Is the named metadata a directory?  (like ``os.path.isdir()``)""" 
	}

518 def 
	$metadata_listdir
 ( 
name
 ) :

519 """List of metadata names in the directory (like ``os.listdir()``)""" 
	}

521 def 
	$run_script
 ( 
script_name
 , 
namespace
 ) :

522 """Execute the named script in the supplied namespace dictionary""" 
	}

525 class 
	cIResourceProvider
 ( 
IMetadataProvider
 ) :

528 def 
	$get_resource_filename
 ( 
manager
 , 
resource_name
 ) :

531 
	}

533 def 
	$get_resource_stream
 ( 
manager
 , 
resource_name
 ) :

536 
	}

538 def 
	$get_resource_string
 ( 
manager
 , 
resource_name
 ) :

541 
	}

543 def 
	$has_resource
 ( 
resource_name
 ) :

544 """Does the package contain the named resource?""" 
	}

546 def 
	$resource_isdir
 ( 
resource_name
 ) :

547 """Is the named resource a directory?  (like ``os.path.isdir()``)""" 
	}

549 def 
	$resource_listdir
 ( 
resource_name
 ) :

550 """List of resource names in the directory (like ``os.listdir()``)""" 
	}

553 class 
	cWorkingSet
 :

556 def 
	$__init__
 ( 
self
 , 
entries
 = None ) :

558 
self
 . 
entries
 = [ ]

559 
self
 . 
entry_keys
 = { }

560 
self
 . 
by_key
 = { }

561 
self
 . 
callbacks
 = [ ]

563 if 
entries
 is None :

564 
entries
 = 
sys
 . 
path

566 for 
entry
 in 
entries
 :

567 
self
 . 
add_entry
 ( 
entry
 ) 
	}

569 @ 
classmethod

570 def 
	$_build_master
 ( 
cls
 ) :

574 
ws
 = 
cls
 ( )

576 from 
	~__main__
 import 
__requires__

577 except 
ImportError
 :

579 return 
ws

583 
ws
 . 
require
 ( 
__requires__
 )

584 except 
VersionConflict
 :

585 return 
cls
 . 
_build_from_requirements
 ( 
__requires__
 )

587 return 
ws
 
	}

589 @ 
classmethod

590 def 
	$_build_from_requirements
 ( 
cls
 , 
req_spec
 ) :

596 
ws
 = 
cls
 ( [ ] )

597 
reqs
 = 
parse_requirements
 ( 
req_spec
 )

598 
dists
 = 
ws
 . 
resolve
 ( 
reqs
 , 
Environment
 ( ) )

599 for 
dist
 in 
dists
 :

600 
ws
 . 
add
 ( 
dist
 )

603 for 
entry
 in 
sys
 . 
path
 :

604 if 
entry
 not in 
ws
 . 
entries
 :

605 
ws
 . 
add_entry
 ( 
entry
 )

608 
sys
 . 
path
 [ : ] = 
ws
 . 
entries

609 return 
ws
 
	}

611 def 
	$add_entry
 ( 
self
 , 
entry
 ) :

621 
self
 . 
entry_keys
 . 
setdefault
 ( 
entry
 , [ ] )

622 
self
 . 
entries
 . 
append
 ( 
entry
 )

623 for 
dist
 in 
find_distributions
 ( 
entry
 , True ) :

624 
self
 . 
add
 ( 
dist
 , 
entry
 , False ) 
	}

626 def 
	$__contains__
 ( 
self
 , 
dist
 ) :

628 return 
self
 . 
by_key
 . 
get
 ( 
dist
 . 
key
 ) == 
dist
 
	}

630 def 
	$find
 ( 
self
 , 
req
 ) :

640 
dist
 = 
self
 . 
by_key
 . 
get
 ( 
req
 . 
key
 )

641 if 
dist
 is not None and 
dist
 not in 
req
 :

643 raise 
VersionConflict
 ( 
dist
 , 
req
 )

644 return 
dist
 
	}

646 def 
	$iter_entry_points
 ( 
self
 , 
group
 , 
name
 = None ) :

654 
entry

655 for 
dist
 in 
self

656 for 
entry
 in 
dist
 . 
get_entry_map
 ( 
group
 ) . 
values
 ( )

657 if 
name
 is None or 
name
 == 
entry
 . 
name

658 ) 
	}

660 def 
	$run_script
 ( 
self
 , 
requires
 , 
script_name
 ) :

662 
ns
 = 
sys
 . 
_getframe
 ( 1 ) . 
f_globals

663 
name
 = 
ns
 [ '__name__' ]

664 
ns
 . 
clear
 ( )

665 
ns
 [ '__name__' ] = 
name

666 
self
 . 
require
 ( 
requires
 ) [ 0 ] . 
run_script
 ( 
script_name
 , 
ns
 ) 
	}

668 def 
	$__iter__
 ( 
self
 ) :

674 
seen
 = { }

675 for 
item
 in 
self
 . 
entries
 :

676 if 
item
 not in 
self
 . 
entry_keys
 :

680 for 
key
 in 
self
 . 
entry_keys
 [ 
item
 ] :

681 if 
key
 not in 
seen
 :

682 
seen
 [ 
key
 ] = 1

683 yield 
self
 . 
by_key
 [ 
key
 ] 
	}

685 def 
	$add
 ( 
self
 , 
dist
 , 
entry
 = None , 
insert
 = True , 
replace
 = False ) :

697 if 
insert
 :

698 
dist
 . 
insert_on
 ( 
self
 . 
entries
 , 
entry
 , 
replace
 = 
replace
 )

700 if 
entry
 is None :

701 
entry
 = 
dist
 . 
location

702 
keys
 = 
self
 . 
entry_keys
 . 
setdefault
 ( 
entry
 , [ ] )

703 
keys2
 = 
self
 . 
entry_keys
 . 
setdefault
 ( 
dist
 . 
location
 , [ ] )

704 if not 
replace
 and 
dist
 . 
key
 in 
self
 . 
by_key
 :

708 
self
 . 
by_key
 [ 
dist
 . 
key
 ] = 
dist

709 if 
dist
 . 
key
 not in 
keys
 :

710 
keys
 . 
append
 ( 
dist
 . 
key
 )

711 if 
dist
 . 
key
 not in 
keys2
 :

712 
keys2
 . 
append
 ( 
dist
 . 
key
 )

713 
self
 . 
_added_new
 ( 
dist
 ) 
	}

715 def 
	$resolve
 ( 
self
 , 
requirements
 , 
env
 = None , 
installer
 = None ,

716 
replace_conflicting
 = False , 
extras
 = None ) :

742 
requirements
 = 
list
 ( 
requirements
 ) [ : : - 1 ]

744 
processed
 = { }

746 
best
 = { }

747 
to_activate
 = [ ]

749 
req_extras
 = 
_ReqExtras
 ( )

753 
required_by
 = 
collections
 . 
defaultdict
 ( 
set
 )

755 while 
requirements
 :

757 
req
 = 
requirements
 . 
pop
 ( 0 )

758 if 
req
 in 
processed
 :

762 if not 
req_extras
 . 
markers_pass
 ( 
req
 , 
extras
 ) :

765 
dist
 = 
best
 . 
get
 ( 
req
 . 
key
 )

766 if 
dist
 is None :

768 
dist
 = 
self
 . 
by_key
 . 
get
 ( 
req
 . 
key
 )

769 if 
dist
 is None or ( 
dist
 not in 
req
 and 
replace_conflicting
 ) :

770 
ws
 = 
self

771 if 
env
 is None :

772 if 
dist
 is None :

773 
env
 = 
Environment
 ( 
self
 . 
entries
 )

778 
env
 = 
Environment
 ( [ ] )

779 
ws
 = 
WorkingSet
 ( [ ] )

780 
dist
 = 
best
 [ 
req
 . 
key
 ] = 
env
 . 
best_match
 (

781 
req
 , 
ws
 , 
installer
 ,

782 
replace_conflicting
 = 
replace_conflicting

784 if 
dist
 is None :

785 
requirers
 = 
required_by
 . 
get
 ( 
req
 , None )

786 raise 
DistributionNotFound
 ( 
req
 , 
requirers
 )

787 
to_activate
 . 
append
 ( 
dist
 )

788 if 
dist
 not in 
req
 :

790 
dependent_req
 = 
required_by
 [ 
req
 ]

791 raise 
VersionConflict
 ( 
dist
 , 
req
 ) . 
with_context
 ( 
dependent_req
 )

794 
new_requirements
 = 
dist
 . 
requires
 ( 
req
 . 
extras
 ) [ : : - 1 ]

795 
requirements
 . 
extend
 ( 
new_requirements
 )

798 for 
new_requirement
 in 
new_requirements
 :

799 
required_by
 [ 
new_requirement
 ] . 
add
 ( 
req
 . 
project_name
 )

800 
req_extras
 [ 
new_requirement
 ] = 
req
 . 
extras

802 
processed
 [ 
req
 ] = True

805 return 
to_activate
 
	}

807 def 
	$find_plugins
 (

808 
self
 , 
plugin_env
 , 
full_env
 = None , 
installer
 = None , 
fallback
 = True ) :

843 
plugin_projects
 = 
list
 ( 
plugin_env
 )

845 
plugin_projects
 . 
sort
 ( )

847 
error_info
 = { }

848 
distributions
 = { }

850 if 
full_env
 is None :

851 
env
 = 
Environment
 ( 
self
 . 
entries
 )

852 
env
 += 
plugin_env

854 
env
 = 
full_env
 + 
plugin_env

856 
shadow_set
 = 
self
 . 
__class__
 ( [ ] )

858 
list
 ( 
map
 ( 
shadow_set
 . 
add
 , 
self
 ) )

860 for 
project_name
 in 
plugin_projects
 :

862 for 
dist
 in 
plugin_env
 [ 
project_name
 ] :

864 
req
 = [ 
dist
 . 
as_requirement
 ( ) ]

867 
resolvees
 = 
shadow_set
 . 
resolve
 ( 
req
 , 
env
 , 
installer
 )

869 except 
ResolutionError
 as 
v
 :

871 
error_info
 [ 
dist
 ] = 
v

872 if 
fallback
 :

880 
list
 ( 
map
 ( 
shadow_set
 . 
add
 , 
resolvees
 ) )

881 
distributions
 . 
update
 ( 
dict
 . 
fromkeys
 ( 
resolvees
 ) )

886 
distributions
 = 
list
 ( 
distributions
 )

887 
distributions
 . 
sort
 ( )

889 return 
distributions
 , 
error_info
 
	}

891 def 
	$require
 ( 
self
 , * 
requirements
 ) :

900 
needed
 = 
self
 . 
resolve
 ( 
parse_requirements
 ( 
requirements
 ) )

902 for 
dist
 in 
needed
 :

903 
self
 . 
add
 ( 
dist
 )

905 return 
needed
 
	}

907 def 
	$subscribe
 ( 
self
 , 
callback
 , 
existing
 = True ) :

913 if 
callback
 in 
self
 . 
callbacks
 :

915 
self
 . 
callbacks
 . 
append
 ( 
callback
 )

916 if not 
existing
 :

918 for 
dist
 in 
self
 :

919 
callback
 ( 
dist
 ) 
	}

921 def 
	$_added_new
 ( 
self
 , 
dist
 ) :

922 for 
callback
 in 
self
 . 
callbacks
 :

923 
callback
 ( 
dist
 ) 
	}

925 def 
	$__getstate__
 ( 
self
 ) :

927 
self
 . 
entries
 [ : ] , 
self
 . 
entry_keys
 . 
copy
 ( ) , 
self
 . 
by_key
 . 
copy
 ( ) ,

928 
self
 . 
callbacks
 [ : ]

929 ) 
	}

931 def 
	$__setstate__
 ( 
self
 , 
e_k_b_c
 ) :

932 
entries
 , 
keys
 , 
by_key
 , 
callbacks
 = 
e_k_b_c

933 
self
 . 
entries
 = 
entries
 [ : ]

934 
self
 . 
entry_keys
 = 
keys
 . 
copy
 ( )

935 
self
 . 
by_key
 = 
by_key
 . 
copy
 ( )

936 
self
 . 
callbacks
 = 
callbacks
 [ : ] 
	}

939 class 
	c_ReqExtras
 ( 
dict
 ) :

944 def 
	$markers_pass
 ( 
self
 , 
req
 , 
extras
 = None ) :

952 
extra_evals
 = (

953 
req
 . 
marker
 . 
evaluate
 ( { 'extra' : 
extra
 } )

954 for 
extra
 in 
self
 . 
get
 ( 
req
 , ( ) ) + ( 
extras
 or ( None , ) )

956 return not 
req
 . 
marker
 or 
any
 ( 
extra_evals
 ) 
	}

959 class 
	cEnvironment
 :

962 def 
	$__init__
 (

963 
self
 , 
search_path
 = None , 
platform
 = 
get_supported_platform
 ( ) ,

964 
python
 = 
PY_MAJOR
 ) :

981 
self
 . 
_distmap
 = { }

982 
self
 . 
platform
 = 
platform

983 
self
 . 
python
 = 
python

984 
self
 . 
scan
 ( 
search_path
 ) 
	}

986 def 
	$can_add
 ( 
self
 , 
dist
 ) :

993 
py_compat
 = (

994 
self
 . 
python
 is None

995 or 
dist
 . 
py_version
 is None

996 or 
dist
 . 
py_version
 == 
self
 . 
python

998 return 
py_compat
 and 
compatible_platforms
 ( 
dist
 . 
platform
 , 
self
 . 
platform
 ) 
	}

1000 def 
	$remove
 ( 
self
 , 
dist
 ) :

1002 
self
 . 
_distmap
 [ 
dist
 . 
key
 ] . 
remove
 ( 
dist
 ) 
	}

1004 def 
	$scan
 ( 
self
 , 
search_path
 = None ) :

1012 if 
search_path
 is None :

1013 
search_path
 = 
sys
 . 
path

1015 for 
item
 in 
search_path
 :

1016 for 
dist
 in 
find_distributions
 ( 
item
 ) :

1017 
self
 . 
add
 ( 
dist
 ) 
	}

1019 def 
	$__getitem__
 ( 
self
 , 
project_name
 ) :

1027 
distribution_key
 = 
project_name
 . 
lower
 ( )

1028 return 
self
 . 
_distmap
 . 
get
 ( 
distribution_key
 , [ ] ) 
	}

1030 def 
	$add
 ( 
self
 , 
dist
 ) :

1033 if 
self
 . 
can_add
 ( 
dist
 ) and 
dist
 . 
has_version
 ( ) :

1034 
dists
 = 
self
 . 
_distmap
 . 
setdefault
 ( 
dist
 . 
key
 , [ ] )

1035 if 
dist
 not in 
dists
 :

1036 
dists
 . 
append
 ( 
dist
 )

1037 
dists
 . 
sort
 ( 
key
 = 
operator
 . 
attrgetter
 ( 'hashcmp' ) , 
reverse
 = True ) 
	}

1039 def 
	$best_match
 (

1040 
self
 , 
req
 , 
working_set
 , 
installer
 = None , 
replace_conflicting
 = False ) :

1054 
dist
 = 
working_set
 . 
find
 ( 
req
 )

1055 except 
VersionConflict
 :

1056 if not 
replace_conflicting
 :

1058 
dist
 = None

1059 if 
dist
 is not None :

1060 return 
dist

1061 for 
dist
 in 
self
 [ 
req
 . 
key
 ] :

1062 if 
dist
 in 
req
 :

1063 return 
dist

1065 return 
self
 . 
obtain
 ( 
req
 , 
installer
 ) 
	}

1067 def 
	$obtain
 ( 
self
 , 
requirement
 , 
installer
 = None ) :

1076 if 
installer
 is not None :

1077 return 
installer
 ( 
requirement
 ) 
	}

1079 def 
	$__iter__
 ( 
self
 ) :

1081 for 
key
 in 
self
 . 
_distmap
 . 
keys
 ( ) :

1082 if 
self
 [ 
key
 ] :

1083 yield 
key
 
	}

1085 def 
	$__iadd__
 ( 
self
 , 
other
 ) :

1087 if 
isinstance
 ( 
other
 , 
Distribution
 ) :

1088 
self
 . 
add
 ( 
other
 )

1089 elif 
isinstance
 ( 
other
 , 
Environment
 ) :

1090 for 
project
 in 
other
 :

1091 for 
dist
 in 
other
 [ 
project
 ] :

1092 
self
 . 
add
 ( 
dist
 )

1094 raise 
TypeError
 ( "Can't add %r to environment" % ( 
other
 , ) )

1095 return 
self
 
	}

1097 def 
	$__add__
 ( 
self
 , 
other
 ) :

1099 
new
 = 
self
 . 
__class__
 ( [ ] , 
platform
 = None , 
python
 = None )

1100 for 
env
 in 
self
 , 
other
 :

1101 
new
 += 
env

1102 return 
new
 
	}

1106 
AvailableDistributions
 = 
Environment

1109 class 
	cExtractionError
 ( 
RuntimeError
 ) :

1125 class 
	cResourceManager
 :

1127 
extraction_path
 = None

1129 def 
	$__init__
 ( 
self
 ) :

1130 
self
 . 
cached_files
 = { } 
	}

1132 def 
	$resource_exists
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1134 return 
get_provider
 ( 
package_or_requirement
 ) . 
has_resource
 ( 
resource_name
 ) 
	}

1136 def 
	$resource_isdir
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1138 return 
get_provider
 ( 
package_or_requirement
 ) . 
resource_isdir
 (

1139 
resource_name

1140 ) 
	}

1142 def 
	$resource_filename
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1144 return 
get_provider
 ( 
package_or_requirement
 ) . 
get_resource_filename
 (

1145 
self
 , 
resource_name

1146 ) 
	}

1148 def 
	$resource_stream
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1150 return 
get_provider
 ( 
package_or_requirement
 ) . 
get_resource_stream
 (

1151 
self
 , 
resource_name

1152 ) 
	}

1154 def 
	$resource_string
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1156 return 
get_provider
 ( 
package_or_requirement
 ) . 
get_resource_string
 (

1157 
self
 , 
resource_name

1158 ) 
	}

1160 def 
	$resource_listdir
 ( 
self
 , 
package_or_requirement
 , 
resource_name
 ) :

1162 return 
get_provider
 ( 
package_or_requirement
 ) . 
resource_listdir
 (

1163 
resource_name

1164 ) 
	}

1166 def 
	$extraction_error
 ( 
self
 ) :

1169 
old_exc
 = 
sys
 . 
exc_info
 ( ) [ 1 ]

1170 
cache_path
 = 
self
 . 
extraction_path
 or 
get_default_cache
 ( )

1172 
tmpl
 = 
textwrap
 . 
dedent
 ( """\n            Can't extract file(s) to egg cache\n\n            The following error occurred while trying to extract file(s)\n            to the Python egg cache:\n\n              {old_exc}\n\n            The Python egg cache directory is currently set to:\n\n              {cache_path}\n\n            Perhaps your account does not have write access to this directory?\n            You can change the cache directory by setting the PYTHON_EGG_CACHE\n            environment variable to point to an accessible directory.\n            """

1187 ) . 
lstrip
 ( )

1188 
err
 = 
ExtractionError
 ( 
tmpl
 . 
format
 ( ** 
locals
 ( ) ) )

1189 
err
 . 
manager
 = 
self

1190 
err
 . 
cache_path
 = 
cache_path

1191 
err
 . 
original_error
 = 
old_exc

1192 raise 
err
 
	}

1194 def 
	$get_cache_path
 ( 
self
 , 
archive_name
 , 
names
 = ( ) ) :

1207 
extract_path
 = 
self
 . 
extraction_path
 or 
get_default_cache
 ( )

1208 
target_path
 = 
os
 . 
path
 . 
join
 ( 
extract_path
 , 
archive_name
 + '-tmp' , * 
names
 )

1210 
_bypass_ensure_directory
 ( 
target_path
 )

1211 except 
Exception
 :

1212 
self
 . 
extraction_error
 ( )

1214 
self
 . 
_warn_unsafe_extraction_path
 ( 
extract_path
 )

1216 
self
 . 
cached_files
 [ 
target_path
 ] = 1

1217 return 
target_path
 
	}

1219 @ 
	`staticmethod

1220 def 
	$_warn_unsafe_extraction_path
 ( 
path
 ) :

1229 if 
os
 . 
name
 == 'nt' and not 
path
 . 
startswith
 ( 
os
 . 
environ
 [ 'windir' ] ) :

1234 
mode
 = 
os
 . 
stat
 ( 
path
 ) . 
st_mode

1235 if 
mode
 & 
stat
 . 
S_IWOTH
 or 
mode
 & 
stat
 . 
S_IWGRP
 :

1236 
msg
 = ( "%s is writable by group/others and vulnerable to attack " "when " "used with get_resource_filename. Consider a more secure " "location (set with .set_extraction_path or the " "PYTHON_EGG_CACHE environment variable)."

1241 % 
path

1243 
warnings
 . 
warn
 ( 
msg
 , 
UserWarning
 ) 
	}

1245 def 
	$postprocess
 ( 
self
 , 
tempname
 , 
filename
 ) :

1260 if 
os
 . 
name
 == 'posix' :

1262 
mode
 = ( ( 
os
 . 
stat
 ( 
tempname
 ) . 
st_mode
 ) | 0o555 ) & 0o7777

1263 
os
 . 
chmod
 ( 
tempname
 , 
mode
 ) 
	}

1265 def 
	$set_extraction_path
 ( 
self
 , 
path
 ) :

1284 if 
self
 . 
cached_files
 :

1285 raise 
ValueError
 ( "Can't change extraction path, files already extracted"

1289 
self
 . 
extraction_path
 = 
path
 
	}

1291 def 
	$cleanup_resources
 ( 
self
 , 
force
 = False ) :

1301 
	}

1305 def 
	$get_default_cache
 ( ) :

1312 
os
 . 
environ
 . 
get
 ( 'PYTHON_EGG_CACHE' )

1313 or 
appdirs
 . 
user_cache_dir
 ( 
appname
 = 'Python-Eggs' )

1314 ) 
	}

1317 def 
	$safe_name
 ( 
name
 ) :

1322 return 
re
 . 
sub
 ( '[^A-Za-z0-9.]+' , '-' , 
name
 ) 
	}

1325 def 
	$safe_version
 ( 
version
 ) :

1331 return 
str
 ( 
packaging
 . 
version
 . 
Version
 ( 
version
 ) )

1332 except 
packaging
 . 
version
 . 
InvalidVersion
 :

1333 
version
 = 
version
 . 
replace
 ( ' ' , '.' )

1334 return 
re
 . 
sub
 ( '[^A-Za-z0-9.]+' , '-' , 
version
 ) 
	}

1337 def 
	$safe_extra
 ( 
extra
 ) :

1343 return 
re
 . 
sub
 ( '[^A-Za-z0-9.-]+' , '_' , 
extra
 ) . 
lower
 ( ) 
	}

1346 def 
	$to_filename
 ( 
name
 ) :

1351 return 
name
 . 
replace
 ( '-' , '_' ) 
	}

1354 def 
	$invalid_marker
 ( 
text
 ) :

1360 
evaluate_marker
 ( 
text
 )

1361 except 
SyntaxError
 as 
e
 :

1362 
e
 . 
filename
 = None

1363 
e
 . 
lineno
 = None

1364 return 
e

1365 return False 
	}

1368 def 
	$evaluate_marker
 ( 
text
 , 
extra
 = None ) :

1377 
marker
 = 
packaging
 . 
markers
 . 
Marker
 ( 
text
 )

1378 return 
marker
 . 
evaluate
 ( )

1379 except 
packaging
 . 
markers
 . 
InvalidMarker
 as 
e
 :

1380 raise 
SyntaxError
 ( 
e
 ) 
	}

1383 class 
	cNullProvider
 :

1386 
egg_name
 = None

1387 
egg_info
 = None

1388 
loader
 = None

1390 def 
	$__init__
 ( 
self
 , 
module
 ) :

1391 
self
 . 
loader
 = 
getattr
 ( 
module
 , '__loader__' , None )

1392 
self
 . 
module_path
 = 
os
 . 
path
 . 
dirname
 ( 
getattr
 ( 
module
 , '__file__' , '' ) ) 
	}

1394 def 
	$get_resource_filename
 ( 
self
 , 
manager
 , 
resource_name
 ) :

1395 return 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) 
	}

1397 def 
	$get_resource_stream
 ( 
self
 , 
manager
 , 
resource_name
 ) :

1398 return 
io
 . 
BytesIO
 ( 
self
 . 
get_resource_string
 ( 
manager
 , 
resource_name
 ) ) 
	}

1400 def 
	$get_resource_string
 ( 
self
 , 
manager
 , 
resource_name
 ) :

1401 return 
self
 . 
_get
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) ) 
	}

1403 def 
	$has_resource
 ( 
self
 , 
resource_name
 ) :

1404 return 
self
 . 
_has
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) ) 
	}

1406 def 
	$has_metadata
 ( 
self
 , 
name
 ) :

1407 return 
self
 . 
egg_info
 and 
self
 . 
_has
 ( 
self
 . 
_fn
 ( 
self
 . 
egg_info
 , 
name
 ) ) 
	}

1409 def 
	$get_metadata
 ( 
self
 , 
name
 ) :

1410 if not 
self
 . 
egg_info
 :

1412 
value
 = 
self
 . 
_get
 ( 
self
 . 
_fn
 ( 
self
 . 
egg_info
 , 
name
 ) )

1413 return 
value
 . 
decode
 ( 'utf-8' ) if 
six
 . 
PY3
 else 
value
 
	}

1415 def 
	$get_metadata_lines
 ( 
self
 , 
name
 ) :

1416 return 
yield_lines
 ( 
self
 . 
get_metadata
 ( 
name
 ) ) 
	}

1418 def 
	$resource_isdir
 ( 
self
 , 
resource_name
 ) :

1419 return 
self
 . 
_isdir
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) ) 
	}

1421 def 
	$metadata_isdir
 ( 
self
 , 
name
 ) :

1422 return 
self
 . 
egg_info
 and 
self
 . 
_isdir
 ( 
self
 . 
_fn
 ( 
self
 . 
egg_info
 , 
name
 ) ) 
	}

1424 def 
	$resource_listdir
 ( 
self
 , 
resource_name
 ) :

1425 return 
self
 . 
_listdir
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) ) 
	}

1427 def 
	$metadata_listdir
 ( 
self
 , 
name
 ) :

1428 if 
self
 . 
egg_info
 :

1429 return 
self
 . 
_listdir
 ( 
self
 . 
_fn
 ( 
self
 . 
egg_info
 , 
name
 ) )

1430 return [ ] 
	}

1432 def 
	$run_script
 ( 
self
 , 
script_name
 , 
namespace
 ) :

1433 
script
 = 'scripts/' + 
script_name

1434 if not 
self
 . 
has_metadata
 ( 
script
 ) :

1435 raise 
ResolutionError
 ( "Script {script!r} not found in metadata at {self.egg_info!r}"

1437 . 
format
 ( ** 
locals
 ( ) ) ,

1439 
script_text
 = 
self
 . 
get_metadata
 ( 
script
 ) . 
replace
 ( '\r\n' , '\n' )

1440 
script_text
 = 
script_text
 . 
replace
 ( '\r' , '\n' )

1441 
script_filename
 = 
self
 . 
_fn
 ( 
self
 . 
egg_info
 , 
script
 )

1442 
namespace
 [ '__file__' ] = 
script_filename

1443 if 
os
 . 
path
 . 
exists
 ( 
script_filename
 ) :

1444 
source
 = 
open
 ( 
script_filename
 ) . 
read
 ( )

1445 
code
 = 
compile
 ( 
source
 , 
script_filename
 , 'exec' )

1446 
exec
 ( 
code
 , 
namespace
 , 
namespace
 )

1448 from 
	~linecache
 import 
cache

1449 
cache
 [ 
script_filename
 ] = (

1450 
len
 ( 
script_text
 ) , 0 , 
script_text
 . 
split
 ( '\n' ) , 
script_filename

1452 
script_code
 = 
compile
 ( 
script_text
 , 
script_filename
 , 'exec' )

1453 
exec
 ( 
script_code
 , 
namespace
 , 
namespace
 ) 
	}

1455 def 
	$_has
 ( 
self
 , 
path
 ) :

1456 raise 
NotImplementedError
 ( "Can't perform this operation for unregistered loader type"

1458 ) 
	}

1460 def 
	$_isdir
 ( 
self
 , 
path
 ) :

1461 raise 
NotImplementedError
 ( "Can't perform this operation for unregistered loader type"

1463 ) 
	}

1465 def 
	$_listdir
 ( 
self
 , 
path
 ) :

1466 raise 
NotImplementedError
 ( "Can't perform this operation for unregistered loader type"

1468 ) 
	}

1470 def 
	$_fn
 ( 
self
 , 
base
 , 
resource_name
 ) :

1471 
self
 . 
_validate_resource_path
 ( 
resource_name
 )

1472 if 
resource_name
 :

1473 return 
os
 . 
path
 . 
join
 ( 
base
 , * 
resource_name
 . 
split
 ( '/' ) )

1474 return 
base
 
	}

1476 @ 
	`staticmethod

1477 def 
	$_validate_resource_path
 ( 
path
 ) :

1516 
invalid
 = (

1517 
os
 . 
path
 . 
pardir
 in 
path
 . 
split
 ( 
posixpath
 . 
sep
 ) or

1518 
posixpath
 . 
isabs
 ( 
path
 ) or

1519 
ntpath
 . 
isabs
 ( 
path
 )

1521 if not 
invalid
 :

1524 
msg
 = "Use of .. or absolute path in a resource path is not allowed."

1527 if 
ntpath
 . 
isabs
 ( 
path
 ) and not 
posixpath
 . 
isabs
 ( 
path
 ) :

1528 raise 
ValueError
 ( 
msg
 )

1532 
warnings
 . 
warn
 (

1533 
msg
 [ : - 1 ] + " and will raise exceptions in a future release." ,

1534 
DeprecationWarning
 ,

1535 
stacklevel
 = 4 ,

1536 ) 
	}

1538 def 
	$_get
 ( 
self
 , 
path
 ) :

1539 if 
hasattr
 ( 
self
 . 
loader
 , 'get_data' ) :

1540 return 
self
 . 
loader
 . 
get_data
 ( 
path
 )

1541 raise 
NotImplementedError
 ( "Can't perform this operation for loaders without 'get_data()'"

1543 ) 
	}

1546 
register_loader_type
 ( 
object
 , 
NullProvider
 )

1549 class 
	cEggProvider
 ( 
NullProvider
 ) :

1552 def 
	$__init__
 ( 
self
 , 
module
 ) :

1553 
NullProvider
 . 
__init__
 ( 
self
 , 
module
 )

1554 
self
 . 
_setup_prefix
 ( ) 
	}

1556 def 
	$_setup_prefix
 ( 
self
 ) :

1559 
path
 = 
self
 . 
module_path

1560 
old
 = None

1561 while 
path
 != 
old
 :

1562 if 
_is_egg_path
 ( 
path
 ) :

1563 
self
 . 
egg_name
 = 
os
 . 
path
 . 
basename
 ( 
path
 )

1564 
self
 . 
egg_info
 = 
os
 . 
path
 . 
join
 ( 
path
 , 'EGG-INFO' )

1565 
self
 . 
egg_root
 = 
path

1567 
old
 = 
path

1568 
path
 , 
base
 = 
os
 . 
path
 . 
split
 ( 
path
 ) 
	}

1571 class 
	cDefaultProvider
 ( 
EggProvider
 ) :

1574 def 
	$_has
 ( 
self
 , 
path
 ) :

1575 return 
os
 . 
path
 . 
exists
 ( 
path
 ) 
	}

1577 def 
	$_isdir
 ( 
self
 , 
path
 ) :

1578 return 
os
 . 
path
 . 
isdir
 ( 
path
 ) 
	}

1580 def 
	$_listdir
 ( 
self
 , 
path
 ) :

1581 return 
os
 . 
listdir
 ( 
path
 ) 
	}

1583 def 
	$get_resource_stream
 ( 
self
 , 
manager
 , 
resource_name
 ) :

1584 return 
open
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) , 'rb' ) 
	}

1586 def 
	$_get
 ( 
self
 , 
path
 ) :

1587 with 
open
 ( 
path
 , 'rb' ) as 
stream
 :

1588 return 
stream
 . 
read
 ( ) 
	}

1590 @ 
classmethod

1591 def 
	$_register
 ( 
cls
 ) :

1592 
loader_names
 = 'SourceFileLoader' , 'SourcelessFileLoader' ,

1593 for 
name
 in 
loader_names
 :

1594 
loader_cls
 = 
getattr
 ( 
importlib_machinery
 , 
name
 , 
type
 ( None ) )

1595 
register_loader_type
 ( 
loader_cls
 , 
cls
 ) 
	}

1598 
DefaultProvider
 . 
_register
 ( )

1601 class 
	cEmptyProvider
 ( 
NullProvider
 ) :

1604 
module_path
 = None

1606 
_isdir
 = 
_has
 = lambda 
self
 , 
path
 : False

1608 def 
	$_get
 ( 
self
 , 
path
 ) :

1609 return '' 
	}

1611 def 
	$_listdir
 ( 
self
 , 
path
 ) :

1612 return [ ] 
	}

1614 def 
	$__init__
 ( 
self
 ) :

1615 pass 
	}

1618 
empty_provider
 = 
EmptyProvider
 ( )

1621 class 
	cZipManifests
 ( 
dict
 ) :

1626 @ 
classmethod

1627 def 
	$build
 ( 
cls
 , 
path
 ) :

1635 with 
zipfile
 . 
ZipFile
 ( 
path
 ) as 
zfile
 :

1636 
items
 = (

1638 
name
 . 
replace
 ( '/' , 
os
 . 
sep
 ) ,

1639 
zfile
 . 
getinfo
 ( 
name
 ) ,

1641 for 
name
 in 
zfile
 . 
namelist
 ( )

1643 return 
dict
 ( 
items
 ) 
	}

1645 
load
 = 
build

1648 class 
	cMemoizedZipManifests
 ( 
ZipManifests
 ) :

1652 
manifest_mod
 = 
collections
 . 
namedtuple
 ( 'manifest_mod' , 'manifest mtime' )

1654 def 
	$load
 ( 
self
 , 
path
 ) :

1658 
path
 = 
os
 . 
path
 . 
normpath
 ( 
path
 )

1659 
mtime
 = 
os
 . 
stat
 ( 
path
 ) . 
st_mtime

1661 if 
path
 not in 
self
 or 
self
 [ 
path
 ] . 
mtime
 != 
mtime
 :

1662 
manifest
 = 
self
 . 
build
 ( 
path
 )

1663 
self
 [ 
path
 ] = 
self
 . 
manifest_mod
 ( 
manifest
 , 
mtime
 )

1665 return 
self
 [ 
path
 ] . 
manifest
 
	}

1668 class 
	cZipProvider
 ( 
EggProvider
 ) :

1671 
eagers
 = None

1672 
_zip_manifests
 = 
MemoizedZipManifests
 ( )

1674 def 
	$__init__
 ( 
self
 , 
module
 ) :

1675 
EggProvider
 . 
__init__
 ( 
self
 , 
module
 )

1676 
self
 . 
zip_pre
 = 
self
 . 
loader
 . 
archive
 + 
os
 . 
sep
 
	}

1678 def 
	$_zipinfo_name
 ( 
self
 , 
fspath
 ) :

1681 
fspath
 = 
fspath
 . 
rstrip
 ( 
os
 . 
sep
 )

1682 if 
fspath
 == 
self
 . 
loader
 . 
archive
 :

1684 if 
fspath
 . 
startswith
 ( 
self
 . 
zip_pre
 ) :

1685 return 
fspath
 [ 
len
 ( 
self
 . 
zip_pre
 ) : ]

1686 raise 
AssertionError
 ( "%s is not a subpath of %s"

1687 % ( 
fspath
 , 
self
 . 
zip_pre
 )

1688 ) 
	}

1690 def 
	$_parts
 ( 
self
 , 
zip_path
 ) :

1693 
fspath
 = 
self
 . 
zip_pre
 + 
zip_path

1694 if 
fspath
 . 
startswith
 ( 
self
 . 
egg_root
 + 
os
 . 
sep
 ) :

1695 return 
fspath
 [ 
len
 ( 
self
 . 
egg_root
 ) + 1 : ] . 
split
 ( 
os
 . 
sep
 )

1696 raise 
AssertionError
 ( "%s is not a subpath of %s"

1697 % ( 
fspath
 , 
self
 . 
egg_root
 )

1698 ) 
	}

1700 @ 
property

1701 def 
	$zipinfo
 ( 
self
 ) :

1702 return 
self
 . 
_zip_manifests
 . 
load
 ( 
self
 . 
loader
 . 
archive
 ) 
	}

1704 def 
	$get_resource_filename
 ( 
self
 , 
manager
 , 
resource_name
 ) :

1705 if not 
self
 . 
egg_name
 :

1706 raise 
NotImplementedError
 ( "resource_filename() only supported for .egg, not .zip"

1710 
zip_path
 = 
self
 . 
_resource_to_zip
 ( 
resource_name
 )

1711 
eagers
 = 
self
 . 
_get_eager_resources
 ( )

1712 if '/' . 
join
 ( 
self
 . 
_parts
 ( 
zip_path
 ) ) in 
eagers
 :

1713 for 
name
 in 
eagers
 :

1714 
self
 . 
_extract_resource
 ( 
manager
 , 
self
 . 
_eager_to_zip
 ( 
name
 ) )

1715 return 
self
 . 
_extract_resource
 ( 
manager
 , 
zip_path
 ) 
	}

1717 @ 
	`staticmethod

1718 def 
	$_get_date_and_size
 ( 
zip_stat
 ) :

1719 
size
 = 
zip_stat
 . 
file_size

1721 
date_time
 = 
zip_stat
 . 
date_time
 + ( 0 , 0 , - 1 )

1723 
timestamp
 = 
time
 . 
mktime
 ( 
date_time
 )

1724 return 
timestamp
 , 
size
 
	}

1726 def 
	$_extract_resource
 ( 
self
 , 
manager
 , 
zip_path
 ) :

1728 if 
zip_path
 in 
self
 . 
_index
 ( ) :

1729 for 
name
 in 
self
 . 
_index
 ( ) [ 
zip_path
 ] :

1730 
last
 = 
self
 . 
_extract_resource
 (

1731 
manager
 , 
os
 . 
path
 . 
join
 ( 
zip_path
 , 
name
 )

1734 return 
os
 . 
path
 . 
dirname
 ( 
last
 )

1736 
timestamp
 , 
size
 = 
self
 . 
_get_date_and_size
 ( 
self
 . 
zipinfo
 [ 
zip_path
 ] )

1738 if not 
WRITE_SUPPORT
 :

1739 raise 
IOError
 ( '"os.rename" and "os.unlink" are not supported ' 'on this platform'

1743 
real_path
 = 
manager
 . 
get_cache_path
 (

1744 
self
 . 
egg_name
 , 
self
 . 
_parts
 ( 
zip_path
 )

1747 if 
self
 . 
_is_current
 ( 
real_path
 , 
zip_path
 ) :

1748 return 
real_path

1750 
outf
 , 
tmpnam
 = 
_mkstemp
 ( ".$extract"

1752 
dir
 = 
os
 . 
path
 . 
dirname
 ( 
real_path
 ) ,

1754 
os
 . 
write
 ( 
outf
 , 
self
 . 
loader
 . 
get_data
 ( 
zip_path
 ) )

1755 
os
 . 
close
 ( 
outf
 )

1756 
utime
 ( 
tmpnam
 , ( 
timestamp
 , 
timestamp
 ) )

1757 
manager
 . 
postprocess
 ( 
tmpnam
 , 
real_path
 )

1760 
rename
 ( 
tmpnam
 , 
real_path
 )

1762 except 
os
 . 
error
 :

1763 if 
os
 . 
path
 . 
isfile
 ( 
real_path
 ) :

1764 if 
self
 . 
_is_current
 ( 
real_path
 , 
zip_path
 ) :

1767 return 
real_path

1769 elif 
os
 . 
name
 == 'nt' :

1770 
unlink
 ( 
real_path
 )

1771 
rename
 ( 
tmpnam
 , 
real_path
 )

1772 return 
real_path

1775 except 
os
 . 
error
 :

1777 
manager
 . 
extraction_error
 ( )

1779 return 
real_path
 
	}

1781 def 
	$_is_current
 ( 
self
 , 
file_path
 , 
zip_path
 ) :

1785 
timestamp
 , 
size
 = 
self
 . 
_get_date_and_size
 ( 
self
 . 
zipinfo
 [ 
zip_path
 ] )

1786 if not 
os
 . 
path
 . 
isfile
 ( 
file_path
 ) :

1788 
stat
 = 
os
 . 
stat
 ( 
file_path
 )

1789 if 
stat
 . 
st_size
 != 
size
 or 
stat
 . 
st_mtime
 != 
timestamp
 :

1792 
zip_contents
 = 
self
 . 
loader
 . 
get_data
 ( 
zip_path
 )

1793 with 
open
 ( 
file_path
 , 'rb' ) as 
f
 :

1794 
file_contents
 = 
f
 . 
read
 ( )

1795 return 
zip_contents
 == 
file_contents
 
	}

1797 def 
	$_get_eager_resources
 ( 
self
 ) :

1798 if 
self
 . 
eagers
 is None :

1799 
eagers
 = [ ]

1800 for 
name
 in ( 'native_libs.txt' , 'eager_resources.txt' ) :

1801 if 
self
 . 
has_metadata
 ( 
name
 ) :

1802 
eagers
 . 
extend
 ( 
self
 . 
get_metadata_lines
 ( 
name
 ) )

1803 
self
 . 
eagers
 = 
eagers

1804 return 
self
 . 
eagers
 
	}

1806 def 
	$_index
 ( 
self
 ) :

1808 return 
self
 . 
_dirindex

1809 except 
AttributeError
 :

1810 
ind
 = { }

1811 for 
path
 in 
self
 . 
zipinfo
 :

1812 
parts
 = 
path
 . 
split
 ( 
os
 . 
sep
 )

1813 while 
parts
 :

1814 
parent
 = 
os
 . 
sep
 . 
join
 ( 
parts
 [ : - 1 ] )

1815 if 
parent
 in 
ind
 :

1816 
ind
 [ 
parent
 ] . 
append
 ( 
parts
 [ - 1 ] )

1819 
ind
 [ 
parent
 ] = [ 
parts
 . 
pop
 ( ) ]

1820 
self
 . 
_dirindex
 = 
ind

1821 return 
ind
 
	}

1823 def 
	$_has
 ( 
self
 , 
fspath
 ) :

1824 
zip_path
 = 
self
 . 
_zipinfo_name
 ( 
fspath
 )

1825 return 
zip_path
 in 
self
 . 
zipinfo
 or 
zip_path
 in 
self
 . 
_index
 ( ) 
	}

1827 def 
	$_isdir
 ( 
self
 , 
fspath
 ) :

1828 return 
self
 . 
_zipinfo_name
 ( 
fspath
 ) in 
self
 . 
_index
 ( ) 
	}

1830 def 
	$_listdir
 ( 
self
 , 
fspath
 ) :

1831 return 
list
 ( 
self
 . 
_index
 ( ) . 
get
 ( 
self
 . 
_zipinfo_name
 ( 
fspath
 ) , ( ) ) ) 
	}

1833 def 
	$_eager_to_zip
 ( 
self
 , 
resource_name
 ) :

1834 return 
self
 . 
_zipinfo_name
 ( 
self
 . 
_fn
 ( 
self
 . 
egg_root
 , 
resource_name
 ) ) 
	}

1836 def 
	$_resource_to_zip
 ( 
self
 , 
resource_name
 ) :

1837 return 
self
 . 
_zipinfo_name
 ( 
self
 . 
_fn
 ( 
self
 . 
module_path
 , 
resource_name
 ) ) 
	}

1840 
register_loader_type
 ( 
zipimport
 . 
zipimporter
 , 
ZipProvider
 )

1843 class 
	cFileMetadata
 ( 
EmptyProvider
 ) :

1855 def 
	$__init__
 ( 
self
 , 
path
 ) :

1856 
self
 . 
path
 = 
path
 
	}

1858 def 
	$has_metadata
 ( 
self
 , 
name
 ) :

1859 return 
name
 == 'PKG-INFO' and 
os
 . 
path
 . 
isfile
 ( 
self
 . 
path
 ) 
	}

1861 def 
	$get_metadata
 ( 
self
 , 
name
 ) :

1862 if 
name
 != 'PKG-INFO' :

1863 raise 
KeyError
 ( "No metadata except PKG-INFO is available" )

1865 with 
io
 . 
open
 ( 
self
 . 
path
 , 
encoding
 = 'utf-8' , 
errors
 = "replace" ) as 
f
 :

1866 
metadata
 = 
f
 . 
read
 ( )

1867 
self
 . 
_warn_on_replacement
 ( 
metadata
 )

1868 return 
metadata
 
	}

1870 def 
	$_warn_on_replacement
 ( 
self
 , 
metadata
 ) :

1872 
replacement_char
 = b'\xef\xbf\xbd' . 
decode
 ( 'utf-8' )

1873 if 
replacement_char
 in 
metadata
 :

1874 
tmpl
 = "{self.path} could not be properly decoded in UTF-8"

1875 
msg
 = 
tmpl
 . 
format
 ( ** 
locals
 ( ) )

1876 
warnings
 . 
warn
 ( 
msg
 ) 
	}

1878 def 
	$get_metadata_lines
 ( 
self
 , 
name
 ) :

1879 return 
yield_lines
 ( 
self
 . 
get_metadata
 ( 
name
 ) ) 
	}

1882 class 
	cPathMetadata
 ( 
DefaultProvider
 ) :

1902 def 
	$__init__
 ( 
self
 , 
path
 , 
egg_info
 ) :

1903 
self
 . 
module_path
 = 
path

1904 
self
 . 
egg_info
 = 
egg_info
 
	}

1907 class 
	cEggMetadata
 ( 
ZipProvider
 ) :

1910 def 
	$__init__
 ( 
self
 , 
importer
 ) :

1913 
self
 . 
zip_pre
 = 
importer
 . 
archive
 + 
os
 . 
sep

1914 
self
 . 
loader
 = 
importer

1915 if 
importer
 . 
prefix
 :

1916 
self
 . 
module_path
 = 
os
 . 
path
 . 
join
 ( 
importer
 . 
archive
 , 
importer
 . 
prefix
 )

1918 
self
 . 
module_path
 = 
importer
 . 
archive

1919 
self
 . 
_setup_prefix
 ( ) 
	}

1922 
_declare_state
 ( 'dict' , 
_distribution_finders
 = { } )

1925 def 
	$register_finder
 ( 
importer_type
 , 
distribution_finder
 ) :

1932 
_distribution_finders
 [ 
importer_type
 ] = 
distribution_finder
 
	}

1935 def 
	$find_distributions
 ( 
path_item
 , 
only
 = False ) :

1937 
importer
 = 
get_importer
 ( 
path_item
 )

1938 
finder
 = 
_find_adapter
 ( 
_distribution_finders
 , 
importer
 )

1939 return 
finder
 ( 
importer
 , 
path_item
 , 
only
 ) 
	}

1942 def 
	$find_eggs_in_zip
 ( 
importer
 , 
path_item
 , 
only
 = False ) :

1946 if 
importer
 . 
archive
 . 
endswith
 ( '.whl' ) :

1950 
metadata
 = 
EggMetadata
 ( 
importer
 )

1951 if 
metadata
 . 
has_metadata
 ( 'PKG-INFO' ) :

1952 yield 
Distribution
 . 
from_filename
 ( 
path_item
 , 
metadata
 = 
metadata
 )

1953 if 
only
 :

1956 for 
subitem
 in 
metadata
 . 
resource_listdir
 ( '' ) :

1957 if 
_is_egg_path
 ( 
subitem
 ) :

1958 
subpath
 = 
os
 . 
path
 . 
join
 ( 
path_item
 , 
subitem
 )

1959 
dists
 = 
find_eggs_in_zip
 ( 
zipimport
 . 
zipimporter
 ( 
subpath
 ) , 
subpath
 )

1960 for 
dist
 in 
dists
 :

1961 yield 
dist

1962 elif 
subitem
 . 
lower
 ( ) . 
endswith
 ( '.dist-info' ) :

1963 
subpath
 = 
os
 . 
path
 . 
join
 ( 
path_item
 , 
subitem
 )

1964 
submeta
 = 
EggMetadata
 ( 
zipimport
 . 
zipimporter
 ( 
subpath
 ) )

1965 
submeta
 . 
egg_info
 = 
subpath

1966 yield 
Distribution
 . 
from_location
 ( 
path_item
 , 
subitem
 , 
submeta
 ) 
	}

1969 
register_finder
 ( 
zipimport
 . 
zipimporter
 , 
find_eggs_in_zip
 )

1972 def 
	$find_nothing
 ( 
importer
 , 
path_item
 , 
only
 = False ) :

1973 return ( ) 
	}

1976 
register_finder
 ( 
object
 , 
find_nothing
 )

1979 def 
	$_by_version_descending
 ( 
names
 ) :

1994 def 
_by_version
 ( 
name
 ) :

1998 
name
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
name
 )

1999 
parts
 = 
itertools
 . 
chain
 ( 
name
 . 
split
 ( '-' ) , [ 
ext
 ] )

2000 return [ 
packaging
 . 
version
 . 
parse
 ( 
part
 ) for 
part
 in 
parts
 ]

2002 return 
sorted
 ( 
names
 , 
key
 = 
_by_version
 , 
reverse
 = True ) 
	}

2005 def 
	$find_on_path
 ( 
importer
 , 
path_item
 , 
only
 = False ) :

2007 
path_item
 = 
_normalize_cached
 ( 
path_item
 )

2009 if 
_is_unpacked_egg
 ( 
path_item
 ) :

2010 yield 
Distribution
 . 
from_filename
 (

2011 
path_item
 , 
metadata
 = 
PathMetadata
 (

2012 
path_item
 , 
os
 . 
path
 . 
join
 ( 
path_item
 , 'EGG-INFO' )

2017 
entries
 = 
safe_listdir
 ( 
path_item
 )

2022 
filtered
 = (

2023 
entry

2024 for 
entry
 in 
entries

2025 if 
dist_factory
 ( 
path_item
 , 
entry
 , 
only
 )

2029 
path_item_entries
 = 
_by_version_descending
 ( 
filtered
 )

2030 for 
entry
 in 
path_item_entries
 :

2031 
fullpath
 = 
os
 . 
path
 . 
join
 ( 
path_item
 , 
entry
 )

2032 
factory
 = 
dist_factory
 ( 
path_item
 , 
entry
 , 
only
 )

2033 for 
dist
 in 
factory
 ( 
fullpath
 ) :

2034 yield 
dist
 
	}

2037 def 
	$dist_factory
 ( 
path_item
 , 
entry
 , 
only
 ) :

2041 
lower
 = 
entry
 . 
lower
 ( )

2042 
is_meta
 = 
any
 ( 
map
 ( 
lower
 . 
endswith
 , ( '.egg-info' , '.dist-info' ) ) )

2044 
distributions_from_metadata

2045 if 
is_meta
 else

2046 
find_distributions

2047 if not 
only
 and 
_is_egg_path
 ( 
entry
 ) else

2048 
resolve_egg_link

2049 if not 
only
 and 
lower
 . 
endswith
 ( '.egg-link' ) else

2050 
NoDists
 ( )

2051 ) 
	}

2054 class 
	cNoDists
 :

2062 def 
	$__bool__
 ( 
self
 ) :

2063 return False 
	}

2064 if 
six
 . 
PY2
 :

2065 
__nonzero__
 = 
__bool__

2067 def 
	$__call__
 ( 
self
 , 
fullpath
 ) :

2068 return 
iter
 ( ( ) ) 
	}

2071 def 
	$safe_listdir
 ( 
path
 ) :

2076 return 
os
 . 
listdir
 ( 
path
 )

2077 except ( 
PermissionError
 , 
NotADirectoryError
 ) :

2079 except 
OSError
 as 
e
 :

2082 
ignorable
 = (

2083 
e
 . 
errno
 in ( 
errno
 . 
ENOTDIR
 , 
errno
 . 
EACCES
 , 
errno
 . 
ENOENT
 )

2085 or 
getattr
 ( 
e
 , "winerror" , None ) == 267

2087 if not 
ignorable
 :

2089 return ( ) 
	}

2092 def 
	$distributions_from_metadata
 ( 
path
 ) :

2093 
root
 = 
os
 . 
path
 . 
dirname
 ( 
path
 )

2094 if 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

2095 if 
len
 ( 
os
 . 
listdir
 ( 
path
 ) ) == 0 :

2098 
metadata
 = 
PathMetadata
 ( 
root
 , 
path
 )

2100 
metadata
 = 
FileMetadata
 ( 
path
 )

2101 
entry
 = 
os
 . 
path
 . 
basename
 ( 
path
 )

2102 yield 
Distribution
 . 
from_location
 (

2103 
root
 , 
entry
 , 
metadata
 , 
precedence
 = 
DEVELOP_DIST
 ,

2104 ) 
	}

2107 def 
	$non_empty_lines
 ( 
path
 ) :

2111 with 
open
 ( 
path
 ) as 
f
 :

2112 for 
line
 in 
f
 :

2113 
line
 = 
line
 . 
strip
 ( )

2114 if 
line
 :

2115 yield 
line
 
	}

2118 def 
	$resolve_egg_link
 ( 
path
 ) :

2123 
referenced_paths
 = 
non_empty_lines
 ( 
path
 )

2124 
resolved_paths
 = (

2125 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
dirname
 ( 
path
 ) , 
ref
 )

2126 for 
ref
 in 
referenced_paths

2128 
dist_groups
 = 
map
 ( 
find_distributions
 , 
resolved_paths
 )

2129 return 
next
 ( 
dist_groups
 , ( ) ) 
	}

2132 
register_finder
 ( 
pkgutil
 . 
ImpImporter
 , 
find_on_path
 )

2134 if 
hasattr
 ( 
importlib_machinery
 , 'FileFinder' ) :

2135 
register_finder
 ( 
importlib_machinery
 . 
FileFinder
 , 
find_on_path
 )

2137 
_declare_state
 ( 'dict' , 
_namespace_handlers
 = { } )

2138 
_declare_state
 ( 'dict' , 
_namespace_packages
 = { } )

2141 def 
	$register_namespace_handler
 ( 
importer_type
 , 
namespace_handler
 ) :

2156 
_namespace_handlers
 [ 
importer_type
 ] = 
namespace_handler
 
	}

2159 def 
	$_handle_ns
 ( 
packageName
 , 
path_item
 ) :

2162 
importer
 = 
get_importer
 ( 
path_item
 )

2163 if 
importer
 is None :

2167 with 
warnings
 . 
catch_warnings
 ( ) :

2168 
warnings
 . 
simplefilter
 ( "ignore" )

2169 
loader
 = 
importer
 . 
find_module
 ( 
packageName
 )

2171 if 
loader
 is None :

2173 
module
 = 
sys
 . 
modules
 . 
get
 ( 
packageName
 )

2174 if 
module
 is None :

2175 
module
 = 
sys
 . 
modules
 [ 
packageName
 ] = 
types
 . 
ModuleType
 ( 
packageName
 )

2176 
module
 . 
__path__
 = [ ]

2177 
_set_parent_ns
 ( 
packageName
 )

2178 elif not 
hasattr
 ( 
module
 , '__path__' ) :

2179 raise 
TypeError
 ( "Not a package:" , 
packageName
 )

2180 
handler
 = 
_find_adapter
 ( 
_namespace_handlers
 , 
importer
 )

2181 
subpath
 = 
handler
 ( 
importer
 , 
path_item
 , 
packageName
 , 
module
 )

2182 if 
subpath
 is not None :

2183 
path
 = 
module
 . 
__path__

2184 
path
 . 
append
 ( 
subpath
 )

2185 
loader
 . 
load_module
 ( 
packageName
 )

2186 
_rebuild_mod_path
 ( 
path
 , 
packageName
 , 
module
 )

2187 return 
subpath
 
	}

2190 def 
	$_rebuild_mod_path
 ( 
orig_path
 , 
package_name
 , 
module
 ) :

2195 
sys_path
 = [ 
_normalize_cached
 ( 
p
 ) for 
p
 in 
sys
 . 
path
 ]

2197 def 
safe_sys_path_index
 ( 
entry
 ) :

2202 return 
sys_path
 . 
index
 ( 
entry
 )

2203 except 
ValueError
 :

2204 return 
float
 ( 'inf' )

2206 def 
position_in_sys_path
 ( 
path
 ) :

2210 
path_parts
 = 
path
 . 
split
 ( 
os
 . 
sep
 )

2211 
module_parts
 = 
package_name
 . 
count
 ( '.' ) + 1

2212 
parts
 = 
path_parts
 [ : - 
module_parts
 ]

2213 return 
safe_sys_path_index
 ( 
_normalize_cached
 ( 
os
 . 
sep
 . 
join
 ( 
parts
 ) ) )

2215 
new_path
 = 
sorted
 ( 
orig_path
 , 
key
 = 
position_in_sys_path
 )

2216 
new_path
 = [ 
_normalize_cached
 ( 
p
 ) for 
p
 in 
new_path
 ]

2218 if 
isinstance
 ( 
module
 . 
__path__
 , 
list
 ) :

2219 
module
 . 
__path__
 [ : ] = 
new_path

2221 
module
 . 
__path__
 = 
new_path
 
	}

2224 def 
	$declare_namespace
 ( 
packageName
 ) :

2227 
_imp
 . 
acquire_lock
 ( )

2229 if 
packageName
 in 
_namespace_packages
 :

2232 
path
 = 
sys
 . 
path

2233 
parent
 , 
_
 , 
_
 = 
packageName
 . 
rpartition
 ( '.' )

2235 if 
parent
 :

2236 
declare_namespace
 ( 
parent
 )

2237 if 
parent
 not in 
_namespace_packages
 :

2238 
__import__
 ( 
parent
 )

2240 
path
 = 
sys
 . 
modules
 [ 
parent
 ] . 
__path__

2241 except 
AttributeError
 :

2242 raise 
TypeError
 ( "Not a package:" , 
parent
 )

2246 
_namespace_packages
 . 
setdefault
 ( 
parent
 or None , [ ] ) . 
append
 ( 
packageName
 )

2247 
_namespace_packages
 . 
setdefault
 ( 
packageName
 , [ ] )

2249 for 
path_item
 in 
path
 :

2252 
_handle_ns
 ( 
packageName
 , 
path_item
 )

2255 
_imp
 . 
release_lock
 ( ) 
	}

2258 def 
	$fixup_namespace_packages
 ( 
path_item
 , 
parent
 = None ) :

2260 
_imp
 . 
acquire_lock
 ( )

2262 for 
package
 in 
_namespace_packages
 . 
get
 ( 
parent
 , ( ) ) :

2263 
subpath
 = 
_handle_ns
 ( 
package
 , 
path_item
 )

2264 if 
subpath
 :

2265 
fixup_namespace_packages
 ( 
subpath
 , 
package
 )

2267 
_imp
 . 
release_lock
 ( ) 
	}

2270 def 
	$file_ns_handler
 ( 
importer
 , 
path_item
 , 
packageName
 , 
module
 ) :

2273 
subpath
 = 
os
 . 
path
 . 
join
 ( 
path_item
 , 
packageName
 . 
split
 ( '.' ) [ - 1 ] )

2274 
normalized
 = 
_normalize_cached
 ( 
subpath
 )

2275 for 
item
 in 
module
 . 
__path__
 :

2276 if 
_normalize_cached
 ( 
item
 ) == 
normalized
 :

2280 return 
subpath
 
	}

2283 
register_namespace_handler
 ( 
pkgutil
 . 
ImpImporter
 , 
file_ns_handler
 )

2284 
register_namespace_handler
 ( 
zipimport
 . 
zipimporter
 , 
file_ns_handler
 )

2286 if 
hasattr
 ( 
importlib_machinery
 , 'FileFinder' ) :

2287 
register_namespace_handler
 ( 
importlib_machinery
 . 
FileFinder
 , 
file_ns_handler
 )

2290 def 
	$null_ns_handler
 ( 
importer
 , 
path_item
 , 
packageName
 , 
module
 ) :

2291 return None 
	}

2294 
register_namespace_handler
 ( 
object
 , 
null_ns_handler
 )

2297 def 
	$normalize_path
 ( 
filename
 ) :

2299 return 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
realpath
 ( 
os
 . 
path
 . 
normpath
 ( 
_cygwin_patch
 ( 
filename
 ) ) ) ) 
	}

2302 def 
	$_cygwin_patch
 ( 
filename
 ) :

2310 return 
os
 . 
path
 . 
abspath
 ( 
filename
 ) if 
sys
 . 
platform
 == 'cygwin' else 
filename
 
	}

2313 def 
	$_normalize_cached
 ( 
filename
 , 
_cache
 = { } ) :

2315 return 
_cache
 [ 
filename
 ]

2316 except 
KeyError
 :

2317 
_cache
 [ 
filename
 ] = 
result
 = 
normalize_path
 ( 
filename
 )

2318 return 
result
 
	}

2321 def 
	$_is_egg_path
 ( 
path
 ) :

2325 return 
path
 . 
lower
 ( ) . 
endswith
 ( '.egg' ) 
	}

2328 def 
	$_is_unpacked_egg
 ( 
path
 ) :

2333 
_is_egg_path
 ( 
path
 ) and

2334 
os
 . 
path
 . 
isfile
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 'EGG-INFO' , 'PKG-INFO' ) )

2335 ) 
	}

2338 def 
	$_set_parent_ns
 ( 
packageName
 ) :

2339 
parts
 = 
packageName
 . 
split
 ( '.' )

2340 
name
 = 
parts
 . 
pop
 ( )

2341 if 
parts
 :

2342 
parent
 = '.' . 
join
 ( 
parts
 )

2343 
setattr
 ( 
sys
 . 
modules
 [ 
parent
 ] , 
name
 , 
sys
 . 
modules
 [ 
packageName
 ] ) 
	}

2346 def 
	$yield_lines
 ( 
strs
 ) :

2348 if 
isinstance
 ( 
strs
 , 
six
 . 
string_types
 ) :

2349 for 
s
 in 
strs
 . 
splitlines
 ( ) :

2350 
s
 = 
s
 . 
strip
 ( )

2352 if 
s
 and not 
s
 . 
startswith
 ( '#' ) :

2353 yield 
s

2355 for 
ss
 in 
strs
 :

2356 for 
s
 in 
yield_lines
 ( 
ss
 ) :

2357 yield 
s
 
	}

2360 
MODULE
 = 
re
 . 
compile
 ( r"\w+(\.\w+)*$" ) . 
match

2361 
EGG_NAME
 = 
re
 . 
compile
 ( r"""\n    (?P<name>[^-]+) (\n        -(?P<ver>[^-]+) (\n            -py(?P<pyver>[^-]+) (\n                -(?P<plat>.+)\n            )?\n        )?\n    )?\n    """

2371 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 ,

2372 ) . 
match

2375 class 
	cEntryPoint
 :

2378 def 
	$__init__
 ( 
self
 , 
name
 , 
module_name
 , 
attrs
 = ( ) , 
extras
 = ( ) , 
dist
 = None ) :

2379 if not 
MODULE
 ( 
module_name
 ) :

2380 raise 
ValueError
 ( "Invalid module name" , 
module_name
 )

2381 
self
 . 
name
 = 
name

2382 
self
 . 
module_name
 = 
module_name

2383 
self
 . 
attrs
 = 
tuple
 ( 
attrs
 )

2384 
self
 . 
extras
 = 
tuple
 ( 
extras
 )

2385 
self
 . 
dist
 = 
dist
 
	}

2387 def 
	$__str__
 ( 
self
 ) :

2388 
s
 = "%s = %s" % ( 
self
 . 
name
 , 
self
 . 
module_name
 )

2389 if 
self
 . 
attrs
 :

2390 
s
 += ':' + '.' . 
join
 ( 
self
 . 
attrs
 )

2391 if 
self
 . 
extras
 :

2392 
s
 += ' [%s]' % ',' . 
join
 ( 
self
 . 
extras
 )

2393 return 
s
 
	}

2395 def 
	$__repr__
 ( 
self
 ) :

2396 return "EntryPoint.parse(%r)" % 
str
 ( 
self
 ) 
	}

2398 def 
	$load
 ( 
self
 , 
require
 = True , * 
args
 , ** 
kwargs
 ) :

2402 if not 
require
 or 
args
 or 
kwargs
 :

2403 
warnings
 . 
warn
 ( "Parameters to load are deprecated.  Call .resolve and " ".require separately."

2406 
PkgResourcesDeprecationWarning
 ,

2407 
stacklevel
 = 2 ,

2409 if 
require
 :

2410 
self
 . 
require
 ( * 
args
 , ** 
kwargs
 )

2411 return 
self
 . 
resolve
 ( ) 
	}

2413 def 
	$resolve
 ( 
self
 ) :

2417 
module
 = 
__import__
 ( 
self
 . 
module_name
 , 
fromlist
 = [ '__name__' ] , 
level
 = 0 )

2419 return 
functools
 . 
reduce
 ( 
getattr
 , 
self
 . 
attrs
 , 
module
 )

2420 except 
AttributeError
 as 
exc
 :

2421 raise 
ImportError
 ( 
str
 ( 
exc
 ) ) 
	}

2423 def 
	$require
 ( 
self
 , 
env
 = None , 
installer
 = None ) :

2424 if 
self
 . 
extras
 and not 
self
 . 
dist
 :

2425 raise 
UnknownExtra
 ( "Can't require() without a distribution" , 
self
 )

2432 
reqs
 = 
self
 . 
dist
 . 
requires
 ( 
self
 . 
extras
 )

2433 
items
 = 
working_set
 . 
resolve
 ( 
reqs
 , 
env
 , 
installer
 , 
extras
 = 
self
 . 
extras
 )

2434 
list
 ( 
map
 ( 
working_set
 . 
add
 , 
items
 ) ) 
	}

2436 
pattern
 = 
re
 . 
compile
 ( r'\s*' r'(?P<name>.+?)\s*' r'=\s*' r'(?P<module>[\w.]+)\s*' r'(:\s*(?P<attr>[\w.]+))?\s*' r'(?P<extras>\[.*\])?\s*$'

2445 @ 
classmethod

2446 def 
	$parse
 ( 
cls
 , 
src
 , 
dist
 = None ) :

2456 
m
 = 
cls
 . 
pattern
 . 
match
 ( 
src
 )

2457 if not 
m
 :

2458 
msg
 = "EntryPoint must be in 'name=module:attrs [extras]' format"

2459 raise 
ValueError
 ( 
msg
 , 
src
 )

2460 
res
 = 
m
 . 
groupdict
 ( )

2461 
extras
 = 
cls
 . 
_parse_extras
 ( 
res
 [ 'extras' ] )

2462 
attrs
 = 
res
 [ 'attr' ] . 
split
 ( '.' ) if 
res
 [ 'attr' ] else ( )

2463 return 
cls
 ( 
res
 [ 'name' ] , 
res
 [ 'module' ] , 
attrs
 , 
extras
 , 
dist
 ) 
	}

2465 @ 
classmethod

2466 def 
	$_parse_extras
 ( 
cls
 , 
extras_spec
 ) :

2467 if not 
extras_spec
 :

2469 
req
 = 
Requirement
 . 
parse
 ( 'x' + 
extras_spec
 )

2470 if 
req
 . 
specs
 :

2471 raise 
ValueError
 ( )

2472 return 
req
 . 
extras
 
	}

2474 @ 
classmethod

2475 def 
	$parse_group
 ( 
cls
 , 
group
 , 
lines
 , 
dist
 = None ) :

2477 if not 
MODULE
 ( 
group
 ) :

2478 raise 
ValueError
 ( "Invalid group name" , 
group
 )

2479 
this
 = { }

2480 for 
line
 in 
yield_lines
 ( 
lines
 ) :

2481 
ep
 = 
cls
 . 
parse
 ( 
line
 , 
dist
 )

2482 if 
ep
 . 
name
 in 
this
 :

2483 raise 
ValueError
 ( "Duplicate entry point" , 
group
 , 
ep
 . 
name
 )

2484 
this
 [ 
ep
 . 
name
 ] = 
ep

2485 return 
this
 
	}

2487 @ 
classmethod

2488 def 
	$parse_map
 ( 
cls
 , 
data
 , 
dist
 = None ) :

2490 if 
isinstance
 ( 
data
 , 
dict
 ) :

2491 
data
 = 
data
 . 
items
 ( )

2493 
data
 = 
split_sections
 ( 
data
 )

2494 
maps
 = { }

2495 for 
group
 , 
lines
 in 
data
 :

2496 if 
group
 is None :

2497 if not 
lines
 :

2499 raise 
ValueError
 ( "Entry points must be listed in groups" )

2500 
group
 = 
group
 . 
strip
 ( )

2501 if 
group
 in 
maps
 :

2502 raise 
ValueError
 ( "Duplicate group name" , 
group
 )

2503 
maps
 [ 
group
 ] = 
cls
 . 
parse_group
 ( 
group
 , 
lines
 , 
dist
 )

2504 return 
maps
 
	}

2507 def 
	$_remove_md5_fragment
 ( 
location
 ) :

2508 if not 
location
 :

2510 
parsed
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
location
 )

2511 if 
parsed
 [ - 1 ] . 
startswith
 ( 'md5=' ) :

2512 return 
urllib
 . 
parse
 . 
urlunparse
 ( 
parsed
 [ : - 1 ] + ( '' , ) )

2513 return 
location
 
	}

2516 def 
	$_version_from_file
 ( 
lines
 ) :

2521 def 
is_version_line
 ( 
line
 ) :

2522 return 
line
 . 
lower
 ( ) . 
startswith
 ( 'version:' )

2523 
version_lines
 = 
filter
 ( 
is_version_line
 , 
lines
 )

2524 
line
 = 
next
 ( 
iter
 ( 
version_lines
 ) , '' )

2525 
_
 , 
_
 , 
value
 = 
line
 . 
partition
 ( ':' )

2526 return 
safe_version
 ( 
value
 . 
strip
 ( ) ) or None 
	}

2529 class 
	cDistribution
 :

2531 
PKG_INFO
 = 'PKG-INFO'

2533 def 
	$__init__
 (

2534 
self
 , 
location
 = None , 
metadata
 = None , 
project_name
 = None ,

2535 
version
 = None , 
py_version
 = 
PY_MAJOR
 , 
platform
 = None ,

2536 
precedence
 = 
EGG_DIST
 ) :

2537 
self
 . 
project_name
 = 
safe_name
 ( 
project_name
 or 'Unknown' )

2538 if 
version
 is not None :

2539 
self
 . 
_version
 = 
safe_version
 ( 
version
 )

2540 
self
 . 
py_version
 = 
py_version

2541 
self
 . 
platform
 = 
platform

2542 
self
 . 
location
 = 
location

2543 
self
 . 
precedence
 = 
precedence

2544 
self
 . 
_provider
 = 
metadata
 or 
empty_provider
 
	}

2546 @ 
classmethod

2547 def 
	$from_location
 ( 
cls
 , 
location
 , 
basename
 , 
metadata
 = None , ** 
kw
 ) :

2548 
project_name
 , 
version
 , 
py_version
 , 
platform
 = [ None ] * 4

2549 
basename
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
basename
 )

2550 if 
ext
 . 
lower
 ( ) in 
_distributionImpl
 :

2551 
cls
 = 
_distributionImpl
 [ 
ext
 . 
lower
 ( ) ]

2553 
match
 = 
EGG_NAME
 ( 
basename
 )

2554 if 
match
 :

2555 
project_name
 , 
version
 , 
py_version
 , 
platform
 = 
match
 . 
group
 ( 'name'

2558 return 
cls
 (

2559 
location
 , 
metadata
 , 
project_name
 = 
project_name
 , 
version
 = 
version
 ,

2560 
py_version
 = 
py_version
 , 
platform
 = 
platform
 , ** 
kw

2561 ) . 
_reload_version
 ( ) 
	}

2563 def 
	$_reload_version
 ( 
self
 ) :

2564 return 
self
 
	}

2566 @ 
property

2567 def 
	$hashcmp
 ( 
self
 ) :

2569 
self
 . 
parsed_version
 ,

2570 
self
 . 
precedence
 ,

2571 
self
 . 
key
 ,

2572 
_remove_md5_fragment
 ( 
self
 . 
location
 ) ,

2573 
self
 . 
py_version
 or '' ,

2574 
self
 . 
platform
 or '' ,

2575 ) 
	}

2577 def 
	$__hash__
 ( 
self
 ) :

2578 return 
hash
 ( 
self
 . 
hashcmp
 ) 
	}

2580 def 
	$__lt__
 ( 
self
 , 
other
 ) :

2581 return 
self
 . 
hashcmp
 < 
other
 . 
hashcmp
 
	}

2583 def 
	$__le__
 ( 
self
 , 
other
 ) :

2584 return 
self
 . 
hashcmp
 <= 
other
 . 
hashcmp
 
	}

2586 def 
	$__gt__
 ( 
self
 , 
other
 ) :

2587 return 
self
 . 
hashcmp
 > 
other
 . 
hashcmp
 
	}

2589 def 
	$__ge__
 ( 
self
 , 
other
 ) :

2590 return 
self
 . 
hashcmp
 >= 
other
 . 
hashcmp
 
	}

2592 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2593 if not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) :

2596 return 
self
 . 
hashcmp
 == 
other
 . 
hashcmp
 
	}

2598 def 
	$__ne__
 ( 
self
 , 
other
 ) :

2599 return not 
self
 == 
other
 
	}

2605 @ 
property

2606 def 
	$key
 ( 
self
 ) :

2608 return 
self
 . 
_key

2609 except 
AttributeError
 :

2610 
self
 . 
_key
 = 
key
 = 
self
 . 
project_name
 . 
lower
 ( )

2611 return 
key
 
	}

2613 @ 
property

2614 def 
	$parsed_version
 ( 
self
 ) :

2615 if not 
hasattr
 ( 
self
 , "_parsed_version" ) :

2616 
self
 . 
_parsed_version
 = 
parse_version
 ( 
self
 . 
version
 )

2618 return 
self
 . 
_parsed_version
 
	}

2620 def 
	$_warn_legacy_version
 ( 
self
 ) :

2621 
LV
 = 
packaging
 . 
version
 . 
LegacyVersion

2622 
is_legacy
 = 
isinstance
 ( 
self
 . 
_parsed_version
 , 
LV
 )

2623 if not 
is_legacy
 :

2632 if not 
self
 . 
version
 :

2635 
tmpl
 = 
textwrap
 . 
dedent
 ( """\n            '{project_name} ({version})' is being parsed as a legacy,\n            non PEP 440,\n            version. You may find odd behavior and sort order.\n            In particular it will be sorted as less than 0.0. It\n            is recommended to migrate to PEP 440 compatible\n            versions.\n            """

2642 ) . 
strip
 ( ) . 
replace
 ( '\n' , ' ' )

2644 
warnings
 . 
warn
 ( 
tmpl
 . 
format
 ( ** 
vars
 ( 
self
 ) ) , 
PEP440Warning
 ) 
	}

2646 @ 
property

2647 def 
	$version
 ( 
self
 ) :

2649 return 
self
 . 
_version

2650 except 
AttributeError
 :

2651 
version
 = 
_version_from_file
 ( 
self
 . 
_get_metadata
 ( 
self
 . 
PKG_INFO
 ) )

2652 if 
version
 is None :

2653 
tmpl
 = "Missing 'Version:' header and/or %s file"

2654 raise 
ValueError
 ( 
tmpl
 % 
self
 . 
PKG_INFO
 , 
self
 )

2655 return 
version
 
	}

2657 @ 
property

2658 def 
	$_dep_map
 ( 
self
 ) :

2664 return 
self
 . 
__dep_map

2665 except 
AttributeError
 :

2666 
self
 . 
__dep_map
 = 
self
 . 
_filter_extras
 ( 
self
 . 
_build_dep_map
 ( ) )

2667 return 
self
 . 
__dep_map
 
	}

2669 @ 
	`staticmethod

2670 def 
	$_filter_extras
 ( 
dm
 ) :

2676 for 
extra
 in 
list
 ( 
filter
 ( None , 
dm
 ) ) :

2677 
new_extra
 = 
extra

2678 
reqs
 = 
dm
 . 
pop
 ( 
extra
 )

2679 
new_extra
 , 
_
 , 
marker
 = 
extra
 . 
partition
 ( ':' )

2680 
fails_marker
 = 
marker
 and (

2681 
invalid_marker
 ( 
marker
 )

2682 or not 
evaluate_marker
 ( 
marker
 )

2684 if 
fails_marker
 :

2685 
reqs
 = [ ]

2686 
new_extra
 = 
safe_extra
 ( 
new_extra
 ) or None

2688 
dm
 . 
setdefault
 ( 
new_extra
 , [ ] ) . 
extend
 ( 
reqs
 )

2689 return 
dm
 
	}

2691 def 
	$_build_dep_map
 ( 
self
 ) :

2692 
dm
 = { }

2693 for 
name
 in 'requires.txt' , 'depends.txt' :

2694 for 
extra
 , 
reqs
 in 
split_sections
 ( 
self
 . 
_get_metadata
 ( 
name
 ) ) :

2695 
dm
 . 
setdefault
 ( 
extra
 , [ ] ) . 
extend
 ( 
parse_requirements
 ( 
reqs
 ) )

2696 return 
dm
 
	}

2698 def 
	$requires
 ( 
self
 , 
extras
 = ( ) ) :

2700 
dm
 = 
self
 . 
_dep_map

2701 
deps
 = [ ]

2702 
deps
 . 
extend
 ( 
dm
 . 
get
 ( None , ( ) ) )

2703 for 
ext
 in 
extras
 :

2705 
deps
 . 
extend
 ( 
dm
 [ 
safe_extra
 ( 
ext
 ) ] )

2706 except 
KeyError
 :

2707 raise 
UnknownExtra
 ( "%s has no such extra feature %r"

2708 % ( 
self
 , 
ext
 )

2710 return 
deps
 
	}

2712 def 
	$_get_metadata
 ( 
self
 , 
name
 ) :

2713 if 
self
 . 
has_metadata
 ( 
name
 ) :

2714 for 
line
 in 
self
 . 
get_metadata_lines
 ( 
name
 ) :

2715 yield 
line
 
	}

2717 def 
	$activate
 ( 
self
 , 
path
 = None , 
replace
 = False ) :

2719 if 
path
 is None :

2720 
path
 = 
sys
 . 
path

2721 
self
 . 
insert_on
 ( 
path
 , 
replace
 = 
replace
 )

2722 if 
path
 is 
sys
 . 
path
 :

2723 
fixup_namespace_packages
 ( 
self
 . 
location
 )

2724 for 
pkg
 in 
self
 . 
_get_metadata
 ( 'namespace_packages.txt' ) :

2725 if 
pkg
 in 
sys
 . 
modules
 :

2726 
declare_namespace
 ( 
pkg
 ) 
	}

2728 def 
	$egg_name
 ( 
self
 ) :

2730 
filename
 = "%s-%s-py%s" % (

2731 
to_filename
 ( 
self
 . 
project_name
 ) , 
to_filename
 ( 
self
 . 
version
 ) ,

2732 
self
 . 
py_version
 or 
PY_MAJOR

2735 if 
self
 . 
platform
 :

2736 
filename
 += '-' + 
self
 . 
platform

2737 return 
filename
 
	}

2739 def 
	$__repr__
 ( 
self
 ) :

2740 if 
self
 . 
location
 :

2741 return "%s (%s)" % ( 
self
 , 
self
 . 
location
 )

2743 return 
str
 ( 
self
 ) 
	}

2745 def 
	$__str__
 ( 
self
 ) :

2747 
version
 = 
getattr
 ( 
self
 , 'version' , None )

2748 except 
ValueError
 :

2749 
version
 = None

2750 
version
 = 
version
 or "[unknown version]"

2751 return "%s %s" % ( 
self
 . 
project_name
 , 
version
 ) 
	}

2753 def 
	$__getattr__
 ( 
self
 , 
attr
 ) :

2755 if 
attr
 . 
startswith
 ( '_' ) :

2756 raise 
AttributeError
 ( 
attr
 )

2757 return 
getattr
 ( 
self
 . 
_provider
 , 
attr
 ) 
	}

2759 def 
	$__dir__
 ( 
self
 ) :

2760 return 
list
 (

2761 
set
 ( 
super
 ( 
Distribution
 , 
self
 ) . 
__dir__
 ( ) )

2762 | 
set
 (

2763 
attr
 for 
attr
 in 
self
 . 
_provider
 . 
__dir__
 ( )

2764 if not 
attr
 . 
startswith
 ( '_' )

2766 ) 
	}

2768 if not 
hasattr
 ( 
object
 , '__dir__' ) :

2770 del 
__dir__

2772 @ 
classmethod

2773 def 
	$from_filename
 ( 
cls
 , 
filename
 , 
metadata
 = None , ** 
kw
 ) :

2774 return 
cls
 . 
from_location
 (

2775 
_normalize_cached
 ( 
filename
 ) , 
os
 . 
path
 . 
basename
 ( 
filename
 ) , 
metadata
 ,

2776 ** 
kw

2777 ) 
	}

2779 def 
	$as_requirement
 ( 
self
 ) :

2781 if 
isinstance
 ( 
self
 . 
parsed_version
 , 
packaging
 . 
version
 . 
Version
 ) :

2782 
spec
 = "%s==%s" % ( 
self
 . 
project_name
 , 
self
 . 
parsed_version
 )

2784 
spec
 = "%s===%s" % ( 
self
 . 
project_name
 , 
self
 . 
parsed_version
 )

2786 return 
Requirement
 . 
parse
 ( 
spec
 ) 
	}

2788 def 
	$load_entry_point
 ( 
self
 , 
group
 , 
name
 ) :

2790 
ep
 = 
self
 . 
get_entry_info
 ( 
group
 , 
name
 )

2791 if 
ep
 is None :

2792 raise 
ImportError
 ( "Entry point %r not found" % ( ( 
group
 , 
name
 ) , ) )

2793 return 
ep
 . 
load
 ( ) 
	}

2795 def 
	$get_entry_map
 ( 
self
 , 
group
 = None ) :

2798 
ep_map
 = 
self
 . 
_ep_map

2799 except 
AttributeError
 :

2800 
ep_map
 = 
self
 . 
_ep_map
 = 
EntryPoint
 . 
parse_map
 (

2801 
self
 . 
_get_metadata
 ( 'entry_points.txt' ) , 
self

2803 if 
group
 is not None :

2804 return 
ep_map
 . 
get
 ( 
group
 , { } )

2805 return 
ep_map
 
	}

2807 def 
	$get_entry_info
 ( 
self
 , 
group
 , 
name
 ) :

2809 return 
self
 . 
get_entry_map
 ( 
group
 ) . 
get
 ( 
name
 ) 
	}

2811 def 
	$insert_on
 ( 
self
 , 
path
 , 
loc
 = None , 
replace
 = False ) :

2831 
loc
 = 
loc
 or 
self
 . 
location

2832 if not 
loc
 :

2835 
nloc
 = 
_normalize_cached
 ( 
loc
 )

2836 
bdir
 = 
os
 . 
path
 . 
dirname
 ( 
nloc
 )

2837 
npath
 = [ ( 
p
 and 
_normalize_cached
 ( 
p
 ) or 
p
 ) for 
p
 in 
path
 ]

2839 for 
p
 , 
item
 in 
enumerate
 ( 
npath
 ) :

2840 if 
item
 == 
nloc
 :

2841 if 
replace
 :

2847 elif 
item
 == 
bdir
 and 
self
 . 
precedence
 == 
EGG_DIST
 :

2850 if ( not 
replace
 ) and 
nloc
 in 
npath
 [ 
p
 : ] :

2852 if 
path
 is 
sys
 . 
path
 :

2853 
self
 . 
check_version_conflict
 ( )

2854 
path
 . 
insert
 ( 
p
 , 
loc
 )

2855 
npath
 . 
insert
 ( 
p
 , 
nloc
 )

2858 if 
path
 is 
sys
 . 
path
 :

2859 
self
 . 
check_version_conflict
 ( )

2860 if 
replace
 :

2861 
path
 . 
insert
 ( 0 , 
loc
 )

2863 
path
 . 
append
 ( 
loc
 )

2869 
np
 = 
npath
 . 
index
 ( 
nloc
 , 
p
 + 1 )

2870 except 
ValueError
 :

2873 del 
npath
 [ 
np
 ] , 
path
 [ 
np
 ]

2875 
p
 = 
np

2877 return 
	}

2879 def 
	$check_version_conflict
 ( 
self
 ) :

2880 if 
self
 . 
key
 == 'setuptools' :

2884 
nsp
 = 
dict
 . 
fromkeys
 ( 
self
 . 
_get_metadata
 ( 'namespace_packages.txt' ) )

2885 
loc
 = 
normalize_path
 ( 
self
 . 
location
 )

2886 for 
modname
 in 
self
 . 
_get_metadata
 ( 'top_level.txt' ) :

2887 if ( 
modname
 not in 
sys
 . 
modules
 or 
modname
 in 
nsp

2888 or 
modname
 in 
_namespace_packages
 ) :

2890 if 
modname
 in ( 'pkg_resources' , 'setuptools' , 'site' ) :

2892 
fn
 = 
getattr
 ( 
sys
 . 
modules
 [ 
modname
 ] , '__file__' , None )

2893 if 
fn
 and ( 
normalize_path
 ( 
fn
 ) . 
startswith
 ( 
loc
 ) or

2894 
fn
 . 
startswith
 ( 
self
 . 
location
 ) ) :

2896 
issue_warning
 ( "Module %s was already imported from %s, but %s is being added" " to sys.path"

2898 % ( 
modname
 , 
fn
 , 
self
 . 
location
 ) ,

2899 ) 
	}

2901 def 
	$has_version
 ( 
self
 ) :

2903 
self
 . 
version

2904 except 
ValueError
 :

2905 
issue_warning
 ( "Unbuilt egg for " + 
repr
 ( 
self
 ) )

2907 return True 
	}

2909 def 
	$clone
 ( 
self
 , ** 
kw
 ) :

2911 
names
 = 'project_name version py_version platform location precedence'

2912 for 
attr
 in 
names
 . 
split
 ( ) :

2913 
kw
 . 
setdefault
 ( 
attr
 , 
getattr
 ( 
self
 , 
attr
 , None ) )

2914 
kw
 . 
setdefault
 ( 'metadata' , 
self
 . 
_provider
 )

2915 return 
self
 . 
__class__
 ( ** 
kw
 ) 
	}

2917 @ 
property

2918 def 
	$extras
 ( 
self
 ) :

2919 return [ 
dep
 for 
dep
 in 
self
 . 
_dep_map
 if 
dep
 ] 
	}

2922 class 
	cEggInfoDistribution
 ( 
Distribution
 ) :

2923 def 
	$_reload_version
 ( 
self
 ) :

2935 
md_version
 = 
_version_from_file
 ( 
self
 . 
_get_metadata
 ( 
self
 . 
PKG_INFO
 ) )

2936 if 
md_version
 :

2937 
self
 . 
_version
 = 
md_version

2938 return 
self
 
	}

2941 class 
	cDistInfoDistribution
 ( 
Distribution
 ) :

2946 
PKG_INFO
 = 'METADATA'

2947 
EQEQ
 = 
re
 . 
compile
 ( r"([\(,])\s*(\d.*?)\s*([,\)])" )

2949 @ 
property

2950 def 
	$_parsed_pkg_info
 ( 
self
 ) :

2953 return 
self
 . 
_pkg_info

2954 except 
AttributeError
 :

2955 
metadata
 = 
self
 . 
get_metadata
 ( 
self
 . 
PKG_INFO
 )

2956 
self
 . 
_pkg_info
 = 
email
 . 
parser
 . 
Parser
 ( ) . 
parsestr
 ( 
metadata
 )

2957 return 
self
 . 
_pkg_info
 
	}

2959 @ 
property

2960 def 
	$_dep_map
 ( 
self
 ) :

2962 return 
self
 . 
__dep_map

2963 except 
AttributeError
 :

2964 
self
 . 
__dep_map
 = 
self
 . 
_compute_dependencies
 ( )

2965 return 
self
 . 
__dep_map
 
	}

2967 def 
	$_compute_dependencies
 ( 
self
 ) :

2969 
dm
 = 
self
 . 
__dep_map
 = { None : [ ] }

2971 
reqs
 = [ ]

2973 for 
req
 in 
self
 . 
_parsed_pkg_info
 . 
get_all
 ( 'Requires-Dist' ) or [ ] :

2974 
reqs
 . 
extend
 ( 
parse_requirements
 ( 
req
 ) )

2976 def 
reqs_for_extra
 ( 
extra
 ) :

2977 for 
req
 in 
reqs
 :

2978 if not 
req
 . 
marker
 or 
req
 . 
marker
 . 
evaluate
 ( { 'extra' : 
extra
 } ) :

2979 yield 
req

2981 
common
 = 
frozenset
 ( 
reqs_for_extra
 ( None ) )

2982 
dm
 [ None ] . 
extend
 ( 
common
 )

2984 for 
extra
 in 
self
 . 
_parsed_pkg_info
 . 
get_all
 ( 'Provides-Extra' ) or [ ] :

2985 
s_extra
 = 
safe_extra
 ( 
extra
 . 
strip
 ( ) )

2986 
dm
 [ 
s_extra
 ] = 
list
 ( 
frozenset
 ( 
reqs_for_extra
 ( 
extra
 ) ) - 
common
 )

2988 return 
dm
 
	}

2991 
_distributionImpl
 = { '.egg'

2992 : 
Distribution
 , '.egg-info'

2993 : 
EggInfoDistribution
 , '.dist-info'

2994 : 
DistInfoDistribution
 ,

2998 def 
	$issue_warning
 ( * 
args
 , ** 
kw
 ) :

2999 
level
 = 1

3000 
g
 = 
globals
 ( )

3004 while 
sys
 . 
_getframe
 ( 
level
 ) . 
f_globals
 is 
g
 :

3005 
level
 += 1

3006 except 
ValueError
 :

3008 
warnings
 . 
warn
 ( 
stacklevel
 = 
level
 + 1 , * 
args
 , ** 
kw
 ) 
	}

3011 class 
	cRequirementParseError
 ( 
ValueError
 ) :

3012 def 
	$__str__
 ( 
self
 ) :

3013 return ' ' . 
join
 ( 
self
 . 
args
 ) 
	}

3016 def 
	$parse_requirements
 ( 
strs
 ) :

3022 
lines
 = 
iter
 ( 
yield_lines
 ( 
strs
 ) )

3024 for 
line
 in 
lines
 :

3026 if ' #' in 
line
 :

3027 
line
 = 
line
 [ : 
line
 . 
find
 ( ' #' ) ]

3029 if 
line
 . 
endswith
 ( '\\' ) :

3030 
line
 = 
line
 [ : - 2 ] . 
strip
 ( )

3032 
line
 += 
next
 ( 
lines
 )

3033 except 
StopIteration
 :

3035 yield 
Requirement
 ( 
line
 ) 
	}

3038 class 
	cRequirement
 ( 
packaging
 . 
requirements
 . 
Requirement
 ) :

3039 def 
	$__init__
 ( 
self
 , 
requirement_string
 ) :

3042 
super
 ( 
Requirement
 , 
self
 ) . 
__init__
 ( 
requirement_string
 )

3043 except 
packaging
 . 
requirements
 . 
InvalidRequirement
 as 
e
 :

3044 raise 
RequirementParseError
 ( 
str
 ( 
e
 ) )

3045 
self
 . 
unsafe_name
 = 
self
 . 
name

3046 
project_name
 = 
safe_name
 ( 
self
 . 
name
 )

3047 
self
 . 
project_name
 , 
self
 . 
key
 = 
project_name
 , 
project_name
 . 
lower
 ( )

3048 
self
 . 
specs
 = [

3049 ( 
spec
 . 
operator
 , 
spec
 . 
version
 ) for 
spec
 in 
self
 . 
specifier
 ]

3050 
self
 . 
extras
 = 
tuple
 ( 
map
 ( 
safe_extra
 , 
self
 . 
extras
 ) )

3051 
self
 . 
hashCmp
 = (

3052 
self
 . 
key
 ,

3053 
self
 . 
specifier
 ,

3054 
frozenset
 ( 
self
 . 
extras
 ) ,

3055 
str
 ( 
self
 . 
marker
 ) if 
self
 . 
marker
 else None ,

3057 
self
 . 
__hash
 = 
hash
 ( 
self
 . 
hashCmp
 ) 
	}

3059 def 
	$__eq__
 ( 
self
 , 
other
 ) :

3061 
isinstance
 ( 
other
 , 
Requirement
 ) and

3062 
self
 . 
hashCmp
 == 
other
 . 
hashCmp

3063 ) 
	}

3065 def 
	$__ne__
 ( 
self
 , 
other
 ) :

3066 return not 
self
 == 
other
 
	}

3068 def 
	$__contains__
 ( 
self
 , 
item
 ) :

3069 if 
isinstance
 ( 
item
 , 
Distribution
 ) :

3070 if 
item
 . 
key
 != 
self
 . 
key
 :

3073 
item
 = 
item
 . 
version

3078 return 
self
 . 
specifier
 . 
contains
 ( 
item
 , 
prereleases
 = True ) 
	}

3080 def 
	$__hash__
 ( 
self
 ) :

3081 return 
self
 . 
__hash
 
	}

3083 def 
	$__repr__
 ( 
self
 ) :

3084 return "Requirement.parse(%r)" % 
str
 ( 
self
 ) 
	}

3086 @ 
	`staticmethod

3087 def 
	$parse
 ( 
s
 ) :

3088 
req
 , = 
parse_requirements
 ( 
s
 )

3089 return 
req
 
	}

3092 def 
	$_always_object
 ( 
classes
 ) :

3097 if 
object
 not in 
classes
 :

3098 return 
classes
 + ( 
object
 , )

3099 return 
classes
 
	}

3102 def 
	$_find_adapter
 ( 
registry
 , 
ob
 ) :

3104 
types
 = 
_always_object
 ( 
inspect
 . 
getmro
 ( 
getattr
 ( 
ob
 , '__class__' , 
type
 ( 
ob
 ) ) ) )

3105 for 
t
 in 
types
 :

3106 if 
t
 in 
registry
 :

3107 return 
registry
 [ 
t
 ] 
	}

3110 def 
	$ensure_directory
 ( 
path
 ) :

3112 
dirname
 = 
os
 . 
path
 . 
dirname
 ( 
path
 )

3113 
py31compat
 . 
makedirs
 ( 
dirname
 , 
exist_ok
 = True ) 
	}

3116 def 
	$_bypass_ensure_directory
 ( 
path
 ) :

3118 if not 
WRITE_SUPPORT
 :

3119 raise 
IOError
 ( '"os.mkdir" not supported on this platform.' )

3120 
dirname
 , 
filename
 = 
split
 ( 
path
 )

3121 if 
dirname
 and 
filename
 and not 
isdir
 ( 
dirname
 ) :

3122 
_bypass_ensure_directory
 ( 
dirname
 )

3124 
mkdir
 ( 
dirname
 , 0o755 )

3125 except 
FileExistsError
 :

3126 pass 
	}

3129 def 
	$split_sections
 ( 
s
 ) :

3137 
section
 = None

3138 
content
 = [ ]

3139 for 
line
 in 
yield_lines
 ( 
s
 ) :

3140 if 
line
 . 
startswith
 ( "[" ) :

3141 if 
line
 . 
endswith
 ( "]" ) :

3142 if 
section
 or 
content
 :

3143 yield 
section
 , 
content

3144 
section
 = 
line
 [ 1 : - 1 ] . 
strip
 ( )

3145 
content
 = [ ]

3147 raise 
ValueError
 ( "Invalid section heading" , 
line
 )

3149 
content
 . 
append
 ( 
line
 )

3152 yield 
section
 , 
content
 
	}

3155 def 
	$_mkstemp
 ( * 
args
 , ** 
kw
 ) :

3156 
old_open
 = 
os
 . 
open

3159 
os
 . 
open
 = 
os_open

3160 return 
tempfile
 . 
mkstemp
 ( * 
args
 , ** 
kw
 )

3163 
os
 . 
open
 = 
old_open
 
	}

3170 
warnings
 . 
filterwarnings
 ( "ignore" , 
category
 = 
PEP440Warning
 , 
append
 = True )

3174 def 
	$_call_aside
 ( 
f
 , * 
args
 , ** 
kwargs
 ) :

3175 
f
 ( * 
args
 , ** 
kwargs
 )

3176 return 
f
 
	}

3179 @ 
	`_call_aside

3180 def 
	$_initialize
 ( 
g
 = 
globals
 ( ) ) :

3182 
manager
 = 
ResourceManager
 ( )

3183 
g
 [ '_manager' ] = 
manager

3184 
g
 . 
update
 (

3185 ( 
name
 , 
getattr
 ( 
manager
 , 
name
 ) )

3186 for 
name
 in 
dir
 ( 
manager
 )

3187 if not 
name
 . 
startswith
 ( '_' )

3188 ) 
	}

3191 @ 
	`_call_aside

3192 def 
	$_initialize_master_working_set
 ( ) :

3204 
working_set
 = 
WorkingSet
 . 
_build_master
 ( )

3205 
_declare_state
 ( 'object' , 
working_set
 = 
working_set
 )

3207 
require
 = 
working_set
 . 
require

3208 
iter_entry_points
 = 
working_set
 . 
iter_entry_points

3209 
add_activation_listener
 = 
working_set
 . 
subscribe

3210 
run_script
 = 
working_set
 . 
run_script

3212 
run_main
 = 
run_script

3217 
tuple
 (

3218 
dist
 . 
activate
 ( 
replace
 = False )

3219 for 
dist
 in 
working_set

3221 
add_activation_listener
 (

3222 lambda 
dist
 : 
dist
 . 
activate
 ( 
replace
 = True ) ,

3223 
existing
 = False ,

3225 
working_set
 . 
entries
 = [ ]

3227 
list
 ( 
map
 ( 
working_set
 . 
add_entry
 , 
sys
 . 
path
 ) )

3228 
globals
 ( ) . 
update
 ( 
locals
 ( ) ) 
	}

3230 class 
	cPkgResourcesDeprecationWarning
 ( 
Warning
 ) :


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/six.py

23 from 
	~__future__
 import 
absolute_import

25 import 
	~functools

26 import 
	~itertools

27 import 
	~operator

28 import 
	~sys

29 import 
	~types

31 
__author__
 = "Benjamin Peterson <benjamin@python.org>"

32 
__version__
 = "1.10.0"

36 
PY2
 = 
sys
 . 
version_info
 [ 0 ] == 2

37 
PY3
 = 
sys
 . 
version_info
 [ 0 ] == 3

38 
PY34
 = 
sys
 . 
version_info
 [ 0 : 2 ] >= ( 3 , 4 )

40 if 
PY3
 :

41 
string_types
 = 
str
 ,

42 
integer_types
 = 
int
 ,

43 
class_types
 = 
type
 ,

44 
text_type
 = 
str

45 
binary_type
 = 
bytes

47 
MAXSIZE
 = 
sys
 . 
maxsize

49 
string_types
 = 
basestring
 ,

50 
integer_types
 = ( 
int
 , 
long
 )

51 
class_types
 = ( 
type
 , 
types
 . 
ClassType
 )

52 
text_type
 = 
unicode

53 
binary_type
 = 
str

55 if 
sys
 . 
platform
 . 
startswith
 ( "java" ) :

57 
MAXSIZE
 = 
int
 ( ( 1 << 31 ) - 1 )

60 class 
	cX
 ( 
object
 ) :

62 def 
	$__len__
 ( 
self
 ) :

63 return 1 << 31 
	}

65 
len
 ( 
X
 ( ) )

66 except 
OverflowError
 :

68 
MAXSIZE
 = 
int
 ( ( 1 << 31 ) - 1 )

71 
MAXSIZE
 = 
int
 ( ( 1 << 63 ) - 1 )

72 del 
X

75 def 
	$_add_doc
 ( 
func
 , 
doc
 ) :

77 
func
 . 
__doc__
 = 
doc
 
	}

80 def 
	$_import_module
 ( 
name
 ) :

82 
__import__
 ( 
name
 )

83 return 
sys
 . 
modules
 [ 
name
 ] 
	}

86 class 
	c_LazyDescr
 ( 
object
 ) :

88 def 
	$__init__
 ( 
self
 , 
name
 ) :

89 
self
 . 
name
 = 
name
 
	}

91 def 
	$__get__
 ( 
self
 , 
obj
 , 
tp
 ) :

92 
result
 = 
self
 . 
_resolve
 ( )

93 
setattr
 ( 
obj
 , 
self
 . 
name
 , 
result
 )

97 
delattr
 ( 
obj
 . 
__class__
 , 
self
 . 
name
 )

98 except 
AttributeError
 :

100 return 
result
 
	}

103 class 
	cMovedModule
 ( 
_LazyDescr
 ) :

105 def 
	$__init__
 ( 
self
 , 
name
 , 
old
 , 
new
 = None ) :

106 
super
 ( 
MovedModule
 , 
self
 ) . 
__init__
 ( 
name
 )

107 if 
PY3
 :

108 if 
new
 is None :

109 
new
 = 
name

110 
self
 . 
mod
 = 
new

112 
self
 . 
mod
 = 
old
 
	}

114 def 
	$_resolve
 ( 
self
 ) :

115 return 
_import_module
 ( 
self
 . 
mod
 ) 
	}

117 def 
	$__getattr__
 ( 
self
 , 
attr
 ) :

118 
_module
 = 
self
 . 
_resolve
 ( )

119 
value
 = 
getattr
 ( 
_module
 , 
attr
 )

120 
setattr
 ( 
self
 , 
attr
 , 
value
 )

121 return 
value
 
	}

124 class 
	c_LazyModule
 ( 
types
 . 
ModuleType
 ) :

126 def 
	$__init__
 ( 
self
 , 
name
 ) :

127 
super
 ( 
_LazyModule
 , 
self
 ) . 
__init__
 ( 
name
 )

128 
self
 . 
__doc__
 = 
self
 . 
__class__
 . 
__doc__
 
	}

130 def 
	$__dir__
 ( 
self
 ) :

131 
attrs
 = [ "__doc__" , "__name__" ]

132 
attrs
 += [ 
attr
 . 
name
 for 
attr
 in 
self
 . 
_moved_attributes
 ]

133 return 
attrs
 
	}

136 
_moved_attributes
 = [ ]

139 class 
	cMovedAttribute
 ( 
_LazyDescr
 ) :

141 def 
	$__init__
 ( 
self
 , 
name
 , 
old_mod
 , 
new_mod
 , 
old_attr
 = None , 
new_attr
 = None ) :

142 
super
 ( 
MovedAttribute
 , 
self
 ) . 
__init__
 ( 
name
 )

143 if 
PY3
 :

144 if 
new_mod
 is None :

145 
new_mod
 = 
name

146 
self
 . 
mod
 = 
new_mod

147 if 
new_attr
 is None :

148 if 
old_attr
 is None :

149 
new_attr
 = 
name

151 
new_attr
 = 
old_attr

152 
self
 . 
attr
 = 
new_attr

154 
self
 . 
mod
 = 
old_mod

155 if 
old_attr
 is None :

156 
old_attr
 = 
name

157 
self
 . 
attr
 = 
old_attr
 
	}

159 def 
	$_resolve
 ( 
self
 ) :

160 
module
 = 
_import_module
 ( 
self
 . 
mod
 )

161 return 
getattr
 ( 
module
 , 
self
 . 
attr
 ) 
	}

164 class 
	c_SixMetaPathImporter
 ( 
object
 ) :

173 def 
	$__init__
 ( 
self
 , 
six_module_name
 ) :

174 
self
 . 
name
 = 
six_module_name

175 
self
 . 
known_modules
 = { } 
	}

177 def 
	$_add_module
 ( 
self
 , 
mod
 , * 
fullnames
 ) :

178 for 
fullname
 in 
fullnames
 :

179 
self
 . 
known_modules
 [ 
self
 . 
name
 + "." + 
fullname
 ] = 
mod
 
	}

181 def 
	$_get_module
 ( 
self
 , 
fullname
 ) :

182 return 
self
 . 
known_modules
 [ 
self
 . 
name
 + "." + 
fullname
 ] 
	}

184 def 
	$find_module
 ( 
self
 , 
fullname
 , 
path
 = None ) :

185 if 
fullname
 in 
self
 . 
known_modules
 :

186 return 
self

187 return None 
	}

189 def 
	$__get_module
 ( 
self
 , 
fullname
 ) :

191 return 
self
 . 
known_modules
 [ 
fullname
 ]

192 except 
KeyError
 :

193 raise 
ImportError
 ( "This loader does not know module " + 
fullname
 ) 
	}

195 def 
	$load_module
 ( 
self
 , 
fullname
 ) :

198 return 
sys
 . 
modules
 [ 
fullname
 ]

199 except 
KeyError
 :

201 
mod
 = 
self
 . 
__get_module
 ( 
fullname
 )

202 if 
isinstance
 ( 
mod
 , 
MovedModule
 ) :

203 
mod
 = 
mod
 . 
_resolve
 ( )

205 
mod
 . 
__loader__
 = 
self

206 
sys
 . 
modules
 [ 
fullname
 ] = 
mod

207 return 
mod
 
	}

209 def 
	$is_package
 ( 
self
 , 
fullname
 ) :

216 return 
hasattr
 ( 
self
 . 
__get_module
 ( 
fullname
 ) , "__path__" ) 
	}

218 def 
	$get_code
 ( 
self
 , 
fullname
 ) :

222 
self
 . 
__get_module
 ( 
fullname
 )

223 return None 
	}

224 
get_source
 = 
get_code

226 
_importer
 = 
_SixMetaPathImporter
 ( 
__name__
 )

229 class 
	c_MovedItems
 ( 
_LazyModule
 ) :

232 
__path__
 = [ ]

235 
_moved_attributes
 = [

236 
MovedAttribute
 ( "cStringIO" , "cStringIO" , "io" , "StringIO" ) ,

237 
MovedAttribute
 ( "filter" , "itertools" , "builtins" , "ifilter" , "filter" ) ,

238 
MovedAttribute
 ( "filterfalse" , "itertools" , "itertools" , "ifilterfalse" , "filterfalse" ) ,

239 
MovedAttribute
 ( "input" , "__builtin__" , "builtins" , "raw_input" , "input" ) ,

240 
MovedAttribute
 ( "intern" , "__builtin__" , "sys" ) ,

241 
MovedAttribute
 ( "map" , "itertools" , "builtins" , "imap" , "map" ) ,

242 
MovedAttribute
 ( "getcwd" , "os" , "os" , "getcwdu" , "getcwd" ) ,

243 
MovedAttribute
 ( "getcwdb" , "os" , "os" , "getcwd" , "getcwdb" ) ,

244 
MovedAttribute
 ( "range" , "__builtin__" , "builtins" , "xrange" , "range" ) ,

245 
MovedAttribute
 ( "reload_module" , "__builtin__" , "importlib" if 
PY34
 else "imp" , "reload" ) ,

246 
MovedAttribute
 ( "reduce" , "__builtin__" , "functools" ) ,

247 
MovedAttribute
 ( "shlex_quote" , "pipes" , "shlex" , "quote" ) ,

248 
MovedAttribute
 ( "StringIO" , "StringIO" , "io" ) ,

249 
MovedAttribute
 ( "UserDict" , "UserDict" , "collections" ) ,

250 
MovedAttribute
 ( "UserList" , "UserList" , "collections" ) ,

251 
MovedAttribute
 ( "UserString" , "UserString" , "collections" ) ,

252 
MovedAttribute
 ( "xrange" , "__builtin__" , "builtins" , "xrange" , "range" ) ,

253 
MovedAttribute
 ( "zip" , "itertools" , "builtins" , "izip" , "zip" ) ,

254 
MovedAttribute
 ( "zip_longest" , "itertools" , "itertools" , "izip_longest" , "zip_longest" ) ,

255 
MovedModule
 ( "builtins" , "__builtin__" ) ,

256 
MovedModule
 ( "configparser" , "ConfigParser" ) ,

257 
MovedModule
 ( "copyreg" , "copy_reg" ) ,

258 
MovedModule
 ( "dbm_gnu" , "gdbm" , "dbm.gnu" ) ,

259 
MovedModule
 ( "_dummy_thread" , "dummy_thread" , "_dummy_thread" ) ,

260 
MovedModule
 ( "http_cookiejar" , "cookielib" , "http.cookiejar" ) ,

261 
MovedModule
 ( "http_cookies" , "Cookie" , "http.cookies" ) ,

262 
MovedModule
 ( "html_entities" , "htmlentitydefs" , "html.entities" ) ,

263 
MovedModule
 ( "html_parser" , "HTMLParser" , "html.parser" ) ,

264 
MovedModule
 ( "http_client" , "httplib" , "http.client" ) ,

265 
MovedModule
 ( "email_mime_multipart" , "email.MIMEMultipart" , "email.mime.multipart" ) ,

266 
MovedModule
 ( "email_mime_nonmultipart" , "email.MIMENonMultipart" , "email.mime.nonmultipart" ) ,

267 
MovedModule
 ( "email_mime_text" , "email.MIMEText" , "email.mime.text" ) ,

268 
MovedModule
 ( "email_mime_base" , "email.MIMEBase" , "email.mime.base" ) ,

269 
MovedModule
 ( "BaseHTTPServer" , "BaseHTTPServer" , "http.server" ) ,

270 
MovedModule
 ( "CGIHTTPServer" , "CGIHTTPServer" , "http.server" ) ,

271 
MovedModule
 ( "SimpleHTTPServer" , "SimpleHTTPServer" , "http.server" ) ,

272 
MovedModule
 ( "cPickle" , "cPickle" , "pickle" ) ,

273 
MovedModule
 ( "queue" , "Queue" ) ,

274 
MovedModule
 ( "reprlib" , "repr" ) ,

275 
MovedModule
 ( "socketserver" , "SocketServer" ) ,

276 
MovedModule
 ( "_thread" , "thread" , "_thread" ) ,

277 
MovedModule
 ( "tkinter" , "Tkinter" ) ,

278 
MovedModule
 ( "tkinter_dialog" , "Dialog" , "tkinter.dialog" ) ,

279 
MovedModule
 ( "tkinter_filedialog" , "FileDialog" , "tkinter.filedialog" ) ,

280 
MovedModule
 ( "tkinter_scrolledtext" , "ScrolledText" , "tkinter.scrolledtext" ) ,

281 
MovedModule
 ( "tkinter_simpledialog" , "SimpleDialog" , "tkinter.simpledialog" ) ,

282 
MovedModule
 ( "tkinter_tix" , "Tix" , "tkinter.tix" ) ,

283 
MovedModule
 ( "tkinter_ttk" , "ttk" , "tkinter.ttk" ) ,

284 
MovedModule
 ( "tkinter_constants" , "Tkconstants" , "tkinter.constants" ) ,

285 
MovedModule
 ( "tkinter_dnd" , "Tkdnd" , "tkinter.dnd" ) ,

286 
MovedModule
 ( "tkinter_colorchooser" , "tkColorChooser" , "tkinter.colorchooser"

288 
MovedModule
 ( "tkinter_commondialog" , "tkCommonDialog" , "tkinter.commondialog"

290 
MovedModule
 ( "tkinter_tkfiledialog" , "tkFileDialog" , "tkinter.filedialog" ) ,

291 
MovedModule
 ( "tkinter_font" , "tkFont" , "tkinter.font" ) ,

292 
MovedModule
 ( "tkinter_messagebox" , "tkMessageBox" , "tkinter.messagebox" ) ,

293 
MovedModule
 ( "tkinter_tksimpledialog" , "tkSimpleDialog" , "tkinter.simpledialog"

295 
MovedModule
 ( "urllib_parse" , 
__name__
 + ".moves.urllib_parse" , "urllib.parse" ) ,

296 
MovedModule
 ( "urllib_error" , 
__name__
 + ".moves.urllib_error" , "urllib.error" ) ,

297 
MovedModule
 ( "urllib" , 
__name__
 + ".moves.urllib" , 
__name__
 + ".moves.urllib" ) ,

298 
MovedModule
 ( "urllib_robotparser" , "robotparser" , "urllib.robotparser" ) ,

299 
MovedModule
 ( "xmlrpc_client" , "xmlrpclib" , "xmlrpc.client" ) ,

300 
MovedModule
 ( "xmlrpc_server" , "SimpleXMLRPCServer" , "xmlrpc.server" ) ,

303 if 
sys
 . 
platform
 == "win32" :

304 
_moved_attributes
 += [

305 
MovedModule
 ( "winreg" , "_winreg" ) ,

308 for 
attr
 in 
_moved_attributes
 :

309 
setattr
 ( 
_MovedItems
 , 
attr
 . 
name
 , 
attr
 )

310 if 
isinstance
 ( 
attr
 , 
MovedModule
 ) :

311 
_importer
 . 
_add_module
 ( 
attr
 , "moves." + 
attr
 . 
name
 )

312 del 
attr

314 
_MovedItems
 . 
_moved_attributes
 = 
_moved_attributes

316 
moves
 = 
_MovedItems
 ( 
__name__
 + ".moves" )

317 
_importer
 . 
_add_module
 ( 
moves
 , "moves" )

320 class 
	cModule_six_moves_urllib_parse
 ( 
_LazyModule
 ) :

325 
_urllib_parse_moved_attributes
 = [

326 
MovedAttribute
 ( "ParseResult" , "urlparse" , "urllib.parse" ) ,

327 
MovedAttribute
 ( "SplitResult" , "urlparse" , "urllib.parse" ) ,

328 
MovedAttribute
 ( "parse_qs" , "urlparse" , "urllib.parse" ) ,

329 
MovedAttribute
 ( "parse_qsl" , "urlparse" , "urllib.parse" ) ,

330 
MovedAttribute
 ( "urldefrag" , "urlparse" , "urllib.parse" ) ,

331 
MovedAttribute
 ( "urljoin" , "urlparse" , "urllib.parse" ) ,

332 
MovedAttribute
 ( "urlparse" , "urlparse" , "urllib.parse" ) ,

333 
MovedAttribute
 ( "urlsplit" , "urlparse" , "urllib.parse" ) ,

334 
MovedAttribute
 ( "urlunparse" , "urlparse" , "urllib.parse" ) ,

335 
MovedAttribute
 ( "urlunsplit" , "urlparse" , "urllib.parse" ) ,

336 
MovedAttribute
 ( "quote" , "urllib" , "urllib.parse" ) ,

337 
MovedAttribute
 ( "quote_plus" , "urllib" , "urllib.parse" ) ,

338 
MovedAttribute
 ( "unquote" , "urllib" , "urllib.parse" ) ,

339 
MovedAttribute
 ( "unquote_plus" , "urllib" , "urllib.parse" ) ,

340 
MovedAttribute
 ( "urlencode" , "urllib" , "urllib.parse" ) ,

341 
MovedAttribute
 ( "splitquery" , "urllib" , "urllib.parse" ) ,

342 
MovedAttribute
 ( "splittag" , "urllib" , "urllib.parse" ) ,

343 
MovedAttribute
 ( "splituser" , "urllib" , "urllib.parse" ) ,

344 
MovedAttribute
 ( "uses_fragment" , "urlparse" , "urllib.parse" ) ,

345 
MovedAttribute
 ( "uses_netloc" , "urlparse" , "urllib.parse" ) ,

346 
MovedAttribute
 ( "uses_params" , "urlparse" , "urllib.parse" ) ,

347 
MovedAttribute
 ( "uses_query" , "urlparse" , "urllib.parse" ) ,

348 
MovedAttribute
 ( "uses_relative" , "urlparse" , "urllib.parse" ) ,

350 for 
attr
 in 
_urllib_parse_moved_attributes
 :

351 
setattr
 ( 
Module_six_moves_urllib_parse
 , 
attr
 . 
name
 , 
attr
 )

352 del 
attr

354 
Module_six_moves_urllib_parse
 . 
_moved_attributes
 = 
_urllib_parse_moved_attributes

356 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_parse
 ( 
__name__
 + ".moves.urllib_parse" ) , "moves.urllib_parse"

360 class 
	cModule_six_moves_urllib_error
 ( 
_LazyModule
 ) :

365 
_urllib_error_moved_attributes
 = [

366 
MovedAttribute
 ( "URLError" , "urllib2" , "urllib.error" ) ,

367 
MovedAttribute
 ( "HTTPError" , "urllib2" , "urllib.error" ) ,

368 
MovedAttribute
 ( "ContentTooShortError" , "urllib" , "urllib.error" ) ,

370 for 
attr
 in 
_urllib_error_moved_attributes
 :

371 
setattr
 ( 
Module_six_moves_urllib_error
 , 
attr
 . 
name
 , 
attr
 )

372 del 
attr

374 
Module_six_moves_urllib_error
 . 
_moved_attributes
 = 
_urllib_error_moved_attributes

376 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_error
 ( 
__name__
 + ".moves.urllib.error" ) , "moves.urllib_error"

380 class 
	cModule_six_moves_urllib_request
 ( 
_LazyModule
 ) :

385 
_urllib_request_moved_attributes
 = [

386 
MovedAttribute
 ( "urlopen" , "urllib2" , "urllib.request" ) ,

387 
MovedAttribute
 ( "install_opener" , "urllib2" , "urllib.request" ) ,

388 
MovedAttribute
 ( "build_opener" , "urllib2" , "urllib.request" ) ,

389 
MovedAttribute
 ( "pathname2url" , "urllib" , "urllib.request" ) ,

390 
MovedAttribute
 ( "url2pathname" , "urllib" , "urllib.request" ) ,

391 
MovedAttribute
 ( "getproxies" , "urllib" , "urllib.request" ) ,

392 
MovedAttribute
 ( "Request" , "urllib2" , "urllib.request" ) ,

393 
MovedAttribute
 ( "OpenerDirector" , "urllib2" , "urllib.request" ) ,

394 
MovedAttribute
 ( "HTTPDefaultErrorHandler" , "urllib2" , "urllib.request" ) ,

395 
MovedAttribute
 ( "HTTPRedirectHandler" , "urllib2" , "urllib.request" ) ,

396 
MovedAttribute
 ( "HTTPCookieProcessor" , "urllib2" , "urllib.request" ) ,

397 
MovedAttribute
 ( "ProxyHandler" , "urllib2" , "urllib.request" ) ,

398 
MovedAttribute
 ( "BaseHandler" , "urllib2" , "urllib.request" ) ,

399 
MovedAttribute
 ( "HTTPPasswordMgr" , "urllib2" , "urllib.request" ) ,

400 
MovedAttribute
 ( "HTTPPasswordMgrWithDefaultRealm" , "urllib2" , "urllib.request" ) ,

401 
MovedAttribute
 ( "AbstractBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

402 
MovedAttribute
 ( "HTTPBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

403 
MovedAttribute
 ( "ProxyBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

404 
MovedAttribute
 ( "AbstractDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

405 
MovedAttribute
 ( "HTTPDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

406 
MovedAttribute
 ( "ProxyDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

407 
MovedAttribute
 ( "HTTPHandler" , "urllib2" , "urllib.request" ) ,

408 
MovedAttribute
 ( "HTTPSHandler" , "urllib2" , "urllib.request" ) ,

409 
MovedAttribute
 ( "FileHandler" , "urllib2" , "urllib.request" ) ,

410 
MovedAttribute
 ( "FTPHandler" , "urllib2" , "urllib.request" ) ,

411 
MovedAttribute
 ( "CacheFTPHandler" , "urllib2" , "urllib.request" ) ,

412 
MovedAttribute
 ( "UnknownHandler" , "urllib2" , "urllib.request" ) ,

413 
MovedAttribute
 ( "HTTPErrorProcessor" , "urllib2" , "urllib.request" ) ,

414 
MovedAttribute
 ( "urlretrieve" , "urllib" , "urllib.request" ) ,

415 
MovedAttribute
 ( "urlcleanup" , "urllib" , "urllib.request" ) ,

416 
MovedAttribute
 ( "URLopener" , "urllib" , "urllib.request" ) ,

417 
MovedAttribute
 ( "FancyURLopener" , "urllib" , "urllib.request" ) ,

418 
MovedAttribute
 ( "proxy_bypass" , "urllib" , "urllib.request" ) ,

420 for 
attr
 in 
_urllib_request_moved_attributes
 :

421 
setattr
 ( 
Module_six_moves_urllib_request
 , 
attr
 . 
name
 , 
attr
 )

422 del 
attr

424 
Module_six_moves_urllib_request
 . 
_moved_attributes
 = 
_urllib_request_moved_attributes

426 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_request
 ( 
__name__
 + ".moves.urllib.request" ) , "moves.urllib_request"

430 class 
	cModule_six_moves_urllib_response
 ( 
_LazyModule
 ) :

435 
_urllib_response_moved_attributes
 = [

436 
MovedAttribute
 ( "addbase" , "urllib" , "urllib.response" ) ,

437 
MovedAttribute
 ( "addclosehook" , "urllib" , "urllib.response" ) ,

438 
MovedAttribute
 ( "addinfo" , "urllib" , "urllib.response" ) ,

439 
MovedAttribute
 ( "addinfourl" , "urllib" , "urllib.response" ) ,

441 for 
attr
 in 
_urllib_response_moved_attributes
 :

442 
setattr
 ( 
Module_six_moves_urllib_response
 , 
attr
 . 
name
 , 
attr
 )

443 del 
attr

445 
Module_six_moves_urllib_response
 . 
_moved_attributes
 = 
_urllib_response_moved_attributes

447 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_response
 ( 
__name__
 + ".moves.urllib.response" ) , "moves.urllib_response"

451 class 
	cModule_six_moves_urllib_robotparser
 ( 
_LazyModule
 ) :

456 
_urllib_robotparser_moved_attributes
 = [

457 
MovedAttribute
 ( "RobotFileParser" , "robotparser" , "urllib.robotparser" ) ,

459 for 
attr
 in 
_urllib_robotparser_moved_attributes
 :

460 
setattr
 ( 
Module_six_moves_urllib_robotparser
 , 
attr
 . 
name
 , 
attr
 )

461 del 
attr

463 
Module_six_moves_urllib_robotparser
 . 
_moved_attributes
 = 
_urllib_robotparser_moved_attributes

465 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_robotparser
 ( 
__name__
 + ".moves.urllib.robotparser" ) , "moves.urllib_robotparser"

469 class 
	cModule_six_moves_urllib
 ( 
types
 . 
ModuleType
 ) :

472 
__path__
 = [ ]

473 
parse
 = 
_importer
 . 
_get_module
 ( "moves.urllib_parse" )

474 
error
 = 
_importer
 . 
_get_module
 ( "moves.urllib_error" )

475 
request
 = 
_importer
 . 
_get_module
 ( "moves.urllib_request" )

476 
response
 = 
_importer
 . 
_get_module
 ( "moves.urllib_response" )

477 
robotparser
 = 
_importer
 . 
_get_module
 ( "moves.urllib_robotparser" )

479 def 
	$__dir__
 ( 
self
 ) :

480 return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ] 
	}

482 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib
 ( 
__name__
 + ".moves.urllib" ) , "moves.urllib"

486 def 
	$add_move
 ( 
move
 ) :

488 
setattr
 ( 
_MovedItems
 , 
move
 . 
name
 , 
move
 ) 
	}

491 def 
	$remove_move
 ( 
name
 ) :

494 
delattr
 ( 
_MovedItems
 , 
name
 )

495 except 
AttributeError
 :

497 del 
moves
 . 
__dict__
 [ 
name
 ]

498 except 
KeyError
 :

499 raise 
AttributeError
 ( "no such move, %r" % ( 
name
 , ) ) 
	}

502 if 
PY3
 :

503 
_meth_func
 = "__func__"

504 
_meth_self
 = "__self__"

506 
_func_closure
 = "__closure__"

507 
_func_code
 = "__code__"

508 
_func_defaults
 = "__defaults__"

509 
_func_globals
 = "__globals__"

511 
_meth_func
 = "im_func"

512 
_meth_self
 = "im_self"

514 
_func_closure
 = "func_closure"

515 
_func_code
 = "func_code"

516 
_func_defaults
 = "func_defaults"

517 
_func_globals
 = "func_globals"

521 
advance_iterator
 = 
next

522 except 
NameError
 :

523 def 
	$advance_iterator
 ( 
it
 ) :

524 return 
it
 . 
next
 ( ) 
	}

525 
next
 = 
advance_iterator

529 
callable
 = 
callable

530 except 
NameError
 :

531 def 
	$callable
 ( 
obj
 ) :

532 return 
any
 ( "__call__" in 
klass
 . 
__dict__
 for 
klass
 in 
type
 ( 
obj
 ) . 
__mro__
 ) 
	}

535 if 
PY3
 :

536 def 
	$get_unbound_function
 ( 
unbound
 ) :

537 return 
unbound
 
	}

539 
create_bound_method
 = 
types
 . 
MethodType

541 def 
	$create_unbound_method
 ( 
func
 , 
cls
 ) :

542 return 
func
 
	}

544 
Iterator
 = 
object

546 def 
	$get_unbound_function
 ( 
unbound
 ) :

547 return 
unbound
 . 
im_func
 
	}

549 def 
	$create_bound_method
 ( 
func
 , 
obj
 ) :

550 return 
types
 . 
MethodType
 ( 
func
 , 
obj
 , 
obj
 . 
__class__
 ) 
	}

552 def 
	$create_unbound_method
 ( 
func
 , 
cls
 ) :

553 return 
types
 . 
MethodType
 ( 
func
 , None , 
cls
 ) 
	}

555 class 
	cIterator
 ( 
object
 ) :

557 def 
	$next
 ( 
self
 ) :

558 return 
type
 ( 
self
 ) . 
__next__
 ( 
self
 ) 
	}

560 
callable
 = 
callable

561 
_add_doc
 ( 
get_unbound_function
 , """Get the function out of a possibly unbound function"""

565 
get_method_function
 = 
operator
 . 
attrgetter
 ( 
_meth_func
 )

566 
get_method_self
 = 
operator
 . 
attrgetter
 ( 
_meth_self
 )

567 
get_function_closure
 = 
operator
 . 
attrgetter
 ( 
_func_closure
 )

568 
get_function_code
 = 
operator
 . 
attrgetter
 ( 
_func_code
 )

569 
get_function_defaults
 = 
operator
 . 
attrgetter
 ( 
_func_defaults
 )

570 
get_function_globals
 = 
operator
 . 
attrgetter
 ( 
_func_globals
 )

573 if 
PY3
 :

574 def 
	$iterkeys
 ( 
d
 , ** 
kw
 ) :

575 return 
iter
 ( 
d
 . 
keys
 ( ** 
kw
 ) ) 
	}

577 def 
	$itervalues
 ( 
d
 , ** 
kw
 ) :

578 return 
iter
 ( 
d
 . 
values
 ( ** 
kw
 ) ) 
	}

580 def 
	$iteritems
 ( 
d
 , ** 
kw
 ) :

581 return 
iter
 ( 
d
 . 
items
 ( ** 
kw
 ) ) 
	}

583 def 
	$iterlists
 ( 
d
 , ** 
kw
 ) :

584 return 
iter
 ( 
d
 . 
lists
 ( ** 
kw
 ) ) 
	}

586 
viewkeys
 = 
operator
 . 
methodcaller
 ( "keys" )

588 
viewvalues
 = 
operator
 . 
methodcaller
 ( "values" )

590 
viewitems
 = 
operator
 . 
methodcaller
 ( "items" )

592 def 
	$iterkeys
 ( 
d
 , ** 
kw
 ) :

593 return 
d
 . 
iterkeys
 ( ** 
kw
 ) 
	}

595 def 
	$itervalues
 ( 
d
 , ** 
kw
 ) :

596 return 
d
 . 
itervalues
 ( ** 
kw
 ) 
	}

598 def 
	$iteritems
 ( 
d
 , ** 
kw
 ) :

599 return 
d
 . 
iteritems
 ( ** 
kw
 ) 
	}

601 def 
	$iterlists
 ( 
d
 , ** 
kw
 ) :

602 return 
d
 . 
iterlists
 ( ** 
kw
 ) 
	}

604 
viewkeys
 = 
operator
 . 
methodcaller
 ( "viewkeys" )

606 
viewvalues
 = 
operator
 . 
methodcaller
 ( "viewvalues" )

608 
viewitems
 = 
operator
 . 
methodcaller
 ( "viewitems" )

610 
_add_doc
 ( 
iterkeys
 , "Return an iterator over the keys of a dictionary." )

611 
_add_doc
 ( 
itervalues
 , "Return an iterator over the values of a dictionary." )

612 
_add_doc
 ( 
iteritems
 , "Return an iterator over the (key, value) pairs of a dictionary."

614 
_add_doc
 ( 
iterlists
 , "Return an iterator over the (key, [values]) pairs of a dictionary."

618 if 
PY3
 :

619 def 
	$b
 ( 
s
 ) :

620 return 
s
 . 
encode
 ( "latin-1" ) 
	}

622 def 
	$u
 ( 
s
 ) :

623 return 
s
 
	}

624 
unichr
 = 
chr

625 import 
	~struct

626 
int2byte
 = 
struct
 . 
Struct
 ( ">B" ) . 
pack

627 del 
struct

628 
byte2int
 = 
operator
 . 
itemgetter
 ( 0 )

629 
indexbytes
 = 
operator
 . 
getitem

630 
iterbytes
 = 
iter

631 import 
	~io

632 
StringIO
 = 
io
 . 
StringIO

633 
BytesIO
 = 
io
 . 
BytesIO

634 
_assertCountEqual
 = "assertCountEqual"

635 if 
sys
 . 
version_info
 [ 1 ] <= 1 :

636 
_assertRaisesRegex
 = "assertRaisesRegexp"

637 
_assertRegex
 = "assertRegexpMatches"

639 
_assertRaisesRegex
 = "assertRaisesRegex"

640 
_assertRegex
 = "assertRegex"

642 def 
	$b
 ( 
s
 ) :

643 return 
s
 
	}

646 def 
	$u
 ( 
s
 ) :

647 return 
unicode
 ( 
s
 . 
replace
 ( r'\\' , r'\\\\' ) , "unicode_escape" ) 
	}

648 
unichr
 = 
unichr

649 
int2byte
 = 
chr

651 def 
	$byte2int
 ( 
bs
 ) :

652 return 
ord
 ( 
bs
 [ 0 ] ) 
	}

654 def 
	$indexbytes
 ( 
buf
 , 
i
 ) :

655 return 
ord
 ( 
buf
 [ 
i
 ] ) 
	}

656 
iterbytes
 = 
functools
 . 
partial
 ( 
itertools
 . 
imap
 , 
ord
 )

657 import 
	~StringIO

658 
StringIO
 = 
BytesIO
 = 
StringIO
 . 
StringIO

659 
_assertCountEqual
 = "assertItemsEqual"

660 
_assertRaisesRegex
 = "assertRaisesRegexp"

661 
_assertRegex
 = "assertRegexpMatches"

662 
_add_doc
 ( 
b
 , """Byte literal""" )

663 
_add_doc
 ( 
u
 , """Text literal""" )

666 def 
	$assertCountEqual
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

667 return 
getattr
 ( 
self
 , 
_assertCountEqual
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

670 def 
	$assertRaisesRegex
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

671 return 
getattr
 ( 
self
 , 
_assertRaisesRegex
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

674 def 
	$assertRegex
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

675 return 
getattr
 ( 
self
 , 
_assertRegex
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

678 if 
PY3
 :

679 
exec_
 = 
getattr
 ( 
moves
 . 
builtins
 , "exec" )

681 def 
	$reraise
 ( 
tp
 , 
value
 , 
tb
 = None ) :

682 if 
value
 is None :

683 
value
 = 
tp
 ( )

684 if 
value
 . 
__traceback__
 is not 
tb
 :

685 raise 
value
 . 
with_traceback
 ( 
tb
 )

686 raise 
value
 
	}

689 def 
	$exec_
 ( 
_code_
 , 
_globs_
 = None , 
_locs_
 = None ) :

691 if 
_globs_
 is None :

692 
frame
 = 
sys
 . 
_getframe
 ( 1 )

693 
_globs_
 = 
frame
 . 
f_globals

694 if 
_locs_
 is None :

695 
_locs_
 = 
frame
 . 
f_locals

696 del 
frame

697 elif 
_locs_
 is None :

698 
_locs_
 = 
_globs_

699 
exec
 ( """exec _code_ in _globs_, _locs_""" ) 
	}

701 
exec_
 ( """def reraise(tp, value, tb=None):\n    raise tp, value, tb\n"""

706 if 
sys
 . 
version_info
 [ : 2 ] == ( 3 , 2 ) :

707 
exec_
 ( """def raise_from(value, from_value):\n    if from_value is None:\n        raise value\n    raise value from from_value\n"""

712 elif 
sys
 . 
version_info
 [ : 2 ] > ( 3 , 2 ) :

713 
exec_
 ( """def raise_from(value, from_value):\n    raise value from from_value\n"""

717 def 
	$raise_from
 ( 
value
 , 
from_value
 ) :

718 raise 
value
 
	}

721 
print_
 = 
getattr
 ( 
moves
 . 
builtins
 , "print" , None )

722 if 
print_
 is None :

723 def 
	$print_
 ( * 
args
 , ** 
kwargs
 ) :

725 
fp
 = 
kwargs
 . 
pop
 ( "file" , 
sys
 . 
stdout
 )

726 if 
fp
 is None :

729 def 
write
 ( 
data
 ) :

730 if not 
isinstance
 ( 
data
 , 
basestring
 ) :

731 
data
 = 
str
 ( 
data
 )

733 if ( 
isinstance
 ( 
fp
 , 
file
 ) and

734 
isinstance
 ( 
data
 , 
unicode
 ) and

735 
fp
 . 
encoding
 is not None ) :

736 
errors
 = 
getattr
 ( 
fp
 , "errors" , None )

737 if 
errors
 is None :

738 
errors
 = "strict"

739 
data
 = 
data
 . 
encode
 ( 
fp
 . 
encoding
 , 
errors
 )

740 
fp
 . 
write
 ( 
data
 )

741 
want_unicode
 = False

742 
sep
 = 
kwargs
 . 
pop
 ( "sep" , None )

743 if 
sep
 is not None :

744 if 
isinstance
 ( 
sep
 , 
unicode
 ) :

745 
want_unicode
 = True

746 elif not 
isinstance
 ( 
sep
 , 
str
 ) :

747 raise 
TypeError
 ( "sep must be None or a string" )

748 
end
 = 
kwargs
 . 
pop
 ( "end" , None )

749 if 
end
 is not None :

750 if 
isinstance
 ( 
end
 , 
unicode
 ) :

751 
want_unicode
 = True

752 elif not 
isinstance
 ( 
end
 , 
str
 ) :

753 raise 
TypeError
 ( "end must be None or a string" )

754 if 
kwargs
 :

755 raise 
TypeError
 ( "invalid keyword arguments to print()" )

756 if not 
want_unicode
 :

757 for 
arg
 in 
args
 :

758 if 
isinstance
 ( 
arg
 , 
unicode
 ) :

759 
want_unicode
 = True

761 if 
want_unicode
 :

762 
newline
 = 
unicode
 ( "\n" )

763 
space
 = 
unicode
 ( " " )

765 
newline
 = "\n"

766 
space
 = " "

767 if 
sep
 is None :

768 
sep
 = 
space

769 if 
end
 is None :

770 
end
 = 
newline

771 for 
i
 , 
arg
 in 
enumerate
 ( 
args
 ) :

772 if 
i
 :

773 
write
 ( 
sep
 )

774 
write
 ( 
arg
 )

775 
write
 ( 
end
 ) 
	}

776 if 
sys
 . 
version_info
 [ : 2 ] < ( 3 , 3 ) :

777 
_print
 = 
print_

779 def 
	$print_
 ( * 
args
 , ** 
kwargs
 ) :

780 
fp
 = 
kwargs
 . 
get
 ( "file" , 
sys
 . 
stdout
 )

781 
flush
 = 
kwargs
 . 
pop
 ( "flush" , False )

782 
_print
 ( * 
args
 , ** 
kwargs
 )

783 if 
flush
 and 
fp
 is not None :

784 
fp
 . 
flush
 ( ) 
	}

786 
_add_doc
 ( 
reraise
 , """Reraise an exception.""" )

788 if 
sys
 . 
version_info
 [ 0 : 2 ] < ( 3 , 4 ) :

789 def 
	$wraps
 ( 
wrapped
 , 
assigned
 = 
functools
 . 
WRAPPER_ASSIGNMENTS
 ,

790 
updated
 = 
functools
 . 
WRAPPER_UPDATES
 ) :

791 def 
wrapper
 ( 
f
 ) :

792 
f
 = 
functools
 . 
wraps
 ( 
wrapped
 , 
assigned
 , 
updated
 ) ( 
f
 )

793 
f
 . 
__wrapped__
 = 
wrapped

794 return 
f

795 return 
wrapper
 
	}

797 
wraps
 = 
functools
 . 
wraps

800 def 
	$with_metaclass
 ( 
meta
 , * 
bases
 ) :

805 class 
	cmetaclass
 ( 
meta
 ) :

807 def 
__new__
 ( 
cls
 , 
name
 , 
this_bases
 , 
d
 ) :

808 return 
meta
 ( 
name
 , 
bases
 , 
d
 )

809 return 
type
 . 
__new__
 ( 
metaclass
 , 'temporary_class' , ( ) , { } ) 
	}

812 def 
	$add_metaclass
 ( 
metaclass
 ) :

814 def 
wrapper
 ( 
cls
 ) :

815 
orig_vars
 = 
cls
 . 
__dict__
 . 
copy
 ( )

816 
slots
 = 
orig_vars
 . 
get
 ( '__slots__' )

817 if 
slots
 is not None :

818 if 
isinstance
 ( 
slots
 , 
str
 ) :

819 
slots
 = [ 
slots
 ]

820 for 
slots_var
 in 
slots
 :

821 
orig_vars
 . 
pop
 ( 
slots_var
 )

822 
orig_vars
 . 
pop
 ( '__dict__' , None )

823 
orig_vars
 . 
pop
 ( '__weakref__' , None )

824 return 
metaclass
 ( 
cls
 . 
__name__
 , 
cls
 . 
__bases__
 , 
orig_vars
 )

825 return 
wrapper
 
	}

828 def 
	$python_2_unicode_compatible
 ( 
klass
 ) :

836 if 
PY2
 :

837 if '__str__' not in 
klass
 . 
__dict__
 :

838 raise 
ValueError
 ( "@python_2_unicode_compatible cannot be applied " "to %s because it doesn't define __str__()."

840 
klass
 . 
__name__
 )

841 
klass
 . 
__unicode__
 = 
klass
 . 
__str__

842 
klass
 . 
__str__
 = lambda 
self
 : 
self
 . 
__unicode__
 ( ) . 
encode
 ( 'utf-8' )

843 return 
klass
 
	}

849 
__path__
 = [ ]

850 
__package__
 = 
__name__

851 if 
globals
 ( ) . 
get
 ( "__spec__" ) is not None :

852 
__spec__
 . 
submodule_search_locations
 = [ ]

856 if 
sys
 . 
meta_path
 :

857 for 
i
 , 
importer
 in 
enumerate
 ( 
sys
 . 
meta_path
 ) :

862 if ( 
type
 ( 
importer
 ) . 
__name__
 == "_SixMetaPathImporter" and

863 
importer
 . 
name
 == 
__name__
 ) :

864 del 
sys
 . 
meta_path
 [ 
i
 ]

866 del 
i
 , 
importer

868 
sys
 . 
meta_path
 . 
append
 ( 
_importer
 )


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/appdirs.py

16 
__version_info__
 = ( 1 , 4 , 3 )

17 
__version__
 = '.' . 
join
 ( 
map
 ( 
str
 , 
__version_info__
 ) )

20 import 
	~sys

21 import 
	~os

23 
PY3
 = 
sys
 . 
version_info
 [ 0 ] == 3

25 if 
PY3
 :

26 
unicode
 = 
str

28 if 
sys
 . 
platform
 . 
startswith
 ( 'java' ) :

29 import 
	~platform

30 
os_name
 = 
platform
 . 
java_ver
 ( ) [ 3 ] [ 0 ]

31 if 
os_name
 . 
startswith
 ( 'Windows' ) :

32 
system
 = 'win32'

33 elif 
os_name
 . 
startswith
 ( 'Mac' ) :

34 
system
 = 'darwin'

39 
system
 = 'linux2'

41 
system
 = 
sys
 . 
platform

45 def 
	$user_data_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
roaming
 = False ) :

77 if 
system
 == "win32" :

78 if 
appauthor
 is None :

79 
appauthor
 = 
appname

80 
const
 = 
roaming
 and "CSIDL_APPDATA" or "CSIDL_LOCAL_APPDATA"

81 
path
 = 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( 
const
 ) )

82 if 
appname
 :

83 if 
appauthor
 is not False :

84 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appauthor
 , 
appname
 )

86 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

87 elif 
system
 == 'darwin' :

88 
path
 = 
os
 . 
path
 . 
expanduser
 ( '~/Library/Application Support/' )

89 if 
appname
 :

90 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

92 
path
 = 
os
 . 
getenv
 ( 'XDG_DATA_HOME' , 
os
 . 
path
 . 
expanduser
 ( "~/.local/share" ) )

93 if 
appname
 :

94 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

95 if 
appname
 and 
version
 :

96 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

97 return 
path
 
	}

100 def 
	$site_data_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
multipath
 = False ) :

131 if 
system
 == "win32" :

132 if 
appauthor
 is None :

133 
appauthor
 = 
appname

134 
path
 = 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( "CSIDL_COMMON_APPDATA" ) )

135 if 
appname
 :

136 if 
appauthor
 is not False :

137 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appauthor
 , 
appname
 )

139 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

140 elif 
system
 == 'darwin' :

141 
path
 = 
os
 . 
path
 . 
expanduser
 ( '/Library/Application Support' )

142 if 
appname
 :

143 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

147 
path
 = 
os
 . 
getenv
 ( 'XDG_DATA_DIRS' ,

148 
os
 . 
pathsep
 . 
join
 ( [ '/usr/local/share' , '/usr/share' ] ) )

149 
pathlist
 = [ 
os
 . 
path
 . 
expanduser
 ( 
x
 . 
rstrip
 ( 
os
 . 
sep
 ) ) for 
x
 in 
path
 . 
split
 ( 
os
 . 
pathsep
 ) ]

150 if 
appname
 :

151 if 
version
 :

152 
appname
 = 
os
 . 
path
 . 
join
 ( 
appname
 , 
version
 )

153 
pathlist
 = [ 
os
 . 
sep
 . 
join
 ( [ 
x
 , 
appname
 ] ) for 
x
 in 
pathlist
 ]

155 if 
multipath
 :

156 
path
 = 
os
 . 
pathsep
 . 
join
 ( 
pathlist
 )

158 
path
 = 
pathlist
 [ 0 ]

159 return 
path

161 if 
appname
 and 
version
 :

162 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

163 return 
path
 
	}

166 def 
	$user_config_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
roaming
 = False ) :

195 if 
system
 in [ "win32" , "darwin" ] :

196 
path
 = 
user_data_dir
 ( 
appname
 , 
appauthor
 , None , 
roaming
 )

198 
path
 = 
os
 . 
getenv
 ( 'XDG_CONFIG_HOME' , 
os
 . 
path
 . 
expanduser
 ( "~/.config" ) )

199 if 
appname
 :

200 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

201 if 
appname
 and 
version
 :

202 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

203 return 
path
 
	}

206 def 
	$site_config_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
multipath
 = False ) :

236 if 
system
 in [ "win32" , "darwin" ] :

237 
path
 = 
site_data_dir
 ( 
appname
 , 
appauthor
 )

238 if 
appname
 and 
version
 :

239 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

243 
path
 = 
os
 . 
getenv
 ( 'XDG_CONFIG_DIRS' , '/etc/xdg' )

244 
pathlist
 = [ 
os
 . 
path
 . 
expanduser
 ( 
x
 . 
rstrip
 ( 
os
 . 
sep
 ) ) for 
x
 in 
path
 . 
split
 ( 
os
 . 
pathsep
 ) ]

245 if 
appname
 :

246 if 
version
 :

247 
appname
 = 
os
 . 
path
 . 
join
 ( 
appname
 , 
version
 )

248 
pathlist
 = [ 
os
 . 
sep
 . 
join
 ( [ 
x
 , 
appname
 ] ) for 
x
 in 
pathlist
 ]

250 if 
multipath
 :

251 
path
 = 
os
 . 
pathsep
 . 
join
 ( 
pathlist
 )

253 
path
 = 
pathlist
 [ 0 ]

254 return 
path
 
	}

257 def 
	$user_cache_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
opinion
 = True ) :

290 if 
system
 == "win32" :

291 if 
appauthor
 is None :

292 
appauthor
 = 
appname

293 
path
 = 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( "CSIDL_LOCAL_APPDATA" ) )

294 if 
appname
 :

295 if 
appauthor
 is not False :

296 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appauthor
 , 
appname
 )

298 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

299 if 
opinion
 :

300 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , "Cache" )

301 elif 
system
 == 'darwin' :

302 
path
 = 
os
 . 
path
 . 
expanduser
 ( '~/Library/Caches' )

303 if 
appname
 :

304 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

306 
path
 = 
os
 . 
getenv
 ( 'XDG_CACHE_HOME' , 
os
 . 
path
 . 
expanduser
 ( '~/.cache' ) )

307 if 
appname
 :

308 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

309 if 
appname
 and 
version
 :

310 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

311 return 
path
 
	}

314 def 
	$user_state_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
roaming
 = False ) :

345 if 
system
 in [ "win32" , "darwin" ] :

346 
path
 = 
user_data_dir
 ( 
appname
 , 
appauthor
 , None , 
roaming
 )

348 
path
 = 
os
 . 
getenv
 ( 'XDG_STATE_HOME' , 
os
 . 
path
 . 
expanduser
 ( "~/.local/state" ) )

349 if 
appname
 :

350 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

351 if 
appname
 and 
version
 :

352 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

353 return 
path
 
	}

356 def 
	$user_log_dir
 ( 
appname
 = None , 
appauthor
 = None , 
version
 = None , 
opinion
 = True ) :

388 if 
system
 == "darwin" :

389 
path
 = 
os
 . 
path
 . 
join
 (

390 
os
 . 
path
 . 
expanduser
 ( '~/Library/Logs' ) ,

391 
appname
 )

392 elif 
system
 == "win32" :

393 
path
 = 
user_data_dir
 ( 
appname
 , 
appauthor
 , 
version
 )

394 
version
 = False

395 if 
opinion
 :

396 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , "Logs" )

398 
path
 = 
user_cache_dir
 ( 
appname
 , 
appauthor
 , 
version
 )

399 
version
 = False

400 if 
opinion
 :

401 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , "log" )

402 if 
appname
 and 
version
 :

403 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
version
 )

404 return 
path
 
	}

407 class 
	cAppDirs
 ( 
object
 ) :

409 def 
	$__init__
 ( 
self
 , 
appname
 = None , 
appauthor
 = None , 
version
 = None ,

410 
roaming
 = False , 
multipath
 = False ) :

411 
self
 . 
appname
 = 
appname

412 
self
 . 
appauthor
 = 
appauthor

413 
self
 . 
version
 = 
version

414 
self
 . 
roaming
 = 
roaming

415 
self
 . 
multipath
 = 
multipath
 
	}

417 @ 
property

418 def 
	$user_data_dir
 ( 
self
 ) :

419 return 
user_data_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

420 
version
 = 
self
 . 
version
 , 
roaming
 = 
self
 . 
roaming
 ) 
	}

422 @ 
property

423 def 
	$site_data_dir
 ( 
self
 ) :

424 return 
site_data_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

425 
version
 = 
self
 . 
version
 , 
multipath
 = 
self
 . 
multipath
 ) 
	}

427 @ 
property

428 def 
	$user_config_dir
 ( 
self
 ) :

429 return 
user_config_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

430 
version
 = 
self
 . 
version
 , 
roaming
 = 
self
 . 
roaming
 ) 
	}

432 @ 
property

433 def 
	$site_config_dir
 ( 
self
 ) :

434 return 
site_config_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

435 
version
 = 
self
 . 
version
 , 
multipath
 = 
self
 . 
multipath
 ) 
	}

437 @ 
property

438 def 
	$user_cache_dir
 ( 
self
 ) :

439 return 
user_cache_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

440 
version
 = 
self
 . 
version
 ) 
	}

442 @ 
property

443 def 
	$user_state_dir
 ( 
self
 ) :

444 return 
user_state_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

445 
version
 = 
self
 . 
version
 ) 
	}

447 @ 
property

448 def 
	$user_log_dir
 ( 
self
 ) :

449 return 
user_log_dir
 ( 
self
 . 
appname
 , 
self
 . 
appauthor
 ,

450 
version
 = 
self
 . 
version
 ) 
	}

455 def 
	$_get_win_folder_from_registry
 ( 
csidl_name
 ) :

460 if 
PY3
 :

461 import 
	~winreg
 as 
_winreg

463 import 
	~_winreg

465 
shell_folder_name
 = { "CSIDL_APPDATA"

469 } [ 
csidl_name
 ]

471 
key
 = 
_winreg
 . 
OpenKey
 (

472 
_winreg
 . 
HKEY_CURRENT_USER
 , r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"

475 
dir
 , 
type
 = 
_winreg
 . 
QueryValueEx
 ( 
key
 , 
shell_folder_name
 )

476 return 
dir
 
	}

479 def 
	$_get_win_folder_with_pywin32
 ( 
csidl_name
 ) :

480 from 
	~win32com.shell
 import 
shellcon
 , 
shell

481 
dir
 = 
shell
 . 
SHGetFolderPath
 ( 0 , 
getattr
 ( 
shellcon
 , 
csidl_name
 ) , 0 , 0 )

486 
dir
 = 
unicode
 ( 
dir
 )

490 
has_high_char
 = False

491 for 
c
 in 
dir
 :

492 if 
ord
 ( 
c
 ) > 255 :

493 
has_high_char
 = True

495 if 
has_high_char
 :

497 import 
	~win32api

498 
dir
 = 
win32api
 . 
GetShortPathName
 ( 
dir
 )

499 except 
ImportError
 :

501 except 
UnicodeError
 :

503 return 
dir
 
	}

506 def 
	$_get_win_folder_with_ctypes
 ( 
csidl_name
 ) :

507 import 
	~ctypes

509 
csidl_const
 = { "CSIDL_APPDATA"

513 } [ 
csidl_name
 ]

515 
buf
 = 
ctypes
 . 
create_unicode_buffer
 ( 1024 )

516 
ctypes
 . 
windll
 . 
shell32
 . 
SHGetFolderPathW
 ( None , 
csidl_const
 , None , 0 , 
buf
 )

520 
has_high_char
 = False

521 for 
c
 in 
buf
 :

522 if 
ord
 ( 
c
 ) > 255 :

523 
has_high_char
 = True

525 if 
has_high_char
 :

526 
buf2
 = 
ctypes
 . 
create_unicode_buffer
 ( 1024 )

527 if 
ctypes
 . 
windll
 . 
kernel32
 . 
GetShortPathNameW
 ( 
buf
 . 
value
 , 
buf2
 , 1024 ) :

528 
buf
 = 
buf2

530 return 
buf
 . 
value
 
	}

532 def 
	$_get_win_folder_with_jna
 ( 
csidl_name
 ) :

533 import 
	~array

534 from 
	~com.sun
 import 
jna

535 from 
	~com.sun.jna.platform
 import 
win32

537 
buf_size
 = 
win32
 . 
WinDef
 . 
MAX_PATH
 * 2

538 
buf
 = 
array
 . 
zeros
 ( 'c' , 
buf_size
 )

539 
shell
 = 
win32
 . 
Shell32
 . 
INSTANCE

540 
shell
 . 
SHGetFolderPath
 ( None , 
getattr
 ( 
win32
 . 
ShlObj
 , 
csidl_name
 ) , None , 
win32
 . 
ShlObj
 . 
SHGFP_TYPE_CURRENT
 , 
buf
 )

541 
dir
 = 
jna
 . 
Native
 . 
toString
 ( 
buf
 . 
tostring
 ( ) ) . 
rstrip
 ( "\0" )

545 
has_high_char
 = False

546 for 
c
 in 
dir
 :

547 if 
ord
 ( 
c
 ) > 255 :

548 
has_high_char
 = True

550 if 
has_high_char
 :

551 
buf
 = 
array
 . 
zeros
 ( 'c' , 
buf_size
 )

552 
kernel
 = 
win32
 . 
Kernel32
 . 
INSTANCE

553 if 
kernel
 . 
GetShortPathName
 ( 
dir
 , 
buf
 , 
buf_size
 ) :

554 
dir
 = 
jna
 . 
Native
 . 
toString
 ( 
buf
 . 
tostring
 ( ) ) . 
rstrip
 ( "\0" )

556 return 
dir
 
	}

558 if 
system
 == "win32" :

560 import 
	~win32com.shell

561 
_get_win_folder
 = 
_get_win_folder_with_pywin32

562 except 
ImportError
 :

564 from 
	~ctypes
 import 
windll

565 
_get_win_folder
 = 
_get_win_folder_with_ctypes

566 except 
ImportError
 :

568 import 
	~com.sun.jna

569 
_get_win_folder
 = 
_get_win_folder_with_jna

570 except 
ImportError
 :

571 
_get_win_folder
 = 
_get_win_folder_from_registry

576 if 
__name__
 == "__main__" :

577 
appname
 = "MyApp"

578 
appauthor
 = "MyCompany"

580 
props
 = ( "user_data_dir" , "user_config_dir"

588 
print
 ( "-- app dirs %s --" % 
__version__
 )

590 
print
 ( "-- app dirs (with optional 'version')" )

591 
dirs
 = 
AppDirs
 ( 
appname
 , 
appauthor
 , 
version
 = "1.0" )

592 for 
prop
 in 
props
 :

593 
print
 ( "%s: %s" % ( 
prop
 , 
getattr
 ( 
dirs
 , 
prop
 ) ) )

595 
print
 ( "\n-- app dirs (without optional 'version')" )

596 
dirs
 = 
AppDirs
 ( 
appname
 , 
appauthor
 )

597 for 
prop
 in 
props
 :

598 
print
 ( "%s: %s" % ( 
prop
 , 
getattr
 ( 
dirs
 , 
prop
 ) ) )

600 
print
 ( "\n-- app dirs (without optional 'appauthor')" )

601 
dirs
 = 
AppDirs
 ( 
appname
 )

602 for 
prop
 in 
props
 :

603 
print
 ( "%s: %s" % ( 
prop
 , 
getattr
 ( 
dirs
 , 
prop
 ) ) )

605 
print
 ( "\n-- app dirs (with disabled 'appauthor')" )

606 
dirs
 = 
AppDirs
 ( 
appname
 , 
appauthor
 = False )

607 for 
prop
 in 
props
 :

608 
print
 ( "%s: %s" % ( 
prop
 , 
getattr
 ( 
dirs
 , 
prop
 ) ) )


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/_compat.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~sys

9 
PY2
 = 
sys
 . 
version_info
 [ 0 ] == 2

10 
PY3
 = 
sys
 . 
version_info
 [ 0 ] == 3

14 if 
PY3
 :

15 
string_types
 = 
str
 ,

17 
string_types
 = 
basestring
 ,

20 def 
	$with_metaclass
 ( 
meta
 , * 
bases
 ) :

27 class 
	cmetaclass
 ( 
meta
 ) :

28 def 
__new__
 ( 
cls
 , 
name
 , 
this_bases
 , 
d
 ) :

29 return 
meta
 ( 
name
 , 
bases
 , 
d
 )

30 return 
type
 . 
__new__
 ( 
metaclass
 , 'temporary_class' , ( ) , { } ) 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/specifiers.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~abc

7 import 
	~functools

8 import 
	~itertools

9 import 
	~re

11 from . 
	~_compat
 import 
string_types
 , 
with_metaclass

12 from . 
	~version
 import 
Version
 , 
LegacyVersion
 , 
parse

15 class 
	cInvalidSpecifier
 ( 
ValueError
 ) :

21 class 
	cBaseSpecifier
 ( 
with_metaclass
 ( 
abc
 . 
ABCMeta
 , 
object
 ) ) :

23 @ 
abc
 . 
	`abstractmethod

24 def 
	$__str__
 ( 
self
 ) :

28 
	}

30 @ 
abc
 . 
	`abstractmethod

31 def 
	$__hash__
 ( 
self
 ) :

34 
	}

36 @ 
abc
 . 
	`abstractmethod

37 def 
	$__eq__
 ( 
self
 , 
other
 ) :

41 
	}

43 @ 
abc
 . 
	`abstractmethod

44 def 
	$__ne__
 ( 
self
 , 
other
 ) :

48 
	}

50 @ 
abc
 . 
	`abstractproperty

51 def 
	$prereleases
 ( 
self
 ) :

55 
	}

57 @ 
prereleases
 . 
	`setter

58 def 
	$prereleases
 ( 
self
 , 
value
 ) :

62 
	}

64 @ 
abc
 . 
	`abstractmethod

65 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

68 
	}

70 @ 
abc
 . 
	`abstractmethod

71 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

75 
	}

78 class 
	c_IndividualSpecifier
 ( 
BaseSpecifier
 ) :

80 
_operators
 = { }

82 def 
	$__init__
 ( 
self
 , 
spec
 = "" , 
prereleases
 = None ) :

83 
match
 = 
self
 . 
_regex
 . 
search
 ( 
spec
 )

84 if not 
match
 :

85 raise 
InvalidSpecifier
 ( "Invalid specifier: '{0}'" . 
format
 ( 
spec
 ) )

87 
self
 . 
_spec
 = (

88 
match
 . 
group
 ( "operator" ) . 
strip
 ( ) ,

89 
match
 . 
group
 ( "version" ) . 
strip
 ( ) ,

93 
self
 . 
_prereleases
 = 
prereleases
 
	}

95 def 
	$__repr__
 ( 
self
 ) :

96 
pre
 = ( ", prereleases={0!r}"

97 . 
format
 ( 
self
 . 
prereleases
 )

98 if 
self
 . 
_prereleases
 is not None

102 return "<{0}({1!r}{2})>" . 
format
 (

103 
self
 . 
__class__
 . 
__name__
 ,

104 
str
 ( 
self
 ) ,

105 
pre
 ,

106 ) 
	}

108 def 
	$__str__
 ( 
self
 ) :

109 return "{0}{1}" . 
format
 ( * 
self
 . 
_spec
 ) 
	}

111 def 
	$__hash__
 ( 
self
 ) :

112 return 
hash
 ( 
self
 . 
_spec
 ) 
	}

114 def 
	$__eq__
 ( 
self
 , 
other
 ) :

115 if 
isinstance
 ( 
other
 , 
string_types
 ) :

117 
other
 = 
self
 . 
__class__
 ( 
other
 )

118 except 
InvalidSpecifier
 :

119 return 
NotImplemented

120 elif not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) :

121 return 
NotImplemented

123 return 
self
 . 
_spec
 == 
other
 . 
_spec
 
	}

125 def 
	$__ne__
 ( 
self
 , 
other
 ) :

126 if 
isinstance
 ( 
other
 , 
string_types
 ) :

128 
other
 = 
self
 . 
__class__
 ( 
other
 )

129 except 
InvalidSpecifier
 :

130 return 
NotImplemented

131 elif not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) :

132 return 
NotImplemented

134 return 
self
 . 
_spec
 != 
other
 . 
_spec
 
	}

136 def 
	$_get_operator
 ( 
self
 , 
op
 ) :

137 return 
getattr
 ( 
self
 , "_compare_{0}" . 
format
 ( 
self
 . 
_operators
 [ 
op
 ] ) ) 
	}

139 def 
	$_coerce_version
 ( 
self
 , 
version
 ) :

140 if not 
isinstance
 ( 
version
 , ( 
LegacyVersion
 , 
Version
 ) ) :

141 
version
 = 
parse
 ( 
version
 )

142 return 
version
 
	}

144 @ 
property

145 def 
	$operator
 ( 
self
 ) :

146 return 
self
 . 
_spec
 [ 0 ] 
	}

148 @ 
property

149 def 
	$version
 ( 
self
 ) :

150 return 
self
 . 
_spec
 [ 1 ] 
	}

152 @ 
property

153 def 
	$prereleases
 ( 
self
 ) :

154 return 
self
 . 
_prereleases
 
	}

156 @ 
prereleases
 . 
	`setter

157 def 
	$prereleases
 ( 
self
 , 
value
 ) :

158 
self
 . 
_prereleases
 = 
value
 
	}

160 def 
	$__contains__
 ( 
self
 , 
item
 ) :

161 return 
self
 . 
contains
 ( 
item
 ) 
	}

163 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

165 if 
prereleases
 is None :

166 
prereleases
 = 
self
 . 
prereleases

170 
item
 = 
self
 . 
_coerce_version
 ( 
item
 )

175 if 
item
 . 
is_prerelease
 and not 
prereleases
 :

180 return 
self
 . 
_get_operator
 ( 
self
 . 
operator
 ) ( 
item
 , 
self
 . 
version
 ) 
	}

182 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

183 
yielded
 = False

184 
found_prereleases
 = [ ]

186 
kw
 = { "prereleases" : 
prereleases
 if 
prereleases
 is not None else True }

190 for 
version
 in 
iterable
 :

191 
parsed_version
 = 
self
 . 
_coerce_version
 ( 
version
 )

193 if 
self
 . 
contains
 ( 
parsed_version
 , ** 
kw
 ) :

197 if ( 
parsed_version
 . 
is_prerelease
 and not

198 ( 
prereleases
 or 
self
 . 
prereleases
 ) ) :

199 
found_prereleases
 . 
append
 ( 
version
 )

203 
yielded
 = True

204 yield 
version

209 if not 
yielded
 and 
found_prereleases
 :

210 for 
version
 in 
found_prereleases
 :

211 yield 
version
 
	}

214 class 
	cLegacySpecifier
 ( 
_IndividualSpecifier
 ) :

216 
_regex_str
 = ( r"""\n        (?P<operator>(==|!=|<=|>=|<|>))\n        \s*\n        (?P<version>\n            [^,;\s)]* # Since this is a "legacy" specifier, and the version\n                      # string can be just about anything, we match everything\n                      # except for whitespace, a semi-colon for marker support,\n                      # a closing paren since versions can be enclosed in\n                      # them, and a comma since it's a version separator.\n        )\n        """

230 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

231 + 
_regex_str
 + r"\s*$" , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

233 
_operators
 = { "=="

242 def 
	$_coerce_version
 ( 
self
 , 
version
 ) :

243 if not 
isinstance
 ( 
version
 , 
LegacyVersion
 ) :

244 
version
 = 
LegacyVersion
 ( 
str
 ( 
version
 ) )

245 return 
version
 
	}

247 def 
	$_compare_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

248 return 
prospective
 == 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

250 def 
	$_compare_not_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

251 return 
prospective
 != 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

253 def 
	$_compare_less_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

254 return 
prospective
 <= 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

256 def 
	$_compare_greater_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

257 return 
prospective
 >= 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

259 def 
	$_compare_less_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

260 return 
prospective
 < 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

262 def 
	$_compare_greater_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

263 return 
prospective
 > 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

266 def 
	$_require_version_compare
 ( 
fn
 ) :

267 @ 
functools
 . 
	`wraps
 ( 
fn
 )

268 def 
wrapped
 ( 
self
 , 
prospective
 , 
spec
 ) :

269 if not 
isinstance
 ( 
prospective
 , 
Version
 ) :

271 return 
fn
 ( 
self
 , 
prospective
 , 
spec
 )

272 return 
wrapped
 
	}

275 class 
	cSpecifier
 ( 
_IndividualSpecifier
 ) :

277 
_regex_str
 = ( r"""\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \s*\n                [^\s]*    # We just match everything, except for whitespace\n                          # since we are only testing for strict identity.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n\n                # You cannot use a wild card and a dev or local version\n                # together so group them with a | and make them optional.\n                (?:\n                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release\n                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local\n                    |\n                    \.\*  # Wild card syntax of .*\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release\n            )\n        )\n        """

372 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

373 + 
_regex_str
 + r"\s*$" , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

375 
_operators
 = { "~="

386 @ 
	`_require_version_compare

387 def 
	$_compare_compatible
 ( 
self
 , 
prospective
 , 
spec
 ) :

397 
prefix
 = "." . 
join
 (

398 
list
 (

399 
itertools
 . 
takewhile
 (

400 lambda 
x
 : ( not 
x
 . 
startswith
 ( "post" ) and not

401 
x
 . 
startswith
 ( "dev" ) ) ,

402 
_version_split
 ( 
spec
 ) ,

408 
prefix
 += ".*"

410 return ( 
self
 . 
_get_operator
 ( ">=" ) ( 
prospective
 , 
spec
 ) and

411 
self
 . 
_get_operator
 ( "==" ) ( 
prospective
 , 
prefix
 ) ) 
	}

413 @ 
	`_require_version_compare

414 def 
	$_compare_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

416 if 
spec
 . 
endswith
 ( ".*" ) :

418 
prospective
 = 
Version
 ( 
prospective
 . 
public
 )

421 
spec
 = 
_version_split
 ( 
spec
 [ : - 2 ] )

426 
prospective
 = 
_version_split
 ( 
str
 ( 
prospective
 ) )

431 
prospective
 = 
prospective
 [ : 
len
 ( 
spec
 ) ]

435 
spec
 , 
prospective
 = 
_pad_version
 ( 
spec
 , 
prospective
 )

438 
spec
 = 
Version
 ( 
spec
 )

443 if not 
spec
 . 
local
 :

444 
prospective
 = 
Version
 ( 
prospective
 . 
public
 )

446 return 
prospective
 == 
spec
 
	}

448 @ 
	`_require_version_compare

449 def 
	$_compare_not_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

450 return not 
self
 . 
_compare_equal
 ( 
prospective
 , 
spec
 ) 
	}

452 @ 
	`_require_version_compare

453 def 
	$_compare_less_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

454 return 
prospective
 <= 
Version
 ( 
spec
 ) 
	}

456 @ 
	`_require_version_compare

457 def 
	$_compare_greater_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

458 return 
prospective
 >= 
Version
 ( 
spec
 ) 
	}

460 @ 
	`_require_version_compare

461 def 
	$_compare_less_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

464 
spec
 = 
Version
 ( 
spec
 )

469 if not 
prospective
 < 
spec
 :

476 if not 
spec
 . 
is_prerelease
 and 
prospective
 . 
is_prerelease
 :

477 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

483 return True 
	}

485 @ 
	`_require_version_compare

486 def 
	$_compare_greater_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

489 
spec
 = 
Version
 ( 
spec
 )

494 if not 
prospective
 > 
spec
 :

501 if not 
spec
 . 
is_postrelease
 and 
prospective
 . 
is_postrelease
 :

502 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

507 if 
prospective
 . 
local
 is not None :

508 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

514 return True 
	}

516 def 
	$_compare_arbitrary
 ( 
self
 , 
prospective
 , 
spec
 ) :

517 return 
str
 ( 
prospective
 ) . 
lower
 ( ) == 
str
 ( 
spec
 ) . 
lower
 ( ) 
	}

519 @ 
property

520 def 
	$prereleases
 ( 
self
 ) :

523 if 
self
 . 
_prereleases
 is not None :

524 return 
self
 . 
_prereleases

529 
operator
 , 
version
 = 
self
 . 
_spec

530 if 
operator
 in [ "==" , ">=" , "<=" , "~=" , "===" ] :

533 if 
operator
 == "==" and 
version
 . 
endswith
 ( ".*" ) :

534 
version
 = 
version
 [ : - 2 ]

538 if 
parse
 ( 
version
 ) . 
is_prerelease
 :

541 return False 
	}

543 @ 
prereleases
 . 
	`setter

544 def 
	$prereleases
 ( 
self
 , 
value
 ) :

545 
self
 . 
_prereleases
 = 
value
 
	}

548 
_prefix_regex
 = 
re
 . 
compile
 ( r"^([0-9]+)((?:a|b|c|rc)[0-9]+)$" )

551 def 
	$_version_split
 ( 
version
 ) :

552 
result
 = [ ]

553 for 
item
 in 
version
 . 
split
 ( "." ) :

554 
match
 = 
_prefix_regex
 . 
search
 ( 
item
 )

555 if 
match
 :

556 
result
 . 
extend
 ( 
match
 . 
groups
 ( ) )

558 
result
 . 
append
 ( 
item
 )

559 return 
result
 
	}

562 def 
	$_pad_version
 ( 
left
 , 
right
 ) :

563 
left_split
 , 
right_split
 = [ ] , [ ]

566 
left_split
 . 
append
 ( 
list
 ( 
itertools
 . 
takewhile
 ( lambda 
x
 : 
x
 . 
isdigit
 ( ) , 
left
 ) ) )

567 
right_split
 . 
append
 ( 
list
 ( 
itertools
 . 
takewhile
 ( lambda 
x
 : 
x
 . 
isdigit
 ( ) , 
right
 ) ) )

570 
left_split
 . 
append
 ( 
left
 [ 
len
 ( 
left_split
 [ 0 ] ) : ] )

571 
right_split
 . 
append
 ( 
right
 [ 
len
 ( 
right_split
 [ 0 ] ) : ] )

574 
left_split
 . 
insert
 (

576 [ "0" ] * 
max
 ( 0 , 
len
 ( 
right_split
 [ 0 ] ) - 
len
 ( 
left_split
 [ 0 ] ) ) ,

578 
right_split
 . 
insert
 (

580 [ "0" ] * 
max
 ( 0 , 
len
 ( 
left_split
 [ 0 ] ) - 
len
 ( 
right_split
 [ 0 ] ) ) ,

584 
list
 ( 
itertools
 . 
chain
 ( * 
left_split
 ) ) ,

585 
list
 ( 
itertools
 . 
chain
 ( * 
right_split
 ) ) ,

586 ) 
	}

589 class 
	cSpecifierSet
 ( 
BaseSpecifier
 ) :

591 def 
	$__init__
 ( 
self
 , 
specifiers
 = "" , 
prereleases
 = None ) :

594 
specifiers
 = [ 
s
 . 
strip
 ( ) for 
s
 in 
specifiers
 . 
split
 ( "," ) if 
s
 . 
strip
 ( ) ]

598 
parsed
 = 
set
 ( )

599 for 
specifier
 in 
specifiers
 :

601 
parsed
 . 
add
 ( 
Specifier
 ( 
specifier
 ) )

602 except 
InvalidSpecifier
 :

603 
parsed
 . 
add
 ( 
LegacySpecifier
 ( 
specifier
 ) )

606 
self
 . 
_specs
 = 
frozenset
 ( 
parsed
 )

610 
self
 . 
_prereleases
 = 
prereleases
 
	}

612 def 
	$__repr__
 ( 
self
 ) :

613 
pre
 = ( ", prereleases={0!r}"

614 . 
format
 ( 
self
 . 
prereleases
 )

615 if 
self
 . 
_prereleases
 is not None

619 return "<SpecifierSet({0!r}{1})>" . 
format
 ( 
str
 ( 
self
 ) , 
pre
 ) 
	}

621 def 
	$__str__
 ( 
self
 ) :

622 return "," . 
join
 ( 
sorted
 ( 
str
 ( 
s
 ) for 
s
 in 
self
 . 
_specs
 ) ) 
	}

624 def 
	$__hash__
 ( 
self
 ) :

625 return 
hash
 ( 
self
 . 
_specs
 ) 
	}

627 def 
	$__and__
 ( 
self
 , 
other
 ) :

628 if 
isinstance
 ( 
other
 , 
string_types
 ) :

629 
other
 = 
SpecifierSet
 ( 
other
 )

630 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

631 return 
NotImplemented

633 
specifier
 = 
SpecifierSet
 ( )

634 
specifier
 . 
_specs
 = 
frozenset
 ( 
self
 . 
_specs
 | 
other
 . 
_specs
 )

636 if 
self
 . 
_prereleases
 is None and 
other
 . 
_prereleases
 is not None :

637 
specifier
 . 
_prereleases
 = 
other
 . 
_prereleases

638 elif 
self
 . 
_prereleases
 is not None and 
other
 . 
_prereleases
 is None :

639 
specifier
 . 
_prereleases
 = 
self
 . 
_prereleases

640 elif 
self
 . 
_prereleases
 == 
other
 . 
_prereleases
 :

641 
specifier
 . 
_prereleases
 = 
self
 . 
_prereleases

643 raise 
ValueError
 ( "Cannot combine SpecifierSets with True and False prerelease " "overrides."

648 return 
specifier
 
	}

650 def 
	$__eq__
 ( 
self
 , 
other
 ) :

651 if 
isinstance
 ( 
other
 , 
string_types
 ) :

652 
other
 = 
SpecifierSet
 ( 
other
 )

653 elif 
isinstance
 ( 
other
 , 
_IndividualSpecifier
 ) :

654 
other
 = 
SpecifierSet
 ( 
str
 ( 
other
 ) )

655 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

656 return 
NotImplemented

658 return 
self
 . 
_specs
 == 
other
 . 
_specs
 
	}

660 def 
	$__ne__
 ( 
self
 , 
other
 ) :

661 if 
isinstance
 ( 
other
 , 
string_types
 ) :

662 
other
 = 
SpecifierSet
 ( 
other
 )

663 elif 
isinstance
 ( 
other
 , 
_IndividualSpecifier
 ) :

664 
other
 = 
SpecifierSet
 ( 
str
 ( 
other
 ) )

665 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

666 return 
NotImplemented

668 return 
self
 . 
_specs
 != 
other
 . 
_specs
 
	}

670 def 
	$__len__
 ( 
self
 ) :

671 return 
len
 ( 
self
 . 
_specs
 ) 
	}

673 def 
	$__iter__
 ( 
self
 ) :

674 return 
iter
 ( 
self
 . 
_specs
 ) 
	}

676 @ 
property

677 def 
	$prereleases
 ( 
self
 ) :

680 if 
self
 . 
_prereleases
 is not None :

681 return 
self
 . 
_prereleases

686 if not 
self
 . 
_specs
 :

691 return 
any
 ( 
s
 . 
prereleases
 for 
s
 in 
self
 . 
_specs
 ) 
	}

693 @ 
prereleases
 . 
	`setter

694 def 
	$prereleases
 ( 
self
 , 
value
 ) :

695 
self
 . 
_prereleases
 = 
value
 
	}

697 def 
	$__contains__
 ( 
self
 , 
item
 ) :

698 return 
self
 . 
contains
 ( 
item
 ) 
	}

700 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

702 if not 
isinstance
 ( 
item
 , ( 
LegacyVersion
 , 
Version
 ) ) :

703 
item
 = 
parse
 ( 
item
 )

708 if 
prereleases
 is None :

709 
prereleases
 = 
self
 . 
prereleases

717 if not 
prereleases
 and 
item
 . 
is_prerelease
 :

724 return 
all
 (

725 
s
 . 
contains
 ( 
item
 , 
prereleases
 = 
prereleases
 )

726 for 
s
 in 
self
 . 
_specs

727 ) 
	}

729 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

733 if 
prereleases
 is None :

734 
prereleases
 = 
self
 . 
prereleases

739 if 
self
 . 
_specs
 :

740 for 
spec
 in 
self
 . 
_specs
 :

741 
iterable
 = 
spec
 . 
filter
 ( 
iterable
 , 
prereleases
 = 
bool
 ( 
prereleases
 ) )

742 return 
iterable

747 
filtered
 = [ ]

748 
found_prereleases
 = [ ]

750 for 
item
 in 
iterable
 :

752 if not 
isinstance
 ( 
item
 , ( 
LegacyVersion
 , 
Version
 ) ) :

753 
parsed_version
 = 
parse
 ( 
item
 )

755 
parsed_version
 = 
item

758 if 
isinstance
 ( 
parsed_version
 , 
LegacyVersion
 ) :

763 if 
parsed_version
 . 
is_prerelease
 and not 
prereleases
 :

764 if not 
filtered
 :

765 
found_prereleases
 . 
append
 ( 
item
 )

767 
filtered
 . 
append
 ( 
item
 )

771 if not 
filtered
 and 
found_prereleases
 and 
prereleases
 is None :

772 return 
found_prereleases

774 return 
filtered
 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/version.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~collections

7 import 
	~itertools

8 import 
	~re

10 from . 
	~_structures
 import 
Infinity

13 
__all__
 = [ "parse"

18 
_Version
 = 
collections
 . 
namedtuple
 ( "_Version"

24 def 
	$parse
 ( 
version
 ) :

31 return 
Version
 ( 
version
 )

32 except 
InvalidVersion
 :

33 return 
LegacyVersion
 ( 
version
 ) 
	}

36 class 
	cInvalidVersion
 ( 
ValueError
 ) :

42 class 
	c_BaseVersion
 ( 
object
 ) :

44 def 
	$__hash__
 ( 
self
 ) :

45 return 
hash
 ( 
self
 . 
_key
 ) 
	}

47 def 
	$__lt__
 ( 
self
 , 
other
 ) :

48 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 < 
o
 ) 
	}

50 def 
	$__le__
 ( 
self
 , 
other
 ) :

51 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 <= 
o
 ) 
	}

53 def 
	$__eq__
 ( 
self
 , 
other
 ) :

54 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 == 
o
 ) 
	}

56 def 
	$__ge__
 ( 
self
 , 
other
 ) :

57 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 >= 
o
 ) 
	}

59 def 
	$__gt__
 ( 
self
 , 
other
 ) :

60 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 > 
o
 ) 
	}

62 def 
	$__ne__
 ( 
self
 , 
other
 ) :

63 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 != 
o
 ) 
	}

65 def 
	$_compare
 ( 
self
 , 
other
 , 
method
 ) :

66 if not 
isinstance
 ( 
other
 , 
_BaseVersion
 ) :

67 return 
NotImplemented

69 return 
method
 ( 
self
 . 
_key
 , 
other
 . 
_key
 ) 
	}

72 class 
	cLegacyVersion
 ( 
_BaseVersion
 ) :

74 def 
	$__init__
 ( 
self
 , 
version
 ) :

75 
self
 . 
_version
 = 
str
 ( 
version
 )

76 
self
 . 
_key
 = 
_legacy_cmpkey
 ( 
self
 . 
_version
 ) 
	}

78 def 
	$__str__
 ( 
self
 ) :

79 return 
self
 . 
_version
 
	}

81 def 
	$__repr__
 ( 
self
 ) :

82 return "<LegacyVersion({0})>" . 
format
 ( 
repr
 ( 
str
 ( 
self
 ) ) ) 
	}

84 @ 
property

85 def 
	$public
 ( 
self
 ) :

86 return 
self
 . 
_version
 
	}

88 @ 
property

89 def 
	$base_version
 ( 
self
 ) :

90 return 
self
 . 
_version
 
	}

92 @ 
property

93 def 
	$local
 ( 
self
 ) :

94 return None 
	}

96 @ 
property

97 def 
	$is_prerelease
 ( 
self
 ) :

98 return False 
	}

100 @ 
property

101 def 
	$is_postrelease
 ( 
self
 ) :

102 return False 
	}

105 
_legacy_version_component_re
 = 
re
 . 
compile
 ( r"(\d+ | [a-z]+ | \.| -)"

106 , 
re
 . 
VERBOSE
 ,

109 
_legacy_version_replacement_map
 = { "pre"

114 def 
	$_parse_version_parts
 ( 
s
 ) :

115 for 
part
 in 
_legacy_version_component_re
 . 
split
 ( 
s
 ) :

116 
part
 = 
_legacy_version_replacement_map
 . 
get
 ( 
part
 , 
part
 )

118 if not 
part
 or 
part
 == "." :

121 if 
part
 [ : 1 ] in "0123456789" :

123 yield 
part
 . 
zfill
 ( 8 )

125 yield "*" + 
part

128 yield "*final" 
	}

131 def 
	$_legacy_cmpkey
 ( 
version
 ) :

136 
epoch
 = - 1

140 
parts
 = [ ]

141 for 
part
 in 
_parse_version_parts
 ( 
version
 . 
lower
 ( ) ) :

142 if 
part
 . 
startswith
 ( "*" ) :

144 if 
part
 < "*final" :

145 while 
parts
 and 
parts
 [ - 1 ] == "*final-" :

146 
parts
 . 
pop
 ( )

149 while 
parts
 and 
parts
 [ - 1 ] == "00000000" :

150 
parts
 . 
pop
 ( )

152 
parts
 . 
append
 ( 
part
 )

153 
parts
 = 
tuple
 ( 
parts
 )

155 return 
epoch
 , 
parts
 
	}

159 
VERSION_PATTERN
 = r"""\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\.]?\n                (?P<post_l>post|rev|r)\n                [-_\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\.]?\n            (?P<dev_l>dev)\n            [-_\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version\n"""

191 class 
	cVersion
 ( 
_BaseVersion
 ) :

193 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

194 + 
VERSION_PATTERN
 + r"\s*$" ,

195 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 ,

198 def 
	$__init__
 ( 
self
 , 
version
 ) :

200 
match
 = 
self
 . 
_regex
 . 
search
 ( 
version
 )

201 if not 
match
 :

202 raise 
InvalidVersion
 ( "Invalid version: '{0}'" . 
format
 ( 
version
 ) )

205 
self
 . 
_version
 = 
_Version
 (

206 
epoch
 = 
int
 ( 
match
 . 
group
 ( "epoch" ) ) if 
match
 . 
group
 ( "epoch" ) else 0 ,

207 
release
 = 
tuple
 ( 
int
 ( 
i
 ) for 
i
 in 
match
 . 
group
 ( "release" ) . 
split
 ( "." ) ) ,

208 
pre
 = 
_parse_letter_version
 (

209 
match
 . 
group
 ( "pre_l" ) ,

210 
match
 . 
group
 ( "pre_n" ) ,

212 
post
 = 
_parse_letter_version
 (

213 
match
 . 
group
 ( "post_l" ) ,

214 
match
 . 
group
 ( "post_n1" ) or 
match
 . 
group
 ( "post_n2" ) ,

216 
dev
 = 
_parse_letter_version
 (

217 
match
 . 
group
 ( "dev_l" ) ,

218 
match
 . 
group
 ( "dev_n" ) ,

220 
local
 = 
_parse_local_version
 ( 
match
 . 
group
 ( "local" ) ) ,

224 
self
 . 
_key
 = 
_cmpkey
 (

225 
self
 . 
_version
 . 
epoch
 ,

226 
self
 . 
_version
 . 
release
 ,

227 
self
 . 
_version
 . 
pre
 ,

228 
self
 . 
_version
 . 
post
 ,

229 
self
 . 
_version
 . 
dev
 ,

230 
self
 . 
_version
 . 
local
 ,

231 ) 
	}

233 def 
	$__repr__
 ( 
self
 ) :

234 return "<Version({0})>" . 
format
 ( 
repr
 ( 
str
 ( 
self
 ) ) ) 
	}

236 def 
	$__str__
 ( 
self
 ) :

237 
parts
 = [ ]

240 if 
self
 . 
_version
 . 
epoch
 != 0 :

241 
parts
 . 
append
 ( "{0}!" . 
format
 ( 
self
 . 
_version
 . 
epoch
 ) )

244 
parts
 . 
append
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
release
 ) )

247 if 
self
 . 
_version
 . 
pre
 is not None :

248 
parts
 . 
append
 ( "" . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
pre
 ) )

251 if 
self
 . 
_version
 . 
post
 is not None :

252 
parts
 . 
append
 ( ".post{0}" . 
format
 ( 
self
 . 
_version
 . 
post
 [ 1 ] ) )

255 if 
self
 . 
_version
 . 
dev
 is not None :

256 
parts
 . 
append
 ( ".dev{0}" . 
format
 ( 
self
 . 
_version
 . 
dev
 [ 1 ] ) )

259 if 
self
 . 
_version
 . 
local
 is not None :

260 
parts
 . 
append
 ( "+{0}"

261 . 
format
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
local
 ) )

264 return "" . 
join
 ( 
parts
 ) 
	}

266 @ 
property

267 def 
	$public
 ( 
self
 ) :

268 return 
str
 ( 
self
 ) . 
split
 ( "+" , 1 ) [ 0 ] 
	}

270 @ 
property

271 def 
	$base_version
 ( 
self
 ) :

272 
parts
 = [ ]

275 if 
self
 . 
_version
 . 
epoch
 != 0 :

276 
parts
 . 
append
 ( "{0}!" . 
format
 ( 
self
 . 
_version
 . 
epoch
 ) )

279 
parts
 . 
append
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
release
 ) )

281 return "" . 
join
 ( 
parts
 ) 
	}

283 @ 
property

284 def 
	$local
 ( 
self
 ) :

285 
version_string
 = 
str
 ( 
self
 )

286 if "+" in 
version_string
 :

287 return 
version_string
 . 
split
 ( "+" , 1 ) [ 1 ] 
	}

289 @ 
property

290 def 
	$is_prerelease
 ( 
self
 ) :

291 return 
bool
 ( 
self
 . 
_version
 . 
dev
 or 
self
 . 
_version
 . 
pre
 ) 
	}

293 @ 
property

294 def 
	$is_postrelease
 ( 
self
 ) :

295 return 
bool
 ( 
self
 . 
_version
 . 
post
 ) 
	}

298 def 
	$_parse_letter_version
 ( 
letter
 , 
number
 ) :

299 if 
letter
 :

302 if 
number
 is None :

303 
number
 = 0

306 
letter
 = 
letter
 . 
lower
 ( )

311 if 
letter
 == "alpha" :

312 
letter
 = "a"

313 elif 
letter
 == "beta" :

314 
letter
 = "b"

315 elif 
letter
 in [ "c" , "pre" , "preview" ] :

316 
letter
 = "rc"

317 elif 
letter
 in [ "rev" , "r" ] :

318 
letter
 = "post"

320 return 
letter
 , 
int
 ( 
number
 )

321 if not 
letter
 and 
number
 :

324 
letter
 = "post"

326 return 
letter
 , 
int
 ( 
number
 ) 
	}

329 
_local_version_seperators
 = 
re
 . 
compile
 ( r"[\._-]" )

332 def 
	$_parse_local_version
 ( 
local
 ) :

336 if 
local
 is not None :

337 return 
tuple
 (

338 
part
 . 
lower
 ( ) if not 
part
 . 
isdigit
 ( ) else 
int
 ( 
part
 )

339 for 
part
 in 
_local_version_seperators
 . 
split
 ( 
local
 )

340 ) 
	}

343 def 
	$_cmpkey
 ( 
epoch
 , 
release
 , 
pre
 , 
post
 , 
dev
 , 
local
 ) :

349 
release
 = 
tuple
 (

350 
reversed
 ( 
list
 (

351 
itertools
 . 
dropwhile
 (

352 lambda 
x
 : 
x
 == 0 ,

353 
reversed
 ( 
release
 ) ,

362 if 
pre
 is None and 
post
 is None and 
dev
 is not None :

363 
pre
 = - 
Infinity

366 elif 
pre
 is None :

367 
pre
 = 
Infinity

370 if 
post
 is None :

371 
post
 = - 
Infinity

374 if 
dev
 is None :

375 
dev
 = 
Infinity

377 if 
local
 is None :

379 
local
 = - 
Infinity

388 
local
 = 
tuple
 (

389 ( 
i
 , "" ) if 
isinstance
 ( 
i
 , 
int
 ) else ( - 
Infinity
 , 
i
 )

390 for 
i
 in 
local

393 return 
epoch
 , 
release
 , 
pre
 , 
post
 , 
dev
 , 
local
 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/markers.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~operator

7 import 
	~os

8 import 
	~platform

9 import 
	~sys

11 from 
	~pkg_resources.extern.pyparsing
 import 
ParseException
 , 
ParseResults
 , 
stringStart
 , 
stringEnd

12 from 
	~pkg_resources.extern.pyparsing
 import 
ZeroOrMore
 , 
Group
 , 
Forward
 , 
QuotedString

13 from 
	~pkg_resources.extern.pyparsing
 import 
Literal
 as 
L

15 from . 
	~_compat
 import 
string_types

16 from . 
	~specifiers
 import 
Specifier
 , 
InvalidSpecifier

19 
__all__
 = [ "InvalidMarker"

25 class 
	cInvalidMarker
 ( 
ValueError
 ) :

31 class 
	cUndefinedComparison
 ( 
ValueError
 ) :

37 class 
	cUndefinedEnvironmentName
 ( 
ValueError
 ) :

44 class 
	cNode
 ( 
object
 ) :

46 def 
	$__init__
 ( 
self
 , 
value
 ) :

47 
self
 . 
value
 = 
value
 
	}

49 def 
	$__str__
 ( 
self
 ) :

50 return 
str
 ( 
self
 . 
value
 ) 
	}

52 def 
	$__repr__
 ( 
self
 ) :

53 return "<{0}({1!r})>" . 
format
 ( 
self
 . 
__class__
 . 
__name__
 , 
str
 ( 
self
 ) ) 
	}

55 def 
	$serialize
 ( 
self
 ) :

56 raise 
NotImplementedError
 
	}

59 class 
	cVariable
 ( 
Node
 ) :

61 def 
	$serialize
 ( 
self
 ) :

62 return 
str
 ( 
self
 ) 
	}

65 class 
	cValue
 ( 
Node
 ) :

67 def 
	$serialize
 ( 
self
 ) :

68 return '"{0}"' . 
format
 ( 
self
 ) 
	}

71 class 
	cOp
 ( 
Node
 ) :

73 def 
	$serialize
 ( 
self
 ) :

74 return 
str
 ( 
self
 ) 
	}

77 
VARIABLE
 = (

78 
L
 ( "implementation_version" ) |

79 
L
 ( "platform_python_implementation" ) |

80 
L
 ( "implementation_name" ) |

81 
L
 ( "python_full_version" ) |

82 
L
 ( "platform_release" ) |

83 
L
 ( "platform_version" ) |

84 
L
 ( "platform_machine" ) |

85 
L
 ( "platform_system" ) |

86 
L
 ( "python_version" ) |

87 
L
 ( "sys_platform" ) |

88 
L
 ( "os_name" ) |

89 
L
 ( "os.name" ) |

90 
L
 ( "sys.platform" ) |

91 
L
 ( "platform.version" ) |

92 
L
 ( "platform.machine" ) |

93 
L
 ( "platform.python_implementation" ) |

94 
L
 ( "python_implementation" ) |

95 
L
 ( "extra" )

97 
ALIASES
 = { 'os.name'

105 
VARIABLE
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Variable
 ( 
ALIASES
 . 
get
 ( 
t
 [ 0 ] , 
t
 [ 0 ] ) ) )

107 
VERSION_CMP
 = (

108 
L
 ( "===" ) |

109 
L
 ( "==" ) |

110 
L
 ( ">=" ) |

111 
L
 ( "<=" ) |

112 
L
 ( "!=" ) |

113 
L
 ( "~=" ) |

114 
L
 ( ">" ) |

115 
L
 ( "<" )

118 
MARKER_OP
 = 
VERSION_CMP
 | 
L
 ( "not in" ) | 
L
 ( "in" )

119 
MARKER_OP
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Op
 ( 
t
 [ 0 ] ) )

121 
MARKER_VALUE
 = 
QuotedString
 ( "'" ) | 
QuotedString
 ( '"' )

122 
MARKER_VALUE
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Value
 ( 
t
 [ 0 ] ) )

124 
BOOLOP
 = 
L
 ( "and" ) | 
L
 ( "or" )

126 
MARKER_VAR
 = 
VARIABLE
 | 
MARKER_VALUE

128 
MARKER_ITEM
 = 
Group
 ( 
MARKER_VAR
 + 
MARKER_OP
 + 
MARKER_VAR
 )

129 
MARKER_ITEM
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
tuple
 ( 
t
 [ 0 ] ) )

131 
LPAREN
 = 
L
 ( "(" ) . 
suppress
 ( )

132 
RPAREN
 = 
L
 ( ")" ) . 
suppress
 ( )

134 
MARKER_EXPR
 = 
Forward
 ( )

135 
MARKER_ATOM
 = 
MARKER_ITEM
 | 
Group
 ( 
LPAREN
 + 
MARKER_EXPR
 + 
RPAREN
 )

136 
MARKER_EXPR
 << 
MARKER_ATOM
 + 
ZeroOrMore
 ( 
BOOLOP
 + 
MARKER_EXPR
 )

138 
MARKER
 = 
stringStart
 + 
MARKER_EXPR
 + 
stringEnd

141 def 
	$_coerce_parse_result
 ( 
results
 ) :

142 if 
isinstance
 ( 
results
 , 
ParseResults
 ) :

143 return [ 
_coerce_parse_result
 ( 
i
 ) for 
i
 in 
results
 ]

145 return 
results
 
	}

148 def 
	$_format_marker
 ( 
marker
 , 
first
 = True ) :

149 assert 
isinstance
 ( 
marker
 , ( 
list
 , 
tuple
 , 
string_types
 ) )

155 if ( 
isinstance
 ( 
marker
 , 
list
 ) and 
len
 ( 
marker
 ) == 1 and

156 
isinstance
 ( 
marker
 [ 0 ] , ( 
list
 , 
tuple
 ) ) ) :

157 return 
_format_marker
 ( 
marker
 [ 0 ] )

159 if 
isinstance
 ( 
marker
 , 
list
 ) :

160 
inner
 = ( 
_format_marker
 ( 
m
 , 
first
 = False ) for 
m
 in 
marker
 )

161 if 
first
 :

162 return " " . 
join
 ( 
inner
 )

164 return "(" + " " . 
join
 ( 
inner
 ) + ")"

165 elif 
isinstance
 ( 
marker
 , 
tuple
 ) :

166 return " " . 
join
 ( [ 
m
 . 
serialize
 ( ) for 
m
 in 
marker
 ] )

168 return 
marker
 
	}

171 
_operators
 = { "in"

172 : lambda 
lhs
 , 
rhs
 : 
lhs
 in 
rhs
 , "not in"

173 : lambda 
lhs
 , 
rhs
 : 
lhs
 not in 
rhs
 , "<"

174 : 
operator
 . 
lt
 , "<="

175 : 
operator
 . 
le
 , "=="

176 : 
operator
 . 
eq
 , "!="

177 : 
operator
 . 
ne
 , ">="

178 : 
operator
 . 
ge
 , ">"

179 : 
operator
 . 
gt
 ,

183 def 
	$_eval_op
 ( 
lhs
 , 
op
 , 
rhs
 ) :

185 
spec
 = 
Specifier
 ( "" . 
join
 ( [ 
op
 . 
serialize
 ( ) , 
rhs
 ] ) )

186 except 
InvalidSpecifier
 :

189 return 
spec
 . 
contains
 ( 
lhs
 )

191 
oper
 = 
_operators
 . 
get
 ( 
op
 . 
serialize
 ( ) )

192 if 
oper
 is None :

193 raise 
UndefinedComparison
 ( "Undefined {0!r} on {1!r} and {2!r}."

194 . 
format
 ( 
op
 , 
lhs
 , 
rhs
 )

197 return 
oper
 ( 
lhs
 , 
rhs
 ) 
	}

200 
_undefined
 = 
object
 ( )

203 def 
	$_get_env
 ( 
environment
 , 
name
 ) :

204 
value
 = 
environment
 . 
get
 ( 
name
 , 
_undefined
 )

206 if 
value
 is 
_undefined
 :

207 raise 
UndefinedEnvironmentName
 ( "{0!r} does not exist in evaluation environment."

208 . 
format
 ( 
name
 )

211 return 
value
 
	}

214 def 
	$_evaluate_markers
 ( 
markers
 , 
environment
 ) :

215 
groups
 = [ [ ] ]

217 for 
marker
 in 
markers
 :

218 assert 
isinstance
 ( 
marker
 , ( 
list
 , 
tuple
 , 
string_types
 ) )

220 if 
isinstance
 ( 
marker
 , 
list
 ) :

221 
groups
 [ - 1 ] . 
append
 ( 
_evaluate_markers
 ( 
marker
 , 
environment
 ) )

222 elif 
isinstance
 ( 
marker
 , 
tuple
 ) :

223 
lhs
 , 
op
 , 
rhs
 = 
marker

225 if 
isinstance
 ( 
lhs
 , 
Variable
 ) :

226 
lhs_value
 = 
_get_env
 ( 
environment
 , 
lhs
 . 
value
 )

227 
rhs_value
 = 
rhs
 . 
value

229 
lhs_value
 = 
lhs
 . 
value

230 
rhs_value
 = 
_get_env
 ( 
environment
 , 
rhs
 . 
value
 )

232 
groups
 [ - 1 ] . 
append
 ( 
_eval_op
 ( 
lhs_value
 , 
op
 , 
rhs_value
 ) )

234 assert 
marker
 in [ "and" , "or" ]

235 if 
marker
 == "or" :

236 
groups
 . 
append
 ( [ ] )

238 return 
any
 ( 
all
 ( 
item
 ) for 
item
 in 
groups
 ) 
	}

241 def 
	$format_full_version
 ( 
info
 ) :

242 
version
 = '{0.major}.{0.minor}.{0.micro}' . 
format
 ( 
info
 )

243 
kind
 = 
info
 . 
releaselevel

244 if 
kind
 != 'final' :

245 
version
 += 
kind
 [ 0 ] + 
str
 ( 
info
 . 
serial
 )

246 return 
version
 
	}

249 def 
	$default_environment
 ( ) :

250 if 
hasattr
 ( 
sys
 , 'implementation' ) :

251 
iver
 = 
format_full_version
 ( 
sys
 . 
implementation
 . 
version
 )

252 
implementation_name
 = 
sys
 . 
implementation
 . 
name

254 
iver
 = '0'

255 
implementation_name
 = ''

258 : 
implementation_name
 , "implementation_version"

259 : 
iver
 , "os_name"

260 : 
os
 . 
name
 , "platform_machine"

261 : 
platform
 . 
machine
 ( ) , "platform_release"

262 : 
platform
 . 
release
 ( ) , "platform_system"

263 : 
platform
 . 
system
 ( ) , "platform_version"

264 : 
platform
 . 
version
 ( ) , "python_full_version"

265 : 
platform
 . 
python_version
 ( ) , "platform_python_implementation"

266 : 
platform
 . 
python_implementation
 ( ) , "python_version"

267 : 
platform
 . 
python_version
 ( ) [ : 3 ] , "sys_platform"

268 : 
sys
 . 
platform
 ,

269 } 
	}

272 class 
	cMarker
 ( 
object
 ) :

274 def 
	$__init__
 ( 
self
 , 
marker
 ) :

276 
self
 . 
_markers
 = 
_coerce_parse_result
 ( 
MARKER
 . 
parseString
 ( 
marker
 ) )

277 except 
ParseException
 as 
e
 :

278 
err_str
 = "Invalid marker: {0!r}, parse error at {1!r}" . 
format
 (

279 
marker
 , 
marker
 [ 
e
 . 
loc
 : 
e
 . 
loc
 + 8 ] )

280 raise 
InvalidMarker
 ( 
err_str
 ) 
	}

282 def 
	$__str__
 ( 
self
 ) :

283 return 
_format_marker
 ( 
self
 . 
_markers
 ) 
	}

285 def 
	$__repr__
 ( 
self
 ) :

286 return "<Marker({0!r})>" . 
format
 ( 
str
 ( 
self
 ) ) 
	}

288 def 
	$evaluate
 ( 
self
 , 
environment
 = None ) :

297 
current_environment
 = 
default_environment
 ( )

298 if 
environment
 is not None :

299 
current_environment
 . 
update
 ( 
environment
 )

301 return 
_evaluate_markers
 ( 
self
 . 
_markers
 , 
current_environment
 ) 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/requirements.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~string

7 import 
	~re

9 from 
	~pkg_resources.extern.pyparsing
 import 
stringStart
 , 
stringEnd
 , 
originalTextFor
 , 
ParseException

10 from 
	~pkg_resources.extern.pyparsing
 import 
ZeroOrMore
 , 
Word
 , 
Optional
 , 
Regex
 , 
Combine

11 from 
	~pkg_resources.extern.pyparsing
 import 
Literal
 as 
L

12 from 
	~pkg_resources.extern.six.moves.urllib
 import 
parse
 as 
urlparse

14 from . 
	~markers
 import 
MARKER_EXPR
 , 
Marker

15 from . 
	~specifiers
 import 
LegacySpecifier
 , 
Specifier
 , 
SpecifierSet

18 class 
	cInvalidRequirement
 ( 
ValueError
 ) :

24 
ALPHANUM
 = 
Word
 ( 
string
 . 
ascii_letters
 + 
string
 . 
digits
 )

26 
LBRACKET
 = 
L
 ( "[" ) . 
suppress
 ( )

27 
RBRACKET
 = 
L
 ( "]" ) . 
suppress
 ( )

28 
LPAREN
 = 
L
 ( "(" ) . 
suppress
 ( )

29 
RPAREN
 = 
L
 ( ")" ) . 
suppress
 ( )

30 
COMMA
 = 
L
 ( "," ) . 
suppress
 ( )

31 
SEMICOLON
 = 
L
 ( ";" ) . 
suppress
 ( )

32 
AT
 = 
L
 ( "@" ) . 
suppress
 ( )

34 
PUNCTUATION
 = 
Word
 ( "-_." )

35 
IDENTIFIER_END
 = 
ALPHANUM
 | ( 
ZeroOrMore
 ( 
PUNCTUATION
 ) + 
ALPHANUM
 )

36 
IDENTIFIER
 = 
Combine
 ( 
ALPHANUM
 + 
ZeroOrMore
 ( 
IDENTIFIER_END
 ) )

38 
NAME
 = 
IDENTIFIER
 ( "name" )

39 
EXTRA
 = 
IDENTIFIER

41 
URI
 = 
Regex
 ( r'[^ ]+' ) ( "url" )

42 
URL
 = ( 
AT
 + 
URI
 )

44 
EXTRAS_LIST
 = 
EXTRA
 + 
ZeroOrMore
 ( 
COMMA
 + 
EXTRA
 )

45 
EXTRAS
 = ( 
LBRACKET
 + 
Optional
 ( 
EXTRAS_LIST
 ) + 
RBRACKET
 ) ( "extras" )

47 
VERSION_PEP440
 = 
Regex
 ( 
Specifier
 . 
_regex_str
 , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

48 
VERSION_LEGACY
 = 
Regex
 ( 
LegacySpecifier
 . 
_regex_str
 , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

50 
VERSION_ONE
 = 
VERSION_PEP440
 ^ 
VERSION_LEGACY

51 
VERSION_MANY
 = 
Combine
 ( 
VERSION_ONE
 + 
ZeroOrMore
 ( 
COMMA
 + 
VERSION_ONE
 ) ,

52 
joinString
 = "," , 
adjacent
 = False ) ( "_raw_spec" )

53 
_VERSION_SPEC
 = 
Optional
 ( ( ( 
LPAREN
 + 
VERSION_MANY
 + 
RPAREN
 ) | 
VERSION_MANY
 ) )

54 
_VERSION_SPEC
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 . 
_raw_spec
 or '' )

56 
VERSION_SPEC
 = 
originalTextFor
 ( 
_VERSION_SPEC
 ) ( "specifier" )

57 
VERSION_SPEC
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 1 ] )

59 
MARKER_EXPR
 = 
originalTextFor
 ( 
MARKER_EXPR
 ( ) ) ( "marker" )

60 
MARKER_EXPR
 . 
setParseAction
 (

61 lambda 
s
 , 
l
 , 
t
 : 
Marker
 ( 
s
 [ 
t
 . 
_original_start
 : 
t
 . 
_original_end
 ] )

63 
MARKER_SEPERATOR
 = 
SEMICOLON

64 
MARKER
 = 
MARKER_SEPERATOR
 + 
MARKER_EXPR

66 
VERSION_AND_MARKER
 = 
VERSION_SPEC
 + 
Optional
 ( 
MARKER
 )

67 
URL_AND_MARKER
 = 
URL
 + 
Optional
 ( 
MARKER
 )

69 
NAMED_REQUIREMENT
 =

70 
NAME
 + 
Optional
 ( 
EXTRAS
 ) + ( 
URL_AND_MARKER
 | 
VERSION_AND_MARKER
 )

72 
REQUIREMENT
 = 
stringStart
 + 
NAMED_REQUIREMENT
 + 
stringEnd

75 class 
	cRequirement
 ( 
object
 ) :

88 def 
	$__init__
 ( 
self
 , 
requirement_string
 ) :

90 
req
 = 
REQUIREMENT
 . 
parseString
 ( 
requirement_string
 )

91 except 
ParseException
 as 
e
 :

92 raise 
InvalidRequirement
 ( "Invalid requirement, parse error at \"{0!r}\""

93 . 
format
 (

94 
requirement_string
 [ 
e
 . 
loc
 : 
e
 . 
loc
 + 8 ] ) )

96 
self
 . 
name
 = 
req
 . 
name

97 if 
req
 . 
url
 :

98 
parsed_url
 = 
urlparse
 . 
urlparse
 ( 
req
 . 
url
 )

99 if not ( 
parsed_url
 . 
scheme
 and 
parsed_url
 . 
netloc
 ) or (

100 not 
parsed_url
 . 
scheme
 and not 
parsed_url
 . 
netloc
 ) :

101 raise 
InvalidRequirement
 ( "Invalid URL given" )

102 
self
 . 
url
 = 
req
 . 
url

104 
self
 . 
url
 = None

105 
self
 . 
extras
 = 
set
 ( 
req
 . 
extras
 . 
asList
 ( ) if 
req
 . 
extras
 else [ ] )

106 
self
 . 
specifier
 = 
SpecifierSet
 ( 
req
 . 
specifier
 )

107 
self
 . 
marker
 = 
req
 . 
marker
 if 
req
 . 
marker
 else None 
	}

109 def 
	$__str__
 ( 
self
 ) :

110 
parts
 = [ 
self
 . 
name
 ]

112 if 
self
 . 
extras
 :

113 
parts
 . 
append
 ( "[{0}]" . 
format
 ( "," . 
join
 ( 
sorted
 ( 
self
 . 
extras
 ) ) ) )

115 if 
self
 . 
specifier
 :

116 
parts
 . 
append
 ( 
str
 ( 
self
 . 
specifier
 ) )

118 if 
self
 . 
url
 :

119 
parts
 . 
append
 ( "@ {0}" . 
format
 ( 
self
 . 
url
 ) )

121 if 
self
 . 
marker
 :

122 
parts
 . 
append
 ( "; {0}" . 
format
 ( 
self
 . 
marker
 ) )

124 return "" . 
join
 ( 
parts
 ) 
	}

126 def 
	$__repr__
 ( 
self
 ) :

127 return "<Requirement({0!r})>" . 
format
 ( 
str
 ( 
self
 ) ) 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/__about__.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 
__all__
 = [ "__title__"

11 
__title__
 = "packaging"

12 
__summary__
 = "Core utilities for Python packages"

13 
__uri__
 = "https://github.com/pypa/packaging"

15 
__version__
 = "16.8"

17 
__author__
 = "Donald Stufft and individual contributors"

18 
__email__
 = "donald@stufft.io"

20 
__license__
 = "BSD or Apache License, Version 2.0"

21 
__copyright__
 = "Copyright 2014-2016 %s" % 
__author__


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/__init__.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 from . 
	~__about__
 import (

7 
__author__
 , 
__copyright__
 , 
__email__
 , 
__license__
 , 
__summary__
 , 
__title__
 ,

8 
__uri__
 , 
__version__

11 
__all__
 = [ "__title__"


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/_structures.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

7 class 
	cInfinity
 ( 
object
 ) :

9 def 
	$__repr__
 ( 
self
 ) :

10 return "Infinity" 
	}

12 def 
	$__hash__
 ( 
self
 ) :

13 return 
hash
 ( 
repr
 ( 
self
 ) ) 
	}

15 def 
	$__lt__
 ( 
self
 , 
other
 ) :

16 return False 
	}

18 def 
	$__le__
 ( 
self
 , 
other
 ) :

19 return False 
	}

21 def 
	$__eq__
 ( 
self
 , 
other
 ) :

22 return 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

24 def 
	$__ne__
 ( 
self
 , 
other
 ) :

25 return not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

27 def 
	$__gt__
 ( 
self
 , 
other
 ) :

28 return True 
	}

30 def 
	$__ge__
 ( 
self
 , 
other
 ) :

31 return True 
	}

33 def 
	$__neg__
 ( 
self
 ) :

34 return 
NegativeInfinity
 
	}

36 
Infinity
 = 
Infinity
 ( )

39 class 
	cNegativeInfinity
 ( 
object
 ) :

41 def 
	$__repr__
 ( 
self
 ) :

42 return "-Infinity" 
	}

44 def 
	$__hash__
 ( 
self
 ) :

45 return 
hash
 ( 
repr
 ( 
self
 ) ) 
	}

47 def 
	$__lt__
 ( 
self
 , 
other
 ) :

48 return True 
	}

50 def 
	$__le__
 ( 
self
 , 
other
 ) :

51 return True 
	}

53 def 
	$__eq__
 ( 
self
 , 
other
 ) :

54 return 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

56 def 
	$__ne__
 ( 
self
 , 
other
 ) :

57 return not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

59 def 
	$__gt__
 ( 
self
 , 
other
 ) :

60 return False 
	}

62 def 
	$__ge__
 ( 
self
 , 
other
 ) :

63 return False 
	}

65 def 
	$__neg__
 ( 
self
 ) :

66 return 
Infinity
 
	}

68 
NegativeInfinity
 = 
NegativeInfinity
 ( )


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/utils.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~re

9 
_canonicalize_regex
 = 
re
 . 
compile
 ( r"[-_.]+" )

12 def 
	$canonicalize_name
 ( 
name
 ) :

14 return 
_canonicalize_regex
 . 
sub
 ( "-" , 
name
 ) . 
lower
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/__init__.py


	@./env/lib/python3.7/site-packages/pkg_resources/_vendor/pyparsing.py

25 
__doc__
 = """\npyparsing module - Classes and methods to define and execute parsing grammars\n=============================================================================\n\nThe pyparsing module is an alternative approach to creating and executing simple grammars,\nvs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you\ndon't need to learn a new syntax for defining grammars or matching expressions - the parsing module\nprovides a library of classes that you use to construct the grammar directly in Python.\n\nHere is a program to parse "Hello, World!" (or any greeting of the form \nC{"<salutation>, <addressee>!"}), built up using L{Word}, L{Literal}, and L{And} elements \n(L{'+'<ParserElement.__add__>} operator gives L{And} expressions, strings are auto-converted to\nL{Literal} expressions)::\n\n    from pyparsing import Word, alphas\n\n    # define grammar of a greeting\n    greet = Word(alphas) + "," + Word(alphas) + "!"\n\n    hello = "Hello, World!"\n    print (hello, "->", greet.parseString(hello))\n\nThe program outputs the following::\n\n    Hello, World! -> ['Hello', ',', 'World', '!']\n\nThe Python representation of the grammar is quite readable, owing to the self-explanatory\nclass names, and the use of '+', '|' and '^' operators.\n\nThe L{ParseResults} object returned from L{ParserElement.parseString<ParserElement.parseString>} can be accessed as a nested list, a dictionary, or an\nobject with named attributes.\n\nThe pyparsing module handles some of the problems that are typically vexing when writing text parsers:\n - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)\n - quoted strings\n - embedded comments\n\n\nGetting Started -\n-----------------\nVisit the classes L{ParserElement} and L{ParseResults} to see the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:\n - construct literal match expressions from L{Literal} and L{CaselessLiteral} classes\n - construct character word-group expressions using the L{Word} class\n - see how to create repetitive expressions using L{ZeroOrMore} and L{OneOrMore} classes\n - use L{'+'<And>}, L{'|'<MatchFirst>}, L{'^'<Or>}, and L{'&'<Each>} operators to combine simple expressions into more complex ones\n - associate names with your parsed results using L{ParserElement.setResultsName}\n - find some helpful expression short-cuts like L{delimitedList} and L{oneOf}\n - find more useful common expressions in the L{pyparsing_common} namespace class\n"""

77 
__version__
 = "2.2.1"

78 
__versionTime__
 = "18 Sep 2018 00:49 UTC"

79 
__author__
 = "Paul McGuire <ptmcg@users.sourceforge.net>"

81 import 
	~string

82 from 
	~weakref
 import 
ref
 as 
wkref

83 import 
	~copy

84 import 
	~sys

85 import 
	~warnings

86 import 
	~re

87 import 
	~sre_constants

88 import 
	~collections

89 import 
	~pprint

90 import 
	~traceback

91 import 
	~types

92 from 
	~datetime
 import 
datetime

95 from 
	~_thread
 import 
RLock

96 except 
ImportError
 :

97 from 
	~threading
 import 
RLock

101 from 
	~collections.abc
 import 
Iterable

102 from 
	~collections.abc
 import 
MutableMapping

103 except 
ImportError
 :

105 from 
	~collections
 import 
Iterable

106 from 
	~collections
 import 
MutableMapping

109 from 
	~collections
 import 
OrderedDict
 as 
_OrderedDict

110 except 
ImportError
 :

112 from 
	~ordereddict
 import 
OrderedDict
 as 
_OrderedDict

113 except 
ImportError
 :

114 
_OrderedDict
 = None

118 
__all__
 = [ 'And'

139 
system_version
 = 
tuple
 ( 
sys
 . 
version_info
 ) [ : 3 ]

140 
PY_3
 = 
system_version
 [ 0 ] == 3

141 if 
PY_3
 :

142 
_MAX_INT
 = 
sys
 . 
maxsize

143 
basestring
 = 
str

144 
unichr
 = 
chr

145 
_ustr
 = 
str

148 
singleArgBuiltins
 = [ 
sum
 , 
len
 , 
sorted
 , 
reversed
 , 
list
 , 
tuple
 , 
set
 , 
any
 , 
all
 , 
min
 , 
max
 ]

151 
_MAX_INT
 = 
sys
 . 
maxint

152 
range
 = 
xrange

154 def 
	$_ustr
 ( 
obj
 ) :

159 if 
isinstance
 ( 
obj
 , 
unicode
 ) :

160 return 
obj

165 return 
str
 ( 
obj
 )

167 except 
UnicodeEncodeError
 :

169 
ret
 = 
unicode
 ( 
obj
 ) . 
encode
 ( 
sys
 . 
getdefaultencoding
 ( ) , 'xmlcharrefreplace' )

170 
xmlcharref
 = 
Regex
 ( r'&#\d+;' )

171 
xmlcharref
 . 
setParseAction
 ( lambda 
t
 : '\\u' + 
hex
 ( 
int
 ( 
t
 [ 0 ] [ 2 : - 1 ] ) ) [ 2 : ] )

172 return 
xmlcharref
 . 
transformString
 ( 
ret
 ) 
	}

175 
singleArgBuiltins
 = [ ]

176 import 
	~__builtin__

177 for 
fname
 in "sum len sorted reversed list tuple set any all min max" . 
split
 ( ) :

179 
singleArgBuiltins
 . 
append
 ( 
getattr
 ( 
__builtin__
 , 
fname
 ) )

180 except 
AttributeError
 :

183 
_generatorType
 = 
type
 ( ( 
y
 for 
y
 in 
range
 ( 1 ) ) )

185 def 
	$_xml_escape
 ( 
data
 ) :

189 
from_symbols
 = '&><"\''

190 
to_symbols
 = ( '&' + 
s
 + ';' for 
s
 in "amp gt lt quot apos" . 
split
 ( ) )

191 for 
from_
 , 
to_
 in 
zip
 ( 
from_symbols
 , 
to_symbols
 ) :

192 
data
 = 
data
 . 
replace
 ( 
from_
 , 
to_
 )

193 return 
data
 
	}

195 class 
	c_Constants
 ( 
object
 ) :

198 
alphas
 = 
string
 . 
ascii_uppercase
 + 
string
 . 
ascii_lowercase

199 
nums
 = "0123456789"

200 
hexnums
 = 
nums
 + "ABCDEFabcdef"

201 
alphanums
 = 
alphas
 + 
nums

202 
_bslash
 = 
chr
 ( 92 )

203 
printables
 = "" . 
join
 ( 
c
 for 
c
 in 
string
 . 
printable
 if 
c
 not in 
string
 . 
whitespace
 )

205 class 
	cParseBaseException
 ( 
Exception
 ) :

209 def 
	$__init__
 ( 
self
 , 
pstr
 , 
loc
 = 0 , 
msg
 = None , 
elem
 = None ) :

210 
self
 . 
loc
 = 
loc

211 if 
msg
 is None :

212 
self
 . 
msg
 = 
pstr

213 
self
 . 
pstr
 = ""

215 
self
 . 
msg
 = 
msg

216 
self
 . 
pstr
 = 
pstr

217 
self
 . 
parserElement
 = 
elem

218 
self
 . 
args
 = ( 
pstr
 , 
loc
 , 
msg
 ) 
	}

220 @ 
classmethod

221 def 
	$_from_exception
 ( 
cls
 , 
pe
 ) :

226 return 
cls
 ( 
pe
 . 
pstr
 , 
pe
 . 
loc
 , 
pe
 . 
msg
 , 
pe
 . 
parserElement
 ) 
	}

228 def 
	$__getattr__
 ( 
self
 , 
aname
 ) :

234 if ( 
aname
 == "lineno" ) :

235 return 
lineno
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

236 elif ( 
aname
 in ( "col" , "column" ) ) :

237 return 
col
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

238 elif ( 
aname
 == "line" ) :

239 return 
line
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

241 raise 
AttributeError
 ( 
aname
 ) 
	}

243 def 
	$__str__
 ( 
self
 ) :

245 ( 
self
 . 
msg
 , 
self
 . 
loc
 , 
self
 . 
lineno
 , 
self
 . 
column
 ) 
	}

246 def 
	$__repr__
 ( 
self
 ) :

247 return 
_ustr
 ( 
self
 ) 
	}

248 def 
	$markInputline
 ( 
self
 , 
markerString
 = ">!<" ) :

252 
line_str
 = 
self
 . 
line

253 
line_column
 = 
self
 . 
column
 - 1

254 if 
markerString
 :

255 
line_str
 = "" . 
join
 ( ( 
line_str
 [ : 
line_column
 ] ,

256 
markerString
 , 
line_str
 [ 
line_column
 : ] ) )

257 return 
line_str
 . 
strip
 ( ) 
	}

258 def 
	$__dir__
 ( 
self
 ) :

259 return "lineno col line" . 
split
 ( ) + 
dir
 ( 
type
 ( 
self
 ) ) 
	}

261 class 
	cParseException
 ( 
ParseBaseException
 ) :

282 class 
	cParseFatalException
 ( 
ParseBaseException
 ) :

287 class 
	cParseSyntaxException
 ( 
ParseFatalException
 ) :

306 class 
	cRecursiveGrammarException
 ( 
Exception
 ) :

308 def 
	$__init__
 ( 
self
 , 
parseElementList
 ) :

309 
self
 . 
parseElementTrace
 = 
parseElementList
 
	}

311 def 
	$__str__
 ( 
self
 ) :

312 return "RecursiveGrammarException: %s" % 
self
 . 
parseElementTrace
 
	}

314 class 
	c_ParseResultsWithOffset
 ( 
object
 ) :

315 def 
	$__init__
 ( 
self
 , 
p1
 , 
p2
 ) :

316 
self
 . 
tup
 = ( 
p1
 , 
p2
 ) 
	}

317 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

318 return 
self
 . 
tup
 [ 
i
 ] 
	}

319 def 
	$__repr__
 ( 
self
 ) :

320 return 
repr
 ( 
self
 . 
tup
 [ 0 ] ) 
	}

321 def 
	$setOffset
 ( 
self
 , 
i
 ) :

322 
self
 . 
tup
 = ( 
self
 . 
tup
 [ 0 ] , 
i
 ) 
	}

324 class 
	cParseResults
 ( 
object
 ) :

363 def 
	$__new__
 ( 
cls
 , 
toklist
 = None , 
name
 = None , 
asList
 = True , 
modal
 = True ) :

364 if 
isinstance
 ( 
toklist
 , 
cls
 ) :

365 return 
toklist

366 
retobj
 = 
object
 . 
__new__
 ( 
cls
 )

367 
retobj
 . 
__doinit
 = True

368 return 
retobj
 
	}

372 def 
	$__init__
 ( 
self
 , 
toklist
 = None , 
name
 = None , 
asList
 = True , 
modal
 = True , 
isinstance
 = 
isinstance
 ) :

373 if 
self
 . 
__doinit
 :

374 
self
 . 
__doinit
 = False

375 
self
 . 
__name
 = None

376 
self
 . 
__parent
 = None

377 
self
 . 
__accumNames
 = { }

378 
self
 . 
__asList
 = 
asList

379 
self
 . 
__modal
 = 
modal

380 if 
toklist
 is None :

381 
toklist
 = [ ]

382 if 
isinstance
 ( 
toklist
 , 
list
 ) :

383 
self
 . 
__toklist
 = 
toklist
 [ : ]

384 elif 
isinstance
 ( 
toklist
 , 
_generatorType
 ) :

385 
self
 . 
__toklist
 = 
list
 ( 
toklist
 )

387 
self
 . 
__toklist
 = [ 
toklist
 ]

388 
self
 . 
__tokdict
 = 
dict
 ( )

390 if 
name
 is not None and 
name
 :

391 if not 
modal
 :

392 
self
 . 
__accumNames
 [ 
name
 ] = 0

393 if 
isinstance
 ( 
name
 , 
int
 ) :

394 
name
 = 
_ustr
 ( 
name
 )

395 
self
 . 
__name
 = 
name

396 if not ( 
isinstance
 ( 
toklist
 , ( 
type
 ( None ) , 
basestring
 , 
list
 ) ) and 
toklist
 in ( None , '' , [ ] ) ) :

397 if 
isinstance
 ( 
toklist
 , 
basestring
 ) :

398 
toklist
 = [ 
toklist
 ]

399 if 
asList
 :

400 if 
isinstance
 ( 
toklist
 , 
ParseResults
 ) :

401 
self
 [ 
name
 ] = 
_ParseResultsWithOffset
 ( 
toklist
 . 
copy
 ( ) , 0 )

403 
self
 [ 
name
 ] = 
_ParseResultsWithOffset
 ( 
ParseResults
 ( 
toklist
 [ 0 ] ) , 0 )

404 
self
 [ 
name
 ] . 
__name
 = 
name

407 
self
 [ 
name
 ] = 
toklist
 [ 0 ]

408 except ( 
KeyError
 , 
TypeError
 , 
IndexError
 ) :

409 
self
 [ 
name
 ] = 
toklist
 
	}

411 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

412 if 
isinstance
 ( 
i
 , ( 
int
 , 
slice
 ) ) :

413 return 
self
 . 
__toklist
 [ 
i
 ]

415 if 
i
 not in 
self
 . 
__accumNames
 :

416 return 
self
 . 
__tokdict
 [ 
i
 ] [ - 1 ] [ 0 ]

418 return 
ParseResults
 ( [ 
v
 [ 0 ] for 
v
 in 
self
 . 
__tokdict
 [ 
i
 ] ] ) 
	}

420 def 
	$__setitem__
 ( 
self
 , 
k
 , 
v
 , 
isinstance
 = 
isinstance
 ) :

421 if 
isinstance
 ( 
v
 , 
_ParseResultsWithOffset
 ) :

422 
self
 . 
__tokdict
 [ 
k
 ] = 
self
 . 
__tokdict
 . 
get
 ( 
k
 , 
list
 ( ) ) + [ 
v
 ]

423 
sub
 = 
v
 [ 0 ]

424 elif 
isinstance
 ( 
k
 , ( 
int
 , 
slice
 ) ) :

425 
self
 . 
__toklist
 [ 
k
 ] = 
v

426 
sub
 = 
v

428 
self
 . 
__tokdict
 [ 
k
 ] = 
self
 . 
__tokdict
 . 
get
 ( 
k
 , 
list
 ( ) ) + [ 
_ParseResultsWithOffset
 ( 
v
 , 0 ) ]

429 
sub
 = 
v

430 if 
isinstance
 ( 
sub
 , 
ParseResults
 ) :

431 
sub
 . 
__parent
 = 
wkref
 ( 
self
 ) 
	}

433 def 
	$__delitem__
 ( 
self
 , 
i
 ) :

434 if 
isinstance
 ( 
i
 , ( 
int
 , 
slice
 ) ) :

435 
mylen
 = 
len
 ( 
self
 . 
__toklist
 )

436 del 
self
 . 
__toklist
 [ 
i
 ]

439 if 
isinstance
 ( 
i
 , 
int
 ) :

440 if 
i
 < 0 :

441 
i
 += 
mylen

442 
i
 = 
slice
 ( 
i
 , 
i
 + 1 )

444 
removed
 = 
list
 ( 
range
 ( * 
i
 . 
indices
 ( 
mylen
 ) ) )

445 
removed
 . 
reverse
 ( )

447 for 
name
 , 
occurrences
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

448 for 
j
 in 
removed
 :

449 for 
k
 , ( 
value
 , 
position
 ) in 
enumerate
 ( 
occurrences
 ) :

450 
occurrences
 [ 
k
 ] = 
_ParseResultsWithOffset
 ( 
value
 , 
position
 - ( 
position
 > 
j
 ) )

452 del 
self
 . 
__tokdict
 [ 
i
 ] 
	}

454 def 
	$__contains__
 ( 
self
 , 
k
 ) :

455 return 
k
 in 
self
 . 
__tokdict
 
	}

457 def 
	$__len__
 ( 
self
 ) : return 
len
 ( 
self
 . 
__toklist
 )

458 def 
__bool__
 ( 
self
 ) : return ( not not 
self
 . 
__toklist
 )

459 
__nonzero__
 = 
__bool__

460 def 
__iter__
 ( 
self
 ) : return 
iter
 ( 
self
 . 
__toklist
 )

461 def 
__reversed__
 ( 
self
 ) : return 
iter
 ( 
self
 . 
__toklist
 [ : : - 1 ] )

462 def 
_iterkeys
 ( 
self
 ) :

463 if 
hasattr
 ( 
self
 . 
__tokdict
 , "iterkeys" ) :

464 return 
self
 . 
__tokdict
 . 
iterkeys
 ( )

466 return 
iter
 ( 
self
 . 
__tokdict
 ) 
	}

468 def 
	$_itervalues
 ( 
self
 ) :

469 return ( 
self
 [ 
k
 ] for 
k
 in 
self
 . 
_iterkeys
 ( ) ) 
	}

471 def 
	$_iteritems
 ( 
self
 ) :

472 return ( ( 
k
 , 
self
 [ 
k
 ] ) for 
k
 in 
self
 . 
_iterkeys
 ( ) ) 
	}

474 if 
PY_3
 :

475 
keys
 = 
_iterkeys
 """Returns an iterator of all named result keys (Python 3.x only)."""

478 
values
 = 
_itervalues
 """Returns an iterator of all named result values (Python 3.x only)."""

481 
items
 = 
_iteritems
 """Returns an iterator of all named result key-value tuples (Python 3.x only)."""

485 
iterkeys
 = 
_iterkeys
 """Returns an iterator of all named result keys (Python 2.x only)."""

488 
itervalues
 = 
_itervalues
 """Returns an iterator of all named result values (Python 2.x only)."""

491 
iteritems
 = 
_iteritems
 """Returns an iterator of all named result key-value tuples (Python 2.x only)."""

494 def 
	$keys
 ( 
self
 ) :

496 return 
list
 ( 
self
 . 
iterkeys
 ( ) ) 
	}

498 def 
	$values
 ( 
self
 ) :

500 return 
list
 ( 
self
 . 
itervalues
 ( ) ) 
	}

502 def 
	$items
 ( 
self
 ) :

504 return 
list
 ( 
self
 . 
iteritems
 ( ) ) 
	}

506 def 
	$haskeys
 ( 
self
 ) :

509 return 
bool
 ( 
self
 . 
__tokdict
 ) 
	}

511 def 
	$pop
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

545 if not 
args
 :

546 
args
 = [ - 1 ]

547 for 
k
 , 
v
 in 
kwargs
 . 
items
 ( ) :

548 if 
k
 == 'default' :

549 
args
 = ( 
args
 [ 0 ] , 
v
 )

551 raise 
TypeError
 ( "pop() got an unexpected keyword argument '%s'" % 
k
 )

552 if ( 
isinstance
 ( 
args
 [ 0 ] , 
int
 ) or

553 
len
 ( 
args
 ) == 1 or

554 
args
 [ 0 ] in 
self
 ) :

555 
index
 = 
args
 [ 0 ]

556 
ret
 = 
self
 [ 
index
 ]

557 del 
self
 [ 
index
 ]

558 return 
ret

560 
defaultvalue
 = 
args
 [ 1 ]

561 return 
defaultvalue
 
	}

563 def 
	$get
 ( 
self
 , 
key
 , 
defaultValue
 = None ) :

580 if 
key
 in 
self
 :

581 return 
self
 [ 
key
 ]

583 return 
defaultValue
 
	}

585 def 
	$insert
 ( 
self
 , 
index
 , 
insStr
 ) :

599 
self
 . 
__toklist
 . 
insert
 ( 
index
 , 
insStr
 )

601 for 
name
 , 
occurrences
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

602 for 
k
 , ( 
value
 , 
position
 ) in 
enumerate
 ( 
occurrences
 ) :

603 
occurrences
 [ 
k
 ] = 
_ParseResultsWithOffset
 ( 
value
 , 
position
 + ( 
position
 > 
index
 ) ) 
	}

605 def 
	$append
 ( 
self
 , 
item
 ) :

617 
self
 . 
__toklist
 . 
append
 ( 
item
 ) 
	}

619 def 
	$extend
 ( 
self
 , 
itemseq
 ) :

632 if 
isinstance
 ( 
itemseq
 , 
ParseResults
 ) :

633 
self
 += 
itemseq

635 
self
 . 
__toklist
 . 
extend
 ( 
itemseq
 ) 
	}

637 def 
	$clear
 ( 
self
 ) :

641 del 
self
 . 
__toklist
 [ : ]

642 
self
 . 
__tokdict
 . 
clear
 ( ) 
	}

644 def 
	$__getattr__
 ( 
self
 , 
name
 ) :

646 return 
self
 [ 
name
 ]

647 except 
KeyError
 :

650 if 
name
 in 
self
 . 
__tokdict
 :

651 if 
name
 not in 
self
 . 
__accumNames
 :

652 return 
self
 . 
__tokdict
 [ 
name
 ] [ - 1 ] [ 0 ]

654 return 
ParseResults
 ( [ 
v
 [ 0 ] for 
v
 in 
self
 . 
__tokdict
 [ 
name
 ] ] )

656 return "" 
	}

658 def 
	$__add__
 ( 
self
 , 
other
 ) :

659 
ret
 = 
self
 . 
copy
 ( )

660 
ret
 += 
other

661 return 
ret
 
	}

663 def 
	$__iadd__
 ( 
self
 , 
other
 ) :

664 if 
other
 . 
__tokdict
 :

665 
offset
 = 
len
 ( 
self
 . 
__toklist
 )

666 
addoffset
 = lambda 
a
 : 
offset
 if 
a
 < 0 else 
a
 + 
offset

667 
otheritems
 = 
other
 . 
__tokdict
 . 
items
 ( )

668 
otherdictitems
 = [ ( 
k
 , 
_ParseResultsWithOffset
 ( 
v
 [ 0 ] , 
addoffset
 ( 
v
 [ 1 ] ) ) )

669 for ( 
k
 , 
vlist
 ) in 
otheritems
 for 
v
 in 
vlist
 ]

670 for 
k
 , 
v
 in 
otherdictitems
 :

671 
self
 [ 
k
 ] = 
v

672 if 
isinstance
 ( 
v
 [ 0 ] , 
ParseResults
 ) :

673 
v
 [ 0 ] . 
__parent
 = 
wkref
 ( 
self
 )

675 
self
 . 
__toklist
 += 
other
 . 
__toklist

676 
self
 . 
__accumNames
 . 
update
 ( 
other
 . 
__accumNames
 )

677 return 
self
 
	}

679 def 
	$__radd__
 ( 
self
 , 
other
 ) :

680 if 
isinstance
 ( 
other
 , 
int
 ) and 
other
 == 0 :

682 return 
self
 . 
copy
 ( )

685 return 
other
 + 
self
 
	}

687 def 
	$__repr__
 ( 
self
 ) :

688 return "(%s, %s)" % ( 
repr
 ( 
self
 . 
__toklist
 ) , 
repr
 ( 
self
 . 
__tokdict
 ) ) 
	}

690 def 
	$__str__
 ( 
self
 ) :

691 return '[' + ', ' . 
join
 ( 
_ustr
 ( 
i
 ) if 
isinstance
 ( 
i
 , 
ParseResults
 ) else 
repr
 ( 
i
 ) for 
i
 in 
self
 . 
__toklist
 ) + ']' 
	}

693 def 
	$_asStringList
 ( 
self
 , 
sep
 = '' ) :

694 
out
 = [ ]

695 for 
item
 in 
self
 . 
__toklist
 :

696 if 
out
 and 
sep
 :

697 
out
 . 
append
 ( 
sep
 )

698 if 
isinstance
 ( 
item
 , 
ParseResults
 ) :

699 
out
 += 
item
 . 
_asStringList
 ( )

701 
out
 . 
append
 ( 
_ustr
 ( 
item
 ) )

702 return 
out
 
	}

704 def 
	$asList
 ( 
self
 ) :

718 return [ 
res
 . 
asList
 ( ) if 
isinstance
 ( 
res
 , 
ParseResults
 ) else 
res
 for 
res
 in 
self
 . 
__toklist
 ] 
	}

720 def 
	$asDict
 ( 
self
 ) :

739 if 
PY_3
 :

740 
item_fn
 = 
self
 . 
items

742 
item_fn
 = 
self
 . 
iteritems

744 def 
toItem
 ( 
obj
 ) :

745 if 
isinstance
 ( 
obj
 , 
ParseResults
 ) :

746 if 
obj
 . 
haskeys
 ( ) :

747 return 
obj
 . 
asDict
 ( )

749 return [ 
toItem
 ( 
v
 ) for 
v
 in 
obj
 ]

751 return 
obj

753 return 
dict
 ( ( 
k
 , 
toItem
 ( 
v
 ) ) for 
k
 , 
v
 in 
item_fn
 ( ) ) 
	}

755 def 
	$copy
 ( 
self
 ) :

759 
ret
 = 
ParseResults
 ( 
self
 . 
__toklist
 )

760 
ret
 . 
__tokdict
 = 
self
 . 
__tokdict
 . 
copy
 ( )

761 
ret
 . 
__parent
 = 
self
 . 
__parent

762 
ret
 . 
__accumNames
 . 
update
 ( 
self
 . 
__accumNames
 )

763 
ret
 . 
__name
 = 
self
 . 
__name

764 return 
ret
 
	}

766 def 
	$asXML
 ( 
self
 , 
doctag
 = None , 
namedItemsOnly
 = False , 
indent
 = "" , 
formatted
 = True ) :

770 
nl
 = "\n"

771 
out
 = [ ]

772 
namedItems
 = 
dict
 ( ( 
v
 [ 1 ] , 
k
 ) for ( 
k
 , 
vlist
 ) in 
self
 . 
__tokdict
 . 
items
 ( )

773 for 
v
 in 
vlist
 )

774 
nextLevelIndent
 = 
indent
 + "  "

777 if not 
formatted
 :

778 
indent
 = ""

779 
nextLevelIndent
 = ""

780 
nl
 = ""

782 
selfTag
 = None

783 if 
doctag
 is not None :

784 
selfTag
 = 
doctag

786 if 
self
 . 
__name
 :

787 
selfTag
 = 
self
 . 
__name

789 if not 
selfTag
 :

790 if 
namedItemsOnly
 :

793 
selfTag
 = "ITEM"

795 
out
 += [ 
nl
 , 
indent
 , "<" , 
selfTag
 , ">" ]

797 for 
i
 , 
res
 in 
enumerate
 ( 
self
 . 
__toklist
 ) :

798 if 
isinstance
 ( 
res
 , 
ParseResults
 ) :

799 if 
i
 in 
namedItems
 :

800 
out
 += [ 
res
 . 
asXML
 ( 
namedItems
 [ 
i
 ] ,

801 
namedItemsOnly
 and 
doctag
 is None ,

802 
nextLevelIndent
 ,

803 
formatted
 ) ]

805 
out
 += [ 
res
 . 
asXML
 ( None ,

806 
namedItemsOnly
 and 
doctag
 is None ,

807 
nextLevelIndent
 ,

808 
formatted
 ) ]

811 
resTag
 = None

812 if 
i
 in 
namedItems
 :

813 
resTag
 = 
namedItems
 [ 
i
 ]

814 if not 
resTag
 :

815 if 
namedItemsOnly
 :

818 
resTag
 = "ITEM"

819 
xmlBodyText
 = 
_xml_escape
 ( 
_ustr
 ( 
res
 ) )

820 
out
 += [ 
nl
 , 
nextLevelIndent
 , "<" , 
resTag
 , ">" ,

821 
xmlBodyText
 , "</"

822 , 
resTag
 , ">" ]

824 
out
 += [ 
nl
 , 
indent
 , "</" , 
selfTag
 , ">" ]

825 return "" . 
join
 ( 
out
 ) 
	}

827 def 
	$__lookup
 ( 
self
 , 
sub
 ) :

828 for 
k
 , 
vlist
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

829 for 
v
 , 
loc
 in 
vlist
 :

830 if 
sub
 is 
v
 :

831 return 
k

832 return None 
	}

834 def 
	$getName
 ( 
self
 ) :

856 if 
self
 . 
__name
 :

857 return 
self
 . 
__name

858 elif 
self
 . 
__parent
 :

859 
par
 = 
self
 . 
__parent
 ( )

860 if 
par
 :

861 return 
par
 . 
__lookup
 ( 
self
 )

864 elif ( 
len
 ( 
self
 ) == 1 and

865 
len
 ( 
self
 . 
__tokdict
 ) == 1 and

866 
next
 ( 
iter
 ( 
self
 . 
__tokdict
 . 
values
 ( ) ) ) [ 0 ] [ 1 ] in ( 0 , - 1 ) ) :

867 return 
next
 ( 
iter
 ( 
self
 . 
__tokdict
 . 
keys
 ( ) ) )

869 return None 
	}

871 def 
	$dump
 ( 
self
 , 
indent
 = '' , 
depth
 = 0 , 
full
 = True ) :

889 
out
 = [ ]

890 
NL
 = '\n'

891 
out
 . 
append
 ( 
indent
 + 
_ustr
 ( 
self
 . 
asList
 ( ) ) )

892 if 
full
 :

893 if 
self
 . 
haskeys
 ( ) :

894 
items
 = 
sorted
 ( ( 
str
 ( 
k
 ) , 
v
 ) for 
k
 , 
v
 in 
self
 . 
items
 ( ) )

895 for 
k
 , 
v
 in 
items
 :

896 if 
out
 :

897 
out
 . 
append
 ( 
NL
 )

898 
out
 . 
append
 ( "%s%s- %s: " % ( 
indent
 , ( '  ' * 
depth
 ) , 
k
 ) )

899 if 
isinstance
 ( 
v
 , 
ParseResults
 ) :

900 if 
v
 :

901 
out
 . 
append
 ( 
v
 . 
dump
 ( 
indent
 , 
depth
 + 1 ) )

903 
out
 . 
append
 ( 
_ustr
 ( 
v
 ) )

905 
out
 . 
append
 ( 
repr
 ( 
v
 ) )

906 elif 
any
 ( 
isinstance
 ( 
vv
 , 
ParseResults
 ) for 
vv
 in 
self
 ) :

907 
v
 = 
self

908 for 
i
 , 
vv
 in 
enumerate
 ( 
v
 ) :

909 if 
isinstance
 ( 
vv
 , 
ParseResults
 ) :

910 
out
 . 
append
 ( "\n%s%s[%d]:\n%s%s%s" % ( 
indent
 , ( '  ' * ( 
depth
 ) ) , 
i
 , 
indent
 , ( '  ' * ( 
depth
 + 1 ) ) , 
vv
 . 
dump
 ( 
indent
 , 
depth
 + 1 ) ) )

912 
out
 . 
append
 ( "\n%s%s[%d]:\n%s%s%s" % ( 
indent
 , ( '  ' * ( 
depth
 ) ) , 
i
 , 
indent
 , ( '  ' * ( 
depth
 + 1 ) ) , 
_ustr
 ( 
vv
 ) ) )

914 return "" . 
join
 ( 
out
 ) 
	}

916 def 
	$pprint
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

937 
pprint
 . 
pprint
 ( 
self
 . 
asList
 ( ) , * 
args
 , ** 
kwargs
 ) 
	}

940 def 
	$__getstate__
 ( 
self
 ) :

941 return ( 
self
 . 
__toklist
 ,

942 ( 
self
 . 
__tokdict
 . 
copy
 ( ) ,

943 
self
 . 
__parent
 is not None and 
self
 . 
__parent
 ( ) or None ,

944 
self
 . 
__accumNames
 ,

945 
self
 . 
__name
 ) ) 
	}

947 def 
	$__setstate__
 ( 
self
 , 
state
 ) :

948 
self
 . 
__toklist
 = 
state
 [ 0 ]

949 ( 
self
 . 
__tokdict
 ,

950 
par
 ,

951 
inAccumNames
 ,

952 
self
 . 
__name
 ) = 
state
 [ 1 ]

953 
self
 . 
__accumNames
 = { }

954 
self
 . 
__accumNames
 . 
update
 ( 
inAccumNames
 )

955 if 
par
 is not None :

956 
self
 . 
__parent
 = 
wkref
 ( 
par
 )

958 
self
 . 
__parent
 = None 
	}

960 def 
	$__getnewargs__
 ( 
self
 ) :

961 return 
self
 . 
__toklist
 , 
self
 . 
__name
 , 
self
 . 
__asList
 , 
self
 . 
__modal
 
	}

963 def 
	$__dir__
 ( 
self
 ) :

964 return ( 
dir
 ( 
type
 ( 
self
 ) ) + 
list
 ( 
self
 . 
keys
 ( ) ) ) 
	}

966 
MutableMapping
 . 
register
 ( 
ParseResults
 )

968 def 
	$col
 ( 
loc
 , 
strg
 ) :

978 
s
 = 
strg

979 return 1 if 0 < 
loc
 < 
len
 ( 
s
 ) and 
s
 [ 
loc
 - 1 ] == '\n' else 
loc
 - 
s
 . 
rfind
 ( "\n" , 0 , 
loc
 ) 
	}

981 def 
	$lineno
 ( 
loc
 , 
strg
 ) :

991 return 
strg
 . 
count
 ( "\n" , 0 , 
loc
 ) + 1 
	}

993 def 
	$line
 ( 
loc
 , 
strg
 ) :

996 
lastCR
 = 
strg
 . 
rfind
 ( "\n" , 0 , 
loc
 )

997 
nextCR
 = 
strg
 . 
find
 ( "\n" , 
loc
 )

998 if 
nextCR
 >= 0 :

999 return 
strg
 [ 
lastCR
 + 1 : 
nextCR
 ]

1001 return 
strg
 [ 
lastCR
 + 1 : ] 
	}

1003 def 
	$_defaultStartDebugAction
 ( 
instring
 , 
loc
 , 
expr
 ) :

1004 
print
 ( ( "Match " + 
_ustr
 ( 
expr
 ) + " at loc " + 
_ustr
 ( 
loc
 ) + "(%d,%d)" % ( 
lineno
 ( 
loc
 , 
instring
 ) , 
col
 ( 
loc
 , 
instring
 ) ) ) ) 
	}

1006 def 
	$_defaultSuccessDebugAction
 ( 
instring
 , 
startloc
 , 
endloc
 , 
expr
 , 
toks
 ) :

1007 
print
 ( "Matched " + 
_ustr
 ( 
expr
 ) + " -> " + 
str
 ( 
toks
 . 
asList
 ( ) ) ) 
	}

1009 def 
	$_defaultExceptionDebugAction
 ( 
instring
 , 
loc
 , 
expr
 , 
exc
 ) :

1010 
print
 ( "Exception raised:" + 
_ustr
 ( 
exc
 ) ) 
	}

1012 def 
	$nullDebugAction
 ( * 
args
 ) :

1014 pass 
	}
 'decorator to trim function calls to match the arity of the target'

1039 def 
	$_trim_arity
 ( 
func
 , 
maxargs
 = 2 ) :

1040 if 
func
 in 
singleArgBuiltins
 :

1041 return lambda 
s
 , 
l
 , 
t
 : 
func
 ( 
t
 )

1042 
limit
 = [ 0 ]

1043 
foundArity
 = [ False ]

1046 if 
system_version
 [ : 2 ] >= ( 3 , 5 ) :

1047 def 
extract_stack
 ( 
limit
 = 0 ) :

1049 
offset
 = - 3 if 
system_version
 == ( 3 , 5 , 0 ) else - 2

1050 
frame_summary
 = 
traceback
 . 
extract_stack
 ( 
limit
 = - 
offset
 + 
limit
 - 1 ) [ 
offset
 ]

1051 return [ 
frame_summary
 [ : 2 ] ]

1052 def 
extract_tb
 ( 
tb
 , 
limit
 = 0 ) :

1053 
frames
 = 
traceback
 . 
extract_tb
 ( 
tb
 , 
limit
 = 
limit
 )

1054 
frame_summary
 = 
frames
 [ - 1 ]

1055 return [ 
frame_summary
 [ : 2 ] ]

1057 
extract_stack
 = 
traceback
 . 
extract_stack

1058 
extract_tb
 = 
traceback
 . 
extract_tb

1063 
LINE_DIFF
 = 6

1066 
this_line
 = 
extract_stack
 ( 
limit
 = 2 ) [ - 1 ]

1067 
pa_call_line_synth
 = ( 
this_line
 [ 0 ] , 
this_line
 [ 1 ] + 
LINE_DIFF
 )

1069 def 
wrapper
 ( * 
args
 ) :

1072 
ret
 = 
func
 ( * 
args
 [ 
limit
 [ 0 ] : ] )

1073 
foundArity
 [ 0 ] = True

1074 return 
ret

1075 except 
TypeError
 :

1077 if 
foundArity
 [ 0 ] :

1081 
tb
 = 
sys
 . 
exc_info
 ( ) [ - 1 ]

1082 if not 
extract_tb
 ( 
tb
 , 
limit
 = 2 ) [ - 1 ] [ : 2 ] == 
pa_call_line_synth
 :

1085 del 
tb

1087 if 
limit
 [ 0 ] <= 
maxargs
 :

1088 
limit
 [ 0 ] += 1

1093 
func_name
 = "<parse action>"

1095 
func_name
 = 
getattr
 ( 
func
 , '__name__' ,

1096 
getattr
 ( 
func
 , '__class__' ) . 
__name__
 )

1097 except 
Exception
 :

1098 
func_name
 = 
str
 ( 
func
 )

1099 
wrapper
 . 
__name__
 = 
func_name

1101 return 
wrapper
 
	}

1103 class 
	cParserElement
 ( 
object
 ) :

1105 
DEFAULT_WHITE_CHARS
 = " \n\t\r"

1106 
verbose_stacktrace
 = False

1108 @ 
	`staticmethod

1109 def 
	$setDefaultWhitespaceChars
 ( 
chars
 ) :

1121 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 = 
chars
 
	}

1123 @ 
	`staticmethod

1124 def 
	$inlineLiteralsUsing
 ( 
cls
 ) :

1142 
ParserElement
 . 
_literalStringClass
 = 
cls
 
	}

1144 def 
	$__init__
 ( 
self
 , 
savelist
 = False ) :

1145 
self
 . 
parseAction
 = 
list
 ( )

1146 
self
 . 
failAction
 = None

1148 
self
 . 
strRepr
 = None

1149 
self
 . 
resultsName
 = None

1150 
self
 . 
saveAsList
 = 
savelist

1151 
self
 . 
skipWhitespace
 = True

1152 
self
 . 
whiteChars
 = 
ParserElement
 . 
DEFAULT_WHITE_CHARS

1153 
self
 . 
copyDefaultWhiteChars
 = True

1154 
self
 . 
mayReturnEmpty
 = False

1155 
self
 . 
keepTabs
 = False

1156 
self
 . 
ignoreExprs
 = 
list
 ( )

1157 
self
 . 
debug
 = False

1158 
self
 . 
streamlined
 = False

1159 
self
 . 
mayIndexError
 = True

1160 
self
 . 
errmsg
 = ""

1161 
self
 . 
modalResults
 = True

1162 
self
 . 
debugActions
 = ( None , None , None )

1163 
self
 . 
re
 = None

1164 
self
 . 
callPreparse
 = True

1165 
self
 . 
callDuringTry
 = False 
	}

1167 def 
	$copy
 ( 
self
 ) :

1183 
cpy
 = 
copy
 . 
copy
 ( 
self
 )

1184 
cpy
 . 
parseAction
 = 
self
 . 
parseAction
 [ : ]

1185 
cpy
 . 
ignoreExprs
 = 
self
 . 
ignoreExprs
 [ : ]

1186 if 
self
 . 
copyDefaultWhiteChars
 :

1187 
cpy
 . 
whiteChars
 = 
ParserElement
 . 
DEFAULT_WHITE_CHARS

1188 return 
cpy
 
	}

1190 def 
	$setName
 ( 
self
 , 
name
 ) :

1198 
self
 . 
name
 = 
name

1199 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

1200 if 
hasattr
 ( 
self
 , "exception" ) :

1201 
self
 . 
exception
 . 
msg
 = 
self
 . 
errmsg

1202 return 
self
 
	}

1204 def 
	$setResultsName
 ( 
self
 , 
name
 , 
listAllMatches
 = False ) :

1224 
newself
 = 
self
 . 
copy
 ( )

1225 if 
name
 . 
endswith
 ( "*" ) :

1226 
name
 = 
name
 [ : - 1 ]

1227 
listAllMatches
 = True

1228 
newself
 . 
resultsName
 = 
name

1229 
newself
 . 
modalResults
 = not 
listAllMatches

1230 return 
newself
 
	}

1232 def 
	$setBreak
 ( 
self
 , 
breakFlag
 = True ) :

1237 if 
breakFlag
 :

1238 
_parseMethod
 = 
self
 . 
_parse

1239 def 
breaker
 ( 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1240 import 
	~pdb

1241 
pdb
 . 
set_trace
 ( )

1242 return 
_parseMethod
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 )

1243 
breaker
 . 
_originalParseMethod
 = 
_parseMethod

1244 
self
 . 
_parse
 = 
breaker

1246 if 
hasattr
 ( 
self
 . 
_parse
 , "_originalParseMethod" ) :

1247 
self
 . 
_parse
 = 
self
 . 
_parse
 . 
_originalParseMethod

1248 return 
self
 
	}

1250 def 
	$setParseAction
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1284 
self
 . 
parseAction
 = 
list
 ( 
map
 ( 
_trim_arity
 , 
list
 ( 
fns
 ) ) )

1285 
self
 . 
callDuringTry
 = 
kwargs
 . 
get
 ( "callDuringTry" , False )

1286 return 
self
 
	}

1288 def 
	$addParseAction
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1294 
self
 . 
parseAction
 += 
list
 ( 
map
 ( 
_trim_arity
 , 
list
 ( 
fns
 ) ) )

1295 
self
 . 
callDuringTry
 = 
self
 . 
callDuringTry
 or 
kwargs
 . 
get
 ( "callDuringTry" , False )

1296 return 
self
 
	}

1298 def 
	$addCondition
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1315 
msg
 = 
kwargs
 . 
get
 ( "message" , "failed user-defined condition" )

1316 
exc_type
 = 
ParseFatalException
 if 
kwargs
 . 
get
 ( "fatal" , False ) else 
ParseException

1317 for 
fn
 in 
fns
 :

1318 def 
pa
 ( 
s
 , 
l
 , 
t
 ) :

1319 if not 
bool
 ( 
_trim_arity
 ( 
fn
 ) ( 
s
 , 
l
 , 
t
 ) ) :

1320 raise 
exc_type
 ( 
s
 , 
l
 , 
msg
 )

1321 
self
 . 
parseAction
 . 
append
 ( 
pa
 )

1322 
self
 . 
callDuringTry
 = 
self
 . 
callDuringTry
 or 
kwargs
 . 
get
 ( "callDuringTry" , False )

1323 return 
self
 
	}

1325 def 
	$setFailAction
 ( 
self
 , 
fn
 ) :

1335 
self
 . 
failAction
 = 
fn

1336 return 
self
 
	}

1338 def 
	$_skipIgnorables
 ( 
self
 , 
instring
 , 
loc
 ) :

1339 
exprsFound
 = True

1340 while 
exprsFound
 :

1341 
exprsFound
 = False

1342 for 
e
 in 
self
 . 
ignoreExprs
 :

1345 
loc
 , 
dummy
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 )

1346 
exprsFound
 = True

1347 except 
ParseException
 :

1349 return 
loc
 
	}

1351 def 
	$preParse
 ( 
self
 , 
instring
 , 
loc
 ) :

1352 if 
self
 . 
ignoreExprs
 :

1353 
loc
 = 
self
 . 
_skipIgnorables
 ( 
instring
 , 
loc
 )

1355 if 
self
 . 
skipWhitespace
 :

1356 
wt
 = 
self
 . 
whiteChars

1357 
instrlen
 = 
len
 ( 
instring
 )

1358 while 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
wt
 :

1359 
loc
 += 1

1361 return 
loc
 
	}

1363 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

1364 return 
loc
 , [ ] 
	}

1366 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

1367 return 
tokenlist
 
	}

1370 def 
	$_parseNoCache
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1371 
debugging
 = ( 
self
 . 
debug
 )

1373 if 
debugging
 or 
self
 . 
failAction
 :

1375 if ( 
self
 . 
debugActions
 [ 0 ] ) :

1376 
self
 . 
debugActions
 [ 0 ] ( 
instring
 , 
loc
 , 
self
 )

1377 if 
callPreParse
 and 
self
 . 
callPreparse
 :

1378 
preloc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1380 
preloc
 = 
loc

1381 
tokensStart
 = 
preloc

1384 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1385 except 
IndexError
 :

1386 raise 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

1387 except 
ParseBaseException
 as 
err
 :

1389 if 
self
 . 
debugActions
 [ 2 ] :

1390 
self
 . 
debugActions
 [ 2 ] ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1391 if 
self
 . 
failAction
 :

1392 
self
 . 
failAction
 ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1395 if 
callPreParse
 and 
self
 . 
callPreparse
 :

1396 
preloc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1398 
preloc
 = 
loc

1399 
tokensStart
 = 
preloc

1400 if 
self
 . 
mayIndexError
 or 
preloc
 >= 
len
 ( 
instring
 ) :

1402 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1403 except 
IndexError
 :

1404 raise 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

1406 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1408 
tokens
 = 
self
 . 
postParse
 ( 
instring
 , 
loc
 , 
tokens
 )

1410 
retTokens
 = 
ParseResults
 ( 
tokens
 , 
self
 . 
resultsName
 , 
asList
 = 
self
 . 
saveAsList
 , 
modal
 = 
self
 . 
modalResults
 )

1411 if 
self
 . 
parseAction
 and ( 
doActions
 or 
self
 . 
callDuringTry
 ) :

1412 if 
debugging
 :

1414 for 
fn
 in 
self
 . 
parseAction
 :

1415 
tokens
 = 
fn
 ( 
instring
 , 
tokensStart
 , 
retTokens
 )

1416 if 
tokens
 is not None :

1417 
retTokens
 = 
ParseResults
 ( 
tokens
 ,

1418 
self
 . 
resultsName
 ,

1419 
asList
 = 
self
 . 
saveAsList
 and 
isinstance
 ( 
tokens
 , ( 
ParseResults
 , 
list
 ) ) ,

1420 
modal
 = 
self
 . 
modalResults
 )

1421 except 
ParseBaseException
 as 
err
 :

1423 if ( 
self
 . 
debugActions
 [ 2 ] ) :

1424 
self
 . 
debugActions
 [ 2 ] ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1427 for 
fn
 in 
self
 . 
parseAction
 :

1428 
tokens
 = 
fn
 ( 
instring
 , 
tokensStart
 , 
retTokens
 )

1429 if 
tokens
 is not None :

1430 
retTokens
 = 
ParseResults
 ( 
tokens
 ,

1431 
self
 . 
resultsName
 ,

1432 
asList
 = 
self
 . 
saveAsList
 and 
isinstance
 ( 
tokens
 , ( 
ParseResults
 , 
list
 ) ) ,

1433 
modal
 = 
self
 . 
modalResults
 )

1434 if 
debugging
 :

1436 if ( 
self
 . 
debugActions
 [ 1 ] ) :

1437 
self
 . 
debugActions
 [ 1 ] ( 
instring
 , 
tokensStart
 , 
loc
 , 
self
 , 
retTokens
 )

1439 return 
loc
 , 
retTokens
 
	}

1441 def 
	$tryParse
 ( 
self
 , 
instring
 , 
loc
 ) :

1443 return 
self
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 = False ) [ 0 ]

1444 except 
ParseFatalException
 :

1445 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

1447 def 
	$canParseNext
 ( 
self
 , 
instring
 , 
loc
 ) :

1449 
self
 . 
tryParse
 ( 
instring
 , 
loc
 )

1450 except ( 
ParseException
 , 
IndexError
 ) :

1453 return True 
	}

1455 class 
	c_UnboundedCache
 ( 
object
 ) :

1456 def 
	$__init__
 ( 
self
 ) :

1457 
cache
 = { }

1458 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1460 def 
get
 ( 
self
 , 
key
 ) :

1461 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1463 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1464 
cache
 [ 
key
 ] = 
value

1466 def 
clear
 ( 
self
 ) :

1467 
cache
 . 
clear
 ( )

1469 def 
cache_len
 ( 
self
 ) :

1470 return 
len
 ( 
cache
 )

1472 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1473 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1474 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1475 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1477 if 
_OrderedDict
 is not None :

1478 class 
	c_FifoCache
 ( 
object
 ) :

1479 def 
	$__init__
 ( 
self
 , 
size
 ) :

1480 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1482 
cache
 = 
_OrderedDict
 ( )

1484 def 
get
 ( 
self
 , 
key
 ) :

1485 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1487 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1488 
cache
 [ 
key
 ] = 
value

1489 while 
len
 ( 
cache
 ) > 
size
 :

1491 
cache
 . 
popitem
 ( False )

1492 except 
KeyError
 :

1495 def 
clear
 ( 
self
 ) :

1496 
cache
 . 
clear
 ( )

1498 def 
cache_len
 ( 
self
 ) :

1499 return 
len
 ( 
cache
 )

1501 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1502 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1503 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1504 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1507 class 
	c_FifoCache
 ( 
object
 ) :

1508 def 
	$__init__
 ( 
self
 , 
size
 ) :

1509 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1511 
cache
 = { }

1512 
key_fifo
 = 
collections
 . 
deque
 ( [ ] , 
size
 )

1514 def 
get
 ( 
self
 , 
key
 ) :

1515 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1517 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1518 
cache
 [ 
key
 ] = 
value

1519 while 
len
 ( 
key_fifo
 ) > 
size
 :

1520 
cache
 . 
pop
 ( 
key_fifo
 . 
popleft
 ( ) , None )

1521 
key_fifo
 . 
append
 ( 
key
 )

1523 def 
clear
 ( 
self
 ) :

1524 
cache
 . 
clear
 ( )

1525 
key_fifo
 . 
clear
 ( )

1527 def 
cache_len
 ( 
self
 ) :

1528 return 
len
 ( 
cache
 )

1530 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1531 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1532 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1533 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1536 
packrat_cache
 = { }

1537 
packrat_cache_lock
 = 
RLock
 ( )

1538 
packrat_cache_stats
 = [ 0 , 0 ]

1542 def 
	$_parseCache
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1543 
HIT
 , 
MISS
 = 0 , 1

1544 
lookup
 = ( 
self
 , 
instring
 , 
loc
 , 
callPreParse
 , 
doActions
 )

1545 with 
ParserElement
 . 
packrat_cache_lock
 :

1546 
cache
 = 
ParserElement
 . 
packrat_cache

1547 
value
 = 
cache
 . 
get
 ( 
lookup
 )

1548 if 
value
 is 
cache
 . 
not_in_cache
 :

1549 
ParserElement
 . 
packrat_cache_stats
 [ 
MISS
 ] += 1

1551 
value
 = 
self
 . 
_parseNoCache
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 )

1552 except 
ParseBaseException
 as 
pe
 :

1554 
cache
 . 
set
 ( 
lookup
 , 
pe
 . 
__class__
 ( * 
pe
 . 
args
 ) )

1557 
cache
 . 
set
 ( 
lookup
 , ( 
value
 [ 0 ] , 
value
 [ 1 ] . 
copy
 ( ) ) )

1558 return 
value

1560 
ParserElement
 . 
packrat_cache_stats
 [ 
HIT
 ] += 1

1561 if 
isinstance
 ( 
value
 , 
Exception
 ) :

1562 raise 
value

1563 return ( 
value
 [ 0 ] , 
value
 [ 1 ] . 
copy
 ( ) ) 
	}

1565 
_parse
 = 
_parseNoCache

1567 @ 
	`staticmethod

1568 def 
	$resetCache
 ( ) :

1569 
ParserElement
 . 
packrat_cache
 . 
clear
 ( )

1570 
ParserElement
 . 
packrat_cache_stats
 [ : ] = [ 0 ] * 
len
 ( 
ParserElement
 . 
packrat_cache_stats
 ) 
	}

1572 
_packratEnabled
 = False

1573 @ 
	`staticmethod

1574 def 
	$enablePackrat
 ( 
cache_size_limit
 = 128 ) :

1600 if not 
ParserElement
 . 
_packratEnabled
 :

1601 
ParserElement
 . 
_packratEnabled
 = True

1602 if 
cache_size_limit
 is None :

1603 
ParserElement
 . 
packrat_cache
 = 
ParserElement
 . 
_UnboundedCache
 ( )

1605 
ParserElement
 . 
packrat_cache
 = 
ParserElement
 . 
_FifoCache
 ( 
cache_size_limit
 )

1606 
ParserElement
 . 
_parse
 = 
ParserElement
 . 
_parseCache
 
	}

1608 def 
	$parseString
 ( 
self
 , 
instring
 , 
parseAll
 = False ) :

1635 
ParserElement
 . 
resetCache
 ( )

1636 if not 
self
 . 
streamlined
 :

1637 
self
 . 
streamline
 ( )

1639 for 
e
 in 
self
 . 
ignoreExprs
 :

1640 
e
 . 
streamline
 ( )

1641 if not 
self
 . 
keepTabs
 :

1642 
instring
 = 
instring
 . 
expandtabs
 ( )

1644 
loc
 , 
tokens
 = 
self
 . 
_parse
 ( 
instring
 , 0 )

1645 if 
parseAll
 :

1646 
loc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1647 
se
 = 
Empty
 ( ) + 
StringEnd
 ( )

1648 
se
 . 
_parse
 ( 
instring
 , 
loc
 )

1649 except 
ParseBaseException
 as 
exc
 :

1650 if 
ParserElement
 . 
verbose_stacktrace
 :

1654 raise 
exc

1656 return 
tokens
 
	}

1658 def 
	$scanString
 ( 
self
 , 
instring
 , 
maxMatches
 = 
_MAX_INT
 , 
overlap
 = False ) :

1688 if not 
self
 . 
streamlined
 :

1689 
self
 . 
streamline
 ( )

1690 for 
e
 in 
self
 . 
ignoreExprs
 :

1691 
e
 . 
streamline
 ( )

1693 if not 
self
 . 
keepTabs
 :

1694 
instring
 = 
_ustr
 ( 
instring
 ) . 
expandtabs
 ( )

1695 
instrlen
 = 
len
 ( 
instring
 )

1696 
loc
 = 0

1697 
preparseFn
 = 
self
 . 
preParse

1698 
parseFn
 = 
self
 . 
_parse

1699 
ParserElement
 . 
resetCache
 ( )

1700 
matches
 = 0

1702 while 
loc
 <= 
instrlen
 and 
matches
 < 
maxMatches
 :

1704 
preloc
 = 
preparseFn
 ( 
instring
 , 
loc
 )

1705 
nextLoc
 , 
tokens
 = 
parseFn
 ( 
instring
 , 
preloc
 , 
callPreParse
 = False )

1706 except 
ParseException
 :

1707 
loc
 = 
preloc
 + 1

1709 if 
nextLoc
 > 
loc
 :

1710 
matches
 += 1

1711 yield 
tokens
 , 
preloc
 , 
nextLoc

1712 if 
overlap
 :

1713 
nextloc
 = 
preparseFn
 ( 
instring
 , 
loc
 )

1714 if 
nextloc
 > 
loc
 :

1715 
loc
 = 
nextLoc

1717 
loc
 += 1

1719 
loc
 = 
nextLoc

1721 
loc
 = 
preloc
 + 1

1722 except 
ParseBaseException
 as 
exc
 :

1723 if 
ParserElement
 . 
verbose_stacktrace
 :

1727 raise 
exc
 
	}

1729 def 
	$transformString
 ( 
self
 , 
instring
 ) :

1746 
out
 = [ ]

1747 
lastE
 = 0

1750 
self
 . 
keepTabs
 = True

1752 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 ) :

1753 
out
 . 
append
 ( 
instring
 [ 
lastE
 : 
s
 ] )

1754 if 
t
 :

1755 if 
isinstance
 ( 
t
 , 
ParseResults
 ) :

1756 
out
 += 
t
 . 
asList
 ( )

1757 elif 
isinstance
 ( 
t
 , 
list
 ) :

1758 
out
 += 
t

1760 
out
 . 
append
 ( 
t
 )

1761 
lastE
 = 
e

1762 
out
 . 
append
 ( 
instring
 [ 
lastE
 : ] )

1763 
out
 = [ 
o
 for 
o
 in 
out
 if 
o
 ]

1764 return "" . 
join
 ( 
map
 ( 
_ustr
 , 
_flatten
 ( 
out
 ) ) )

1765 except 
ParseBaseException
 as 
exc
 :

1766 if 
ParserElement
 . 
verbose_stacktrace
 :

1770 raise 
exc
 
	}

1772 def 
	$searchString
 ( 
self
 , 
instring
 , 
maxMatches
 = 
_MAX_INT
 ) :

1791 return 
ParseResults
 ( [ 
t
 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 , 
maxMatches
 ) ] )

1792 except 
ParseBaseException
 as 
exc
 :

1793 if 
ParserElement
 . 
verbose_stacktrace
 :

1797 raise 
exc
 
	}

1799 def 
	$split
 ( 
self
 , 
instring
 , 
maxsplit
 = 
_MAX_INT
 , 
includeSeparators
 = False ) :

1812 
splits
 = 0

1813 
last
 = 0

1814 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 , 
maxMatches
 = 
maxsplit
 ) :

1815 yield 
instring
 [ 
last
 : 
s
 ]

1816 if 
includeSeparators
 :

1817 yield 
t
 [ 0 ]

1818 
last
 = 
e

1819 yield 
instring
 [ 
last
 : ] 
	}

1821 def 
	$__add__
 ( 
self
 , 
other
 ) :

1833 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1834 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1835 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1836 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1837 
SyntaxWarning
 , 
stacklevel
 = 2 )

1839 return 
And
 ( [ 
self
 , 
other
 ] ) 
	}

1841 def 
	$__radd__
 ( 
self
 , 
other
 ) :

1845 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1846 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1847 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1848 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1849 
SyntaxWarning
 , 
stacklevel
 = 2 )

1851 return 
other
 + 
self
 
	}

1853 def 
	$__sub__
 ( 
self
 , 
other
 ) :

1857 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1858 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1859 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1860 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1861 
SyntaxWarning
 , 
stacklevel
 = 2 )

1863 return 
self
 + 
And
 . 
_ErrorStop
 ( ) + 
other
 
	}

1865 def 
	$__rsub__
 ( 
self
 , 
other
 ) :

1869 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1870 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1871 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1872 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1873 
SyntaxWarning
 , 
stacklevel
 = 2 )

1875 return 
other
 - 
self
 
	}

1877 def 
	$__mul__
 ( 
self
 , 
other
 ) :

1897 if 
isinstance
 ( 
other
 , 
int
 ) :

1898 
minElements
 , 
optElements
 = 
other
 , 0

1899 elif 
isinstance
 ( 
other
 , 
tuple
 ) :

1900 
other
 = ( 
other
 + ( None , None ) ) [ : 2 ]

1901 if 
other
 [ 0 ] is None :

1902 
other
 = ( 0 , 
other
 [ 1 ] )

1903 if 
isinstance
 ( 
other
 [ 0 ] , 
int
 ) and 
other
 [ 1 ] is None :

1904 if 
other
 [ 0 ] == 0 :

1905 return 
ZeroOrMore
 ( 
self
 )

1906 if 
other
 [ 0 ] == 1 :

1907 return 
OneOrMore
 ( 
self
 )

1909 return 
self
 * 
other
 [ 0 ] + 
ZeroOrMore
 ( 
self
 )

1910 elif 
isinstance
 ( 
other
 [ 0 ] , 
int
 ) and 
isinstance
 ( 
other
 [ 1 ] , 
int
 ) :

1911 
minElements
 , 
optElements
 = 
other

1912 
optElements
 -= 
minElements

1914 raise 
TypeError
 ( "cannot multiply 'ParserElement' and ('%s','%s') objects" , 
type
 ( 
other
 [ 0 ] ) , 
type
 ( 
other
 [ 1 ] ) )

1916 raise 
TypeError
 ( "cannot multiply 'ParserElement' and '%s' objects" , 
type
 ( 
other
 ) )

1918 if 
minElements
 < 0 :

1919 raise 
ValueError
 ( "cannot multiply ParserElement by negative value" )

1920 if 
optElements
 < 0 :

1921 raise 
ValueError
 ( "second tuple value must be greater or equal to first tuple value" )

1922 if 
minElements
 == 
optElements
 == 0 :

1923 raise 
ValueError
 ( "cannot multiply ParserElement by 0 or (0,0)" )

1925 if ( 
optElements
 ) :

1926 def 
makeOptionalList
 ( 
n
 ) :

1927 if 
n
 > 1 :

1928 return 
Optional
 ( 
self
 + 
makeOptionalList
 ( 
n
 - 1 ) )

1930 return 
Optional
 ( 
self
 )

1931 if 
minElements
 :

1932 if 
minElements
 == 1 :

1933 
ret
 = 
self
 + 
makeOptionalList
 ( 
optElements
 )

1935 
ret
 = 
And
 ( [ 
self
 ] * 
minElements
 ) + 
makeOptionalList
 ( 
optElements
 )

1937 
ret
 = 
makeOptionalList
 ( 
optElements
 )

1939 if 
minElements
 == 1 :

1940 
ret
 = 
self

1942 
ret
 = 
And
 ( [ 
self
 ] * 
minElements
 )

1943 return 
ret
 
	}

1945 def 
	$__rmul__
 ( 
self
 , 
other
 ) :

1946 return 
self
 . 
__mul__
 ( 
other
 ) 
	}

1948 def 
	$__or__
 ( 
self
 , 
other
 ) :

1952 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1953 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1954 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1955 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1956 
SyntaxWarning
 , 
stacklevel
 = 2 )

1958 return 
MatchFirst
 ( [ 
self
 , 
other
 ] ) 
	}

1960 def 
	$__ror__
 ( 
self
 , 
other
 ) :

1964 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1965 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1966 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1967 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1968 
SyntaxWarning
 , 
stacklevel
 = 2 )

1970 return 
other
 | 
self
 
	}

1972 def 
	$__xor__
 ( 
self
 , 
other
 ) :

1976 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1977 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1978 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1979 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1980 
SyntaxWarning
 , 
stacklevel
 = 2 )

1982 return 
Or
 ( [ 
self
 , 
other
 ] ) 
	}

1984 def 
	$__rxor__
 ( 
self
 , 
other
 ) :

1988 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1989 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1990 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1991 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1992 
SyntaxWarning
 , 
stacklevel
 = 2 )

1994 return 
other
 ^ 
self
 
	}

1996 def 
	$__and__
 ( 
self
 , 
other
 ) :

2000 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2001 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

2002 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2003 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

2004 
SyntaxWarning
 , 
stacklevel
 = 2 )

2006 return 
Each
 ( [ 
self
 , 
other
 ] ) 
	}

2008 def 
	$__rand__
 ( 
self
 , 
other
 ) :

2012 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2013 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

2014 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2015 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

2016 
SyntaxWarning
 , 
stacklevel
 = 2 )

2018 return 
other
 & 
self
 
	}

2020 def 
	$__invert__
 ( 
self
 ) :

2024 return 
NotAny
 ( 
self
 ) 
	}

2026 def 
	$__call__
 ( 
self
 , 
name
 = None ) :

2040 if 
name
 is not None :

2041 return 
self
 . 
setResultsName
 ( 
name
 )

2043 return 
self
 . 
copy
 ( ) 
	}

2045 def 
	$suppress
 ( 
self
 ) :

2050 return 
Suppress
 ( 
self
 ) 
	}

2052 def 
	$leaveWhitespace
 ( 
self
 ) :

2058 
self
 . 
skipWhitespace
 = False

2059 return 
self
 
	}

2061 def 
	$setWhitespaceChars
 ( 
self
 , 
chars
 ) :

2065 
self
 . 
skipWhitespace
 = True

2066 
self
 . 
whiteChars
 = 
chars

2067 
self
 . 
copyDefaultWhiteChars
 = False

2068 return 
self
 
	}

2070 def 
	$parseWithTabs
 ( 
self
 ) :

2076 
self
 . 
keepTabs
 = True

2077 return 
self
 
	}

2079 def 
	$ignore
 ( 
self
 , 
other
 ) :

2092 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2093 
other
 = 
Suppress
 ( 
other
 )

2095 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

2096 if 
other
 not in 
self
 . 
ignoreExprs
 :

2097 
self
 . 
ignoreExprs
 . 
append
 ( 
other
 )

2099 
self
 . 
ignoreExprs
 . 
append
 ( 
Suppress
 ( 
other
 . 
copy
 ( ) ) )

2100 return 
self
 
	}

2102 def 
	$setDebugActions
 ( 
self
 , 
startAction
 , 
successAction
 , 
exceptionAction
 ) :

2106 
self
 . 
debugActions
 = ( 
startAction
 or 
_defaultStartDebugAction
 ,

2107 
successAction
 or 
_defaultSuccessDebugAction
 ,

2108 
exceptionAction
 or 
_defaultExceptionDebugAction
 )

2109 
self
 . 
debug
 = True

2110 return 
self
 
	}

2112 def 
	$setDebug
 ( 
self
 , 
flag
 = True ) :

2147 if 
flag
 :

2148 
self
 . 
setDebugActions
 ( 
_defaultStartDebugAction
 , 
_defaultSuccessDebugAction
 , 
_defaultExceptionDebugAction
 )

2150 
self
 . 
debug
 = False

2151 return 
self
 
	}

2153 def 
	$__str__
 ( 
self
 ) :

2154 return 
self
 . 
name
 
	}

2156 def 
	$__repr__
 ( 
self
 ) :

2157 return 
_ustr
 ( 
self
 ) 
	}

2159 def 
	$streamline
 ( 
self
 ) :

2160 
self
 . 
streamlined
 = True

2161 
self
 . 
strRepr
 = None

2162 return 
self
 
	}

2164 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

2165 pass 
	}

2167 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

2171 
self
 . 
checkRecursion
 ( [ ] ) 
	}

2173 def 
	$parseFile
 ( 
self
 , 
file_or_filename
 , 
parseAll
 = False ) :

2180 
file_contents
 = 
file_or_filename
 . 
read
 ( )

2181 except 
AttributeError
 :

2182 with 
open
 ( 
file_or_filename
 , "r" ) as 
f
 :

2183 
file_contents
 = 
f
 . 
read
 ( )

2185 return 
self
 . 
parseString
 ( 
file_contents
 , 
parseAll
 )

2186 except 
ParseBaseException
 as 
exc
 :

2187 if 
ParserElement
 . 
verbose_stacktrace
 :

2191 raise 
exc
 
	}

2193 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2194 if 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2195 return 
self
 is 
other
 or 
vars
 ( 
self
 ) == 
vars
 ( 
other
 )

2196 elif 
isinstance
 ( 
other
 , 
basestring
 ) :

2197 return 
self
 . 
matches
 ( 
other
 )

2199 return 
super
 ( 
ParserElement
 , 
self
 ) == 
other
 
	}

2201 def 
	$__ne__
 ( 
self
 , 
other
 ) :

2202 return not ( 
self
 == 
other
 ) 
	}

2204 def 
	$__hash__
 ( 
self
 ) :

2205 return 
hash
 ( 
id
 ( 
self
 ) ) 
	}

2207 def 
	$__req__
 ( 
self
 , 
other
 ) :

2208 return 
self
 == 
other
 
	}

2210 def 
	$__rne__
 ( 
self
 , 
other
 ) :

2211 return not ( 
self
 == 
other
 ) 
	}

2213 def 
	$matches
 ( 
self
 , 
testString
 , 
parseAll
 = True ) :

2227 
self
 . 
parseString
 ( 
_ustr
 ( 
testString
 ) , 
parseAll
 = 
parseAll
 )

2229 except 
ParseBaseException
 :

2230 return False 
	}

2232 def 
	$runTests
 ( 
self
 , 
tests
 , 
parseAll
 = True , 
comment
 = '#' , 
fullDump
 = True , 
printResults
 = True , 
failureTests
 = False ) :

2319 if 
isinstance
 ( 
tests
 , 
basestring
 ) :

2320 
tests
 = 
list
 ( 
map
 ( 
str
 . 
strip
 , 
tests
 . 
rstrip
 ( ) . 
splitlines
 ( ) ) )

2321 if 
isinstance
 ( 
comment
 , 
basestring
 ) :

2322 
comment
 = 
Literal
 ( 
comment
 )

2323 
allResults
 = [ ]

2324 
comments
 = [ ]

2325 
success
 = True

2326 for 
t
 in 
tests
 :

2327 if 
comment
 is not None and 
comment
 . 
matches
 ( 
t
 , False ) or 
comments
 and not 
t
 :

2328 
comments
 . 
append
 ( 
t
 )

2330 if not 
t
 :

2332 
out
 = [ '\n' . 
join
 ( 
comments
 ) , 
t
 ]

2333 
comments
 = [ ]

2335 
t
 = 
t
 . 
replace
 ( r'\n' , '\n' )

2336 
result
 = 
self
 . 
parseString
 ( 
t
 , 
parseAll
 = 
parseAll
 )

2337 
out
 . 
append
 ( 
result
 . 
dump
 ( 
full
 = 
fullDump
 ) )

2338 
success
 = 
success
 and not 
failureTests

2339 except 
ParseBaseException
 as 
pe
 :

2340 
fatal
 = "(FATAL)" if 
isinstance
 ( 
pe
 , 
ParseFatalException
 ) else ""

2341 if '\n' in 
t
 :

2342 
out
 . 
append
 ( 
line
 ( 
pe
 . 
loc
 , 
t
 ) )

2343 
out
 . 
append
 ( ' ' * ( 
col
 ( 
pe
 . 
loc
 , 
t
 ) - 1 ) + '^' + 
fatal
 )

2345 
out
 . 
append
 ( ' ' * 
pe
 . 
loc
 + '^' + 
fatal
 )

2346 
out
 . 
append
 ( "FAIL: " + 
str
 ( 
pe
 ) )

2347 
success
 = 
success
 and 
failureTests

2348 
result
 = 
pe

2349 except 
Exception
 as 
exc
 :

2350 
out
 . 
append
 ( "FAIL-EXCEPTION: " + 
str
 ( 
exc
 ) )

2351 
success
 = 
success
 and 
failureTests

2352 
result
 = 
exc

2354 if 
printResults
 :

2355 if 
fullDump
 :

2356 
out
 . 
append
 ( '' )

2357 
print
 ( '\n' . 
join
 ( 
out
 ) )

2359 
allResults
 . 
append
 ( ( 
t
 , 
result
 ) )

2361 return 
success
 , 
allResults
 
	}

2364 class 
	cToken
 ( 
ParserElement
 ) :

2368 def 
	$__init__
 ( 
self
 ) :

2369 
super
 ( 
Token
 , 
self
 ) . 
__init__
 ( 
savelist
 = False ) 
	}

2372 class 
	cEmpty
 ( 
Token
 ) :

2376 def 
	$__init__
 ( 
self
 ) :

2377 
super
 ( 
Empty
 , 
self
 ) . 
__init__
 ( )

2378 
self
 . 
name
 = "Empty"

2379 
self
 . 
mayReturnEmpty
 = True

2380 
self
 . 
mayIndexError
 = False 
	}

2383 class 
	cNoMatch
 ( 
Token
 ) :

2387 def 
	$__init__
 ( 
self
 ) :

2388 
super
 ( 
NoMatch
 , 
self
 ) . 
__init__
 ( )

2389 
self
 . 
name
 = "NoMatch"

2390 
self
 . 
mayReturnEmpty
 = True

2391 
self
 . 
mayIndexError
 = False

2392 
self
 . 
errmsg
 = "Unmatchable token" 
	}

2394 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2395 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2398 class 
	cLiteral
 ( 
Token
 ) :

2412 def 
	$__init__
 ( 
self
 , 
matchString
 ) :

2413 
super
 ( 
Literal
 , 
self
 ) . 
__init__
 ( )

2414 
self
 . 
match
 = 
matchString

2415 
self
 . 
matchLen
 = 
len
 ( 
matchString
 )

2417 
self
 . 
firstMatchChar
 = 
matchString
 [ 0 ]

2418 except 
IndexError
 :

2419 
warnings
 . 
warn
 ( "null string passed to Literal; use Empty() instead" ,

2420 
SyntaxWarning
 , 
stacklevel
 = 2 )

2421 
self
 . 
__class__
 = 
Empty

2422 
self
 . 
name
 = '"%s"' % 
_ustr
 ( 
self
 . 
match
 )

2423 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2424 
self
 . 
mayReturnEmpty
 = False

2425 
self
 . 
mayIndexError
 = False 
	}

2431 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2432 if ( 
instring
 [ 
loc
 ] == 
self
 . 
firstMatchChar
 and

2433 ( 
self
 . 
matchLen
 == 1 or 
instring
 . 
startswith
 ( 
self
 . 
match
 , 
loc
 ) ) ) :

2434 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2435 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2436 
_L
 = 
Literal

2437 
ParserElement
 . 
_literalStringClass
 = 
Literal

2439 class 
	cKeyword
 ( 
Token
 ) :

2456 
DEFAULT_KEYWORD_CHARS
 = 
alphanums
 + "_$"

2458 def 
	$__init__
 ( 
self
 , 
matchString
 , 
identChars
 = None , 
caseless
 = False ) :

2459 
super
 ( 
Keyword
 , 
self
 ) . 
__init__
 ( )

2460 if 
identChars
 is None :

2461 
identChars
 = 
Keyword
 . 
DEFAULT_KEYWORD_CHARS

2462 
self
 . 
match
 = 
matchString

2463 
self
 . 
matchLen
 = 
len
 ( 
matchString
 )

2465 
self
 . 
firstMatchChar
 = 
matchString
 [ 0 ]

2466 except 
IndexError
 :

2467 
warnings
 . 
warn
 ( "null string passed to Keyword; use Empty() instead" ,

2468 
SyntaxWarning
 , 
stacklevel
 = 2 )

2469 
self
 . 
name
 = '"%s"' % 
self
 . 
match

2470 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2471 
self
 . 
mayReturnEmpty
 = False

2472 
self
 . 
mayIndexError
 = False

2473 
self
 . 
caseless
 = 
caseless

2474 if 
caseless
 :

2475 
self
 . 
caselessmatch
 = 
matchString
 . 
upper
 ( )

2476 
identChars
 = 
identChars
 . 
upper
 ( )

2477 
self
 . 
identChars
 = 
set
 ( 
identChars
 ) 
	}

2479 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2480 if 
self
 . 
caseless
 :

2481 if ( ( 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
caselessmatch
 ) and

2482 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) and

2483 ( 
loc
 == 0 or 
instring
 [ 
loc
 - 1 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) ) :

2484 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2486 if ( 
instring
 [ 
loc
 ] == 
self
 . 
firstMatchChar
 and

2487 ( 
self
 . 
matchLen
 == 1 or 
instring
 . 
startswith
 ( 
self
 . 
match
 , 
loc
 ) ) and

2488 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] not in 
self
 . 
identChars
 ) and

2489 ( 
loc
 == 0 or 
instring
 [ 
loc
 - 1 ] not in 
self
 . 
identChars
 ) ) :

2490 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2491 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2493 def 
	$copy
 ( 
self
 ) :

2494 
c
 = 
super
 ( 
Keyword
 , 
self
 ) . 
copy
 ( )

2495 
c
 . 
identChars
 = 
Keyword
 . 
DEFAULT_KEYWORD_CHARS

2496 return 
c
 
	}

2498 @ 
	`staticmethod

2499 def 
	$setDefaultKeywordChars
 ( 
chars
 ) :

2502 
Keyword
 . 
DEFAULT_KEYWORD_CHARS
 = 
chars
 
	}

2504 class 
	cCaselessLiteral
 ( 
Literal
 ) :

2515 def 
	$__init__
 ( 
self
 , 
matchString
 ) :

2516 
super
 ( 
CaselessLiteral
 , 
self
 ) . 
__init__
 ( 
matchString
 . 
upper
 ( ) )

2518 
self
 . 
returnString
 = 
matchString

2519 
self
 . 
name
 = "'%s'" % 
self
 . 
returnString

2520 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name
 
	}

2522 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2523 if 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
match
 :

2524 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
returnString

2525 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2527 class 
	cCaselessKeyword
 ( 
Keyword
 ) :

2536 def 
	$__init__
 ( 
self
 , 
matchString
 , 
identChars
 = None ) :

2537 
super
 ( 
CaselessKeyword
 , 
self
 ) . 
__init__
 ( 
matchString
 , 
identChars
 , 
caseless
 = True ) 
	}

2539 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2540 if ( ( 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
caselessmatch
 ) and

2541 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) ) :

2542 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2543 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2545 class 
	cCloseMatch
 ( 
Token
 ) :

2570 def 
	$__init__
 ( 
self
 , 
match_string
 , 
maxMismatches
 = 1 ) :

2571 
super
 ( 
CloseMatch
 , 
self
 ) . 
__init__
 ( )

2572 
self
 . 
name
 = 
match_string

2573 
self
 . 
match_string
 = 
match_string

2574 
self
 . 
maxMismatches
 = 
maxMismatches

2575 
self
 . 
errmsg
 = "Expected %r (with up to %d mismatches)" % ( 
self
 . 
match_string
 , 
self
 . 
maxMismatches
 )

2576 
self
 . 
mayIndexError
 = False

2577 
self
 . 
mayReturnEmpty
 = False 
	}

2579 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2580 
start
 = 
loc

2581 
instrlen
 = 
len
 ( 
instring
 )

2582 
maxloc
 = 
start
 + 
len
 ( 
self
 . 
match_string
 )

2584 if 
maxloc
 <= 
instrlen
 :

2585 
match_string
 = 
self
 . 
match_string

2586 
match_stringloc
 = 0

2587 
mismatches
 = [ ]

2588 
maxMismatches
 = 
self
 . 
maxMismatches

2590 for 
match_stringloc
 , 
s_m
 in 
enumerate
 ( 
zip
 ( 
instring
 [ 
loc
 : 
maxloc
 ] , 
self
 . 
match_string
 ) ) :

2591 
src
 , 
mat
 = 
s_m

2592 if 
src
 != 
mat
 :

2593 
mismatches
 . 
append
 ( 
match_stringloc
 )

2594 if 
len
 ( 
mismatches
 ) > 
maxMismatches
 :

2597 
loc
 = 
match_stringloc
 + 1

2598 
results
 = 
ParseResults
 ( [ 
instring
 [ 
start
 : 
loc
 ] ] )

2599 
results
 [ 'original' ] = 
self
 . 
match_string

2600 
results
 [ 'mismatches' ] = 
mismatches

2601 return 
loc
 , 
results

2603 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2606 class 
	cWord
 ( 
Token
 ) :

2653 def 
	$__init__
 ( 
self
 , 
initChars
 , 
bodyChars
 = None , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 , 
asKeyword
 = False , 
excludeChars
 = None ) :

2654 
super
 ( 
Word
 , 
self
 ) . 
__init__
 ( )

2655 if 
excludeChars
 :

2656 
initChars
 = '' . 
join
 ( 
c
 for 
c
 in 
initChars
 if 
c
 not in 
excludeChars
 )

2657 if 
bodyChars
 :

2658 
bodyChars
 = '' . 
join
 ( 
c
 for 
c
 in 
bodyChars
 if 
c
 not in 
excludeChars
 )

2659 
self
 . 
initCharsOrig
 = 
initChars

2660 
self
 . 
initChars
 = 
set
 ( 
initChars
 )

2661 if 
bodyChars
 :

2662 
self
 . 
bodyCharsOrig
 = 
bodyChars

2663 
self
 . 
bodyChars
 = 
set
 ( 
bodyChars
 )

2665 
self
 . 
bodyCharsOrig
 = 
initChars

2666 
self
 . 
bodyChars
 = 
set
 ( 
initChars
 )

2668 
self
 . 
maxSpecified
 = 
max
 > 0

2670 if 
min
 < 1 :

2671 raise 
ValueError
 ( "cannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permitted" )

2673 
self
 . 
minLen
 = 
min

2675 if 
max
 > 0 :

2676 
self
 . 
maxLen
 = 
max

2678 
self
 . 
maxLen
 = 
_MAX_INT

2680 if 
exact
 > 0 :

2681 
self
 . 
maxLen
 = 
exact

2682 
self
 . 
minLen
 = 
exact

2684 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2685 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2686 
self
 . 
mayIndexError
 = False

2687 
self
 . 
asKeyword
 = 
asKeyword

2689 if ' ' not in 
self
 . 
initCharsOrig
 + 
self
 . 
bodyCharsOrig
 and ( 
min
 == 1 and 
max
 == 0 and 
exact
 == 0 ) :

2690 if 
self
 . 
bodyCharsOrig
 == 
self
 . 
initCharsOrig
 :

2691 
self
 . 
reString
 = "[%s]+" % 
_escapeRegexRangeChars
 ( 
self
 . 
initCharsOrig
 )

2692 elif 
len
 ( 
self
 . 
initCharsOrig
 ) == 1 :

2693 
self
 . 
reString
 = "%s[%s]*" %

2694 ( 
re
 . 
escape
 ( 
self
 . 
initCharsOrig
 ) ,

2695 
_escapeRegexRangeChars
 ( 
self
 . 
bodyCharsOrig
 ) , )

2697 
self
 . 
reString
 = "[%s][%s]*" %

2698 ( 
_escapeRegexRangeChars
 ( 
self
 . 
initCharsOrig
 ) ,

2699 
_escapeRegexRangeChars
 ( 
self
 . 
bodyCharsOrig
 ) , )

2700 if 
self
 . 
asKeyword
 :

2701 
self
 . 
reString
 = r"\b" + 
self
 . 
reString
 + r"\b"

2703 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
reString
 )

2704 except 
Exception
 :

2705 
self
 . 
re
 = None 
	}

2707 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2708 if 
self
 . 
re
 :

2709 
result
 = 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 )

2710 if not 
result
 :

2711 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2713 
loc
 = 
result
 . 
end
 ( )

2714 return 
loc
 , 
result
 . 
group
 ( )

2716 if not ( 
instring
 [ 
loc
 ] in 
self
 . 
initChars
 ) :

2717 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2719 
start
 = 
loc

2720 
loc
 += 1

2721 
instrlen
 = 
len
 ( 
instring
 )

2722 
bodychars
 = 
self
 . 
bodyChars

2723 
maxloc
 = 
start
 + 
self
 . 
maxLen

2724 
maxloc
 = 
min
 ( 
maxloc
 , 
instrlen
 )

2725 while 
loc
 < 
maxloc
 and 
instring
 [ 
loc
 ] in 
bodychars
 :

2726 
loc
 += 1

2728 
throwException
 = False

2729 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

2730 
throwException
 = True

2731 if 
self
 . 
maxSpecified
 and 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
bodychars
 :

2732 
throwException
 = True

2733 if 
self
 . 
asKeyword
 :

2734 if ( 
start
 > 0 and 
instring
 [ 
start
 - 1 ] in 
bodychars
 ) or ( 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
bodychars
 ) :

2735 
throwException
 = True

2737 if 
throwException
 :

2738 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2740 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

2742 def 
	$__str__
 ( 
self
 ) :

2744 return 
super
 ( 
Word
 , 
self
 ) . 
__str__
 ( )

2745 except 
Exception
 :

2749 if 
self
 . 
strRepr
 is None :

2751 def 
charsAsStr
 ( 
s
 ) :

2752 if 
len
 ( 
s
 ) > 4 :

2753 return 
s
 [ : 4 ] + "..."

2755 return 
s

2757 if ( 
self
 . 
initCharsOrig
 != 
self
 . 
bodyCharsOrig
 ) :

2758 
self
 . 
strRepr
 = "W:(%s,%s)" % ( 
charsAsStr
 ( 
self
 . 
initCharsOrig
 ) , 
charsAsStr
 ( 
self
 . 
bodyCharsOrig
 ) )

2760 
self
 . 
strRepr
 = "W:(%s)" % 
charsAsStr
 ( 
self
 . 
initCharsOrig
 )

2762 return 
self
 . 
strRepr
 
	}

2765 class 
	cRegex
 ( 
Token
 ) :

2778 
compiledREtype
 = 
type
 ( 
re
 . 
compile
 ( "[A-Z]" ) )

2779 def 
	$__init__
 ( 
self
 , 
pattern
 , 
flags
 = 0 ) :

2781 
super
 ( 
Regex
 , 
self
 ) . 
__init__
 ( )

2783 if 
isinstance
 ( 
pattern
 , 
basestring
 ) :

2784 if not 
pattern
 :

2785 
warnings
 . 
warn
 ( "null string passed to Regex; use Empty() instead" ,

2786 
SyntaxWarning
 , 
stacklevel
 = 2 )

2788 
self
 . 
pattern
 = 
pattern

2789 
self
 . 
flags
 = 
flags

2792 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
pattern
 , 
self
 . 
flags
 )

2793 
self
 . 
reString
 = 
self
 . 
pattern

2794 except 
sre_constants
 . 
error
 :

2795 
warnings
 . 
warn
 ( "invalid pattern (%s) passed to Regex" % 
pattern
 ,

2796 
SyntaxWarning
 , 
stacklevel
 = 2 )

2799 elif 
isinstance
 ( 
pattern
 , 
Regex
 . 
compiledREtype
 ) :

2800 
self
 . 
re
 = 
pattern

2801 
self
 . 
pattern
 =

2802 
self
 . 
reString
 = 
str
 ( 
pattern
 )

2803 
self
 . 
flags
 = 
flags

2806 raise 
ValueError
 ( "Regex may only be constructed with a string or a compiled RE object" )

2808 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2809 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2810 
self
 . 
mayIndexError
 = False

2811 
self
 . 
mayReturnEmpty
 = True 
	}

2813 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2814 
result
 = 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 )

2815 if not 
result
 :

2816 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2818 
loc
 = 
result
 . 
end
 ( )

2819 
d
 = 
result
 . 
groupdict
 ( )

2820 
ret
 = 
ParseResults
 ( 
result
 . 
group
 ( ) )

2821 if 
d
 :

2822 for 
k
 in 
d
 :

2823 
ret
 [ 
k
 ] = 
d
 [ 
k
 ]

2824 return 
loc
 , 
ret
 
	}

2826 def 
	$__str__
 ( 
self
 ) :

2828 return 
super
 ( 
Regex
 , 
self
 ) . 
__str__
 ( )

2829 except 
Exception
 :

2832 if 
self
 . 
strRepr
 is None :

2833 
self
 . 
strRepr
 = "Re:(%s)" % 
repr
 ( 
self
 . 
pattern
 )

2835 return 
self
 . 
strRepr
 
	}

2838 class 
	cQuotedString
 ( 
Token
 ) :

2863 def 
	$__init__
 ( 
self
 , 
quoteChar
 , 
escChar
 = None , 
escQuote
 = None , 
multiline
 = False , 
unquoteResults
 = True , 
endQuoteChar
 = None , 
convertWhitespaceEscapes
 = True ) :

2864 
super
 ( 
QuotedString
 , 
self
 ) . 
__init__
 ( )

2867 
quoteChar
 = 
quoteChar
 . 
strip
 ( )

2868 if not 
quoteChar
 :

2869 
warnings
 . 
warn
 ( "quoteChar cannot be the empty string" , 
SyntaxWarning
 , 
stacklevel
 = 2 )

2870 raise 
SyntaxError
 ( )

2872 if 
endQuoteChar
 is None :

2873 
endQuoteChar
 = 
quoteChar

2875 
endQuoteChar
 = 
endQuoteChar
 . 
strip
 ( )

2876 if not 
endQuoteChar
 :

2877 
warnings
 . 
warn
 ( "endQuoteChar cannot be the empty string" , 
SyntaxWarning
 , 
stacklevel
 = 2 )

2878 raise 
SyntaxError
 ( )

2880 
self
 . 
quoteChar
 = 
quoteChar

2881 
self
 . 
quoteCharLen
 = 
len
 ( 
quoteChar
 )

2882 
self
 . 
firstQuoteChar
 = 
quoteChar
 [ 0 ]

2883 
self
 . 
endQuoteChar
 = 
endQuoteChar

2884 
self
 . 
endQuoteCharLen
 = 
len
 ( 
endQuoteChar
 )

2885 
self
 . 
escChar
 = 
escChar

2886 
self
 . 
escQuote
 = 
escQuote

2887 
self
 . 
unquoteResults
 = 
unquoteResults

2888 
self
 . 
convertWhitespaceEscapes
 = 
convertWhitespaceEscapes

2890 if 
multiline
 :

2891 
self
 . 
flags
 = 
re
 . 
MULTILINE
 | 
re
 . 
DOTALL

2892 
self
 . 
pattern
 = r'%s(?:[^%s%s]' %

2893 ( 
re
 . 
escape
 ( 
self
 . 
quoteChar
 ) ,

2894 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 0 ] ) ,

2895 ( 
escChar
 is not None and 
_escapeRegexRangeChars
 ( 
escChar
 ) or '' ) )

2897 
self
 . 
flags
 = 0

2898 
self
 . 
pattern
 = r'%s(?:[^%s\n\r%s]' %

2899 ( 
re
 . 
escape
 ( 
self
 . 
quoteChar
 ) ,

2900 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 0 ] ) ,

2901 ( 
escChar
 is not None and 
_escapeRegexRangeChars
 ( 
escChar
 ) or '' ) )

2902 if 
len
 ( 
self
 . 
endQuoteChar
 ) > 1 :

2903 
self
 . 
pattern
 += ( '|(?:'

2904 + ')|(?:' . 
join
 ( "%s[^%s]" % ( 
re
 . 
escape
 ( 
self
 . 
endQuoteChar
 [ : 
i
 ] ) ,

2905 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 
i
 ] ) )

2906 for 
i
 in 
range
 ( 
len
 ( 
self
 . 
endQuoteChar
 ) - 1 , 0 , - 1 ) ) + ')'

2908 if 
escQuote
 :

2909 
self
 . 
pattern
 += ( r'|(?:%s)' % 
re
 . 
escape
 ( 
escQuote
 ) )

2910 if 
escChar
 :

2911 
self
 . 
pattern
 += ( r'|(?:%s.)' % 
re
 . 
escape
 ( 
escChar
 ) )

2912 
self
 . 
escCharReplacePattern
 = 
re
 . 
escape
 ( 
self
 . 
escChar
 ) + "(.)"

2913 
self
 . 
pattern
 += ( r')*%s' % 
re
 . 
escape
 ( 
self
 . 
endQuoteChar
 ) )

2916 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
pattern
 , 
self
 . 
flags
 )

2917 
self
 . 
reString
 = 
self
 . 
pattern

2918 except 
sre_constants
 . 
error
 :

2919 
warnings
 . 
warn
 ( "invalid pattern (%s) passed to Regex" % 
self
 . 
pattern
 ,

2920 
SyntaxWarning
 , 
stacklevel
 = 2 )

2923 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2924 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2925 
self
 . 
mayIndexError
 = False

2926 
self
 . 
mayReturnEmpty
 = True 
	}

2928 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2929 
result
 = 
instring
 [ 
loc
 ] == 
self
 . 
firstQuoteChar
 and 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 ) or None

2930 if not 
result
 :

2931 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2933 
loc
 = 
result
 . 
end
 ( )

2934 
ret
 = 
result
 . 
group
 ( )

2936 if 
self
 . 
unquoteResults
 :

2939 
ret
 = 
ret
 [ 
self
 . 
quoteCharLen
 : - 
self
 . 
endQuoteCharLen
 ]

2941 if 
isinstance
 ( 
ret
 , 
basestring
 ) :

2943 if '\\' in 
ret
 and 
self
 . 
convertWhitespaceEscapes
 :

2944 
ws_map
 = { r'\t'

2950 for 
wslit
 , 
wschar
 in 
ws_map
 . 
items
 ( ) :

2951 
ret
 = 
ret
 . 
replace
 ( 
wslit
 , 
wschar
 )

2954 if 
self
 . 
escChar
 :

2955 
ret
 = 
re
 . 
sub
 ( 
self
 . 
escCharReplacePattern
 , r"\g<1>" , 
ret
 )

2958 if 
self
 . 
escQuote
 :

2959 
ret
 = 
ret
 . 
replace
 ( 
self
 . 
escQuote
 , 
self
 . 
endQuoteChar
 )

2961 return 
loc
 , 
ret
 
	}

2963 def 
	$__str__
 ( 
self
 ) :

2965 return 
super
 ( 
QuotedString
 , 
self
 ) . 
__str__
 ( )

2966 except 
Exception
 :

2969 if 
self
 . 
strRepr
 is None :

2970 
self
 . 
strRepr
 = "quoted string, starting with %s ending with %s" % ( 
self
 . 
quoteChar
 , 
self
 . 
endQuoteChar
 )

2972 return 
self
 . 
strRepr
 
	}

2975 class 
	cCharsNotIn
 ( 
Token
 ) :

2991 def 
	$__init__
 ( 
self
 , 
notChars
 , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 ) :

2992 
super
 ( 
CharsNotIn
 , 
self
 ) . 
__init__
 ( )

2993 
self
 . 
skipWhitespace
 = False

2994 
self
 . 
notChars
 = 
notChars

2996 if 
min
 < 1 :

2997 raise 
ValueError
 ( "cannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permitted" )

2999 
self
 . 
minLen
 = 
min

3001 if 
max
 > 0 :

3002 
self
 . 
maxLen
 = 
max

3004 
self
 . 
maxLen
 = 
_MAX_INT

3006 if 
exact
 > 0 :

3007 
self
 . 
maxLen
 = 
exact

3008 
self
 . 
minLen
 = 
exact

3010 
self
 . 
name
 = 
_ustr
 ( 
self
 )

3011 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

3012 
self
 . 
mayReturnEmpty
 = ( 
self
 . 
minLen
 == 0 )

3013 
self
 . 
mayIndexError
 = False 
	}

3015 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3016 if 
instring
 [ 
loc
 ] in 
self
 . 
notChars
 :

3017 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3019 
start
 = 
loc

3020 
loc
 += 1

3021 
notchars
 = 
self
 . 
notChars

3022 
maxlen
 = 
min
 ( 
start
 + 
self
 . 
maxLen
 , 
len
 ( 
instring
 ) )

3023 while 
loc
 < 
maxlen
 and

3024 ( 
instring
 [ 
loc
 ] not in 
notchars
 ) :

3025 
loc
 += 1

3027 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

3028 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3030 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

3032 def 
	$__str__
 ( 
self
 ) :

3034 return 
super
 ( 
CharsNotIn
 , 
self
 ) . 
__str__
 ( )

3035 except 
Exception
 :

3038 if 
self
 . 
strRepr
 is None :

3039 if 
len
 ( 
self
 . 
notChars
 ) > 4 :

3040 
self
 . 
strRepr
 = "!W:(%s...)" % 
self
 . 
notChars
 [ : 4 ]

3042 
self
 . 
strRepr
 = "!W:(%s)" % 
self
 . 
notChars

3044 return 
self
 . 
strRepr
 
	}

3046 class 
	cWhite
 ( 
Token
 ) :

3054 
whiteStrs
 = { " "

3061 def 
	$__init__
 ( 
self
 , 
ws
 = " \t\r\n" , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 ) :

3062 
super
 ( 
White
 , 
self
 ) . 
__init__
 ( )

3063 
self
 . 
matchWhite
 = 
ws

3064 
self
 . 
setWhitespaceChars
 ( "" . 
join
 ( 
c
 for 
c
 in 
self
 . 
whiteChars
 if 
c
 not in 
self
 . 
matchWhite
 ) )

3066 
self
 . 
name
 = ( "" . 
join
 ( 
White
 . 
whiteStrs
 [ 
c
 ] for 
c
 in 
self
 . 
matchWhite
 ) )

3067 
self
 . 
mayReturnEmpty
 = True

3068 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

3070 
self
 . 
minLen
 = 
min

3072 if 
max
 > 0 :

3073 
self
 . 
maxLen
 = 
max

3075 
self
 . 
maxLen
 = 
_MAX_INT

3077 if 
exact
 > 0 :

3078 
self
 . 
maxLen
 = 
exact

3079 
self
 . 
minLen
 = 
exact
 
	}

3081 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3082 if not ( 
instring
 [ 
loc
 ] in 
self
 . 
matchWhite
 ) :

3083 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3084 
start
 = 
loc

3085 
loc
 += 1

3086 
maxloc
 = 
start
 + 
self
 . 
maxLen

3087 
maxloc
 = 
min
 ( 
maxloc
 , 
len
 ( 
instring
 ) )

3088 while 
loc
 < 
maxloc
 and 
instring
 [ 
loc
 ] in 
self
 . 
matchWhite
 :

3089 
loc
 += 1

3091 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

3092 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3094 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

3097 class 
	c_PositionToken
 ( 
Token
 ) :

3098 def 
	$__init__
 ( 
self
 ) :

3099 
super
 ( 
_PositionToken
 , 
self
 ) . 
__init__
 ( )

3100 
self
 . 
name
 = 
self
 . 
__class__
 . 
__name__

3101 
self
 . 
mayReturnEmpty
 = True

3102 
self
 . 
mayIndexError
 = False 
	}

3104 class 
	cGoToColumn
 ( 
_PositionToken
 ) :

3108 def 
	$__init__
 ( 
self
 , 
colno
 ) :

3109 
super
 ( 
GoToColumn
 , 
self
 ) . 
__init__
 ( )

3110 
self
 . 
col
 = 
colno
 
	}

3112 def 
	$preParse
 ( 
self
 , 
instring
 , 
loc
 ) :

3113 if 
col
 ( 
loc
 , 
instring
 ) != 
self
 . 
col
 :

3114 
instrlen
 = 
len
 ( 
instring
 )

3115 if 
self
 . 
ignoreExprs
 :

3116 
loc
 = 
self
 . 
_skipIgnorables
 ( 
instring
 , 
loc
 )

3117 while 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] . 
isspace
 ( ) and 
col
 ( 
loc
 , 
instring
 ) != 
self
 . 
col
 :

3118 
loc
 += 1

3119 return 
loc
 
	}

3121 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3122 
thiscol
 = 
col
 ( 
loc
 , 
instring
 )

3123 if 
thiscol
 > 
self
 . 
col
 :

3124 raise 
ParseException
 ( 
instring
 , 
loc
 , "Text not in expected column" , 
self
 )

3125 
newloc
 = 
loc
 + 
self
 . 
col
 - 
thiscol

3126 
ret
 = 
instring
 [ 
loc
 : 
newloc
 ]

3127 return 
newloc
 , 
ret
 
	}

3130 class 
	cLineStart
 ( 
_PositionToken
 ) :

3151 def 
	$__init__
 ( 
self
 ) :

3152 
super
 ( 
LineStart
 , 
self
 ) . 
__init__
 ( )

3153 
self
 . 
errmsg
 = "Expected start of line" 
	}

3155 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3156 if 
col
 ( 
loc
 , 
instring
 ) == 1 :

3157 return 
loc
 , [ ]

3158 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3160 class 
	cLineEnd
 ( 
_PositionToken
 ) :

3164 def 
	$__init__
 ( 
self
 ) :

3165 
super
 ( 
LineEnd
 , 
self
 ) . 
__init__
 ( )

3166 
self
 . 
setWhitespaceChars
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 . 
replace
 ( "\n" , "" ) )

3167 
self
 . 
errmsg
 = "Expected end of line" 
	}

3169 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3170 if 
loc
 < 
len
 ( 
instring
 ) :

3171 if 
instring
 [ 
loc
 ] == "\n" :

3172 return 
loc
 + 1 , "\n"

3174 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3175 elif 
loc
 == 
len
 ( 
instring
 ) :

3176 return 
loc
 + 1 , [ ]

3178 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3180 class 
	cStringStart
 ( 
_PositionToken
 ) :

3184 def 
	$__init__
 ( 
self
 ) :

3185 
super
 ( 
StringStart
 , 
self
 ) . 
__init__
 ( )

3186 
self
 . 
errmsg
 = "Expected start of text" 
	}

3188 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3189 if 
loc
 != 0 :

3191 if 
loc
 != 
self
 . 
preParse
 ( 
instring
 , 0 ) :

3192 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3193 return 
loc
 , [ ] 
	}

3195 class 
	cStringEnd
 ( 
_PositionToken
 ) :

3199 def 
	$__init__
 ( 
self
 ) :

3200 
super
 ( 
StringEnd
 , 
self
 ) . 
__init__
 ( )

3201 
self
 . 
errmsg
 = "Expected end of text" 
	}

3203 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3204 if 
loc
 < 
len
 ( 
instring
 ) :

3205 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3206 elif 
loc
 == 
len
 ( 
instring
 ) :

3207 return 
loc
 + 1 , [ ]

3208 elif 
loc
 > 
len
 ( 
instring
 ) :

3209 return 
loc
 , [ ]

3211 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3213 class 
	cWordStart
 ( 
_PositionToken
 ) :

3221 def 
	$__init__
 ( 
self
 , 
wordChars
 = 
printables
 ) :

3222 
super
 ( 
WordStart
 , 
self
 ) . 
__init__
 ( )

3223 
self
 . 
wordChars
 = 
set
 ( 
wordChars
 )

3224 
self
 . 
errmsg
 = "Not at the start of a word" 
	}

3226 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3227 if 
loc
 != 0 :

3228 if ( 
instring
 [ 
loc
 - 1 ] in 
self
 . 
wordChars
 or

3229 
instring
 [ 
loc
 ] not in 
self
 . 
wordChars
 ) :

3230 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3231 return 
loc
 , [ ] 
	}

3233 class 
	cWordEnd
 ( 
_PositionToken
 ) :

3241 def 
	$__init__
 ( 
self
 , 
wordChars
 = 
printables
 ) :

3242 
super
 ( 
WordEnd
 , 
self
 ) . 
__init__
 ( )

3243 
self
 . 
wordChars
 = 
set
 ( 
wordChars
 )

3244 
self
 . 
skipWhitespace
 = False

3245 
self
 . 
errmsg
 = "Not at the end of a word" 
	}

3247 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3248 
instrlen
 = 
len
 ( 
instring
 )

3249 if 
instrlen
 > 0 and 
loc
 < 
instrlen
 :

3250 if ( 
instring
 [ 
loc
 ] in 
self
 . 
wordChars
 or

3251 
instring
 [ 
loc
 - 1 ] not in 
self
 . 
wordChars
 ) :

3252 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3253 return 
loc
 , [ ] 
	}

3256 class 
	cParseExpression
 ( 
ParserElement
 ) :

3260 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3261 
super
 ( 
ParseExpression
 , 
self
 ) . 
__init__
 ( 
savelist
 )

3262 if 
isinstance
 ( 
exprs
 , 
_generatorType
 ) :

3263 
exprs
 = 
list
 ( 
exprs
 )

3265 if 
isinstance
 ( 
exprs
 , 
basestring
 ) :

3266 
self
 . 
exprs
 = [ 
ParserElement
 . 
_literalStringClass
 ( 
exprs
 ) ]

3267 elif 
isinstance
 ( 
exprs
 , 
Iterable
 ) :

3268 
exprs
 = 
list
 ( 
exprs
 )

3270 if 
all
 ( 
isinstance
 ( 
expr
 , 
basestring
 ) for 
expr
 in 
exprs
 ) :

3271 
exprs
 = 
map
 ( 
ParserElement
 . 
_literalStringClass
 , 
exprs
 )

3272 
self
 . 
exprs
 = 
list
 ( 
exprs
 )

3275 
self
 . 
exprs
 = 
list
 ( 
exprs
 )

3276 except 
TypeError
 :

3277 
self
 . 
exprs
 = [ 
exprs
 ]

3278 
self
 . 
callPreparse
 = False 
	}

3280 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

3281 return 
self
 . 
exprs
 [ 
i
 ] 
	}

3283 def 
	$append
 ( 
self
 , 
other
 ) :

3284 
self
 . 
exprs
 . 
append
 ( 
other
 )

3285 
self
 . 
strRepr
 = None

3286 return 
self
 
	}

3288 def 
	$leaveWhitespace
 ( 
self
 ) :

3291 
self
 . 
skipWhitespace
 = False

3292 
self
 . 
exprs
 = [ 
e
 . 
copy
 ( ) for 
e
 in 
self
 . 
exprs
 ]

3293 for 
e
 in 
self
 . 
exprs
 :

3294 
e
 . 
leaveWhitespace
 ( )

3295 return 
self
 
	}

3297 def 
	$ignore
 ( 
self
 , 
other
 ) :

3298 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

3299 if 
other
 not in 
self
 . 
ignoreExprs
 :

3300 
super
 ( 
ParseExpression
 , 
self
 ) . 
ignore
 ( 
other
 )

3301 for 
e
 in 
self
 . 
exprs
 :

3302 
e
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3304 
super
 ( 
ParseExpression
 , 
self
 ) . 
ignore
 ( 
other
 )

3305 for 
e
 in 
self
 . 
exprs
 :

3306 
e
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3307 return 
self
 
	}

3309 def 
	$__str__
 ( 
self
 ) :

3311 return 
super
 ( 
ParseExpression
 , 
self
 ) . 
__str__
 ( )

3312 except 
Exception
 :

3315 if 
self
 . 
strRepr
 is None :

3316 
self
 . 
strRepr
 = "%s:(%s)" % ( 
self
 . 
__class__
 . 
__name__
 , 
_ustr
 ( 
self
 . 
exprs
 ) )

3317 return 
self
 . 
strRepr
 
	}

3319 def 
	$streamline
 ( 
self
 ) :

3320 
super
 ( 
ParseExpression
 , 
self
 ) . 
streamline
 ( )

3322 for 
e
 in 
self
 . 
exprs
 :

3323 
e
 . 
streamline
 ( )

3328 if ( 
len
 ( 
self
 . 
exprs
 ) == 2 ) :

3329 
other
 = 
self
 . 
exprs
 [ 0 ]

3330 if ( 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) and

3331 not ( 
other
 . 
parseAction
 ) and

3332 
other
 . 
resultsName
 is None and

3333 not 
other
 . 
debug
 ) :

3334 
self
 . 
exprs
 = 
other
 . 
exprs
 [ : ] + [ 
self
 . 
exprs
 [ 1 ] ]

3335 
self
 . 
strRepr
 = None

3336 
self
 . 
mayReturnEmpty
 |= 
other
 . 
mayReturnEmpty

3337 
self
 . 
mayIndexError
 |= 
other
 . 
mayIndexError

3339 
other
 = 
self
 . 
exprs
 [ - 1 ]

3340 if ( 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) and

3341 not ( 
other
 . 
parseAction
 ) and

3342 
other
 . 
resultsName
 is None and

3343 not 
other
 . 
debug
 ) :

3344 
self
 . 
exprs
 = 
self
 . 
exprs
 [ : - 1 ] + 
other
 . 
exprs
 [ : ]

3345 
self
 . 
strRepr
 = None

3346 
self
 . 
mayReturnEmpty
 |= 
other
 . 
mayReturnEmpty

3347 
self
 . 
mayIndexError
 |= 
other
 . 
mayIndexError

3349 
self
 . 
errmsg
 = "Expected " + 
_ustr
 ( 
self
 )

3351 return 
self
 
	}

3353 def 
	$setResultsName
 ( 
self
 , 
name
 , 
listAllMatches
 = False ) :

3354 
ret
 = 
super
 ( 
ParseExpression
 , 
self
 ) . 
setResultsName
 ( 
name
 , 
listAllMatches
 )

3355 return 
ret
 
	}

3357 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

3358 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

3359 for 
e
 in 
self
 . 
exprs
 :

3360 
e
 . 
validate
 ( 
tmp
 )

3361 
self
 . 
checkRecursion
 ( [ ] ) 
	}

3363 def 
	$copy
 ( 
self
 ) :

3364 
ret
 = 
super
 ( 
ParseExpression
 , 
self
 ) . 
copy
 ( )

3365 
ret
 . 
exprs
 = [ 
e
 . 
copy
 ( ) for 
e
 in 
self
 . 
exprs
 ]

3366 return 
ret
 
	}

3368 class 
	cAnd
 ( 
ParseExpression
 ) :

3384 class 
	c_ErrorStop
 ( 
Empty
 ) :

3385 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

3386 
super
 ( 
And
 . 
_ErrorStop
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

3387 
self
 . 
name
 = '-'

3388 
self
 . 
leaveWhitespace
 ( ) 
	}

3390 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = True ) :

3391 
super
 ( 
And
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3392 
self
 . 
mayReturnEmpty
 = 
all
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3393 
self
 . 
setWhitespaceChars
 ( 
self
 . 
exprs
 [ 0 ] . 
whiteChars
 )

3394 
self
 . 
skipWhitespace
 = 
self
 . 
exprs
 [ 0 ] . 
skipWhitespace

3395 
self
 . 
callPreparse
 = True 
	}

3397 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3400 
loc
 , 
resultlist
 = 
self
 . 
exprs
 [ 0 ] . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3401 
errorStop
 = False

3402 for 
e
 in 
self
 . 
exprs
 [ 1 : ] :

3403 if 
isinstance
 ( 
e
 , 
And
 . 
_ErrorStop
 ) :

3404 
errorStop
 = True

3406 if 
errorStop
 :

3408 
loc
 , 
exprtokens
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3409 except 
ParseSyntaxException
 :

3411 except 
ParseBaseException
 as 
pe
 :

3412 
pe
 . 
__traceback__
 = None

3413 raise 
ParseSyntaxException
 . 
_from_exception
 ( 
pe
 )

3414 except 
IndexError
 :

3415 raise 
ParseSyntaxException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

3417 
loc
 , 
exprtokens
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3418 if 
exprtokens
 or 
exprtokens
 . 
haskeys
 ( ) :

3419 
resultlist
 += 
exprtokens

3420 return 
loc
 , 
resultlist
 
	}

3422 def 
	$__iadd__
 ( 
self
 , 
other
 ) :

3423 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3424 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3425 return 
self
 . 
append
 ( 
other
 ) 
	}

3427 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3428 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3429 for 
e
 in 
self
 . 
exprs
 :

3430 
e
 . 
checkRecursion
 ( 
subRecCheckList
 )

3431 if not 
e
 . 
mayReturnEmpty
 :

3432 break 
	}

3434 def 
	$__str__
 ( 
self
 ) :

3435 if 
hasattr
 ( 
self
 , "name" ) :

3436 return 
self
 . 
name

3438 if 
self
 . 
strRepr
 is None :

3439 
self
 . 
strRepr
 = "{" + " " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3441 return 
self
 . 
strRepr
 
	}

3444 class 
	cOr
 ( 
ParseExpression
 ) :

3458 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3459 
super
 ( 
Or
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3460 if 
self
 . 
exprs
 :

3461 
self
 . 
mayReturnEmpty
 = 
any
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3463 
self
 . 
mayReturnEmpty
 = True 
	}

3465 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3466 
maxExcLoc
 = - 1

3467 
maxException
 = None

3468 
matches
 = [ ]

3469 for 
e
 in 
self
 . 
exprs
 :

3471 
loc2
 = 
e
 . 
tryParse
 ( 
instring
 , 
loc
 )

3472 except 
ParseException
 as 
err
 :

3473 
err
 . 
__traceback__
 = None

3474 if 
err
 . 
loc
 > 
maxExcLoc
 :

3475 
maxException
 = 
err

3476 
maxExcLoc
 = 
err
 . 
loc

3477 except 
IndexError
 :

3478 if 
len
 ( 
instring
 ) > 
maxExcLoc
 :

3479 
maxException
 = 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
e
 . 
errmsg
 , 
self
 )

3480 
maxExcLoc
 = 
len
 ( 
instring
 )

3483 
matches
 . 
append
 ( ( 
loc2
 , 
e
 ) )

3485 if 
matches
 :

3486 
matches
 . 
sort
 ( 
key
 = lambda 
x
 : - 
x
 [ 0 ] )

3487 for 
_
 , 
e
 in 
matches
 :

3489 return 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3490 except 
ParseException
 as 
err
 :

3491 
err
 . 
__traceback__
 = None

3492 if 
err
 . 
loc
 > 
maxExcLoc
 :

3493 
maxException
 = 
err

3494 
maxExcLoc
 = 
err
 . 
loc

3496 if 
maxException
 is not None :

3497 
maxException
 . 
msg
 = 
self
 . 
errmsg

3498 raise 
maxException

3500 raise 
ParseException
 ( 
instring
 , 
loc
 , "no defined alternatives to match" , 
self
 ) 
	}

3503 def 
	$__ixor__
 ( 
self
 , 
other
 ) :

3504 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3505 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3506 return 
self
 . 
append
 ( 
other
 ) 
	}

3508 def 
	$__str__
 ( 
self
 ) :

3509 if 
hasattr
 ( 
self
 , "name" ) :

3510 return 
self
 . 
name

3512 if 
self
 . 
strRepr
 is None :

3513 
self
 . 
strRepr
 = "{" + " ^ " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3515 return 
self
 . 
strRepr
 
	}

3517 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3518 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3519 for 
e
 in 
self
 . 
exprs
 :

3520 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3523 class 
	cMatchFirst
 ( 
ParseExpression
 ) :

3540 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3541 
super
 ( 
MatchFirst
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3542 if 
self
 . 
exprs
 :

3543 
self
 . 
mayReturnEmpty
 = 
any
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3545 
self
 . 
mayReturnEmpty
 = True 
	}

3547 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3548 
maxExcLoc
 = - 1

3549 
maxException
 = None

3550 for 
e
 in 
self
 . 
exprs
 :

3552 
ret
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3553 return 
ret

3554 except 
ParseException
 as 
err
 :

3555 if 
err
 . 
loc
 > 
maxExcLoc
 :

3556 
maxException
 = 
err

3557 
maxExcLoc
 = 
err
 . 
loc

3558 except 
IndexError
 :

3559 if 
len
 ( 
instring
 ) > 
maxExcLoc
 :

3560 
maxException
 = 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
e
 . 
errmsg
 , 
self
 )

3561 
maxExcLoc
 = 
len
 ( 
instring
 )

3565 if 
maxException
 is not None :

3566 
maxException
 . 
msg
 = 
self
 . 
errmsg

3567 raise 
maxException

3569 raise 
ParseException
 ( 
instring
 , 
loc
 , "no defined alternatives to match" , 
self
 ) 
	}

3571 def 
	$__ior__
 ( 
self
 , 
other
 ) :

3572 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3573 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3574 return 
self
 . 
append
 ( 
other
 ) 
	}

3576 def 
	$__str__
 ( 
self
 ) :

3577 if 
hasattr
 ( 
self
 , "name" ) :

3578 return 
self
 . 
name

3580 if 
self
 . 
strRepr
 is None :

3581 
self
 . 
strRepr
 = "{" + " | " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3583 return 
self
 . 
strRepr
 
	}

3585 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3586 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3587 for 
e
 in 
self
 . 
exprs
 :

3588 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3591 class 
	cEach
 ( 
ParseExpression
 ) :

3645 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = True ) :

3646 
super
 ( 
Each
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3647 
self
 . 
mayReturnEmpty
 = 
all
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3648 
self
 . 
skipWhitespace
 = True

3649 
self
 . 
initExprGroups
 = True 
	}

3651 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3652 if 
self
 . 
initExprGroups
 :

3653 
self
 . 
opt1map
 = 
dict
 ( ( 
id
 ( 
e
 . 
expr
 ) , 
e
 ) for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) )

3654 
opt1
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) ]

3655 
opt2
 = [ 
e
 for 
e
 in 
self
 . 
exprs
 if 
e
 . 
mayReturnEmpty
 and not 
isinstance
 ( 
e
 , 
Optional
 ) ]

3656 
self
 . 
optionals
 = 
opt1
 + 
opt2

3657 
self
 . 
multioptionals
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
ZeroOrMore
 ) ]

3658 
self
 . 
multirequired
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
OneOrMore
 ) ]

3659 
self
 . 
required
 = [ 
e
 for 
e
 in 
self
 . 
exprs
 if not 
isinstance
 ( 
e
 , ( 
Optional
 , 
ZeroOrMore
 , 
OneOrMore
 ) ) ]

3660 
self
 . 
required
 += 
self
 . 
multirequired

3661 
self
 . 
initExprGroups
 = False

3662 
tmpLoc
 = 
loc

3663 
tmpReqd
 = 
self
 . 
required
 [ : ]

3664 
tmpOpt
 = 
self
 . 
optionals
 [ : ]

3665 
matchOrder
 = [ ]

3667 
keepMatching
 = True

3668 while 
keepMatching
 :

3669 
tmpExprs
 = 
tmpReqd
 + 
tmpOpt
 + 
self
 . 
multioptionals
 + 
self
 . 
multirequired

3670 
failed
 = [ ]

3671 for 
e
 in 
tmpExprs
 :

3673 
tmpLoc
 = 
e
 . 
tryParse
 ( 
instring
 , 
tmpLoc
 )

3674 except 
ParseException
 :

3675 
failed
 . 
append
 ( 
e
 )

3677 
matchOrder
 . 
append
 ( 
self
 . 
opt1map
 . 
get
 ( 
id
 ( 
e
 ) , 
e
 ) )

3678 if 
e
 in 
tmpReqd
 :

3679 
tmpReqd
 . 
remove
 ( 
e
 )

3680 elif 
e
 in 
tmpOpt
 :

3681 
tmpOpt
 . 
remove
 ( 
e
 )

3682 if 
len
 ( 
failed
 ) == 
len
 ( 
tmpExprs
 ) :

3683 
keepMatching
 = False

3685 if 
tmpReqd
 :

3686 
missing
 = ", " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
tmpReqd
 )

3687 raise 
ParseException
 ( 
instring
 , 
loc
 , "Missing one or more required elements (%s)" % 
missing
 )

3690 
matchOrder
 += [ 
e
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) and 
e
 . 
expr
 in 
tmpOpt
 ]

3692 
resultlist
 = [ ]

3693 for 
e
 in 
matchOrder
 :

3694 
loc
 , 
results
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3695 
resultlist
 . 
append
 ( 
results
 )

3697 
finalResults
 = 
sum
 ( 
resultlist
 , 
ParseResults
 ( [ ] ) )

3698 return 
loc
 , 
finalResults
 
	}

3700 def 
	$__str__
 ( 
self
 ) :

3701 if 
hasattr
 ( 
self
 , "name" ) :

3702 return 
self
 . 
name

3704 if 
self
 . 
strRepr
 is None :

3705 
self
 . 
strRepr
 = "{" + " & " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3707 return 
self
 . 
strRepr
 
	}

3709 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3710 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3711 for 
e
 in 
self
 . 
exprs
 :

3712 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3715 class 
	cParseElementEnhance
 ( 
ParserElement
 ) :

3719 def 
	$__init__
 ( 
self
 , 
expr
 , 
savelist
 = False ) :

3720 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
__init__
 ( 
savelist
 )

3721 if 
isinstance
 ( 
expr
 , 
basestring
 ) :

3722 if 
issubclass
 ( 
ParserElement
 . 
_literalStringClass
 , 
Token
 ) :

3723 
expr
 = 
ParserElement
 . 
_literalStringClass
 ( 
expr
 )

3725 
expr
 = 
ParserElement
 . 
_literalStringClass
 ( 
Literal
 ( 
expr
 ) )

3726 
self
 . 
expr
 = 
expr

3727 
self
 . 
strRepr
 = None

3728 if 
expr
 is not None :

3729 
self
 . 
mayIndexError
 = 
expr
 . 
mayIndexError

3730 
self
 . 
mayReturnEmpty
 = 
expr
 . 
mayReturnEmpty

3731 
self
 . 
setWhitespaceChars
 ( 
expr
 . 
whiteChars
 )

3732 
self
 . 
skipWhitespace
 = 
expr
 . 
skipWhitespace

3733 
self
 . 
saveAsList
 = 
expr
 . 
saveAsList

3734 
self
 . 
callPreparse
 = 
expr
 . 
callPreparse

3735 
self
 . 
ignoreExprs
 . 
extend
 ( 
expr
 . 
ignoreExprs
 ) 
	}

3737 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3738 if 
self
 . 
expr
 is not None :

3739 return 
self
 . 
expr
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3741 raise 
ParseException
 ( "" , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3743 def 
	$leaveWhitespace
 ( 
self
 ) :

3744 
self
 . 
skipWhitespace
 = False

3745 
self
 . 
expr
 = 
self
 . 
expr
 . 
copy
 ( )

3746 if 
self
 . 
expr
 is not None :

3747 
self
 . 
expr
 . 
leaveWhitespace
 ( )

3748 return 
self
 
	}

3750 def 
	$ignore
 ( 
self
 , 
other
 ) :

3751 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

3752 if 
other
 not in 
self
 . 
ignoreExprs
 :

3753 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
ignore
 ( 
other
 )

3754 if 
self
 . 
expr
 is not None :

3755 
self
 . 
expr
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3757 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
ignore
 ( 
other
 )

3758 if 
self
 . 
expr
 is not None :

3759 
self
 . 
expr
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3760 return 
self
 
	}

3762 def 
	$streamline
 ( 
self
 ) :

3763 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
streamline
 ( )

3764 if 
self
 . 
expr
 is not None :

3765 
self
 . 
expr
 . 
streamline
 ( )

3766 return 
self
 
	}

3768 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3769 if 
self
 in 
parseElementList
 :

3770 raise 
RecursiveGrammarException
 ( 
parseElementList
 + [ 
self
 ] )

3771 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3772 if 
self
 . 
expr
 is not None :

3773 
self
 . 
expr
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3775 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

3776 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

3777 if 
self
 . 
expr
 is not None :

3778 
self
 . 
expr
 . 
validate
 ( 
tmp
 )

3779 
self
 . 
checkRecursion
 ( [ ] ) 
	}

3781 def 
	$__str__
 ( 
self
 ) :

3783 return 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
__str__
 ( )

3784 except 
Exception
 :

3787 if 
self
 . 
strRepr
 is None and 
self
 . 
expr
 is not None :

3788 
self
 . 
strRepr
 = "%s:(%s)" % ( 
self
 . 
__class__
 . 
__name__
 , 
_ustr
 ( 
self
 . 
expr
 ) )

3789 return 
self
 . 
strRepr
 
	}

3792 class 
	cFollowedBy
 ( 
ParseElementEnhance
 ) :

3809 def 
	$__init__
 ( 
self
 , 
expr
 ) :

3810 
super
 ( 
FollowedBy
 , 
self
 ) . 
__init__
 ( 
expr
 )

3811 
self
 . 
mayReturnEmpty
 = True 
	}

3813 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3814 
self
 . 
expr
 . 
tryParse
 ( 
instring
 , 
loc
 )

3815 return 
loc
 , [ ] 
	}

3818 class 
	cNotAny
 ( 
ParseElementEnhance
 ) :

3829 def 
	$__init__
 ( 
self
 , 
expr
 ) :

3830 
super
 ( 
NotAny
 , 
self
 ) . 
__init__
 ( 
expr
 )

3832 
self
 . 
skipWhitespace
 = False

3833 
self
 . 
mayReturnEmpty
 = True

3834 
self
 . 
errmsg
 = "Found unwanted token, " + 
_ustr
 ( 
self
 . 
expr
 ) 
	}

3836 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3837 if 
self
 . 
expr
 . 
canParseNext
 ( 
instring
 , 
loc
 ) :

3838 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3839 return 
loc
 , [ ] 
	}

3841 def 
	$__str__
 ( 
self
 ) :

3842 if 
hasattr
 ( 
self
 , "name" ) :

3843 return 
self
 . 
name

3845 if 
self
 . 
strRepr
 is None :

3846 
self
 . 
strRepr
 = "~{" + 
_ustr
 ( 
self
 . 
expr
 ) + "}"

3848 return 
self
 . 
strRepr
 
	}

3850 class 
	c_MultipleMatch
 ( 
ParseElementEnhance
 ) :

3851 def 
	$__init__
 ( 
self
 , 
expr
 , 
stopOn
 = None ) :

3852 
super
 ( 
_MultipleMatch
 , 
self
 ) . 
__init__
 ( 
expr
 )

3853 
self
 . 
saveAsList
 = True

3854 
ender
 = 
stopOn

3855 if 
isinstance
 ( 
ender
 , 
basestring
 ) :

3856 
ender
 = 
ParserElement
 . 
_literalStringClass
 ( 
ender
 )

3857 
self
 . 
not_ender
 = ~ 
ender
 if 
ender
 is not None else None 
	}

3859 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3860 
self_expr_parse
 = 
self
 . 
expr
 . 
_parse

3861 
self_skip_ignorables
 = 
self
 . 
_skipIgnorables

3862 
check_ender
 = 
self
 . 
not_ender
 is not None

3863 if 
check_ender
 :

3864 
try_not_ender
 = 
self
 . 
not_ender
 . 
tryParse

3868 if 
check_ender
 :

3869 
try_not_ender
 ( 
instring
 , 
loc
 )

3870 
loc
 , 
tokens
 = 
self_expr_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3872 
hasIgnoreExprs
 = ( not not 
self
 . 
ignoreExprs
 )

3874 if 
check_ender
 :

3875 
try_not_ender
 ( 
instring
 , 
loc
 )

3876 if 
hasIgnoreExprs
 :

3877 
preloc
 = 
self_skip_ignorables
 ( 
instring
 , 
loc
 )

3879 
preloc
 = 
loc

3880 
loc
 , 
tmptokens
 = 
self_expr_parse
 ( 
instring
 , 
preloc
 , 
doActions
 )

3881 if 
tmptokens
 or 
tmptokens
 . 
haskeys
 ( ) :

3882 
tokens
 += 
tmptokens

3883 except ( 
ParseException
 , 
IndexError
 ) :

3886 return 
loc
 , 
tokens
 
	}

3888 class 
	cOneOrMore
 ( 
_MultipleMatch
 ) :

3914 def 
	$__str__
 ( 
self
 ) :

3915 if 
hasattr
 ( 
self
 , "name" ) :

3916 return 
self
 . 
name

3918 if 
self
 . 
strRepr
 is None :

3919 
self
 . 
strRepr
 = "{" + 
_ustr
 ( 
self
 . 
expr
 ) + "}..."

3921 return 
self
 . 
strRepr
 
	}

3923 class 
	cZeroOrMore
 ( 
_MultipleMatch
 ) :

3935 def 
	$__init__
 ( 
self
 , 
expr
 , 
stopOn
 = None ) :

3936 
super
 ( 
ZeroOrMore
 , 
self
 ) . 
__init__
 ( 
expr
 , 
stopOn
 = 
stopOn
 )

3937 
self
 . 
mayReturnEmpty
 = True 
	}

3939 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3941 return 
super
 ( 
ZeroOrMore
 , 
self
 ) . 
parseImpl
 ( 
instring
 , 
loc
 , 
doActions
 )

3942 except ( 
ParseException
 , 
IndexError
 ) :

3943 return 
loc
 , [ ] 
	}

3945 def 
	$__str__
 ( 
self
 ) :

3946 if 
hasattr
 ( 
self
 , "name" ) :

3947 return 
self
 . 
name

3949 if 
self
 . 
strRepr
 is None :

3950 
self
 . 
strRepr
 = "[" + 
_ustr
 ( 
self
 . 
expr
 ) + "]..."

3952 return 
self
 . 
strRepr
 
	}

3954 class 
	c_NullToken
 ( 
object
 ) :

3955 def 
	$__bool__
 ( 
self
 ) :

3956 return False 
	}

3957 
__nonzero__
 = 
__bool__

3958 def 
	$__str__
 ( 
self
 ) :

3959 return "" 
	}

3961 
_optionalNotMatched
 = 
_NullToken
 ( )

3962 class 
	cOptional
 ( 
ParseElementEnhance
 ) :

3997 def 
	$__init__
 ( 
self
 , 
expr
 , 
default
 = 
_optionalNotMatched
 ) :

3998 
super
 ( 
Optional
 , 
self
 ) . 
__init__
 ( 
expr
 , 
savelist
 = False )

3999 
self
 . 
saveAsList
 = 
self
 . 
expr
 . 
saveAsList

4000 
self
 . 
defaultValue
 = 
default

4001 
self
 . 
mayReturnEmpty
 = True 
	}

4003 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

4005 
loc
 , 
tokens
 = 
self
 . 
expr
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

4006 except ( 
ParseException
 , 
IndexError
 ) :

4007 if 
self
 . 
defaultValue
 is not 
_optionalNotMatched
 :

4008 if 
self
 . 
expr
 . 
resultsName
 :

4009 
tokens
 = 
ParseResults
 ( [ 
self
 . 
defaultValue
 ] )

4010 
tokens
 [ 
self
 . 
expr
 . 
resultsName
 ] = 
self
 . 
defaultValue

4012 
tokens
 = [ 
self
 . 
defaultValue
 ]

4014 
tokens
 = [ ]

4015 return 
loc
 , 
tokens
 
	}

4017 def 
	$__str__
 ( 
self
 ) :

4018 if 
hasattr
 ( 
self
 , "name" ) :

4019 return 
self
 . 
name

4021 if 
self
 . 
strRepr
 is None :

4022 
self
 . 
strRepr
 = "[" + 
_ustr
 ( 
self
 . 
expr
 ) + "]"

4024 return 
self
 . 
strRepr
 
	}

4026 class 
	cSkipTo
 ( 
ParseElementEnhance
 ) :

4081 def 
	$__init__
 ( 
self
 , 
other
 , 
include
 = False , 
ignore
 = None , 
failOn
 = None ) :

4082 
super
 ( 
SkipTo
 , 
self
 ) . 
__init__
 ( 
other
 )

4083 
self
 . 
ignoreExpr
 = 
ignore

4084 
self
 . 
mayReturnEmpty
 = True

4085 
self
 . 
mayIndexError
 = False

4086 
self
 . 
includeMatch
 = 
include

4087 
self
 . 
asList
 = False

4088 if 
isinstance
 ( 
failOn
 , 
basestring
 ) :

4089 
self
 . 
failOn
 = 
ParserElement
 . 
_literalStringClass
 ( 
failOn
 )

4091 
self
 . 
failOn
 = 
failOn

4092 
self
 . 
errmsg
 = "No match found for " + 
_ustr
 ( 
self
 . 
expr
 ) 
	}

4094 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

4095 
startloc
 = 
loc

4096 
instrlen
 = 
len
 ( 
instring
 )

4097 
expr
 = 
self
 . 
expr

4098 
expr_parse
 = 
self
 . 
expr
 . 
_parse

4099 
self_failOn_canParseNext
 = 
self
 . 
failOn
 . 
canParseNext
 if 
self
 . 
failOn
 is not None else None

4100 
self_ignoreExpr_tryParse
 = 
self
 . 
ignoreExpr
 . 
tryParse
 if 
self
 . 
ignoreExpr
 is not None else None

4102 
tmploc
 = 
loc

4103 while 
tmploc
 <= 
instrlen
 :

4104 if 
self_failOn_canParseNext
 is not None :

4106 if 
self_failOn_canParseNext
 ( 
instring
 , 
tmploc
 ) :

4109 if 
self_ignoreExpr_tryParse
 is not None :

4113 
tmploc
 = 
self_ignoreExpr_tryParse
 ( 
instring
 , 
tmploc
 )

4114 except 
ParseBaseException
 :

4118 
expr_parse
 ( 
instring
 , 
tmploc
 , 
doActions
 = False , 
callPreParse
 = False )

4119 except ( 
ParseException
 , 
IndexError
 ) :

4121 
tmploc
 += 1

4128 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

4131 
loc
 = 
tmploc

4132 
skiptext
 = 
instring
 [ 
startloc
 : 
loc
 ]

4133 
skipresult
 = 
ParseResults
 ( 
skiptext
 )

4135 if 
self
 . 
includeMatch
 :

4136 
loc
 , 
mat
 = 
expr_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

4137 
skipresult
 += 
mat

4139 return 
loc
 , 
skipresult
 
	}

4141 class 
	cForward
 ( 
ParseElementEnhance
 ) :

4160 def 
	$__init__
 ( 
self
 , 
other
 = None ) :

4161 
super
 ( 
Forward
 , 
self
 ) . 
__init__
 ( 
other
 , 
savelist
 = False ) 
	}

4163 def 
	$__lshift__
 ( 
self
 , 
other
 ) :

4164 if 
isinstance
 ( 
other
 , 
basestring
 ) :

4165 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

4166 
self
 . 
expr
 = 
other

4167 
self
 . 
strRepr
 = None

4168 
self
 . 
mayIndexError
 = 
self
 . 
expr
 . 
mayIndexError

4169 
self
 . 
mayReturnEmpty
 = 
self
 . 
expr
 . 
mayReturnEmpty

4170 
self
 . 
setWhitespaceChars
 ( 
self
 . 
expr
 . 
whiteChars
 )

4171 
self
 . 
skipWhitespace
 = 
self
 . 
expr
 . 
skipWhitespace

4172 
self
 . 
saveAsList
 = 
self
 . 
expr
 . 
saveAsList

4173 
self
 . 
ignoreExprs
 . 
extend
 ( 
self
 . 
expr
 . 
ignoreExprs
 )

4174 return 
self
 
	}

4176 def 
	$__ilshift__
 ( 
self
 , 
other
 ) :

4177 return 
self
 << 
other
 
	}

4179 def 
	$leaveWhitespace
 ( 
self
 ) :

4180 
self
 . 
skipWhitespace
 = False

4181 return 
self
 
	}

4183 def 
	$streamline
 ( 
self
 ) :

4184 if not 
self
 . 
streamlined
 :

4185 
self
 . 
streamlined
 = True

4186 if 
self
 . 
expr
 is not None :

4187 
self
 . 
expr
 . 
streamline
 ( )

4188 return 
self
 
	}

4190 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

4191 if 
self
 not in 
validateTrace
 :

4192 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

4193 if 
self
 . 
expr
 is not None :

4194 
self
 . 
expr
 . 
validate
 ( 
tmp
 )

4195 
self
 . 
checkRecursion
 ( [ ] ) 
	}

4197 def 
	$__str__
 ( 
self
 ) :

4198 if 
hasattr
 ( 
self
 , "name" ) :

4199 return 
self
 . 
name

4200 return 
self
 . 
__class__
 . 
__name__
 + ": ..."

4203 
self
 . 
_revertClass
 = 
self
 . 
__class__

4204 
self
 . 
__class__
 = 
_ForwardNoRecurse

4206 if 
self
 . 
expr
 is not None :

4207 
retString
 = 
_ustr
 ( 
self
 . 
expr
 )

4209 
retString
 = "None"

4211 
self
 . 
__class__
 = 
self
 . 
_revertClass

4212 return 
self
 . 
__class__
 . 
__name__
 + ": " + 
retString
 
	}

4214 def 
	$copy
 ( 
self
 ) :

4215 if 
self
 . 
expr
 is not None :

4216 return 
super
 ( 
Forward
 , 
self
 ) . 
copy
 ( )

4218 
ret
 = 
Forward
 ( )

4219 
ret
 <<= 
self

4220 return 
ret
 
	}

4222 class 
	c_ForwardNoRecurse
 ( 
Forward
 ) :

4223 def 
	$__str__
 ( 
self
 ) :

4224 return "..." 
	}

4226 class 
	cTokenConverter
 ( 
ParseElementEnhance
 ) :

4230 def 
	$__init__
 ( 
self
 , 
expr
 , 
savelist
 = False ) :

4231 
super
 ( 
TokenConverter
 , 
self
 ) . 
__init__
 ( 
expr
 )

4232 
self
 . 
saveAsList
 = False 
	}

4234 class 
	cCombine
 ( 
TokenConverter
 ) :

4251 def 
	$__init__
 ( 
self
 , 
expr
 , 
joinString
 = "" , 
adjacent
 = True ) :

4252 
super
 ( 
Combine
 , 
self
 ) . 
__init__
 ( 
expr
 )

4254 if 
adjacent
 :

4255 
self
 . 
leaveWhitespace
 ( )

4256 
self
 . 
adjacent
 = 
adjacent

4257 
self
 . 
skipWhitespace
 = True

4258 
self
 . 
joinString
 = 
joinString

4259 
self
 . 
callPreparse
 = True 
	}

4261 def 
	$ignore
 ( 
self
 , 
other
 ) :

4262 if 
self
 . 
adjacent
 :

4263 
ParserElement
 . 
ignore
 ( 
self
 , 
other
 )

4265 
super
 ( 
Combine
 , 
self
 ) . 
ignore
 ( 
other
 )

4266 return 
self
 
	}

4268 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4269 
retToks
 = 
tokenlist
 . 
copy
 ( )

4270 del 
retToks
 [ : ]

4271 
retToks
 += 
ParseResults
 ( [ "" . 
join
 ( 
tokenlist
 . 
_asStringList
 ( 
self
 . 
joinString
 ) ) ] , 
modal
 = 
self
 . 
modalResults
 )

4273 if 
self
 . 
resultsName
 and 
retToks
 . 
haskeys
 ( ) :

4274 return [ 
retToks
 ]

4276 return 
retToks
 
	}

4278 class 
	cGroup
 ( 
TokenConverter
 ) :

4292 def 
	$__init__
 ( 
self
 , 
expr
 ) :

4293 
super
 ( 
Group
 , 
self
 ) . 
__init__
 ( 
expr
 )

4294 
self
 . 
saveAsList
 = True 
	}

4296 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4297 return [ 
tokenlist
 ] 
	}

4299 class 
	cDict
 ( 
TokenConverter
 ) :

4335 def 
	$__init__
 ( 
self
 , 
expr
 ) :

4336 
super
 ( 
Dict
 , 
self
 ) . 
__init__
 ( 
expr
 )

4337 
self
 . 
saveAsList
 = True 
	}

4339 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4340 for 
i
 , 
tok
 in 
enumerate
 ( 
tokenlist
 ) :

4341 if 
len
 ( 
tok
 ) == 0 :

4343 
ikey
 = 
tok
 [ 0 ]

4344 if 
isinstance
 ( 
ikey
 , 
int
 ) :

4345 
ikey
 = 
_ustr
 ( 
tok
 [ 0 ] ) . 
strip
 ( )

4346 if 
len
 ( 
tok
 ) == 1 :

4347 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( "" , 
i
 )

4348 elif 
len
 ( 
tok
 ) == 2 and not 
isinstance
 ( 
tok
 [ 1 ] , 
ParseResults
 ) :

4349 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
tok
 [ 1 ] , 
i
 )

4351 
dictvalue
 = 
tok
 . 
copy
 ( )

4352 del 
dictvalue
 [ 0 ]

4353 if 
len
 ( 
dictvalue
 ) != 1 or ( 
isinstance
 ( 
dictvalue
 , 
ParseResults
 ) and 
dictvalue
 . 
haskeys
 ( ) ) :

4354 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
dictvalue
 , 
i
 )

4356 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
dictvalue
 [ 0 ] , 
i
 )

4358 if 
self
 . 
resultsName
 :

4359 return [ 
tokenlist
 ]

4361 return 
tokenlist
 
	}

4364 class 
	cSuppress
 ( 
TokenConverter
 ) :

4383 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4384 return [ ] 
	}

4386 def 
	$suppress
 ( 
self
 ) :

4387 return 
self
 
	}

4390 class 
	cOnlyOnce
 ( 
object
 ) :

4394 def 
	$__init__
 ( 
self
 , 
methodCall
 ) :

4395 
self
 . 
callable
 = 
_trim_arity
 ( 
methodCall
 )

4396 
self
 . 
called
 = False 
	}

4397 def 
	$__call__
 ( 
self
 , 
s
 , 
l
 , 
t
 ) :

4398 if not 
self
 . 
called
 :

4399 
results
 = 
self
 . 
callable
 ( 
s
 , 
l
 , 
t
 )

4400 
self
 . 
called
 = True

4401 return 
results

4402 raise 
ParseException
 ( 
s
 , 
l
 , "" ) 
	}

4403 def 
	$reset
 ( 
self
 ) :

4404 
self
 . 
called
 = False 
	}

4406 def 
	$traceParseAction
 ( 
f
 ) :

4427 
f
 = 
_trim_arity
 ( 
f
 )

4428 def 
z
 ( * 
paArgs
 ) :

4429 
thisFunc
 = 
f
 . 
__name__

4430 
s
 , 
l
 , 
t
 = 
paArgs
 [ - 3 : ]

4431 if 
len
 ( 
paArgs
 ) > 3 :

4432 
thisFunc
 = 
paArgs
 [ 0 ] . 
__class__
 . 
__name__
 + '.' + 
thisFunc

4433 
sys
 . 
stderr
 . 
write
 ( ">>entering %s(line: '%s', %d, %r)\n" % ( 
thisFunc
 , 
line
 ( 
l
 , 
s
 ) , 
l
 , 
t
 ) )

4435 
ret
 = 
f
 ( * 
paArgs
 )

4436 except 
Exception
 as 
exc
 :

4437 
sys
 . 
stderr
 . 
write
 ( "<<leaving %s (exception: %s)\n" % ( 
thisFunc
 , 
exc
 ) )

4439 
sys
 . 
stderr
 . 
write
 ( "<<leaving %s (ret: %r)\n" % ( 
thisFunc
 , 
ret
 ) )

4440 return 
ret

4442 
z
 . 
__name__
 = 
f
 . 
__name__

4443 except 
AttributeError
 :

4445 return 
z
 
	}

4450 def 
	$delimitedList
 ( 
expr
 , 
delim
 = "," , 
combine
 = False ) :

4463 
dlName
 = 
_ustr
 ( 
expr
 ) + " [" + 
_ustr
 ( 
delim
 ) + " " + 
_ustr
 ( 
expr
 ) + "]..."

4464 if 
combine
 :

4465 return 
Combine
 ( 
expr
 + 
ZeroOrMore
 ( 
delim
 + 
expr
 ) ) . 
setName
 ( 
dlName
 )

4467 return ( 
expr
 + 
ZeroOrMore
 ( 
Suppress
 ( 
delim
 ) + 
expr
 ) ) . 
setName
 ( 
dlName
 ) 
	}

4469 def 
	$countedArray
 ( 
expr
 , 
intExpr
 = None ) :

4487 
arrayExpr
 = 
Forward
 ( )

4488 def 
countFieldParseAction
 ( 
s
 , 
l
 , 
t
 ) :

4489 
n
 = 
t
 [ 0 ]

4490 
arrayExpr
 << ( 
n
 and 
Group
 ( 
And
 ( [ 
expr
 ] * 
n
 ) ) or 
Group
 ( 
empty
 ) )

4492 if 
intExpr
 is None :

4493 
intExpr
 = 
Word
 ( 
nums
 ) . 
setParseAction
 ( lambda 
t
 : 
int
 ( 
t
 [ 0 ] ) )

4495 
intExpr
 = 
intExpr
 . 
copy
 ( )

4496 
intExpr
 . 
setName
 ( "arrayLen" )

4497 
intExpr
 . 
addParseAction
 ( 
countFieldParseAction
 , 
callDuringTry
 = True )

4498 return ( 
intExpr
 + 
arrayExpr
 ) . 
setName
 ( '(len) ' + 
_ustr
 ( 
expr
 ) + '...' ) 
	}

4500 def 
	$_flatten
 ( 
L
 ) :

4501 
ret
 = [ ]

4502 for 
i
 in 
L
 :

4503 if 
isinstance
 ( 
i
 , 
list
 ) :

4504 
ret
 . 
extend
 ( 
_flatten
 ( 
i
 ) )

4506 
ret
 . 
append
 ( 
i
 )

4507 return 
ret
 
	}

4509 def 
	$matchPreviousLiteral
 ( 
expr
 ) :

4522 
rep
 = 
Forward
 ( )

4523 def 
copyTokenToRepeater
 ( 
s
 , 
l
 , 
t
 ) :

4524 if 
t
 :

4525 if 
len
 ( 
t
 ) == 1 :

4526 
rep
 << 
t
 [ 0 ]

4529 
tflat
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4530 
rep
 << 
And
 ( 
Literal
 ( 
tt
 ) for 
tt
 in 
tflat
 )

4532 
rep
 << 
Empty
 ( )

4533 
expr
 . 
addParseAction
 ( 
copyTokenToRepeater
 , 
callDuringTry
 = True )

4534 
rep
 . 
setName
 ( '(prev) ' + 
_ustr
 ( 
expr
 ) )

4535 return 
rep
 
	}

4537 def 
	$matchPreviousExpr
 ( 
expr
 ) :

4551 
rep
 = 
Forward
 ( )

4552 
e2
 = 
expr
 . 
copy
 ( )

4553 
rep
 <<= 
e2

4554 def 
copyTokenToRepeater
 ( 
s
 , 
l
 , 
t
 ) :

4555 
matchTokens
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4556 def 
mustMatchTheseTokens
 ( 
s
 , 
l
 , 
t
 ) :

4557 
theseTokens
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4558 if 
theseTokens
 != 
matchTokens
 :

4559 raise 
ParseException
 ( "" , 0 , "" )

4560 
rep
 . 
setParseAction
 ( 
mustMatchTheseTokens
 , 
callDuringTry
 = True )

4561 
expr
 . 
addParseAction
 ( 
copyTokenToRepeater
 , 
callDuringTry
 = True )

4562 
rep
 . 
setName
 ( '(prev) ' + 
_ustr
 ( 
expr
 ) )

4563 return 
rep
 
	}

4565 def 
	$_escapeRegexRangeChars
 ( 
s
 ) :

4567 for 
c
 in r"\^-]" :

4568 
s
 = 
s
 . 
replace
 ( 
c
 , 
_bslash
 + 
c
 )

4569 
s
 = 
s
 . 
replace
 ( "\n" , r"\n" )

4570 
s
 = 
s
 . 
replace
 ( "\t" , r"\t" )

4571 return 
_ustr
 ( 
s
 ) 
	}

4573 def 
	$oneOf
 ( 
strs
 , 
caseless
 = False , 
useRegex
 = True ) :

4596 if 
caseless
 :

4597 
isequal
 = ( lambda 
a
 , 
b
 : 
a
 . 
upper
 ( ) == 
b
 . 
upper
 ( ) )

4598 
masks
 = ( lambda 
a
 , 
b
 : 
b
 . 
upper
 ( ) . 
startswith
 ( 
a
 . 
upper
 ( ) ) )

4599 
parseElementClass
 = 
CaselessLiteral

4601 
isequal
 = ( lambda 
a
 , 
b
 : 
a
 == 
b
 )

4602 
masks
 = ( lambda 
a
 , 
b
 : 
b
 . 
startswith
 ( 
a
 ) )

4603 
parseElementClass
 = 
Literal

4605 
symbols
 = [ ]

4606 if 
isinstance
 ( 
strs
 , 
basestring
 ) :

4607 
symbols
 = 
strs
 . 
split
 ( )

4608 elif 
isinstance
 ( 
strs
 , 
Iterable
 ) :

4609 
symbols
 = 
list
 ( 
strs
 )

4611 
warnings
 . 
warn
 ( "Invalid argument to oneOf, expected string or iterable" ,

4612 
SyntaxWarning
 , 
stacklevel
 = 2 )

4613 if not 
symbols
 :

4614 return 
NoMatch
 ( )

4616 
i
 = 0

4617 while 
i
 < 
len
 ( 
symbols
 ) - 1 :

4618 
cur
 = 
symbols
 [ 
i
 ]

4619 for 
j
 , 
other
 in 
enumerate
 ( 
symbols
 [ 
i
 + 1 : ] ) :

4620 if ( 
isequal
 ( 
other
 , 
cur
 ) ) :

4621 del 
symbols
 [ 
i
 + 
j
 + 1 ]

4623 elif ( 
masks
 ( 
cur
 , 
other
 ) ) :

4624 del 
symbols
 [ 
i
 + 
j
 + 1 ]

4625 
symbols
 . 
insert
 ( 
i
 , 
other
 )

4626 
cur
 = 
other

4629 
i
 += 1

4631 if not 
caseless
 and 
useRegex
 :

4634 if 
len
 ( 
symbols
 ) == 
len
 ( "" . 
join
 ( 
symbols
 ) ) :

4635 return 
Regex
 ( "[%s]" % "" . 
join
 ( 
_escapeRegexRangeChars
 ( 
sym
 ) for 
sym
 in 
symbols
 ) ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) )

4637 return 
Regex
 ( "|" . 
join
 ( 
re
 . 
escape
 ( 
sym
 ) for 
sym
 in 
symbols
 ) ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) )

4638 except 
Exception
 :

4639 
warnings
 . 
warn
 ( "Exception creating Regex for oneOf, building MatchFirst" ,

4640 
SyntaxWarning
 , 
stacklevel
 = 2 )

4644 return 
MatchFirst
 ( 
parseElementClass
 ( 
sym
 ) for 
sym
 in 
symbols
 ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) ) 
	}

4646 def 
	$dictOf
 ( 
key
 , 
value
 ) :

4679 return 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
key
 + 
value
 ) ) ) 
	}

4681 def 
	$originalTextFor
 ( 
expr
 , 
asString
 = True ) :

4705 
locMarker
 = 
Empty
 ( ) . 
setParseAction
 ( lambda 
s
 , 
loc
 , 
t
 : 
loc
 )

4706 
endlocMarker
 = 
locMarker
 . 
copy
 ( )

4707 
endlocMarker
 . 
callPreparse
 = False

4708 
matchExpr
 = 
locMarker
 ( "_original_start" ) + 
expr
 + 
endlocMarker
 ( "_original_end" )

4709 if 
asString
 :

4710 
extractText
 = lambda 
s
 , 
l
 , 
t
 : 
s
 [ 
t
 . 
_original_start
 : 
t
 . 
_original_end
 ]

4712 def 
extractText
 ( 
s
 , 
l
 , 
t
 ) :

4713 
t
 [ : ] = [ 
s
 [ 
t
 . 
pop
 ( '_original_start' ) : 
t
 . 
pop
 ( '_original_end' ) ] ]

4714 
matchExpr
 . 
setParseAction
 ( 
extractText
 )

4715 
matchExpr
 . 
ignoreExprs
 = 
expr
 . 
ignoreExprs

4716 return 
matchExpr
 
	}

4718 def 
	$ungroup
 ( 
expr
 ) :

4723 return 
TokenConverter
 ( 
expr
 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] ) 
	}

4725 def 
	$locatedExpr
 ( 
expr
 ) :

4745 
locator
 = 
Empty
 ( ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
l
 )

4746 return 
Group
 ( 
locator
 ( "locn_start" ) + 
expr
 ( "value" ) + 
locator
 . 
copy
 ( ) . 
leaveWhitespace
 ( ) ( "locn_end" ) ) 
	}

4750 
empty
 = 
Empty
 ( ) . 
setName
 ( "empty" )

4751 
lineStart
 = 
LineStart
 ( ) . 
setName
 ( "lineStart" )

4752 
lineEnd
 = 
LineEnd
 ( ) . 
setName
 ( "lineEnd" )

4753 
stringStart
 = 
StringStart
 ( ) . 
setName
 ( "stringStart" )

4754 
stringEnd
 = 
StringEnd
 ( ) . 
setName
 ( "stringEnd" )

4756 
_escapedPunc
 = 
Word
 ( 
_bslash
 , r"\[]-*.$+^?()~ " , 
exact
 = 2 ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] [ 1 ] )

4757 
_escapedHexChar
 = 
Regex
 ( r"\\0?[xX][0-9a-fA-F]+" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
unichr
 ( 
int
 ( 
t
 [ 0 ] . 
lstrip
 ( r'\0x' ) , 16 ) ) )

4758 
_escapedOctChar
 = 
Regex
 ( r"\\0[0-7]+" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
unichr
 ( 
int
 ( 
t
 [ 0 ] [ 1 : ] , 8 ) ) )

4759 
_singleChar
 = 
_escapedPunc
 | 
_escapedHexChar
 | 
_escapedOctChar
 | 
CharsNotIn
 ( r'\]' , 
exact
 = 1 )

4760 
_charRange
 = 
Group
 ( 
_singleChar
 + 
Suppress
 ( "-" ) + 
_singleChar
 )

4761 
_reBracketExpr
 = 
Literal
 ( "[" ) + 
Optional
 ( "^" ) . 
setResultsName
 ( "negate" ) + 
Group
 ( 
OneOrMore
 ( 
_charRange
 | 
_singleChar
 ) ) . 
setResultsName
 ( "body" ) + "]"

4763 def 
	$srange
 ( 
s
 ) :

4781 
_expanded
 = lambda 
p
 : 
p
 if not 
isinstance
 ( 
p
 , 
ParseResults
 ) else '' . 
join
 ( 
unichr
 ( 
c
 ) for 
c
 in 
range
 ( 
ord
 ( 
p
 [ 0 ] ) , 
ord
 ( 
p
 [ 1 ] ) + 1 ) )

4783 return "" . 
join
 ( 
_expanded
 ( 
part
 ) for 
part
 in 
_reBracketExpr
 . 
parseString
 ( 
s
 ) . 
body
 )

4784 except 
Exception
 :

4785 return "" 
	}

4787 def 
	$matchOnlyAtCol
 ( 
n
 ) :

4792 def 
verifyCol
 ( 
strg
 , 
locn
 , 
toks
 ) :

4793 if 
col
 ( 
locn
 , 
strg
 ) != 
n
 :

4794 raise 
ParseException
 ( 
strg
 , 
locn
 , "matched token not at column %d" % 
n
 )

4795 return 
verifyCol
 
	}

4797 def 
	$replaceWith
 ( 
replStr
 ) :

4809 return lambda 
s
 , 
l
 , 
t
 : [ 
replStr
 ] 
	}

4811 def 
	$removeQuotes
 ( 
s
 , 
l
 , 
t
 ) :

4823 return 
t
 [ 0 ] [ 1 : - 1 ] 
	}

4825 def 
	$tokenMap
 ( 
func
 , * 
args
 ) :

4857 def 
pa
 ( 
s
 , 
l
 , 
t
 ) :

4858 return [ 
func
 ( 
tokn
 , * 
args
 ) for 
tokn
 in 
t
 ]

4861 
func_name
 = 
getattr
 ( 
func
 , '__name__' ,

4862 
getattr
 ( 
func
 , '__class__' ) . 
__name__
 )

4863 except 
Exception
 :

4864 
func_name
 = 
str
 ( 
func
 )

4865 
pa
 . 
__name__
 = 
func_name

4867 return 
pa
 
	}

4869 
upcaseTokens
 = 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
upper
 ( ) ) """(Deprecated) Helper parse action to convert tokens to upper case. Deprecated in favor of L{pyparsing_common.upcaseTokens}"""

4872 
downcaseTokens
 = 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
lower
 ( ) ) """(Deprecated) Helper parse action to convert tokens to lower case. Deprecated in favor of L{pyparsing_common.downcaseTokens}"""

4875 def 
	$_makeTags
 ( 
tagStr
 , 
xml
 ) :

4877 if 
isinstance
 ( 
tagStr
 , 
basestring
 ) :

4878 
resname
 = 
tagStr

4879 
tagStr
 = 
Keyword
 ( 
tagStr
 , 
caseless
 = not 
xml
 )

4881 
resname
 = 
tagStr
 . 
name

4883 
tagAttrName
 = 
Word
 ( 
alphas
 , 
alphanums
 + "_-:" )

4884 if ( 
xml
 ) :

4885 
tagAttrValue
 = 
dblQuotedString
 . 
copy
 ( ) . 
setParseAction
 ( 
removeQuotes
 )

4886 
openTag
 = 
Suppress
 ( "<" ) + 
tagStr
 ( "tag" ) +

4887 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
tagAttrName
 + 
Suppress
 ( "=" ) + 
tagAttrValue
 ) ) ) +

4888 
Optional
 ( "/" , 
default
 = [ False ] ) . 
setResultsName
 ( "empty" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] == '/' ) + 
Suppress
 ( ">" )

4890 
printablesLessRAbrack
 = "" . 
join
 ( 
c
 for 
c
 in 
printables
 if 
c
 not in ">" )

4891 
tagAttrValue
 = 
quotedString
 . 
copy
 ( ) . 
setParseAction
 ( 
removeQuotes
 ) | 
Word
 ( 
printablesLessRAbrack
 )

4892 
openTag
 = 
Suppress
 ( "<" ) + 
tagStr
 ( "tag" ) +

4893 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
tagAttrName
 . 
setParseAction
 ( 
downcaseTokens
 ) +

4894 
Optional
 ( 
Suppress
 ( "=" ) + 
tagAttrValue
 ) ) ) ) +

4895 
Optional
 ( "/" , 
default
 = [ False ] ) . 
setResultsName
 ( "empty" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] == '/' ) + 
Suppress
 ( ">" )

4896 
closeTag
 = 
Combine
 ( 
_L
 ( "</" ) + 
tagStr
 + ">" )

4898 
openTag
 = 
openTag
 . 
setResultsName
 ( "start" + "" . 
join
 ( 
resname
 . 
replace
 ( ":" , " " ) . 
title
 ( ) . 
split
 ( ) ) ) . 
setName
 ( "<%s>" % 
resname
 )

4899 
closeTag
 = 
closeTag
 . 
setResultsName
 ( "end" + "" . 
join
 ( 
resname
 . 
replace
 ( ":" , " " ) . 
title
 ( ) . 
split
 ( ) ) ) . 
setName
 ( "</%s>" % 
resname
 )

4900 
openTag
 . 
tag
 = 
resname

4901 
closeTag
 . 
tag
 = 
resname

4902 return 
openTag
 , 
closeTag
 
	}

4904 def 
	$makeHTMLTags
 ( 
tagStr
 ) :

4921 return 
_makeTags
 ( 
tagStr
 , False ) 
	}

4923 def 
	$makeXMLTags
 ( 
tagStr
 ) :

4930 return 
_makeTags
 ( 
tagStr
 , True ) 
	}

4932 def 
	$withAttribute
 ( * 
args
 , ** 
attrDict
 ) :

4982 if 
args
 :

4983 
attrs
 = 
args
 [ : ]

4985 
attrs
 = 
attrDict
 . 
items
 ( )

4986 
attrs
 = [ ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
attrs
 ]

4987 def 
pa
 ( 
s
 , 
l
 , 
tokens
 ) :

4988 for 
attrName
 , 
attrValue
 in 
attrs
 :

4989 if 
attrName
 not in 
tokens
 :

4990 raise 
ParseException
 ( 
s
 , 
l
 , "no matching attribute " + 
attrName
 )

4991 if 
attrValue
 != 
withAttribute
 . 
ANY_VALUE
 and 
tokens
 [ 
attrName
 ] != 
attrValue
 :

4992 raise 
ParseException
 ( 
s
 , 
l
 , "attribute '%s' has value '%s', must be '%s'" %

4993 ( 
attrName
 , 
tokens
 [ 
attrName
 ] , 
attrValue
 ) )

4994 return 
pa
 
	}

4995 
withAttribute
 . 
ANY_VALUE
 = 
object
 ( )

4997 def 
	$withClass
 ( 
classname
 , 
namespace
 = '' ) :

5029 
classattr
 = "%s:class" % 
namespace
 if 
namespace
 else "class"

5030 return 
withAttribute
 ( ** { 
classattr
 : 
classname
 } ) 
	}

5032 
opAssoc
 = 
_Constants
 ( )

5033 
opAssoc
 . 
LEFT
 = 
object
 ( )

5034 
opAssoc
 . 
RIGHT
 = 
object
 ( )

5036 def 
	$infixNotation
 ( 
baseExpr
 , 
opList
 , 
lpar
 = 
Suppress
 ( '(' ) , 
rpar
 = 
Suppress
 ( ')' ) ) :

5097 
ret
 = 
Forward
 ( )

5098 
lastExpr
 = 
baseExpr
 | ( 
lpar
 + 
ret
 + 
rpar
 )

5099 for 
i
 , 
operDef
 in 
enumerate
 ( 
opList
 ) :

5100 
opExpr
 , 
arity
 , 
rightLeftAssoc
 , 
pa
 = ( 
operDef
 + ( None , ) ) [ : 4 ]

5101 
termName
 = "%s term" % 
opExpr
 if 
arity
 < 3 else "%s%s term" % 
opExpr

5102 if 
arity
 == 3 :

5103 if 
opExpr
 is None or 
len
 ( 
opExpr
 ) != 2 :

5104 raise 
ValueError
 ( "if numterms=3, opExpr must be a tuple or list of two expressions" )

5105 
opExpr1
 , 
opExpr2
 = 
opExpr

5106 
thisExpr
 = 
Forward
 ( ) . 
setName
 ( 
termName
 )

5107 if 
rightLeftAssoc
 == 
opAssoc
 . 
LEFT
 :

5108 if 
arity
 == 1 :

5109 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 ) )

5110 elif 
arity
 == 2 :

5111 if 
opExpr
 is not None :

5112 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 + 
lastExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 + 
lastExpr
 ) )

5114 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
lastExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
lastExpr
 ) )

5115 elif 
arity
 == 3 :

5116 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr1
 + 
lastExpr
 + 
opExpr2
 + 
lastExpr
 ) +

5117 
Group
 ( 
lastExpr
 + 
opExpr1
 + 
lastExpr
 + 
opExpr2
 + 
lastExpr
 )

5119 raise 
ValueError
 ( "operator must be unary (1), binary (2), or ternary (3)" )

5120 elif 
rightLeftAssoc
 == 
opAssoc
 . 
RIGHT
 :

5121 if 
arity
 == 1 :

5123 if not 
isinstance
 ( 
opExpr
 , 
Optional
 ) :

5124 
opExpr
 = 
Optional
 ( 
opExpr
 )

5125 
matchExpr
 = 
FollowedBy
 ( 
opExpr
 . 
expr
 + 
thisExpr
 ) + 
Group
 ( 
opExpr
 + 
thisExpr
 )

5126 elif 
arity
 == 2 :

5127 if 
opExpr
 is not None :

5128 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 + 
thisExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 + 
thisExpr
 ) )

5130 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
thisExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
thisExpr
 ) )

5131 elif 
arity
 == 3 :

5132 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr1
 + 
thisExpr
 + 
opExpr2
 + 
thisExpr
 ) +

5133 
Group
 ( 
lastExpr
 + 
opExpr1
 + 
thisExpr
 + 
opExpr2
 + 
thisExpr
 )

5135 raise 
ValueError
 ( "operator must be unary (1), binary (2), or ternary (3)" )

5137 raise 
ValueError
 ( "operator must indicate right or left associativity" )

5138 if 
pa
 :

5139 if 
isinstance
 ( 
pa
 , ( 
tuple
 , 
list
 ) ) :

5140 
matchExpr
 . 
setParseAction
 ( * 
pa
 )

5142 
matchExpr
 . 
setParseAction
 ( 
pa
 )

5143 
thisExpr
 <<= ( 
matchExpr
 . 
setName
 ( 
termName
 ) | 
lastExpr
 )

5144 
lastExpr
 = 
thisExpr

5145 
ret
 <<= 
lastExpr

5146 return 
ret
 
	}

5148 
operatorPrecedence
 = 
infixNotation
 """(Deprecated) Former name of C{L{infixNotation}}, will be dropped in a future release."""

5151 
dblQuotedString
 = 
Combine
 ( 
Regex
 ( r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*' ) + '"' ) . 
setName
 ( "string enclosed in double quotes" )

5152 
sglQuotedString
 = 
Combine
 ( 
Regex
 ( r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*" ) + "'" ) . 
setName
 ( "string enclosed in single quotes" )

5153 
quotedString
 = 
Combine
 ( 
Regex
 ( r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*' ) + '"' |

5154 
Regex
 ( r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*" ) + "'" ) . 
setName
 ( "quotedString using single or double quotes" )

5155 
unicodeString
 = 
Combine
 ( 
_L
 ( 'u' ) + 
quotedString
 . 
copy
 ( ) ) . 
setName
 ( "unicode string literal" )

5157 def 
	$nestedExpr
 ( 
opener
 = "(" , 
closer
 = ")" , 
content
 = None , 
ignoreExpr
 = 
quotedString
 . 
copy
 ( ) ) :

5215 if 
opener
 == 
closer
 :

5216 raise 
ValueError
 ( "opening and closing strings cannot be the same" )

5217 if 
content
 is None :

5218 if 
isinstance
 ( 
opener
 , 
basestring
 ) and 
isinstance
 ( 
closer
 , 
basestring
 ) :

5219 if 
len
 ( 
opener
 ) == 1 and 
len
 ( 
closer
 ) == 1 :

5220 if 
ignoreExpr
 is not None :

5221 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
ignoreExpr
 +

5222 
CharsNotIn
 ( 
opener
 + 
closer
 + 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5223 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5225 
content
 = ( 
empty
 . 
copy
 ( ) + 
CharsNotIn
 ( 
opener
 + 
closer
 + 
ParserElement
 . 
DEFAULT_WHITE_CHARS

5226 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5228 if 
ignoreExpr
 is not None :

5229 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
ignoreExpr
 +

5230 ~ 
Literal
 ( 
opener
 ) + ~ 
Literal
 ( 
closer
 ) +

5231 
CharsNotIn
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5232 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5234 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
Literal
 ( 
opener
 ) + ~ 
Literal
 ( 
closer
 ) +

5235 
CharsNotIn
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5236 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5238 raise 
ValueError
 ( "opening and closing arguments must be strings if no content expression is given" )

5239 
ret
 = 
Forward
 ( )

5240 if 
ignoreExpr
 is not None :

5241 
ret
 <<= 
Group
 ( 
Suppress
 ( 
opener
 ) + 
ZeroOrMore
 ( 
ignoreExpr
 | 
ret
 | 
content
 ) + 
Suppress
 ( 
closer
 ) )

5243 
ret
 <<= 
Group
 ( 
Suppress
 ( 
opener
 ) + 
ZeroOrMore
 ( 
ret
 | 
content
 ) + 
Suppress
 ( 
closer
 ) )

5244 
ret
 . 
setName
 ( 'nested %s%s expression' % ( 
opener
 , 
closer
 ) )

5245 return 
ret
 
	}

5247 def 
	$indentedBlock
 ( 
blockStatementExpr
 , 
indentStack
 , 
indent
 = True ) :

5325 def 
checkPeerIndent
 ( 
s
 , 
l
 , 
t
 ) :

5326 if 
l
 >= 
len
 ( 
s
 ) : return

5327 
curCol
 = 
col
 ( 
l
 , 
s
 )

5328 if 
curCol
 != 
indentStack
 [ - 1 ] :

5329 if 
curCol
 > 
indentStack
 [ - 1 ] :

5330 raise 
ParseFatalException
 ( 
s
 , 
l
 , "illegal nesting" )

5331 raise 
ParseException
 ( 
s
 , 
l
 , "not a peer entry" )

5333 def 
checkSubIndent
 ( 
s
 , 
l
 , 
t
 ) :

5334 
curCol
 = 
col
 ( 
l
 , 
s
 )

5335 if 
curCol
 > 
indentStack
 [ - 1 ] :

5336 
indentStack
 . 
append
 ( 
curCol
 )

5338 raise 
ParseException
 ( 
s
 , 
l
 , "not a subentry" )

5340 def 
checkUnindent
 ( 
s
 , 
l
 , 
t
 ) :

5341 if 
l
 >= 
len
 ( 
s
 ) : return

5342 
curCol
 = 
col
 ( 
l
 , 
s
 )

5343 if not ( 
indentStack
 and 
curCol
 < 
indentStack
 [ - 1 ] and 
curCol
 <= 
indentStack
 [ - 2 ] ) :

5344 raise 
ParseException
 ( 
s
 , 
l
 , "not an unindent" )

5345 
indentStack
 . 
pop
 ( )

5347 
NL
 = 
OneOrMore
 ( 
LineEnd
 ( ) . 
setWhitespaceChars
 ( "\t " ) . 
suppress
 ( ) )

5348 
INDENT
 = ( 
Empty
 ( ) + 
Empty
 ( ) . 
setParseAction
 ( 
checkSubIndent
 ) ) . 
setName
 ( 'INDENT' )

5349 
PEER
 = 
Empty
 ( ) . 
setParseAction
 ( 
checkPeerIndent
 ) . 
setName
 ( '' )

5350 
UNDENT
 = 
Empty
 ( ) . 
setParseAction
 ( 
checkUnindent
 ) . 
setName
 ( 'UNINDENT' )

5351 if 
indent
 :

5352 
smExpr
 = 
Group
 ( 
Optional
 ( 
NL
 ) +

5354 
INDENT
 + ( 
OneOrMore
 ( 
PEER
 + 
Group
 ( 
blockStatementExpr
 ) + 
Optional
 ( 
NL
 ) ) ) + 
UNDENT
 )

5356 
smExpr
 = 
Group
 ( 
Optional
 ( 
NL
 ) +

5357 ( 
OneOrMore
 ( 
PEER
 + 
Group
 ( 
blockStatementExpr
 ) + 
Optional
 ( 
NL
 ) ) ) )

5358 
blockStatementExpr
 . 
ignore
 ( 
_bslash
 + 
LineEnd
 ( ) )

5359 return 
smExpr
 . 
setName
 ( 'indented block' ) 
	}

5361 
alphas8bit
 = 
srange
 ( r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]" )

5362 
punc8bit
 = 
srange
 ( r"[\0xa1-\0xbf\0xd7\0xf7]" )

5364 
anyOpenTag
 , 
anyCloseTag
 = 
makeHTMLTags
 ( 
Word
 ( 
alphas
 , 
alphanums
 + "_:" ) . 
setName
 ( 'any tag' ) )

5365 
_htmlEntityMap
 = 
dict
 ( 
zip
 ( "gt lt amp nbsp quot apos" . 
split
 ( ) , '><& "\'' ) )

5366 
commonHTMLEntity
 = 
Regex
 ( '&(?P<entity>' + '|' . 
join
 ( 
_htmlEntityMap
 . 
keys
 ( ) ) + ");" ) . 
setName
 ( "common HTML entity" )

5367 def 
	$replaceHTMLEntity
 ( 
t
 ) :

5369 return 
_htmlEntityMap
 . 
get
 ( 
t
 . 
entity
 ) 
	}

5372 
cStyleComment
 = 
Combine
 ( 
Regex
 ( r"/\*(?:[^*]|\*(?!/))*" ) + '*/' ) . 
setName
 ( "C style comment" ) "Comment of the form C{/* ... */}"

5375 
htmlComment
 = 
Regex
 ( r"<!--[\s\S]*?-->" ) . 
setName
 ( "HTML comment" ) "Comment of the form C{<!-- ... -->}"

5378 
restOfLine
 = 
Regex
 ( r".*" ) . 
leaveWhitespace
 ( ) . 
setName
 ( "rest of line" )

5379 
dblSlashComment
 = 
Regex
 ( r"//(?:\\\n|[^\n])*" ) . 
setName
 ( "// comment" ) "Comment of the form C{// ... (to end of line)}"

5382 
cppStyleComment
 = 
Combine
 ( 
Regex
 ( r"/\*(?:[^*]|\*(?!/))*" ) + '*/' | 
dblSlashComment
 ) . 
setName
 ( "C++ style comment" ) "Comment of either form C{L{cStyleComment}} or C{L{dblSlashComment}}"

5385 
javaStyleComment
 = 
cppStyleComment
 "Same as C{L{cppStyleComment}}"

5388 
pythonStyleComment
 = 
Regex
 ( r"#.*" ) . 
setName
 ( "Python style comment" ) "Comment of the form C{# ... (to end of line)}"

5391 
_commasepitem
 = 
Combine
 ( 
OneOrMore
 ( 
Word
 ( 
printables
 , 
excludeChars
 = ',' ) +

5392 
Optional
 ( 
Word
 ( " \t" ) +

5393 ~ 
Literal
 ( "," ) + ~ 
LineEnd
 ( ) ) ) ) . 
streamline
 ( ) . 
setName
 ( "commaItem" )

5394 
commaSeparatedList
 = 
delimitedList
 ( 
Optional
 ( 
quotedString
 . 
copy
 ( ) | 
_commasepitem
 , 
default
 = "" ) ) . 
setName
 ( "commaSeparatedList" ) """(Deprecated) Predefined expression of 1 or more printable words or quoted strings, separated by commas.\n   This expression is deprecated in favor of L{pyparsing_common.comma_separated_list}."""

5399 class 
	cpyparsing_common
 :

5535 
convertToInteger
 = 
tokenMap
 ( 
int
 ) """\n    Parse action for converting parsed integers to Python int\n    """

5540 
convertToFloat
 = 
tokenMap
 ( 
float
 ) """\n    Parse action for converting parsed numbers to Python float\n    """

5545 
integer
 = 
Word
 ( 
nums
 ) . 
setName
 ( "integer" ) . 
setParseAction
 ( 
convertToInteger
 ) """expression that parses an unsigned integer, returns an int"""

5548 
hex_integer
 = 
Word
 ( 
hexnums
 ) . 
setName
 ( "hex integer" ) . 
setParseAction
 ( 
tokenMap
 ( 
int
 , 16 ) ) """expression that parses a hexadecimal integer, returns an int"""

5551 
signed_integer
 = 
Regex
 ( r'[+-]?\d+' ) . 
setName
 ( "signed integer" ) . 
setParseAction
 ( 
convertToInteger
 ) """expression that parses an integer with optional leading sign, returns an int"""

5554 
fraction
 = ( 
signed_integer
 ( ) . 
setParseAction
 ( 
convertToFloat
 ) + '/' + 
signed_integer
 ( ) . 
setParseAction
 ( 
convertToFloat
 ) ) . 
setName
 ( "fraction" ) """fractional expression of an integer divided by an integer, returns a float"""

5556 
fraction
 . 
addParseAction
 ( lambda 
t
 : 
t
 [ 0 ] / 
t
 [ - 1 ] )

5558 
mixed_integer
 = ( 
fraction
 | 
signed_integer
 + 
Optional
 ( 
Optional
 ( '-' ) . 
suppress
 ( ) + 
fraction
 ) ) . 
setName
 ( "fraction or mixed integer-fraction" ) """mixed integer of the form 'integer - fraction', with optional leading integer, returns float"""

5560 
mixed_integer
 . 
addParseAction
 ( 
sum
 )

5562 
real
 = 
Regex
 ( r'[+-]?\d+\.\d*' ) . 
setName
 ( "real number" ) . 
setParseAction
 ( 
convertToFloat
 ) """expression that parses a floating point number and returns a float"""

5565 
sci_real
 = 
Regex
 ( r'[+-]?\d+([eE][+-]?\d+|\.\d*([eE][+-]?\d+)?)' ) . 
setName
 ( "real number with scientific notation" ) . 
setParseAction
 ( 
convertToFloat
 ) """expression that parses a floating point number with optional scientific notation and returns a float"""

5569 
number
 = ( 
sci_real
 | 
real
 | 
signed_integer
 ) . 
streamline
 ( ) """any numeric expression, returns the corresponding Python type"""

5572 
fnumber
 = 
Regex
 ( r'[+-]?\d+\.?\d*([eE][+-]?\d+)?' ) . 
setName
 ( "fnumber" ) . 
setParseAction
 ( 
convertToFloat
 ) """any int or real number, returned as float"""

5575 
identifier
 = 
Word
 ( 
alphas
 + '_' , 
alphanums
 + '_' ) . 
setName
 ( "identifier" ) """typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')"""

5578 
ipv4_address
 = 
Regex
 ( r'(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}' ) . 
setName
 ( "IPv4 address" ) "IPv4 address (C{0.0.0.0 - 255.255.255.255})"

5581 
_ipv6_part
 = 
Regex
 ( r'[0-9a-fA-F]{1,4}' ) . 
setName
 ( "hex_integer" )

5582 
_full_ipv6_address
 = ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * 7 ) . 
setName
 ( "full IPv6 address" )

5583 
_short_ipv6_address
 = ( 
Optional
 ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * ( 0 , 6 ) ) + "::" + 
Optional
 ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * ( 0 , 6 ) ) ) . 
setName
 ( "short IPv6 address" )

5584 
_short_ipv6_address
 . 
addCondition
 ( lambda 
t
 : 
sum
 ( 1 for 
tt
 in 
t
 if 
pyparsing_common
 . 
_ipv6_part
 . 
matches
 ( 
tt
 ) ) < 8 )

5585 
_mixed_ipv6_address
 = ( "::ffff:" + 
ipv4_address
 ) . 
setName
 ( "mixed IPv6 address" )

5586 
ipv6_address
 = 
Combine
 ( ( 
_full_ipv6_address
 | 
_mixed_ipv6_address
 | 
_short_ipv6_address
 ) . 
setName
 ( "IPv6 address" ) ) . 
setName
 ( "IPv6 address" ) "IPv6 address (long, short, or mixed form)"

5589 
mac_address
 = 
Regex
 ( r'[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}' ) . 
setName
 ( "MAC address" ) "MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)"

5592 @ 
	`staticmethod

5593 def 
	$convertToDate
 ( 
fmt
 = "%Y-%m-%d" ) :

5607 def 
cvt_fn
 ( 
s
 , 
l
 , 
t
 ) :

5609 return 
datetime
 . 
strptime
 ( 
t
 [ 0 ] , 
fmt
 ) . 
date
 ( )

5610 except 
ValueError
 as 
ve
 :

5611 raise 
ParseException
 ( 
s
 , 
l
 , 
str
 ( 
ve
 ) )

5612 return 
cvt_fn
 
	}

5614 @ 
	`staticmethod

5615 def 
	$convertToDatetime
 ( 
fmt
 = "%Y-%m-%dT%H:%M:%S.%f" ) :

5629 def 
cvt_fn
 ( 
s
 , 
l
 , 
t
 ) :

5631 return 
datetime
 . 
strptime
 ( 
t
 [ 0 ] , 
fmt
 )

5632 except 
ValueError
 as 
ve
 :

5633 raise 
ParseException
 ( 
s
 , 
l
 , 
str
 ( 
ve
 ) )

5634 return 
cvt_fn
 
	}

5636 
iso8601_date
 = 
Regex
 ( r'(?P<year>\d{4})(?:-(?P<month>\d\d)(?:-(?P<day>\d\d))?)?' ) . 
setName
 ( "ISO8601 date" ) "ISO8601 date (C{yyyy-mm-dd})"

5639 
iso8601_datetime
 = 
Regex
 ( r'(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d)[T ](?P<hour>\d\d):(?P<minute>\d\d)(:(?P<second>\d\d(\.\d*)?)?)?(?P<tz>Z|[+-]\d\d:?\d\d)?' ) . 
setName
 ( "ISO8601 datetime" ) "ISO8601 datetime (C{yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)}) - trailing seconds, milliseconds, and timezone optional; accepts separating C{'T'} or C{' '}"

5642 
uuid
 = 
Regex
 ( r'[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}' ) . 
setName
 ( "UUID" ) "UUID (C{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx})"

5645 
_html_stripper
 = 
anyOpenTag
 . 
suppress
 ( ) | 
anyCloseTag
 . 
suppress
 ( )

5646 @ 
	`staticmethod

5647 def 
	$stripHTMLTags
 ( 
s
 , 
l
 , 
tokens
 ) :

5659 return 
pyparsing_common
 . 
_html_stripper
 . 
transformString
 ( 
tokens
 [ 0 ] ) 
	}

5661 
_commasepitem
 = 
Combine
 ( 
OneOrMore
 ( ~ 
Literal
 ( "," ) + ~ 
LineEnd
 ( ) + 
Word
 ( 
printables
 , 
excludeChars
 = ',' )

5662 + 
Optional
 ( 
White
 ( " \t" ) ) ) ) . 
streamline
 ( ) . 
setName
 ( "commaItem" )

5663 
comma_separated_list
 = 
delimitedList
 ( 
Optional
 ( 
quotedString
 . 
copy
 ( ) | 
_commasepitem
 , 
default
 = "" ) ) . 
setName
 ( "comma separated list" ) """Predefined expression of 1 or more printable words or quoted strings, separated by commas."""

5666 
upcaseTokens
 = 
staticmethod
 ( 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
upper
 ( ) ) ) """Parse action to convert tokens to upper case."""

5669 
downcaseTokens
 = 
staticmethod
 ( 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
lower
 ( ) ) ) """Parse action to convert tokens to lower case."""

5673 if 
__name__
 == "__main__" :

5675 
selectToken
 = 
CaselessLiteral
 ( "select" )

5676 
fromToken
 = 
CaselessLiteral
 ( "from" )

5678 
ident
 = 
Word
 ( 
alphas
 , 
alphanums
 + "_$" )

5680 
columnName
 = 
delimitedList
 ( 
ident
 , "." , 
combine
 = True ) . 
setParseAction
 ( 
upcaseTokens
 )

5681 
columnNameList
 = 
Group
 ( 
delimitedList
 ( 
columnName
 ) ) . 
setName
 ( "columns" )

5682 
columnSpec
 = ( '*' | 
columnNameList
 )

5684 
tableName
 = 
delimitedList
 ( 
ident
 , "." , 
combine
 = True ) . 
setParseAction
 ( 
upcaseTokens
 )

5685 
tableNameList
 = 
Group
 ( 
delimitedList
 ( 
tableName
 ) ) . 
setName
 ( "tables" )

5687 
simpleSQL
 = 
selectToken
 ( "command" ) + 
columnSpec
 ( "columns" ) + 
fromToken
 + 
tableNameList
 ( "tables" )

5690 
simpleSQL
 . 
runTests
 ( """\n        # '*' as column list and dotted table name\n        select * from SYS.XYZZY\n\n        # caseless match on "SELECT", and casts back to "select"\n        SELECT * from XYZZY, ABC\n\n        # list of column names, and mixed case SELECT keyword\n        Select AA,BB,CC from Sys.dual\n\n        # multiple tables\n        Select A, B, C from Sys.dual, Table2\n\n        # invalid SELECT keyword - should fail\n        Xelect A, B, C from Sys.dual\n\n        # incomplete command - should fail\n        Select\n\n        # invalid column name - should fail\n        Select ^^^ frox Sys.dual\n\n        """

5714 
pyparsing_common
 . 
number
 . 
runTests
 ( """\n        100\n        -100\n        +100\n        3.14159\n        6.02e23\n        1e-12\n        """

5724 
pyparsing_common
 . 
fnumber
 . 
runTests
 ( """\n        100\n        -100\n        +100\n        3.14159\n        6.02e23\n        1e-12\n        """

5733 
pyparsing_common
 . 
hex_integer
 . 
runTests
 ( """\n        100\n        FF\n        """

5738 import 
	~uuid

5739 
pyparsing_common
 . 
uuid
 . 
setParseAction
 ( 
tokenMap
 ( 
uuid
 . 
UUID
 ) )

5740 
pyparsing_common
 . 
uuid
 . 
runTests
 ( """\n        12345678-1234-5678-1234-567812345678\n        """


	@./env/lib/python3.7/site-packages/pkg_resources/extern/__init__.py

1 import 
	~sys

4 class 
	cVendorImporter
 :

10 def 
	$__init__
 ( 
self
 , 
root_name
 , 
vendored_names
 = ( ) , 
vendor_pkg
 = None ) :

11 
self
 . 
root_name
 = 
root_name

12 
self
 . 
vendored_names
 = 
set
 ( 
vendored_names
 )

13 
self
 . 
vendor_pkg
 = 
vendor_pkg
 or 
root_name
 . 
replace
 ( 'extern' , '_vendor' ) 
	}

15 @ 
property

16 def 
	$search_path
 ( 
self
 ) :

20 yield 
self
 . 
vendor_pkg
 + '.'

21 yield '' 
	}

23 def 
	$find_module
 ( 
self
 , 
fullname
 , 
path
 = None ) :

28 
root
 , 
base
 , 
target
 = 
fullname
 . 
partition
 ( 
self
 . 
root_name
 + '.' )

29 if 
root
 :

31 if not 
any
 ( 
map
 ( 
target
 . 
startswith
 , 
self
 . 
vendored_names
 ) ) :

33 return 
self
 
	}

35 def 
	$load_module
 ( 
self
 , 
fullname
 ) :

39 
root
 , 
base
 , 
target
 = 
fullname
 . 
partition
 ( 
self
 . 
root_name
 + '.' )

40 for 
prefix
 in 
self
 . 
search_path
 :

42 
extant
 = 
prefix
 + 
target

43 
__import__
 ( 
extant
 )

44 
mod
 = 
sys
 . 
modules
 [ 
extant
 ]

45 
sys
 . 
modules
 [ 
fullname
 ] = 
mod

51 if 
prefix
 and 
sys
 . 
version_info
 > ( 3 , 3 ) :

52 del 
sys
 . 
modules
 [ 
extant
 ]

53 return 
mod

54 except 
ImportError
 :

57 raise 
ImportError
 ( "The '{target}' package is required; " "normally this is bundled with this package so if you get " "this warning, consult the packager of your " "distribution."

61 . 
format
 ( ** 
locals
 ( ) )

62 ) 
	}

64 def 
	$install
 ( 
self
 ) :

68 if 
self
 not in 
sys
 . 
meta_path
 :

69 
sys
 . 
meta_path
 . 
append
 ( 
self
 ) 
	}

72 
names
 = 'packaging' , 'pyparsing' , 'six' , 'appdirs'

73 
VendorImporter
 ( 
__name__
 , 
names
 ) . 
install
 ( )


	@./env/lib/python3.7/site-packages/easy_install.py

3 if 
__name__
 == '__main__' :

4 from 
	~setuptools.command.easy_install
 import 
main

5 
main
 ( )


	@./env/lib/python3.7/site-packages/regex/test/test_regex.py

1 import 
	~regex

2 import 
	~string

3 from 
	~weakref
 import 
proxy

4 import 
	~unittest

5 import 
	~copy

6 import 
	~pickle

7 from 
	~test.support
 import 
run_unittest

8 import 
	~sys

11 class 
	cStrSubclass
 ( 
str
 ) :

12 def 
	$__getitem__
 ( 
self
 , 
index
 ) :

13 return 
StrSubclass
 ( 
super
 ( ) . 
__getitem__
 ( 
index
 ) ) 
	}

15 class 
	cBytesSubclass
 ( 
bytes
 ) :

16 def 
	$__getitem__
 ( 
self
 , 
index
 ) :

17 return 
BytesSubclass
 ( 
super
 ( ) . 
__getitem__
 ( 
index
 ) ) 
	}

19 class 
	cRegexTests
 ( 
unittest
 . 
TestCase
 ) :

20 
PATTERN_CLASS
 = "<class '_regex.Pattern'>"

21 
FLAGS_WITH_COMPILED_PAT
 = "cannot process flags argument with a compiled pattern"

22 
INVALID_GROUP_REF
 = "invalid group reference"

23 
MISSING_GT
 = "missing >"

24 
BAD_GROUP_NAME
 = "bad character in group name"

25 
MISSING_GROUP_NAME
 = "missing group name"

26 
MISSING_LT
 = "missing <"

27 
UNKNOWN_GROUP_I
 = "unknown group"

28 
UNKNOWN_GROUP
 = "unknown group"

29 
BAD_ESCAPE
 = r"bad escape \(end of pattern\)"

30 
BAD_OCTAL_ESCAPE
 = r"bad escape \\"

31 
BAD_SET
 = "unterminated character set"

32 
STR_PAT_ON_BYTES
 = "cannot use a string pattern on a bytes-like object"

33 
BYTES_PAT_ON_STR
 = "cannot use a bytes pattern on a string-like object"

34 
STR_PAT_BYTES_TEMPL
 = "expected str instance, bytes found"

35 
BYTES_PAT_STR_TEMPL
 = "expected a bytes-like object, str found"

36 
BYTES_PAT_UNI_FLAG
 = "cannot use UNICODE flag with a bytes pattern"

37 
MIXED_FLAGS
 = "ASCII, LOCALE and UNICODE flags are mutually incompatible"

38 
MISSING_RPAREN
 = "missing \\)"

39 
TRAILING_CHARS
 = "unbalanced parenthesis"

40 
BAD_CHAR_RANGE
 = "bad character range"

41 
NOTHING_TO_REPEAT
 = "nothing to repeat"

42 
MULTIPLE_REPEAT
 = "multiple repeat"

43 
OPEN_GROUP
 = "cannot refer to an open group"

44 
DUPLICATE_GROUP
 = "duplicate group"

45 
CANT_TURN_OFF
 = "bad inline flags: cannot turn flags off"

46 
UNDEF_CHAR_NAME
 = "undefined character name"

48 def 
	$assertTypedEqual
 ( 
self
 , 
actual
 , 
expect
 , 
msg
 = None ) :

49 
self
 . 
assertEqual
 ( 
actual
 , 
expect
 , 
msg
 )

51 def 
recurse
 ( 
actual
 , 
expect
 ) :

52 if 
isinstance
 ( 
expect
 , ( 
tuple
 , 
list
 ) ) :

53 for 
x
 , 
y
 in 
zip
 ( 
actual
 , 
expect
 ) :

54 
recurse
 ( 
x
 , 
y
 )

56 
self
 . 
assertIs
 ( 
type
 ( 
actual
 ) , 
type
 ( 
expect
 ) , 
msg
 )

58 
recurse
 ( 
actual
 , 
expect
 ) 
	}

60 def 
	$test_weakref
 ( 
self
 ) :

61 
s
 = 'QabbbcR'

62 
x
 = 
regex
 . 
compile
 ( 'ab+c' )

63 
y
 = 
proxy
 ( 
x
 )

64 if 
x
 . 
findall
 ( 'QabbbcR' ) != 
y
 . 
findall
 ( 'QabbbcR' ) :

65 
self
 . 
fail
 ( ) 
	}

67 def 
	$test_search_star_plus
 ( 
self
 ) :

68 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'a*' , 'xxx' ) . 
span
 ( 0 ) , ( 0 , 0 ) )

69 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'x*' , 'axx' ) . 
span
 ( ) , ( 0 , 0 ) )

70 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'x+' , 'axx' ) . 
span
 ( 0 ) , ( 1 , 3 ) )

71 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'x+' , 'axx' ) . 
span
 ( ) , ( 1 , 3 ) )

72 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'x' , 'aaa' ) , None )

73 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a*' , 'xxx' ) . 
span
 ( 0 ) , ( 0 , 0 ) )

74 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a*' , 'xxx' ) . 
span
 ( ) , ( 0 , 0 ) )

75 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'x*' , 'xxxa' ) . 
span
 ( 0 ) , ( 0 , 3 ) )

76 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'x*' , 'xxxa' ) . 
span
 ( ) , ( 0 , 3 ) )

77 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a+' , 'xxx' ) , None ) 
	}

79 def 
	$bump_num
 ( 
self
 , 
matchobj
 ) :

80 
int_value
 = 
int
 ( 
matchobj
 [ 0 ] )

81 return 
str
 ( 
int_value
 + 1 ) 
	}

83 def 
	$test_basic_regex_sub
 ( 
self
 ) :

84 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( "(?i)b+" , "x" , "bbbb BBBB" ) , 'x x' )

85 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'\d+' , 
self
 . 
bump_num
 , '08.2 -2 23x99y' ) , '9.3 -3 24x100y'

87 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'\d+' , 
self
 . 
bump_num
 , '08.2 -2 23x99y' , 3 ) , '9.3 -3 23x99y'

90 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '.' , lambda 
m
 : r"\n" , 'x' ) , "\\n" )

91 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '.' , r"\n" , 'x' ) , "\n" )

93 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<a>\g<a>' , 'xx' ) , 'xxxx' )

94 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<a>\g<1>' , 'xx' ) , 'xxxx' )

95 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<unk>x)' , r'\g<unk>\g<unk>' , 'xx' ) , 'xxxx'

97 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<unk>x)' , r'\g<1>\g<1>' , 'xx' ) , 'xxxx' )

99 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'a' , r'\t\n\v\r\f\a\b\B\Z\a\A\w\W\s\S\d\D' , 'a'

101 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'a' , '\t\n\v\r\f\a' , 'a' ) , "\t\n\v\r\f\a" )

102 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'a' , '\t\n\v\r\f\a' , 'a' ) , 
chr
 ( 9 ) + 
chr
 ( 10 )

103 + 
chr
 ( 11 ) + 
chr
 ( 13 ) + 
chr
 ( 12 ) + 
chr
 ( 7 ) )

105 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'^\s*' , 'X' , 'test' ) , 'Xtest' )

107 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"x" , r"\x0A" , "x" ) , "\n" )

108 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"x" , r"\u000A" , "x" ) , "\n" )

109 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"x" , r"\U0000000A" , "x" ) , "\n" )

110 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"x" , r"\N{LATIN CAPITAL LETTER A}" , "x"

113 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( br"x" , br"\x0A" , b"x" ) , b"\n" )

114 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( br"x" , br"\u000A" , b"x" ) , b"\\u000A" )

115 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( br"x" , br"\U0000000A" , b"x" ) , b"\\U0000000A"

117 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( br"x" , br"\N{LATIN CAPITAL LETTER A}" , b"x"

118 ) , b"\\N{LATIN CAPITAL LETTER A}" ) 
	}

120 def 
	$test_bug_449964
 ( 
self
 ) :

122 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(?P<unk>x)' , r'\g<1>\g<1>\b' , 'xx' ) , "xx\bxx\b"

123 ) 
	}

125 def 
	$test_bug_449000
 ( 
self
 ) :

127 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'\r\n' , r'\n' , 'abc\r\ndef\r\n' ) , "abc\ndef\n"

129 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '\r\n' , r'\n' , 'abc\r\ndef\r\n' ) , "abc\ndef\n"

131 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'\r\n' , '\n' , 'abc\r\ndef\r\n' ) , "abc\ndef\n"

133 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '\r\n' , '\n' , 'abc\r\ndef\r\n' ) , "abc\ndef\n"

134 ) 
	}

136 def 
	$test_bug_1661
 ( 
self
 ) :

138 
pattern
 = 
regex
 . 
compile
 ( '.' )

139 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
FLAGS_WITH_COMPILED_PAT
 ,

140 lambda : 
regex
 . 
match
 ( 
pattern
 , 'A' , 
regex
 . 
I
 ) )

141 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
FLAGS_WITH_COMPILED_PAT
 ,

142 lambda : 
regex
 . 
search
 ( 
pattern
 , 'A' , 
regex
 . 
I
 ) )

143 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
FLAGS_WITH_COMPILED_PAT
 ,

144 lambda : 
regex
 . 
findall
 ( 
pattern
 , 'A' , 
regex
 . 
I
 ) )

145 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
FLAGS_WITH_COMPILED_PAT
 ,

146 lambda : 
regex
 . 
compile
 ( 
pattern
 , 
regex
 . 
I
 ) ) 
	}

148 def 
	$test_bug_3629
 ( 
self
 ) :

150 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( "(?P<quote>)(?(quote))" ) ) ) ,

151 
self
 . 
PATTERN_CLASS
 ) 
	}

153 def 
	$test_sub_template_numeric_escape
 ( 
self
 ) :

155 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\0' , 'x' ) , "\0" )

156 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\000' , 'x' ) , "\000" )

157 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\001' , 'x' ) , "\001" )

158 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\008' , 'x' ) , "\0" + "8" )

159 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\009' , 'x' ) , "\0" + "9" )

160 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\111' , 'x' ) , "\111" )

161 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\117' , 'x' ) , "\117" )

163 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\1111' , 'x' ) , "\1111" )

164 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\1111' , 'x' ) , "\111" + "1" )

166 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\00' , 'x' ) , '\x00' )

167 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\07' , 'x' ) , '\x07' )

168 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\08' , 'x' ) , "\0" + "8" )

169 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\09' , 'x' ) , "\0" + "9" )

170 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\0a' , 'x' ) , "\0" + "a" )

172 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\400' , 'x' ) , "\u0100" )

173 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x' , r'\777' , 'x' ) , "\u01FF" )

174 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( b'x' , br'\400' , b'x' ) , b"\x00" )

175 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( b'x' , br'\777' , b'x' ) , b"\xFF" )

177 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

178 
regex
 . 
sub
 ( 'x' , r'\1' , 'x' ) )

179 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

180 
regex
 . 
sub
 ( 'x' , r'\8' , 'x' ) )

181 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

182 
regex
 . 
sub
 ( 'x' , r'\9' , 'x' ) )

183 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

184 
regex
 . 
sub
 ( 'x' , r'\11' , 'x' ) )

185 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

186 
regex
 . 
sub
 ( 'x' , r'\18' , 'x' ) )

187 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

188 
regex
 . 
sub
 ( 'x' , r'\1a' , 'x' ) )

189 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

190 
regex
 . 
sub
 ( 'x' , r'\90' , 'x' ) )

191 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

192 
regex
 . 
sub
 ( 'x' , r'\99' , 'x' ) )

193 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

194 
regex
 . 
sub
 ( 'x' , r'\118' , 'x' ) )

195 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

196 
regex
 . 
sub
 ( 'x' , r'\11a' , 'x' ) )

197 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

198 
regex
 . 
sub
 ( 'x' , r'\181' , 'x' ) )

199 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

200 
regex
 . 
sub
 ( 'x' , r'\800' , 'x' ) )

203 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(((((((((((x)))))))))))' , r'\11' , 'x' ) , 'x'

205 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '((((((((((y))))))))))(.)' , r'\118' , 'xyz' ) , 'xz8'

207 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '((((((((((y))))))))))(.)' , r'\11a' , 'xyz' ) , 'xza'

208 ) 
	}

210 def 
	$test_qualified_re_sub
 ( 
self
 ) :

211 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'a' , 'b' , 'aaaaa' ) , 'bbbbb' )

212 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'a' , 'b' , 'aaaaa' , 1 ) , 'baaaa' ) 
	}

214 def 
	$test_bug_114660
 ( 
self
 ) :

215 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(\S)\s+(\S)' , r'\1 \2' , 'hello  there' ) , 'hello there'

216 ) 
	}

218 def 
	$test_bug_462270
 ( 
self
 ) :

220 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

221 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0)x*' , '-' , 'abxd' ) , '-a-b--d-' )

223 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0)x*' , '-' , 'abxd' ) , '-a-b-d-' )

224 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V1)x*' , '-' , 'abxd' ) , '-a-b--d-' )

225 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( 'x+' , '-' , 'abxd' ) , 'ab-d' ) 
	}

227 def 
	$test_bug_14462
 ( 
self
 ) :

229 
group_name
 = '\xFF'

230 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?P<' + 
group_name
 + '>a)' , 'abc'

231 ) . 
group
 ( 
group_name
 ) , 'a' ) 
	}

233 def 
	$test_symbolic_refs
 ( 
self
 ) :

234 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
MISSING_GT
 , lambda :

235 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<a' , 'xx' ) )

236 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
MISSING_GROUP_NAME
 , lambda :

237 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<' , 'xx' ) )

238 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
MISSING_LT
 , lambda :

239 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g' , 'xx' ) )

240 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 , lambda :

241 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<a a>' , 'xx' ) )

242 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 , lambda :

243 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<1a1>' , 'xx' ) )

244 
self
 . 
assertRaisesRegex
 ( 
IndexError
 , 
self
 . 
UNKNOWN_GROUP_I
 , lambda :

245 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<ab>' , 'xx' ) )

249 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<a>x)|(?P<b>y)' , r'\g<b>' , 'xx' ) , '' )

250 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?P<a>x)|(?P<b>y)' , r'\2' , 'xx' ) , '' )

253 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 , lambda :

254 
regex
 . 
sub
 ( '(?P<a>x)' , r'\g<-1>' , 'xx' ) ) 
	}

256 def 
	$test_re_subn
 ( 
self
 ) :

257 
self
 . 
assertEqual
 ( 
regex
 . 
subn
 ( "(?i)b+" , "x" , "bbbb BBBB" ) , ( 'x x' , 2 ) )

258 
self
 . 
assertEqual
 ( 
regex
 . 
subn
 ( "b+" , "x" , "bbbb BBBB" ) , ( 'x BBBB' , 1 ) )

259 
self
 . 
assertEqual
 ( 
regex
 . 
subn
 ( "b+" , "x" , "xyz" ) , ( 'xyz' , 0 ) )

260 
self
 . 
assertEqual
 ( 
regex
 . 
subn
 ( "b*" , "x" , "xyz" ) , ( 'xxxyxzx' , 4 ) )

261 
self
 . 
assertEqual
 ( 
regex
 . 
subn
 ( "b*" , "x" , "xyz" , 2 ) , ( 'xxxyz' , 2 ) ) 
	}

263 def 
	$test_re_split
 ( 
self
 ) :

264 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( ":" , ":a:b::c" ) , [ '' , 'a' , 'b' , '' , 'c' ] )

265 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

266 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( ":*" , ":a:b::c" ) , [ '' , '' , 'a' , '' , 'b'

268 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:*)" , ":a:b::c" ) , [ '' , ':' , '' , '' , 'a'

270 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?::*)" , ":a:b::c" ) , [ '' , '' , 'a' , ''

272 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:)*" , ":a:b::c" ) , [ '' , ':' , '' ,

275 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( ":*" , ":a:b::c" ) , [ '' , 'a' , 'b' , 'c' ] )

276 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:*)" , ":a:b::c" ) , [ '' , ':' , 'a' , ':'

278 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?::*)" , ":a:b::c" ) , [ '' , 'a' , 'b' , 'c'

280 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:)*" , ":a:b::c" ) , [ '' , ':' , 'a' , ':'

282 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "([b:]+)" , ":a:b::c" ) , [ '' , ':' , 'a' , ':b::'

284 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(b)|(:+)" , ":a:b::c" ) , [ '' , None , ':' , 'a'

286 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?:b)|(?::+)" , ":a:b::c" ) , [ '' , 'a' , '' , ''

289 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "x" , "xaxbxc" ) , [ '' , 'a' , 'b' , 'c' ] )

290 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "x" , "xaxbxc" ) ] , [ '' , 'a' , 'b'

293 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?r)x" , "xaxbxc" ) , [ 'c' , 'b' , 'a' , '' ] )

294 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?r)x" , "xaxbxc" ) ] , [ 'c' , 'b'

297 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(x)|(y)" , "xaxbxc" ) , [ '' , 'x' , None , 'a' , 'x'

299 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(x)|(y)" , "xaxbxc" ) ] ,

302 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?r)(x)|(y)" , "xaxbxc" ) , [ 'c' , 'x' , None , 'b'

304 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?r)(x)|(y)" , "xaxbxc" ) ] ,

307 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\b" , "a b c" ) , [ '' , 'a' , ' ' , 'b' , ' '

309 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\m" , "a b c" ) , [ '' , 'a ' , 'b ' , 'c'

311 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\M" , "a b c" ) , [ 'a' , ' b' , ' c' , ''

312 ] ) 
	}

314 def 
	$test_qualified_re_split
 ( 
self
 ) :

315 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( ":" , ":a:b::c" , 2 ) , [ '' , 'a' , 'b::c' ] )

316 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( ':' , 'a:b:c:d' , 2 ) , [ 'a' , 'b' , 'c:d' ] )

317 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:)" , ":a:b::c" , 2 ) , [ '' , ':' , 'a' , ':' , 'b::c'

320 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

321 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:*)" , ":a:b::c" , 2 ) , [ '' , ':' , '' , ''

324 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(:*)" , ":a:b::c" , 2 ) , [ '' , ':' , 'a' , ':'

325 , 'b::c' ] ) 
	}

327 def 
	$test_re_findall
 ( 
self
 ) :

328 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( ":+" , "abc" ) , [ ] )

329 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( ":+" , "a:b::c:::d" ) , [ ':' , '::' , ':::' ] )

330 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "(:+)" , "a:b::c:::d" ) , [ ':' , '::' , ':::'

332 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "(:)(:*)" , "a:b::c:::d" ) , [ ( ':' , '' ) ,

335 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?P<test>.{0,5}?TEST)\)" , "(MY TEST)"

337 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?P<test>.{0,3}?TEST)\)" , "(MY TEST)"

339 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?P<test>.{0,3}?T)\)" , "(MY T)" ) ,

342 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[^a]{2}[A-Z]" , "\n  S" ) , [ '  S' ] )

343 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[^a]{2,3}[A-Z]" , "\n  S" ) , [ '\n  S' ] )

344 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[^a]{2,3}[A-Z]" , "\n   S" ) , [ '   S' ] )

346 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"X(Y[^Y]+?){1,2}( |Q)+DEF" , "XYABCYPPQ\nQ DEF"

349 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(\nTest(\n+.+?){0,2}?)?\n+End" , "\nTest\nxyz\nxyz\nEnd"

350 ) , [ ( '\nTest\nxyz\nxyz' , '\nxyz' ) ] ) 
	}

352 def 
	$test_bug_117612
 ( 
self
 ) :

353 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(a|(b))" , "aba" ) , [ ( 'a' , '' ) , ( 'b' , 'b'

354 ) , ( 'a' , '' ) ] ) 
	}

356 def 
	$test_re_match
 ( 
self
 ) :

357 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a' , 'a' ) [ : ] , ( 'a' , ) )

358 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)' , 'a' ) [ : ] , ( 'a' , 'a' ) )

359 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)' , 'a' ) [ 0 ] , 'a' )

360 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)' , 'a' ) [ 1 ] , 'a' )

361 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)' , 'a' ) . 
group
 ( 1 , 1 ) , ( 'a' , 'a' ) )

363 
pat
 = 
regex
 . 
compile
 ( '((a)|(b))(c)?' )

364 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'a' ) [ : ] , ( 'a' , 'a' , 'a' , None , None ) )

365 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'b' ) [ : ] , ( 'b' , 'b' , None , 'b' , None ) )

366 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'ac' ) [ : ] , ( 'ac' , 'a' , 'a' , None , 'c' ) )

367 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'bc' ) [ : ] , ( 'bc' , 'b' , None , 'b' , 'c' ) )

368 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'bc' ) [ : ] , ( 'bc' , 'b' , None , 'b' , 'c' ) )

371 
m
 = 
regex
 . 
match
 ( '(a)' , 'a' )

372 
self
 . 
assertEqual
 ( 
m
 . 
group
 ( ) , 'a' )

373 
self
 . 
assertEqual
 ( 
m
 . 
group
 ( 0 ) , 'a' )

374 
self
 . 
assertEqual
 ( 
m
 . 
group
 ( 1 ) , 'a' )

375 
self
 . 
assertEqual
 ( 
m
 . 
group
 ( 1 , 1 ) , ( 'a' , 'a' ) )

377 
pat
 = 
regex
 . 
compile
 ( '(?:(?P<a1>a)|(?P<b2>b))(?P<c3>c)?' )

378 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'a' ) . 
group
 ( 1 , 2 , 3 ) , ( 'a' , None , None ) )

379 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'b' ) . 
group
 ( 'a1' , 'b2' , 'c3' ) , ( None , 'b' ,

381 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 'ac' ) . 
group
 ( 1 , 'b2' , 3 ) , ( 'a' , None , 'c' ) ) 
	}

383 def 
	$test_re_groupref_exists
 ( 
self
 ) :

384 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\()?([^()]+)(?(1)\))$' , '(a)' ) [ : ] ,

386 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\()?([^()]+)(?(1)\))$' , 'a' ) [ : ] , ( 'a' ,

388 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\()?([^()]+)(?(1)\))$' , 'a)' ) , None )

389 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\()?([^()]+)(?(1)\))$' , '(a' ) , None )

390 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(?:(a)|c)((?(1)b|d))$' , 'ab' ) [ : ] , ( 'ab' , 'a'

392 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(?:(a)|c)((?(1)b|d))$' , 'cd' ) [ : ] , ( 'cd' ,

394 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(?:(a)|c)((?(1)|d))$' , 'cd' ) [ : ] , ( 'cd' ,

396 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(?:(a)|c)((?(1)|d))$' , 'a' ) [ : ] , ( 'a' , 'a'

400 
p
 = 
regex
 . 
compile
 ( '(?P<g1>a)(?P<g2>b)?((?(g2)c|d))' )

401 
self
 . 
assertEqual
 ( 
p
 . 
match
 ( 'abc' ) [ : ] , ( 'abc' , 'a' , 'b' , 'c' ) )

402 
self
 . 
assertEqual
 ( 
p
 . 
match
 ( 'ad' ) [ : ] , ( 'ad' , 'a' , None , 'd' ) )

403 
self
 . 
assertEqual
 ( 
p
 . 
match
 ( 'abd' ) , None )

404 
self
 . 
assertEqual
 ( 
p
 . 
match
 ( 'ac' ) , None ) 
	}

406 def 
	$test_re_groupref
 ( 
self
 ) :

407 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\|)?([^()]+)\1$' , '|a|' ) [ : ] , ( '|a|' , '|'

409 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\|)?([^()]+)\1?$' , 'a' ) [ : ] , ( 'a' ,

411 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\|)?([^()]+)\1$' , 'a|' ) , None )

412 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(\|)?([^()]+)\1$' , '|a' ) , None )

413 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(?:(a)|c)(\1)$' , 'aa' ) [ : ] , ( 'aa' , 'a' , 'a'

415 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'^(?:(a)|c)(\1)?$' , 'c' ) [ : ] , ( 'c' , None ,

418 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?i)(.{1,40}?),(.{1,40}?)(?:;)+(.{1,80}).{1,40}?\3(\ |;)+(.{1,80}?)\1" , "TEST, BEST; LEST ; Lest 123 Test, Best"

420 , ' ' , '123 ' ) ] ) 
	}

422 def 
	$test_groupdict
 ( 
self
 ) :

423 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?P<first>first) (?P<second>second)' , 'first second'

424 ) . 
groupdict
 ( ) , { 'first' : 'first' , 'second' : 'second' } ) 
	}

426 def 
	$test_expand
 ( 
self
 ) :

427 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?P<first>first) (?P<second>second)" , "first second"

428 ) . 
expand
 ( r"\2 \1 \g<second> \g<first>" ) , 'second first second first'

429 ) 
	}

431 def 
	$test_repeat_minmax
 ( 
self
 ) :

432 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1}$" , "abc" ) , None )

433 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1}?$" , "abc" ) , None )

434 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,2}$" , "abc" ) , None )

435 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,2}?$" , "abc" ) , None )

437 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){3}$" , "abc" ) [ 1 ] , 'c' )

438 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,3}$" , "abc" ) [ 1 ] , 'c' )

439 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,4}$" , "abc" ) [ 1 ] , 'c' )

440 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){3,4}?$" , "abc" ) [ 1 ] , 'c' )

441 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){3}?$" , "abc" ) [ 1 ] , 'c' )

442 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,3}?$" , "abc" ) [ 1 ] , 'c' )

443 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){1,4}?$" , "abc" ) [ 1 ] , 'c' )

444 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^(\w){3,4}?$" , "abc" ) [ 1 ] , 'c' )

446 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1}$" , "xxx" ) , None )

447 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1}?$" , "xxx" ) , None )

448 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1,2}$" , "xxx" ) , None )

449 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1,2}?$" , "xxx" ) , None )

451 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1}" , "xxx" ) [ 0 ] , 'x' )

452 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{1}?" , "xxx" ) [ 0 ] , 'x' )

453 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{0,1}" , "xxx" ) [ 0 ] , 'x' )

454 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{0,1}?" , "xxx" ) [ 0 ] , '' )

456 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{3}$" , "xxx" ) ) , True )

457 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{1,3}$" , "xxx" ) ) , True )

458 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{1,4}$" , "xxx" ) ) , True )

459 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{3,4}?$" , "xxx" ) ) , True )

460 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{3}?$" , "xxx" ) ) , True )

461 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{1,3}?$" , "xxx" ) ) , True )

462 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{1,4}?$" , "xxx" ) ) , True )

463 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{3,4}?$" , "xxx" ) ) , True )

465 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "^x{}$" , "xxx" ) , None )

466 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "^x{}$" , "x{}" ) ) , True ) 
	}

468 def 
	$test_getattr
 ( 
self
 ) :

469 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( "(?i)(a)(b)" ) . 
pattern
 , '(?i)(a)(b)' )

470 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( "(?i)(a)(b)" ) . 
flags
 , 
regex
 . 
I
 | 
regex
 . 
U
 |

471 
regex
 . 
DEFAULT_VERSION
 )

472 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( b"(?i)(a)(b)" ) . 
flags
 , 
regex
 . 
A
 | 
regex
 . 
I

473 | 
regex
 . 
DEFAULT_VERSION
 )

474 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( "(?i)(a)(b)" ) . 
groups
 , 2 )

475 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( "(?i)(a)(b)" ) . 
groupindex
 , { } )

477 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( "(?i)(?P<first>a)(?P<other>b)" ) . 
groupindex
 ,

480 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)" , "a" ) . 
pos
 , 0 )

481 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)" , "a" ) . 
endpos
 , 1 )

483 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "b(c)" , "abcdef" ) . 
pos
 , 0 )

484 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "b(c)" , "abcdef" ) . 
endpos
 , 6 )

485 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "b(c)" , "abcdef" ) . 
span
 ( ) , ( 1 , 3 ) )

486 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "b(c)" , "abcdef" ) . 
span
 ( 1 ) , ( 2 , 3 ) )

488 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)" , "a" ) . 
string
 , 'a' )

489 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)" , "a" ) . 
regs
 , ( ( 0 , 1 ) , ( 0 , 1 ) ) )

490 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
match
 ( "(a)" , "a" ) . 
re
 ) ) ,

491 
self
 . 
PATTERN_CLASS
 )

494 
p
 = 
regex
 . 
compile
 ( r'abc(?P<n>def)' )

495 
p
 . 
groupindex
 [ "n" ] = 0

496 
self
 . 
assertEqual
 ( 
p
 . 
groupindex
 [ "n" ] , 1 ) 
	}

498 def 
	$test_special_escapes
 ( 
self
 ) :

499 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\b(b.)\b" , "abcd abc bcd bx" ) [ 1 ] , 'bx' )

500 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\B(b.)\B" , "abc bcd bc abxd" ) [ 1 ] , 'bx' )

501 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"\b(b.)\b" , b"abcd abc bcd bx" ,

502 
regex
 . 
LOCALE
 ) [ 1 ] , b'bx' )

503 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"\B(b.)\B" , b"abc bcd bc abxd" ,

504 
regex
 . 
LOCALE
 ) [ 1 ] , b'bx' )

505 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\b(b.)\b" , "abcd abc bcd bx" ,

506 
regex
 . 
UNICODE
 ) [ 1 ] , 'bx' )

507 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\B(b.)\B" , "abc bcd bc abxd" ,

508 
regex
 . 
UNICODE
 ) [ 1 ] , 'bx' )

510 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^abc$" , "\nabc\n" , 
regex
 . 
M
 ) [ 0 ] , 'abc' )

511 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^\Aabc\Z$" , "abc" , 
regex
 . 
M
 ) [ 0 ] , 'abc' )

512 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^\Aabc\Z$" , "\nabc\n" , 
regex
 . 
M
 ) , None )

514 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"\b(b.)\b" , b"abcd abc bcd bx" ) [ 1 ] , b'bx'

516 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"\B(b.)\B" , b"abc bcd bc abxd" ) [ 1 ] , b'bx'

518 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"^abc$" , b"\nabc\n" , 
regex
 . 
M
 ) [ 0 ] , b'abc'

520 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"^\Aabc\Z$" , b"abc" , 
regex
 . 
M
 ) [ 0 ] , b'abc'

522 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"^\Aabc\Z$" , b"\nabc\n" , 
regex
 . 
M
 ) ,

525 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\d\D\w\W\s\S" , "1aa! a" ) [ 0 ] , '1aa! a' )

526 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"\d\D\w\W\s\S" , b"1aa! a" ,

527 
regex
 . 
LOCALE
 ) [ 0 ] , b'1aa! a' )

528 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\d\D\w\W\s\S" , "1aa! a" ,

529 
regex
 . 
UNICODE
 ) [ 0 ] , '1aa! a' ) 
	}

531 def 
	$test_bigcharset
 ( 
self
 ) :

532 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"([\u2222\u2223])" , "\u2222" ) [ 1 ] , '\u2222'

534 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"([\u2222\u2223])" , "\u2222" ,

535 
regex
 . 
UNICODE
 ) [ 1 ] , '\u2222' )

536 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( "." , "e\xe8\xe9\xea\xeb\u0113\u011b\u0117"

537 , 
flags
 = 
regex
 . 
UNICODE
 ) ) , 'e\xe8\xe9\xea\xeb\u0113\u011b\u0117'

539 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[e\xe8\xe9\xea\xeb\u0113\u011b\u0117]" , "e\xe8\xe9\xea\xeb\u0113\u011b\u0117"

540 , 
flags
 = 
regex
 . 
UNICODE
 ) ) , 'e\xe8\xe9\xea\xeb\u0113\u011b\u0117'

542 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"e|\xe8|\xe9|\xea|\xeb|\u0113|\u011b|\u0117" , "e\xe8\xe9\xea\xeb\u0113\u011b\u0117"

543 , 
flags
 = 
regex
 . 
UNICODE
 ) ) , 'e\xe8\xe9\xea\xeb\u0113\u011b\u0117'

544 ) 
	}

546 def 
	$test_anyall
 ( 
self
 ) :

547 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "a.b" , "a\nb" , 
regex
 . 
DOTALL
 ) [ 0 ] , "a\nb" )

548 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "a.*b" , "a\n\nb" , 
regex
 . 
DOTALL
 ) [ 0 ] , "a\n\nb"

549 ) 
	}

551 def 
	$test_non_consuming
 ( 
self
 ) :

552 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?=\s[^a]))" , "a b" ) [ 1 ] , 'a' )

553 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?=\s[^a]*))" , "a b" ) [ 1 ] , 'a' )

554 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?=\s[abc]))" , "a b" ) [ 1 ] , 'a' )

555 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?=\s[abc]*))" , "a bc" ) [ 1 ] , 'a' )

556 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?=\s\1)" , "a a" ) [ 1 ] , 'a' )

557 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?=\s\1*)" , "a aa" ) [ 1 ] , 'a' )

558 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?=\s(abc|a))" , "a a" ) [ 1 ] , 'a' )

560 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?!\s[^a]))" , "a a" ) [ 1 ] , 'a' )

561 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a(?!\s[abc]))" , "a d" ) [ 1 ] , 'a' )

562 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?!\s\1)" , "a b" ) [ 1 ] , 'a' )

563 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?!\s(abc|a))" , "a b" ) [ 1 ] , 'a' ) 
	}

565 def 
	$test_ignore_case
 ( 
self
 ) :

566 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "abc" , "ABC" , 
regex
 . 
I
 ) [ 0 ] , 'ABC' )

567 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b"abc" , b"ABC" , 
regex
 . 
I
 ) [ 0 ] , b'ABC' )

569 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a\s[^a]*)" , "a bb" , 
regex
 . 
I
 ) [ 1 ] , 'a bb'

571 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a\s[abc])" , "a b" , 
regex
 . 
I
 ) [ 1 ] , 'a b' )

572 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a\s[abc]*)" , "a bb" , 
regex
 . 
I
 ) [ 1 ] , 'a bb'

574 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"((a)\s\2)" , "a a" , 
regex
 . 
I
 ) [ 1 ] , 'a a' )

575 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"((a)\s\2*)" , "a aa" , 
regex
 . 
I
 ) [ 1 ] , 'a aa'

577 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"((a)\s(abc|a))" , "a a" , 
regex
 . 
I
 ) [ 1 ] , 'a a'

579 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"((a)\s(abc|a)*)" , "a aa" , 
regex
 . 
I
 ) [ 1 ] , 'a aa'

583 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"[Z-a]" , "_" ) . 
span
 ( ) , ( 0 , 1 ) )

584 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?i)[Z-a]" , "_" ) . 
span
 ( ) , ( 0 , 1 ) )

586 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?i)nao" , "nAo" ) ) , True )

587 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?i)n\xE3o" , "n\xC3o" ) ) , True )

588 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?i)n\xE3o" , "N\xC3O" ) ) , True )

589 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?i)s" , "\u017F" ) ) , True ) 
	}

591 def 
	$test_case_folding
 ( 
self
 ) :

592 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)ss" , "SS" ) . 
span
 ( ) , ( 0 , 2 ) )

593 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SS" , "ss" ) . 
span
 ( ) , ( 0 , 2 ) )

594 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SS" , "\N{LATIN SMALL LETTER SHARP S}"

595 ) . 
span
 ( ) , ( 0 , 1 ) )

596 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\N{LATIN SMALL LETTER SHARP S}" , "SS"

597 ) . 
span
 ( ) , ( 0 , 2 ) )

599 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\N{LATIN SMALL LIGATURE ST}" , "ST"

600 ) . 
span
 ( ) , ( 0 , 2 ) )

601 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)ST" , "\N{LATIN SMALL LIGATURE ST}"

602 ) . 
span
 ( ) , ( 0 , 1 ) )

603 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)ST" , "\N{LATIN SMALL LIGATURE LONG S T}"

604 ) . 
span
 ( ) , ( 0 , 1 ) )

606 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SST" , "\N{LATIN SMALL LETTER SHARP S}t"

607 ) . 
span
 ( ) , ( 0 , 2 ) )

608 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SST" , "s\N{LATIN SMALL LIGATURE LONG S T}"

609 ) . 
span
 ( ) , ( 0 , 2 ) )

610 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SST" , "s\N{LATIN SMALL LIGATURE ST}"

611 ) . 
span
 ( ) , ( 0 , 2 ) )

612 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\N{LATIN SMALL LIGATURE ST}" , "SST"

613 ) . 
span
 ( ) , ( 1 , 3 ) )

614 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)SST" , "s\N{LATIN SMALL LIGATURE ST}"

615 ) . 
span
 ( ) , ( 0 , 2 ) )

617 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)FFI" , "\N{LATIN SMALL LIGATURE FFI}"

618 ) . 
span
 ( ) , ( 0 , 1 ) )

619 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)FFI" , "\N{LATIN SMALL LIGATURE FF}i"

620 ) . 
span
 ( ) , ( 0 , 2 ) )

621 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)FFI" , "f\N{LATIN SMALL LIGATURE FI}"

622 ) . 
span
 ( ) , ( 0 , 2 ) )

623 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\N{LATIN SMALL LIGATURE FFI}" , "FFI"

624 ) . 
span
 ( ) , ( 0 , 3 ) )

625 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\N{LATIN SMALL LIGATURE FF}i" , "FFI"

626 ) . 
span
 ( ) , ( 0 , 3 ) )

627 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)f\N{LATIN SMALL LIGATURE FI}" , "FFI"

628 ) . 
span
 ( ) , ( 0 , 3 ) )

630 
sigma
 = "\u03A3\u03C3\u03C2"

631 for 
ch1
 in 
sigma
 :

632 for 
ch2
 in 
sigma
 :

633 if not 
regex
 . 
match
 ( r"(?fi)" + 
ch1
 , 
ch2
 ) :

634 
self
 . 
fail
 ( )

636 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)ff" , "\uFB00\uFB01" ) ) ,

638 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)ff" , "\uFB01\uFB00" ) ) ,

640 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)fi" , "\uFB00\uFB01" ) ) ,

642 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)fi" , "\uFB01\uFB00" ) ) ,

644 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)fffi" , "\uFB00\uFB01" ) ) ,

646 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)f\uFB03" , "\uFB00\uFB01"

648 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)ff" , "\uFB00\uFB01" ) ) ,

650 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)fi" , "\uFB00\uFB01" ) ) ,

652 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)fffi" , "\uFB00\uFB01" ) ) ,

654 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)f\uFB03" , "\uFB00\uFB01"

656 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)f\uFB01" , "\uFB00i" ) ) ,

658 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r"(?iV1)f\uFB01" , "\uFB00i" ) ) ,

661 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?iV0)\m(?:word){e<=3}\M(?<!\m(?:word){e<=1}\M)" , "word word2 word word3 word word234 word23 word"

664 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?iV1)\m(?:word){e<=3}\M(?<!\m(?:word){e<=1}\M)" , "word word2 word word3 word word234 word23 word"

668 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)a\N{LATIN SMALL LIGATURE FFI}ne" , "  affine  "

669 ) . 
span
 ( ) , ( 2 , 8 ) )

670 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)a(?:\N{LATIN SMALL LIGATURE FFI}|x)ne" , "  affine  "

671 ) . 
span
 ( ) , ( 2 , 8 ) )

672 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)a(?:\N{LATIN SMALL LIGATURE FFI}|xy)ne" , "  affine  "

673 ) . 
span
 ( ) , ( 2 , 8 ) )

674 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)a\L<options>ne" , "affine" ,

675 
options
 = [ "\N{LATIN SMALL LIGATURE FFI}" ] ) . 
span
 ( ) , ( 0 , 6 ) )

676 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)a\L<options>ne" , "a\N{LATIN SMALL LIGATURE FFI}ne"

677 , 
options
 = [ "ffi" ] ) . 
span
 ( ) , ( 0 , 4 ) ) 
	}

679 def 
	$test_category
 ( 
self
 ) :

680 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(\s)" , " " ) [ 1 ] , ' ' ) 
	}

682 def 
	$test_not_literal
 ( 
self
 ) :

683 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\s([^a])" , " b" ) [ 1 ] , 'b' )

684 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\s([^a]*)" , " bb" ) [ 1 ] , 'bb' ) 
	}

686 def 
	$test_search_coverage
 ( 
self
 ) :

687 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\s(b)" , " b" ) [ 1 ] , 'b' )

688 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a\s" , "a " ) [ 0 ] , 'a ' ) 
	}

690 def 
	$test_re_escape
 ( 
self
 ) :

691 
p
 = ""

692 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( 
p
 ) , 
p
 )

693 for 
i
 in 
range
 ( 0 , 256 ) :

694 
p
 += 
chr
 ( 
i
 )

695 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 
regex
 . 
escape
 ( 
chr
 ( 
i
 ) ) , 
chr
 ( 
i
 ) ) ) ,

697 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 
regex
 . 
escape
 ( 
chr
 ( 
i
 ) ) , 
chr
 ( 
i
 ) ) . 
span
 ( ) ,

700 
pat
 = 
regex
 . 
compile
 ( 
regex
 . 
escape
 ( 
p
 ) )

701 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 
p
 ) . 
span
 ( ) , ( 0 , 256 ) ) 
	}

703 def 
	$test_re_escape_byte
 ( 
self
 ) :

704 
p
 = b""

705 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( 
p
 ) , 
p
 )

706 for 
i
 in 
range
 ( 0 , 256 ) :

707 
b
 = 
bytes
 ( [ 
i
 ] )

708 
p
 += 
b

709 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 
regex
 . 
escape
 ( 
b
 ) , 
b
 ) ) , True )

710 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 
regex
 . 
escape
 ( 
b
 ) , 
b
 ) . 
span
 ( ) , ( 0 , 1 ) )

712 
pat
 = 
regex
 . 
compile
 ( 
regex
 . 
escape
 ( 
p
 ) )

713 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( 
p
 ) . 
span
 ( ) , ( 0 , 256 ) ) 
	}

715 def 
	$test_constants
 ( 
self
 ) :

716 if 
regex
 . 
I
 != 
regex
 . 
IGNORECASE
 :

717 
self
 . 
fail
 ( )

718 if 
regex
 . 
L
 != 
regex
 . 
LOCALE
 :

719 
self
 . 
fail
 ( )

720 if 
regex
 . 
M
 != 
regex
 . 
MULTILINE
 :

721 
self
 . 
fail
 ( )

722 if 
regex
 . 
S
 != 
regex
 . 
DOTALL
 :

723 
self
 . 
fail
 ( )

724 if 
regex
 . 
X
 != 
regex
 . 
VERBOSE
 :

725 
self
 . 
fail
 ( ) 
	}

727 def 
	$test_flags
 ( 
self
 ) :

728 for 
flag
 in [ 
regex
 . 
I
 , 
regex
 . 
M
 , 
regex
 . 
X
 , 
regex
 . 
S
 , 
regex
 . 
L
 ] :

729 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '^pattern$' , 
flag
 ) ) ) ,

730 
self
 . 
PATTERN_CLASS
 ) 
	}

732 def 
	$test_sre_character_literals
 ( 
self
 ) :

733 for 
i
 in [ 0 , 8 , 16 , 32 , 64 , 127 , 128 , 255 ] :

734 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\%03o" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

735 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\%03o0" % 
i
 , 
chr
 ( 
i
 ) + "0" ) ) ,

737 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\%03o8" % 
i
 , 
chr
 ( 
i
 ) + "8" ) ) ,

739 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\x%02x" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

740 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\x%02x0" % 
i
 , 
chr
 ( 
i
 ) + "0" ) ) ,

742 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\x%02xz" % 
i
 , 
chr
 ( 
i
 ) + "z" ) ) ,

745 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 , lambda :

746 
regex
 . 
match
 ( r"\911" , "" ) ) 
	}

748 def 
	$test_sre_character_class_literals
 ( 
self
 ) :

749 for 
i
 in [ 0 , 8 , 16 , 32 , 64 , 127 , 128 , 255 ] :

750 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\%03o]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

751 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\%03o0]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

752 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\%03o8]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

753 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\x%02x]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

754 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\x%02x0]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

755 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"[\x%02xz]" % 
i
 , 
chr
 ( 
i
 ) ) ) , True )

757 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_OCTAL_ESCAPE
 , lambda :

758 
regex
 . 
match
 ( r"[\911]" , "" ) ) 
	}

760 def 
	$test_bug_113254
 ( 
self
 ) :

761 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)|(b)' , 'b' ) . 
start
 ( 1 ) , - 1 )

762 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)|(b)' , 'b' ) . 
end
 ( 1 ) , - 1 )

763 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)|(b)' , 'b' ) . 
span
 ( 1 ) , ( - 1 , - 1 ) ) 
	}

765 def 
	$test_bug_527371
 ( 
self
 ) :

767 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)?a' , 'a' ) . 
lastindex
 , None )

768 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(a)(b)?b' , 'ab' ) . 
lastindex
 , 1 )

769 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?P<a>a)(?P<b>b)?b' , 'ab' ) . 
lastgroup
 , 'a'

771 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?P<a>a(b))" , "ab" ) . 
lastgroup
 , 'a' )

772 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "((a))" , "a" ) . 
lastindex
 , 1 ) 
	}

774 def 
	$test_bug_545855
 ( 
self
 ) :

777 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_SET
 , lambda :

778 
regex
 . 
compile
 ( 'foo[a-' ) ) 
	}

780 def 
	$test_bug_418626
 ( 
self
 ) :

784 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '.*?c' , 10000 * 'ab' + 'cd' ) . 
end
 ( 0 ) ,

786 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '.*?cd' , 5000 * 'ab' + 'c' + 5000 * 'ab' + 'cde'

787 ) . 
end
 ( 0 ) , 20003 )

788 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '.*?cd' , 20000 * 'abc' + 'de' ) . 
end
 ( 0 ) ,

792 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(a|b)*?c' , 10000 * 'ab' + 'cd' ) . 
end
 ( 0 ) ,

793 20001 ) 
	}

795 def 
	$test_bug_612074
 ( 
self
 ) :

796 
pat
 = "[" + 
regex
 . 
escape
 ( "\u2039" ) + "]"

797 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( 
pat
 ) and 1 , 1 ) 
	}

799 def 
	$test_stack_overflow
 ( 
self
 ) :

802 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x)*' , 50000 * 'x' ) [ 1 ] , 'x' )

803 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x)*y' , 50000 * 'x' + 'y' ) [ 1 ] , 'x' )

804 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x)*?y' , 50000 * 'x' + 'y' ) [ 1 ] , 'x' ) 
	}

806 def 
	$test_scanner
 ( 
self
 ) :

807 def 
s_ident
 ( 
scanner
 , 
token
 ) : return 
token

808 def 
s_operator
 ( 
scanner
 , 
token
 ) : return "op%s" % 
token

809 def 
s_float
 ( 
scanner
 , 
token
 ) : return 
float
 ( 
token
 )

810 def 
s_int
 ( 
scanner
 , 
token
 ) : return 
int
 ( 
token
 )

812 
scanner
 = 
regex
 . 
Scanner
 ( [ ( r"[a-zA-Z_]\w*" , 
s_ident
 ) , ( r"\d+\.\d*" ,

813 
s_float
 ) , ( r"\d+" , 
s_int
 ) , ( r"=|\+|-|\*|/" , 
s_operator
 ) , ( r"\s+" ,

816 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
scanner
 . 
scanner
 . 
scanner
 ( "" ) . 
pattern
 ) ) ,

817 
self
 . 
PATTERN_CLASS
 )

819 
self
 . 
assertEqual
 ( 
scanner
 . 
scan
 ( "sum = 3*foo + 312.50 + bar" ) , ( [ 'sum' , 'op='

820 , 3 , 'op*' , 'foo' , 'op+' , 312.5 , 'op+' , 'bar' ] , '' ) ) 
	}

822 def 
	$test_bug_448951
 ( 
self
 ) :

825 for 
op
 in '' , '?' , '*' :

826 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'((.%s):)?z' % 
op
 , 'z' ) [ : ] , ( 'z' ,

828 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'((.%s):)?z' % 
op
 , 'a:z' ) [ : ] , ( 'a:z' , 'a:'

829 , 'a' ) ) 
	}

831 def 
	$test_bug_725106
 ( 
self
 ) :

833 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((a)|b)*' , 'abc' ) [ : ] , ( 'ab' , 'b' , 'a' ) )

834 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(([ab])|c)*' , 'abc' ) [ : ] , ( 'abc' , 'c' , 'b'

836 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((d)|[ab])*' , 'abc' ) [ : ] , ( 'ab' , 'b' ,

838 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((a)c|[ab])*' , 'abc' ) [ : ] , ( 'ab' , 'b' ,

840 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((a)|b)*?c' , 'abc' ) [ : ] , ( 'abc' , 'b' , 'a'

842 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^(([ab])|c)*?d' , 'abcd' ) [ : ] , ( 'abcd' , 'c'

844 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((d)|[ab])*?c' , 'abc' ) [ : ] , ( 'abc' , 'b' ,

846 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '^((a)c|[ab])*?c' , 'abc' ) [ : ] , ( 'abc' , 'b' ,

847 None ) ) 
	}

849 def 
	$test_bug_725149
 ( 
self
 ) :

851 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)(?:(?=(b)*)c)*' , 'abb' ) [ : ] , ( 'a' , 'a' ,

853 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)((?!(b)*))*' , 'abb' ) [ : ] , ( 'a' , 'a' ,

854 None , None ) ) 
	}

856 def 
	$test_bug_764548
 ( 
self
 ) :

858 class 
	cmy_unicode
 ( 
str
 ) : pass

859 
pat
 = 
regex
 . 
compile
 ( 
my_unicode
 ( "abc" ) )

860 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( "xyz" ) , None ) 
	}

862 def 
	$test_finditer
 ( 
self
 ) :

863 
it
 = 
regex
 . 
finditer
 ( r":+" , "a:b::c:::d" )

864 
self
 . 
assertEqual
 ( [ 
item
 [ 0 ] for 
item
 in 
it
 ] , [ ':' , '::' , ':::' ] ) 
	}

866 def 
	$test_bug_926075
 ( 
self
 ) :

867 if 
regex
 . 
compile
 ( 'bug_926075' ) is 
regex
 . 
compile
 ( b'bug_926075' ) :

868 
self
 . 
fail
 ( ) 
	}

870 def 
	$test_bug_931848
 ( 
self
 ) :

871 
pattern
 = "[\u002E\u3002\uFF0E\uFF61]"

872 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( 
pattern
 ) . 
split
 ( "a.b.c" ) , [ 'a' , 'b' , 'c'

873 ] ) 
	}

875 def 
	$test_bug_581080
 ( 
self
 ) :

876 
it
 = 
regex
 . 
finditer
 ( r"\s" , "a b" )

877 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) . 
span
 ( ) , ( 1 , 2 ) )

878 
self
 . 
assertRaises
 ( 
StopIteration
 , lambda : 
next
 ( 
it
 ) )

880 
scanner
 = 
regex
 . 
compile
 ( r"\s" ) . 
scanner
 ( "a b" )

881 
self
 . 
assertEqual
 ( 
scanner
 . 
search
 ( ) . 
span
 ( ) , ( 1 , 2 ) )

882 
self
 . 
assertEqual
 ( 
scanner
 . 
search
 ( ) , None ) 
	}

884 def 
	$test_bug_817234
 ( 
self
 ) :

885 
it
 = 
regex
 . 
finditer
 ( r".*" , "asdf" )

886 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) . 
span
 ( ) , ( 0 , 4 ) )

887 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) . 
span
 ( ) , ( 4 , 4 ) )

888 
self
 . 
assertRaises
 ( 
StopIteration
 , lambda : 
next
 ( 
it
 ) ) 
	}

890 def 
	$test_empty_array
 ( 
self
 ) :

892 import 
	~array

893 for 
typecode
 in 'bBuhHiIlLfd' :

894 
a
 = 
array
 . 
array
 ( 
typecode
 )

895 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( b"bla" ) . 
match
 ( 
a
 ) , None )

896 
self
 . 
assertEqual
 ( 
regex
 . 
compile
 ( b"" ) . 
match
 ( 
a
 ) [ 1 : ] , ( ) ) 
	}

898 def 
	$test_inline_flags
 ( 
self
 ) :

900 
upper_char
 = 
chr
 ( 0x1ea0 )

901 
lower_char
 = 
chr
 ( 0x1ea1 )

903 
p
 = 
regex
 . 
compile
 ( 
upper_char
 , 
regex
 . 
I
 | 
regex
 . 
U
 )

904 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
lower_char
 ) ) , True )

906 
p
 = 
regex
 . 
compile
 ( 
lower_char
 , 
regex
 . 
I
 | 
regex
 . 
U
 )

907 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
upper_char
 ) ) , True )

909 
p
 = 
regex
 . 
compile
 ( '(?i)' + 
upper_char
 , 
regex
 . 
U
 )

910 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
lower_char
 ) ) , True )

912 
p
 = 
regex
 . 
compile
 ( '(?i)' + 
lower_char
 , 
regex
 . 
U
 )

913 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
upper_char
 ) ) , True )

915 
p
 = 
regex
 . 
compile
 ( '(?iu)' + 
upper_char
 )

916 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
lower_char
 ) ) , True )

918 
p
 = 
regex
 . 
compile
 ( '(?iu)' + 
lower_char
 )

919 
self
 . 
assertEqual
 ( 
bool
 ( 
p
 . 
match
 ( 
upper_char
 ) ) , True )

921 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?i)a" , "A" ) ) , True )

922 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"a(?i)" , "A" ) ) , True )

923 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"(?iV1)a" , "A" ) ) , True )

924 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"a(?iV1)" , "A" ) , None ) 
	}

926 def 
	$test_dollar_matches_twice
 ( 
self
 ) :

928 
pattern
 = 
regex
 . 
compile
 ( '$' )

929 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , 'a\nb\n' ) , 'a\nb#\n#' )

930 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , 'a\nb\nc' ) , 'a\nb\nc#' )

931 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , '\n' ) , '#\n#' )

933 
pattern
 = 
regex
 . 
compile
 ( '$' , 
regex
 . 
MULTILINE
 )

934 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , 'a\nb\n' ) , 'a#\nb#\n#' )

935 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , 'a\nb\nc' ) , 'a#\nb#\nc#' )

936 
self
 . 
assertEqual
 ( 
pattern
 . 
sub
 ( '#' , '\n' ) , '#\n#' ) 
	}

938 def 
	$test_bytes_str_mixing
 ( 
self
 ) :

940 
pat
 = 
regex
 . 
compile
 ( '.' )

941 
bpat
 = 
regex
 . 
compile
 ( b'.' )

942 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
STR_PAT_ON_BYTES
 , lambda :

943 
pat
 . 
match
 ( b'b' ) )

944 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
BYTES_PAT_ON_STR
 , lambda :

945 
bpat
 . 
match
 ( 'b' ) )

946 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
STR_PAT_BYTES_TEMPL
 , lambda :

947 
pat
 . 
sub
 ( b'b' , 'c' ) )

948 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
STR_PAT_ON_BYTES
 , lambda :

949 
pat
 . 
sub
 ( 'b' , b'c' ) )

950 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
STR_PAT_ON_BYTES
 , lambda :

951 
pat
 . 
sub
 ( b'b' , b'c' ) )

952 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
BYTES_PAT_ON_STR
 , lambda :

953 
bpat
 . 
sub
 ( b'b' , 'c' ) )

954 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
BYTES_PAT_STR_TEMPL
 , lambda :

955 
bpat
 . 
sub
 ( 'b' , b'c' ) )

956 
self
 . 
assertRaisesRegex
 ( 
TypeError
 , 
self
 . 
BYTES_PAT_ON_STR
 , lambda :

957 
bpat
 . 
sub
 ( 'b' , 'c' ) )

959 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
BYTES_PAT_UNI_FLAG
 , lambda :

960 
regex
 . 
compile
 ( br'\w' , 
regex
 . 
UNICODE
 ) )

961 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
BYTES_PAT_UNI_FLAG
 , lambda :

962 
regex
 . 
compile
 ( br'(?u)\w' ) )

963 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
MIXED_FLAGS
 , lambda :

964 
regex
 . 
compile
 ( r'\w' , 
regex
 . 
UNICODE
 | 
regex
 . 
ASCII
 ) )

965 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
MIXED_FLAGS
 , lambda :

966 
regex
 . 
compile
 ( r'(?u)\w' , 
regex
 . 
ASCII
 ) )

967 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
MIXED_FLAGS
 , lambda :

968 
regex
 . 
compile
 ( r'(?a)\w' , 
regex
 . 
UNICODE
 ) )

969 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
MIXED_FLAGS
 , lambda :

970 
regex
 . 
compile
 ( r'(?au)\w' ) ) 
	}

972 def 
	$test_ascii_and_unicode_flag
 ( 
self
 ) :

974 for 
flags
 in ( 0 , 
regex
 . 
UNICODE
 ) :

975 
pat
 = 
regex
 . 
compile
 ( '\xc0' , 
flags
 | 
regex
 . 
IGNORECASE
 )

976 
self
 . 
assertEqual
 ( 
bool
 ( 
pat
 . 
match
 ( '\xe0' ) ) , True )

977 
pat
 = 
regex
 . 
compile
 ( r'\w' , 
flags
 )

978 
self
 . 
assertEqual
 ( 
bool
 ( 
pat
 . 
match
 ( '\xe0' ) ) , True )

980 
pat
 = 
regex
 . 
compile
 ( '\xc0' , 
regex
 . 
ASCII
 | 
regex
 . 
IGNORECASE
 )

981 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( '\xe0' ) , None )

982 
pat
 = 
regex
 . 
compile
 ( '(?a)\xc0' , 
regex
 . 
IGNORECASE
 )

983 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( '\xe0' ) , None )

984 
pat
 = 
regex
 . 
compile
 ( r'\w' , 
regex
 . 
ASCII
 )

985 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( '\xe0' ) , None )

986 
pat
 = 
regex
 . 
compile
 ( r'(?a)\w' )

987 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( '\xe0' ) , None )

990 for 
flags
 in ( 0 , 
regex
 . 
ASCII
 ) :

991 
pat
 = 
regex
 . 
compile
 ( b'\xc0' , 
flags
 | 
regex
 . 
IGNORECASE
 )

992 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( b'\xe0' ) , None )

993 
pat
 = 
regex
 . 
compile
 ( br'\w' )

994 
self
 . 
assertEqual
 ( 
pat
 . 
match
 ( b'\xe0' ) , None )

996 
self
 . 
assertRaisesRegex
 ( 
ValueError
 , 
self
 . 
MIXED_FLAGS
 , lambda :

997 
regex
 . 
compile
 ( r'(?au)\w' ) ) 
	}

999 def 
	$test_subscripting_match
 ( 
self
 ) :

1000 
m
 = 
regex
 . 
match
 ( r'(?<a>\w)' , 'xy' )

1001 if not 
m
 :

1002 
self
 . 
fail
 ( "Failed: expected match but returned None" )

1003 elif not 
m
 or 
m
 [ 0 ] != 
m
 . 
group
 ( 0 ) or 
m
 [ 1 ] != 
m
 . 
group
 ( 1 ) :

1004 
self
 . 
fail
 ( "Failed" )

1005 if not 
m
 :

1006 
self
 . 
fail
 ( "Failed: expected match but returned None" )

1007 elif 
m
 [ : ] != ( 'x' , 'x' ) :

1008 
self
 . 
fail
 ( "Failed: expected \"('x', 'x')\" but got {} instead" . 
format
 ( 
ascii
 ( 
m
 [ : ] ) ) ) 
	}

1010 def 
	$test_new_named_groups
 ( 
self
 ) :

1011 
m0
 = 
regex
 . 
match
 ( r'(?P<a>\w)' , 'x' )

1012 
m1
 = 
regex
 . 
match
 ( r'(?<a>\w)' , 'x' )

1013 if not ( 
m0
 and 
m1
 and 
m0
 [ : ] == 
m1
 [ : ] ) :

1014 
self
 . 
fail
 ( "Failed" ) 
	}

1016 def 
	$test_properties
 ( 
self
 ) :

1017 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'(?ai)\xC0' , b'\xE0' ) , None )

1018 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?ai)\xC0' , b'\xE0' ) , None )

1019 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?a)\w' , b'\xE0' ) , None )

1020 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\w' , '\xE0' ) ) , True )

1027 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\d' , b'0' ) ) , True )

1028 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\s' , b' ' ) ) , True )

1029 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\w' , b'a' ) ) , True )

1030 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\d' , b'?' ) , None )

1031 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\s' , b'?' ) , None )

1032 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\w' , b'?' ) , None )

1034 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\D' , b'0' ) , None )

1035 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\S' , b' ' ) , None )

1036 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br'(?L)\W' , b'a' ) , None )

1037 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\D' , b'?' ) ) , True )

1038 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\S' , b'?' ) ) , True )

1039 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( br'(?L)\W' , b'?' ) ) , True )

1041 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Cyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1043 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?i)\p{Cyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1045 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{IsCyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1047 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Script=Cyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1049 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{InCyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1051 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Block=Cyrillic}' , '\N{CYRILLIC CAPITAL LETTER A}'

1053 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:Cyrillic:]]' , '\N{CYRILLIC CAPITAL LETTER A}'

1055 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:IsCyrillic:]]' , '\N{CYRILLIC CAPITAL LETTER A}'

1057 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:Script=Cyrillic:]]' , '\N{CYRILLIC CAPITAL LETTER A}'

1059 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:InCyrillic:]]' , '\N{CYRILLIC CAPITAL LETTER A}'

1061 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:Block=Cyrillic:]]' , '\N{CYRILLIC CAPITAL LETTER A}'

1064 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\P{Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1066 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\P{IsCyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1068 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\P{Script=Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1070 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\P{InCyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1072 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\P{Block=Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1074 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{^Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1076 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{^IsCyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1078 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{^Script=Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1080 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{^InCyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1082 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{^Block=Cyrillic}' , '\N{LATIN CAPITAL LETTER A}'

1084 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:^Cyrillic:]]' , '\N{LATIN CAPITAL LETTER A}'

1086 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:^IsCyrillic:]]' , '\N{LATIN CAPITAL LETTER A}'

1088 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:^Script=Cyrillic:]]' , '\N{LATIN CAPITAL LETTER A}'

1090 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:^InCyrillic:]]' , '\N{LATIN CAPITAL LETTER A}'

1092 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'[[:^Block=Cyrillic:]]' , '\N{LATIN CAPITAL LETTER A}'

1095 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\d' , '0' ) ) , True )

1096 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\s' , ' ' ) ) , True )

1097 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\w' , 'A' ) ) , True )

1098 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\d" , "?" ) , None )

1099 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\s" , "?" ) , None )

1100 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\w" , "?" ) , None )

1101 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\D" , "0" ) , None )

1102 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\S" , " " ) , None )

1103 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\W" , "A" ) , None )

1104 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\D' , '?' ) ) , True )

1105 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\S' , '?' ) ) , True )

1106 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\W' , '?' ) ) , True )

1108 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{L}' , 'A' ) ) , True )

1109 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{L}' , 'a' ) ) , True )

1110 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Lu}' , 'A' ) ) , True )

1111 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Ll}' , 'a' ) ) , True )

1113 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?i)a' , 'a' ) ) , True )

1114 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?i)a' , 'A' ) ) , True )

1116 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\w' , '0' ) ) , True )

1117 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\w' , 'a' ) ) , True )

1118 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\w' , '_' ) ) , True )

1120 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\X" , "\xE0" ) . 
span
 ( ) , ( 0 , 1 ) )

1121 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\X" , "a\u0300" ) . 
span
 ( ) , ( 0 , 2 ) )

1122 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X" , "a\xE0a\u0300e\xE9e\u0301"

1125 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X{3}" , "a\xE0a\u0300e\xE9e\u0301"

1127 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X" , "\r\r\n\u0301A\u0301" ) ,

1130 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'\p{Ll}' , 'a' ) ) , True )

1132 
chars_u
 = "-09AZaz_\u0393\u03b3"

1133 
chars_b
 = b"-09AZaz_"

1134 
word_set
 = 
set
 ( "Ll Lm Lo Lt Lu Mc Me Mn Nd Nl No Pc" . 
split
 ( ) )

1136 
tests
 = [

1137 ( r"\w" , 
chars_u
 , "09AZaz_\u0393\u03b3" ) ,

1138 ( r"[[:word:]]" , 
chars_u
 , "09AZaz_\u0393\u03b3" ) ,

1139 ( r"\W" , 
chars_u
 , "-" ) ,

1140 ( r"[[:^word:]]" , 
chars_u
 , "-" ) ,

1141 ( r"\d" , 
chars_u
 , "09" ) ,

1142 ( r"[[:digit:]]" , 
chars_u
 , "09" ) ,

1143 ( r"\D" , 
chars_u
 , "-AZaz_\u0393\u03b3" ) ,

1144 ( r"[[:^digit:]]" , 
chars_u
 , "-AZaz_\u0393\u03b3" ) ,

1145 ( r"[[:alpha:]]" , 
chars_u
 , "AZaz\u0393\u03b3" ) ,

1146 ( r"[[:^alpha:]]" , 
chars_u
 , "-09_" ) ,

1147 ( r"[[:alnum:]]" , 
chars_u
 , "09AZaz\u0393\u03b3" ) ,

1148 ( r"[[:^alnum:]]" , 
chars_u
 , "-_" ) ,

1149 ( r"[[:xdigit:]]" , 
chars_u
 , "09Aa" ) ,

1150 ( r"[[:^xdigit:]]" , 
chars_u
 , "-Zz_\u0393\u03b3" ) ,

1156 ( br"(?L)\w" , 
chars_b
 , b"09AZaz_" ) ,

1157 ( br"(?L)[[:word:]]" , 
chars_b
 , b"09AZaz_" ) ,

1158 ( br"(?L)\W" , 
chars_b
 , b"-" ) ,

1159 ( br"(?L)[[:^word:]]" , 
chars_b
 , b"-" ) ,

1160 ( br"(?L)\d" , 
chars_b
 , b"09" ) ,

1161 ( br"(?L)[[:digit:]]" , 
chars_b
 , b"09" ) ,

1162 ( br"(?L)\D" , 
chars_b
 , b"-AZaz_" ) ,

1163 ( br"(?L)[[:^digit:]]" , 
chars_b
 , b"-AZaz_" ) ,

1164 ( br"(?L)[[:alpha:]]" , 
chars_b
 , b"AZaz" ) ,

1165 ( br"(?L)[[:^alpha:]]" , 
chars_b
 , b"-09_" ) ,

1166 ( br"(?L)[[:alnum:]]" , 
chars_b
 , b"09AZaz" ) ,

1167 ( br"(?L)[[:^alnum:]]" , 
chars_b
 , b"-_" ) ,

1168 ( br"(?L)[[:xdigit:]]" , 
chars_b
 , b"09Aa" ) ,

1169 ( br"(?L)[[:^xdigit:]]" , 
chars_b
 , b"-Zz_" ) ,

1171 ( br"(?a)\w" , 
chars_b
 , b"09AZaz_" ) ,

1172 ( br"(?a)[[:word:]]" , 
chars_b
 , b"09AZaz_" ) ,

1173 ( br"(?a)\W" , 
chars_b
 , b"-" ) ,

1174 ( br"(?a)[[:^word:]]" , 
chars_b
 , b"-" ) ,

1175 ( br"(?a)\d" , 
chars_b
 , b"09" ) ,

1176 ( br"(?a)[[:digit:]]" , 
chars_b
 , b"09" ) ,

1177 ( br"(?a)\D" , 
chars_b
 , b"-AZaz_" ) ,

1178 ( br"(?a)[[:^digit:]]" , 
chars_b
 , b"-AZaz_" ) ,

1179 ( br"(?a)[[:alpha:]]" , 
chars_b
 , b"AZaz" ) ,

1180 ( br"(?a)[[:^alpha:]]" , 
chars_b
 , b"-09_" ) ,

1181 ( br"(?a)[[:alnum:]]" , 
chars_b
 , b"09AZaz" ) ,

1182 ( br"(?a)[[:^alnum:]]" , 
chars_b
 , b"-_" ) ,

1183 ( br"(?a)[[:xdigit:]]" , 
chars_b
 , b"09Aa" ) ,

1184 ( br"(?a)[[:^xdigit:]]" , 
chars_b
 , b"-Zz_" ) ,

1186 for 
pattern
 , 
chars
 , 
expected
 in 
tests
 :

1188 if 
chars
 [ : 0 ] . 
join
 ( 
regex
 . 
findall
 ( 
pattern
 , 
chars
 ) ) != 
expected
 :

1189 
self
 . 
fail
 ( "Failed: {}" . 
format
 ( 
pattern
 ) )

1190 except 
Exception
 as 
e
 :

1191 
self
 . 
fail
 ( "Failed: {} raised {}" . 
format
 ( 
pattern
 , 
ascii
 ( 
e
 ) ) )

1193 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\p{NumericValue=0}" , "0" ) ) ,

1195 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\p{NumericValue=1/2}" , "\N{VULGAR FRACTION ONE HALF}"

1197 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\p{NumericValue=0.5}" , "\N{VULGAR FRACTION ONE HALF}"

1198 ) ) , True ) 
	}

1200 def 
	$test_word_class
 ( 
self
 ) :

1201 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\w+" , " \u0939\u093f\u0928\u094d\u0926\u0940,"

1204 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\W+" , " \u0939\u093f\u0928\u094d\u0926\u0940,"

1206 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\b" , " \u0939\u093f\u0928\u094d\u0926\u0940,"

1209 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\B" , " \u0939\u093f\u0928\u094d\u0926\u0940,"

1211 , '\u0928' , '\u094d' , '\u0926' , '\u0940,' , '' ] ) 
	}

1213 def 
	$test_search_anchor
 ( 
self
 ) :

1214 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\G\w{2}" , "abcd ef" ) , [ 'ab' , 'cd' ] ) 
	}

1216 def 
	$test_search_reverse
 ( 
self
 ) :

1217 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)." , "abc" ) , [ 'c' , 'b' , 'a' ] )

1218 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)." , "abc" , 
overlapped
 = True ) , [ 'c' , 'b'

1220 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).." , "abcde" ) , [ 'de' , 'bc' ] )

1221 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).." , "abcde" , 
overlapped
 = True ) ,

1223 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)(.)(-)(.)" , "a-b-c" ,

1224 
overlapped
 = True ) , [ ( "b" , "-" , "c" ) , ( "a" , "-" , "b" ) ] )

1226 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r)." , "abc" ) ] , [ 'c' , 'b'

1228 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).." , "abcde" ,

1229 
overlapped
 = True ) ] , [ 'de' , 'cd' , 'bc' , 'ab' ] )

1230 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r)." , "abc" ) ] , [ 'c' , 'b'

1232 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).." , "abcde" ,

1233 
overlapped
 = True ) ] , [ 'de' , 'cd' , 'bc' , 'ab' ] )

1235 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"^|\w+" , "foo bar" ) , [ '' , 'foo' , 'bar'

1237 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?V1)^|\w+" , "foo bar" ) , [ '' , 'foo' , 'bar'

1239 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)^|\w+" , "foo bar" ) , [ 'bar' , 'foo' , ''

1241 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?rV1)^|\w+" , "foo bar" ) , [ 'bar' , 'foo'

1244 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"^|\w+" , "foo bar" ) ] ,

1246 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?V1)^|\w+" , "foo bar"

1248 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r)^|\w+" , "foo bar"

1250 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?rV1)^|\w+" , "foo bar"

1253 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\G\w{2}" , "abcd ef" ) , [ 'ab' , 'cd' ] )

1254 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".{2}(?<=\G.*)" , "abcd" ) , [ 'ab' , 'cd' ] )

1255 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)\G\w{2}" , "abcd ef" ) , [ ] )

1256 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)\w{2}\G" , "abcd ef" ) , [ 'ef' ] )

1258 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"q*" , "qqwe" ) , [ 'qq' , '' , '' , '' ] )

1259 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?V1)q*" , "qqwe" ) , [ 'qq' , '' , '' , '' ] )

1260 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)q*" , "qqwe" ) , [ '' , '' , 'qq' , '' ] )

1261 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?rV1)q*" , "qqwe" ) , [ '' , '' , 'qq' , ''

1264 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "." , "abcd" , 
pos
 = 1 , 
endpos
 = 3 ) , [ 'b' , 'c'

1266 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "." , "abcd" , 
pos
 = 1 , 
endpos
 = - 1 ) , [ 'b' , 'c'

1268 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( "." , "abcd" , 
pos
 = 1 ,

1269 
endpos
 = 3 ) ] , [ 'b' , 'c' ] )

1270 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( "." , "abcd" , 
pos
 = 1 ,

1271 
endpos
 = - 1 ) ] , [ 'b' , 'c' ] )

1273 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( "(?r)." , "abcd" , 
pos
 = 1 ,

1274 
endpos
 = 3 ) ] , [ 'c' , 'b' ] )

1275 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( "(?r)." , "abcd" , 
pos
 = 1 ,

1276 
endpos
 = - 1 ) ] , [ 'c' , 'b' ] )

1277 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "(?r)." , "abcd" , 
pos
 = 1 , 
endpos
 = 3 ) , [ 'c' , 'b'

1279 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( "(?r)." , "abcd" , 
pos
 = 1 , 
endpos
 = - 1 ) ,

1282 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[ab]" , "aB" , 
regex
 . 
I
 ) , [ 'a' , 'B' ] )

1283 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)[ab]" , "aB" , 
regex
 . 
I
 ) , [ 'B' , 'a' ] )

1285 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).{2}" , "abc" ) , [ 'bc' ] )

1286 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).{2}" , "abc" , 
overlapped
 = True ) ,

1288 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(\w+) (\w+)" , "first second third fourth fifth"

1291 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)(\w+) (\w+)" , "first second third fourth fifth"

1295 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).{2}" , "abc" ) ] ,

1297 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).{2}" , "abc" ,

1298 
overlapped
 = True ) ] , [ 'bc' , 'ab' ] )

1299 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(\w+) (\w+)" , "first second third fourth fifth"

1302 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r)(\w+) (\w+)" , "first second third fourth fifth"

1306 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "abcdef" , "abcdef" ) . 
span
 ( ) , ( 0 , 6 ) )

1307 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?r)abcdef" , "abcdef" ) . 
span
 ( ) , ( 0 , 6 ) )

1308 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?i)abcdef" , "ABCDEF" ) . 
span
 ( ) , ( 0 , 6 ) )

1309 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?ir)abcdef" , "ABCDEF" ) . 
span
 ( ) , ( 0 , 6 ) )

1311 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(.)" , r"\1" , "abc" ) , 'abc' )

1312 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?r)(.)" , r"\1" , "abc" ) , 'abc' ) 
	}

1314 def 
	$test_atomic
 ( 
self
 ) :

1316 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?>a*)a" , "aa" ) , None ) 
	}

1318 def 
	$test_possessive
 ( 
self
 ) :

1320 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a?a" , "a" ) . 
span
 ( ) , ( 0 , 1 ) )

1321 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a*a" , "aaa" ) . 
span
 ( ) , ( 0 , 3 ) )

1322 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a+a" , "aaa" ) . 
span
 ( ) , ( 0 , 3 ) )

1323 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a{1,3}a" , "aaa" ) . 
span
 ( ) , ( 0 , 3 ) )

1326 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)?ab" , "ab" ) . 
span
 ( ) , ( 0 , 2 ) )

1327 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)*ab" , "ababab" ) . 
span
 ( ) , ( 0 , 6 ) )

1328 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)+ab" , "ababab" ) . 
span
 ( ) , ( 0 , 6 ) )

1329 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab){1,3}ab" , "ababab" ) . 
span
 ( ) , ( 0 ,

1333 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a?+a" , "a" ) , None )

1334 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a*+a" , "aaa" ) , None )

1335 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a++a" , "aaa" ) , None )

1336 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"a{1,3}+a" , "aaa" ) , None )

1339 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)?+ab" , "ab" ) , None )

1340 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)*+ab" , "ababab" ) , None )

1341 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab)++ab" , "ababab" ) , None )

1342 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:ab){1,3}+ab" , "ababab" ) , None ) 
	}

1344 def 
	$test_zerowidth
 ( 
self
 ) :

1346 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1347 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"\b" , "a b" ) , [ '' , 'a' , ' ' , 'b' , ''

1350 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"\b" , "a b" ) , [ 'a b' ] )

1351 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"(?V1)\b" , "a b" ) , [ '' , 'a' , ' ' , 'b' , ''

1355 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"^|\w+" , "foo bar" ) , [ '' , 'foo' , 'bar'

1357 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"^|\w+" , "foo bar" ) ] ,

1359 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)^|\w+" , "foo bar" ) , [ 'bar' , 'foo'

1361 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r)^|\w+" , "foo bar"

1363 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?V1)^|\w+" , "foo bar" ) , [ '' , 'foo' , 'bar'

1365 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?V1)^|\w+" , "foo bar"

1367 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?rV1)^|\w+" , "foo bar" ) , [ 'bar' , 'foo'

1369 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?rV1)^|\w+" , "foo bar"

1372 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1373 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "" , "xaxbxc" ) , [ '' , 'x' , 'a' , 'x' , 'b'

1375 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "" , "xaxbxc" ) ] , [ '' , 'x'

1378 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "" , "xaxbxc" ) , [ 'xaxbxc' ] )

1379 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "" , "xaxbxc" ) ] ,

1382 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1383 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?r)" , "xaxbxc" ) , [ '' , 'c' , 'x' , 'b' , 'x'

1385 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?r)" , "xaxbxc" ) ] ,

1388 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?r)" , "xaxbxc" ) , [ 'xaxbxc' ] )

1389 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?r)" , "xaxbxc" ) ] ,

1392 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?V1)" , "xaxbxc" ) , [ '' , 'x' , 'a' , 'x' , 'b'

1394 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?V1)" , "xaxbxc" ) ] , [ '' , 'x'

1397 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( "(?rV1)" , "xaxbxc" ) , [ '' , 'c' , 'x' , 'b' , 'x'

1399 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( "(?rV1)" , "xaxbxc" ) ] , [ '' , 'c'

1400 , 'x' , 'b' , 'x' , 'a' , 'x' , '' ] ) 
	}

1402 def 
	$test_scoped_and_inline_flags
 ( 
self
 ) :

1404 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?i)Ab" , "ab" ) . 
span
 ( ) , ( 0 , 2 ) )

1405 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?i:A)b" , "ab" ) . 
span
 ( ) , ( 0 , 2 ) )

1406 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"A(?i)b" , "ab" ) . 
span
 ( ) , ( 0 , 2 ) )

1407 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"A(?iV1)b" , "ab" ) , None )

1409 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
CANT_TURN_OFF
 , lambda :

1410 
regex
 . 
search
 ( r"(?V0-i)Ab" , "ab" , 
flags
 = 
regex
 . 
I
 ) )

1412 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V0)Ab" , "ab" ) , None )

1413 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)Ab" , "ab" ) , None )

1414 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1-i)Ab" , "ab" , 
flags
 = 
regex
 . 
I
 ) , None )

1415 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?-i:A)b" , "ab" , 
flags
 = 
regex
 . 
I
 ) , None )

1416 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"A(?V1-i)b" , "ab" ,

1417 
flags
 = 
regex
 . 
I
 ) . 
span
 ( ) , ( 0 , 2 ) ) 
	}

1419 def 
	$test_repeated_repeats
 ( 
self
 ) :

1421 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:a+)+" , "aaa" ) . 
span
 ( ) , ( 0 , 3 ) )

1422 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:(?:ab)+c)+" , "abcabc" ) . 
span
 ( ) , ( 0 ,

1426 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:a+){2,}" , "aaa" ) . 
span
 ( ) , ( 0 , 3 ) ) 
	}

1428 def 
	$test_lookbehind
 ( 
self
 ) :

1429 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"123(?<=a\d+)" , "a123" ) . 
span
 ( ) , ( 1 , 4 ) )

1430 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"123(?<=a\d+)" , "b123" ) , None )

1431 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"123(?<!a\d+)" , "a123" ) , None )

1432 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"123(?<!a\d+)" , "b123" ) . 
span
 ( ) , ( 1 , 4 ) )

1434 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(a)b(?<=b)(c)" , "abc" ) ) , True )

1435 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?<=c)(c)" , "abc" ) , None )

1436 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(a)b(?=c)(c)" , "abc" ) ) , True )

1437 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?=b)(c)" , "abc" ) , None )

1439 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?<=(?(2)x|c))c" , "abc" ) ,

1441 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?<=(?(2)b|x))c" , "abc" ) ,

1443 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?<=(?(2)x|b))c" , "abc"

1445 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?<=(?(1)c|x))c" , "abc" ) ,

1447 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?<=(?(1)b|x))c" , "abc"

1450 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?=(?(2)x|c))c" , "abc"

1452 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?=(?(2)c|x))c" , "abc" ) ,

1454 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?=(?(2)x|c))c" , "abc"

1456 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?=(?(1)b|x))c" , "abc" ) ,

1458 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(?:(a)|(x))b(?=(?(1)c|x))c" , "abc"

1461 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?<=(?(2)x|c))(c)" , "abc" ) , None )

1462 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?<=(?(2)b|x))(c)" , "abc" ) , None )

1463 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?<=(?(1)c|x))(c)" , "abc" ) , None )

1464 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(a)b(?<=(?(1)b|x))(c)" , "abc" ) ) ,

1467 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(a)b(?=(?(2)x|c))(c)" , "abc" ) ) ,

1469 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "(a)b(?=(?(2)b|x))(c)" , "abc" ) , None )

1470 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( "(a)b(?=(?(1)c|x))(c)" , "abc" ) ) ,

1473 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( r"(a)\2(b)" ) ) ) ,

1474 
self
 . 
PATTERN_CLASS
 ) 
	}

1476 def 
	$test_unmatched_in_sub
 ( 
self
 ) :

1479 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1480 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "xy" ) , 'y-x-'

1483 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "xy" ) , 'y-x'

1485 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V1)(x)?(y)?" , r"\2-\1" , "xy" ) , 'y-x-' )

1486 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1487 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "x" ) , '-x-' )

1489 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "x" ) , '-x' )

1490 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V1)(x)?(y)?" , r"\2-\1" , "x" ) , '-x-' )

1491 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1492 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "y" ) , 'y--' )

1494 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)(x)?(y)?" , r"\2-\1" , "y" ) , 'y-' )

1495 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V1)(x)?(y)?" , r"\2-\1" , "y" ) , 'y--' ) 
	}

1497 def 
	$test_bug_10328
 ( 
self
 ) :

1499 
pat
 = 
regex
 . 
compile
 ( r'(?mV0)(?P<trailing_ws>[ \t]+\r*$)|(?P<no_final_newline>(?<=[^\n])\Z)' )

1500 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

1501 
self
 . 
assertEqual
 ( 
pat
 . 
subn
 ( lambda 
m
 : '<' + 
m
 . 
lastgroup
 + '>' , 'foobar '

1504 
self
 . 
assertEqual
 ( 
pat
 . 
subn
 ( lambda 
m
 : '<' + 
m
 . 
lastgroup
 + '>' , 'foobar '

1506 
self
 . 
assertEqual
 ( [ 
m
 . 
group
 ( ) for 
m
 in 
pat
 . 
finditer
 ( 'foobar ' ) ] , [ ' ' , ''

1508 
pat
 = 
regex
 . 
compile
 ( r'(?mV1)(?P<trailing_ws>[ \t]+\r*$)|(?P<no_final_newline>(?<=[^\n])\Z)' )

1509 
self
 . 
assertEqual
 ( 
pat
 . 
subn
 ( lambda 
m
 : '<' + 
m
 . 
lastgroup
 + '>' , 'foobar '

1511 
self
 . 
assertEqual
 ( [ 
m
 . 
group
 ( ) for 
m
 in 
pat
 . 
finditer
 ( 'foobar ' ) ] , [ ' ' , ''

1512 ] ) 
	}

1514 def 
	$test_overlapped
 ( 
self
 ) :

1515 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".." , "abcde" ) , [ 'ab' , 'cd' ] )

1516 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".." , "abcde" , 
overlapped
 = True ) , [ 'ab' , 'bc'

1518 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).." , "abcde" ) , [ 'de' , 'bc' ] )

1519 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r).." , "abcde" , 
overlapped
 = True ) ,

1521 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(.)(-)(.)" , "a-b-c" , 
overlapped
 = True ) ,

1524 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r".." , "abcde" ) ] , [ 'ab' , 'cd'

1526 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r".." , "abcde" ,

1527 
overlapped
 = True ) ] , [ 'ab' , 'bc' , 'cd' , 'de' ] )

1528 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).." , "abcde" ) ] ,

1530 
self
 . 
assertEqual
 ( [ 
m
 [ 0 ] for 
m
 in 
regex
 . 
finditer
 ( r"(?r).." , "abcde" ,

1531 
overlapped
 = True ) ] , [ 'de' , 'cd' , 'bc' , 'ab' ] )

1533 
self
 . 
assertEqual
 ( [ 
m
 . 
groups
 ( ) for 
m
 in 
regex
 . 
finditer
 ( r"(.)(-)(.)" , "a-b-c"

1534 , 
overlapped
 = True ) ] , [ ( "a" , "-" , "b" ) , ( "b" , "-" , "c" ) ] )

1535 
self
 . 
assertEqual
 ( [ 
m
 . 
groups
 ( ) for 
m
 in 
regex
 . 
finditer
 ( r"(?r)(.)(-)(.)" , "a-b-c"

1536 , 
overlapped
 = True ) ] , [ ( "b" , "-" , "c" ) , ( "a" , "-" , "b" ) ] ) 
	}

1538 def 
	$test_splititer
 ( 
self
 ) :

1539 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r"," , "a,b,,c," ) , [ 'a' , 'b' , '' , 'c' , '' ] )

1540 
self
 . 
assertEqual
 ( [ 
m
 for 
m
 in 
regex
 . 
splititer
 ( r"," , "a,b,,c," ) ] , [ 'a' , 'b'

1541 , '' , 'c' , '' ] ) 
	}

1543 def 
	$test_grapheme
 ( 
self
 ) :

1544 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\X" , "\xE0" ) . 
span
 ( ) , ( 0 , 1 ) )

1545 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\X" , "a\u0300" ) . 
span
 ( ) , ( 0 , 2 ) )

1547 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X" , "a\xE0a\u0300e\xE9e\u0301"

1550 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X{3}" , "a\xE0a\u0300e\xE9e\u0301"

1552 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\X" , "\r\r\n\u0301A\u0301" ) ,

1553 [ '\r' , '\r\n' , '\u0301' , 'A\u0301' ] ) 
	}

1555 def 
	$test_word_boundary
 ( 
self
 ) :

1556 
text
 = 'The quick ("brown") fox can\'t jump 32.3 feet, right?'

1557 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1)\b' , 
text
 ) , [ '' , 'The' , ' ' , 'quick'

1561 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1w)\b' , 
text
 ) , [ '' , 'The' , ' ' , 'quick'

1566 
text
 = "The  fox"

1567 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1)\b' , 
text
 ) , [ '' , 'The' , '  ' , 'fox'

1569 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1w)\b' , 
text
 ) , [ '' , 'The' , '  ' , 'fox'

1572 
text
 = "can't aujourd'hui l'objectif"

1573 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1)\b' , 
text
 ) , [ '' , 'can' , "'" , 't'

1576 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'(?V1w)\b' , 
text
 ) , [ '' , "can't" , ' ' , "aujourd'hui"

1577 , ' ' , "l'objectif" , '' ] ) 
	}

1579 def 
	$test_line_boundary
 ( 
self
 ) :

1580 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".+" , "Line 1\nLine 2\n" ) , [ "Line 1" , "Line 2"

1582 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".+" , "Line 1\rLine 2\r" ) ,

1584 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r".+" , "Line 1\r\nLine 2\r\n" ) ,

1586 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?w).+" , "Line 1\nLine 2\n" ) ,

1588 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?w).+" , "Line 1\rLine 2\r" ) ,

1590 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?w).+" , "Line 1\r\nLine 2\r\n" ) ,

1593 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^abc" , "abc" ) . 
start
 ( ) , 0 )

1594 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^abc" , "\nabc" ) , None )

1595 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^abc" , "\rabc" ) , None )

1596 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)^abc" , "abc" ) . 
start
 ( ) , 0 )

1597 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)^abc" , "\nabc" ) , None )

1598 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)^abc" , "\rabc" ) , None )

1600 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"abc$" , "abc" ) . 
start
 ( ) , 0 )

1601 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"abc$" , "abc\n" ) . 
start
 ( ) , 0 )

1602 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"abc$" , "abc\r" ) , None )

1603 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)abc$" , "abc" ) . 
start
 ( ) , 0 )

1604 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)abc$" , "abc\n" ) . 
start
 ( ) , 0 )

1605 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?w)abc$" , "abc\r" ) . 
start
 ( ) , 0 )

1607 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)^abc" , "abc" ) . 
start
 ( ) , 0 )

1608 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)^abc" , "\nabc" ) . 
start
 ( ) , 1 )

1609 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)^abc" , "\rabc" ) , None )

1610 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)^abc" , "abc" ) . 
start
 ( ) , 0 )

1611 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)^abc" , "\nabc" ) . 
start
 ( ) , 1 )

1612 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)^abc" , "\rabc" ) . 
start
 ( ) , 1 )

1614 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)abc$" , "abc" ) . 
start
 ( ) , 0 )

1615 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)abc$" , "abc\n" ) . 
start
 ( ) , 0 )

1616 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?m)abc$" , "abc\r" ) , None )

1617 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)abc$" , "abc" ) . 
start
 ( ) , 0 )

1618 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)abc$" , "abc\n" ) . 
start
 ( ) , 0 )

1619 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?mw)abc$" , "abc\r" ) . 
start
 ( ) , 0 ) 
	}

1621 def 
	$test_branch_reset
 ( 
self
 ) :

1622 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:(a)|(b))(c)" , "ac" ) . 
groups
 ( ) , ( 'a' ,

1624 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:(a)|(b))(c)" , "bc" ) . 
groups
 ( ) , ( None , 'b'

1626 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:(?<a>a)|(?<b>b))(?<c>c)" , "ac"

1627 ) . 
groups
 ( ) , ( 'a' , None , 'c' ) )

1628 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:(?<a>a)|(?<b>b))(?<c>c)" , "bc"

1629 ) . 
groups
 ( ) , ( None , 'b' , 'c' ) )

1631 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?<a>a)(?:(?<b>b)|(?<c>c))(?<d>d)" , "abd"

1632 ) . 
groups
 ( ) , ( 'a' , 'b' , None , 'd' ) )

1633 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?<a>a)(?:(?<b>b)|(?<c>c))(?<d>d)" , "acd"

1634 ) . 
groups
 ( ) , ( 'a' , None , 'c' , 'd' ) )

1635 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?:(b)|(c))(d)" , "abd" ) . 
groups
 ( ) ,

1638 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?:(b)|(c))(d)" , "acd" ) . 
groups
 ( ) ,

1640 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(a)(?|(b)|(b))(d)" , "abd" ) . 
groups
 ( ) ,

1642 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)|(?<b>b))(c)" , "ac" ) . 
groups
 ( ) ,

1644 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)|(?<b>b))(c)" , "bc" ) . 
groups
 ( ) ,

1646 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)|(?<a>b))(c)" , "ac" ) . 
groups
 ( ) ,

1649 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)|(?<a>b))(c)" , "bc" ) . 
groups
 ( ) ,

1652 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(?<b>c)(?<a>d))(e)" , "abe"

1653 ) . 
groups
 ( ) , ( 'a' , 'b' , 'e' ) )

1654 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(?<b>c)(?<a>d))(e)" , "cde"

1655 ) . 
groups
 ( ) , ( 'd' , 'c' , 'e' ) )

1656 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(?<b>c)(d))(e)" , "abe"

1657 ) . 
groups
 ( ) , ( 'a' , 'b' , 'e' ) )

1658 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(?<b>c)(d))(e)" , "cde"

1659 ) . 
groups
 ( ) , ( 'd' , 'c' , 'e' ) )

1660 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(d))(e)" , "abe"

1661 ) . 
groups
 ( ) , ( 'a' , 'b' , 'e' ) )

1662 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(d))(e)" , "cde"

1663 ) . 
groups
 ( ) , ( 'c' , 'd' , 'e' ) )

1666 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(?<a>d))(e)" , "abe"

1667 ) . 
groups
 ( ) , ( "a" , "b" , "e" ) )

1668 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(?<a>d))(e)" , "abe"

1669 ) . 
capturesdict
 ( ) , { "a" : [ "a" ] , "b" : [ "b" ] } )

1670 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(?<a>d))(e)" , "cde"

1671 ) . 
groups
 ( ) , ( "d" , None , "e" ) )

1672 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?|(?<a>a)(?<b>b)|(c)(?<a>d))(e)" , "cde"

1673 ) . 
capturesdict
 ( ) , { "a" : [ "c" , "d" ] , "b" : [ ] } ) 
	}

1675 def 
	$test_set
 ( 
self
 ) :

1676 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"[a]" , "a" ) . 
span
 ( ) , ( 0 , 1 ) )

1677 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?i)[a]" , "A" ) . 
span
 ( ) , ( 0 , 1 ) )

1678 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"[a-b]" , r"a" ) . 
span
 ( ) , ( 0 , 1 ) )

1679 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?i)[a-b]" , r"A" ) . 
span
 ( ) , ( 0 , 1 ) )

1681 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"(?V0)([][])" , r"-" , "a[b]c" ) , "a-b-c" )

1683 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[\p{Alpha}]" , "a0" ) , [ "a" ] )

1684 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?i)[\p{Alpha}]" , "A0" ) , [ "A" ] )

1686 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[a\p{Alpha}]" , "ab0" ) , [ "a" , "b" ] )

1687 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[a\P{Alpha}]" , "ab0" ) , [ "a" , "0" ] )

1688 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?i)[a\p{Alpha}]" , "ab0" ) , [ "a" , "b"

1690 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?i)[a\P{Alpha}]" , "ab0" ) , [ "a" , "0"

1693 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[a-b\p{Alpha}]" , "abC0" ) , [ "a" , "b"

1695 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?i)[a-b\p{Alpha}]" , "AbC0" ) , [ "A" , "b"

1698 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[\p{Alpha}]" , "a0" ) , [ "a" ] )

1699 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[\P{Alpha}]" , "a0" ) , [ "0" ] )

1700 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[^\p{Alpha}]" , "a0" ) , [ "0" ] )

1701 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"[^\P{Alpha}]" , "a0" ) , [ "a" ] )

1703 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^\d-h]" , "a^b12c-h" ) ) , 'a^bc'

1705 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^\dh]" , "a^b12c-h" ) ) , 'a^bc-'

1707 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^h\s\db]" , "a^b 12c-h" ) ) , 'a^c-'

1709 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^b\w]" , "a b" ) ) , ' ' )

1710 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^b\S]" , "a b" ) ) , ' ' )

1711 
self
 . 
assertEqual
 ( "" . 
join
 ( 
regex
 . 
findall
 ( r"[^8\d]" , "a 1b2" ) ) , 'a b' )

1713 
all_chars
 = "" . 
join
 ( 
chr
 ( 
c
 ) for 
c
 in 
range
 ( 0x100 ) )

1714 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"\p{ASCII}" , 
all_chars
 ) ) , 128 )

1715 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"\p{Letter}" , 
all_chars
 ) ) ,

1717 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"\p{Digit}" , 
all_chars
 ) ) , 10 )

1720 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}&&\p{Letter}]" ,

1721 
all_chars
 ) ) , 52 )

1722 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}&&\p{Alnum}&&\p{Letter}]" ,

1723 
all_chars
 ) ) , 52 )

1724 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}&&\p{Alnum}&&\p{Digit}]" ,

1725 
all_chars
 ) ) , 10 )

1726 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}&&\p{Cc}]" ,

1727 
all_chars
 ) ) , 33 )

1728 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}&&\p{Graph}]" ,

1729 
all_chars
 ) ) , 94 )

1730 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{ASCII}--\p{Cc}]" ,

1731 
all_chars
 ) ) , 95 )

1732 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"[\p{Letter}\p{Digit}]" ,

1733 
all_chars
 ) ) , 127 )

1734 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{Letter}||\p{Digit}]" ,

1735 
all_chars
 ) ) , 127 )

1736 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"\p{HexDigit}" , 
all_chars
 ) ) ,

1738 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{HexDigit}~~\p{Digit}]" ,

1739 
all_chars
 ) ) , 12 )

1740 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r"(?V1)[\p{Digit}~~\p{HexDigit}]" ,

1741 
all_chars
 ) ) , 12 )

1743 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( r"(?V0)([][-])" ) ) ) ,

1744 
self
 . 
PATTERN_CLASS
 )

1745 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?V1)[[a-z]--[aei]]" , "abc" ) , [ "b" , "c"

1747 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?iV1)[[a-z]--[aei]]" , "abc" ) , [ "b" , "c"

1749 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?V1)[\w--a]" , "abc" ) , [ "b" , "c" ] )

1750 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?iV1)[\w--a]" , "abc" ) , [ "b" , "c" ] ) 
	}

1752 def 
	$test_various
 ( 
self
 ) :

1753 
tests
 = [

1755 ( '(?P<foo_123' , '' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_GT
 ) ,

1756 ( '(?P<1>a)' , '' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 ) ,

1757 ( '(?P<!>a)' , '' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 ) ,

1758 ( '(?P<foo!>a)' , '' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 ) ,

1761 ( '(?P<foo_123>a)(?P=foo_123' , 'aa' , '' , 
regex
 . 
error
 ,

1762 
self
 . 
MISSING_RPAREN
 ) ,

1763 ( '(?P<foo_123>a)(?P=1)' , 'aa' , '1' , 
ascii
 ( 'a' ) ) ,

1764 ( '(?P<foo_123>a)(?P=0)' , 'aa' , '' , 
regex
 . 
error
 ,

1765 
self
 . 
BAD_GROUP_NAME
 ) ,

1766 ( '(?P<foo_123>a)(?P=-1)' , 'aa' , '' , 
regex
 . 
error
 ,

1767 
self
 . 
BAD_GROUP_NAME
 ) ,

1768 ( '(?P<foo_123>a)(?P=!)' , 'aa' , '' , 
regex
 . 
error
 ,

1769 
self
 . 
BAD_GROUP_NAME
 ) ,

1770 ( '(?P<foo_123>a)(?P=foo_124)' , 'aa' , '' , 
regex
 . 
error
 ,

1771 
self
 . 
UNKNOWN_GROUP
 ) ,

1773 ( '(?P<foo_123>a)' , 'a' , '1' , 
ascii
 ( 'a' ) ) ,

1774 ( '(?P<foo_123>a)(?P=foo_123)' , 'aa' , '1' , 
ascii
 ( 'a' ) ) ,

1777 ( r'(?<foo_123>a)\g<foo_123' , 'aa' , '' , 
ascii
 ( None ) ) ,

1778 ( r'(?<foo_123>a)\g<1>' , 'aa' , '1' , 
ascii
 ( 'a' ) ) ,

1779 ( r'(?<foo_123>a)\g<!>' , 'aa' , '' , 
ascii
 ( None ) ) ,

1780 ( r'(?<foo_123>a)\g<foo_124>' , 'aa' , '' , 
regex
 . 
error
 ,

1781 
self
 . 
UNKNOWN_GROUP
 ) ,

1783 ( '(?<foo_123>a)' , 'a' , '1' , 
ascii
 ( 'a' ) ) ,

1784 ( r'(?<foo_123>a)\g<foo_123>' , 'aa' , '1' , 
ascii
 ( 'a' ) ) ,

1787 ( '\\1' , 'a' , '' , 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 ) ,

1789 ( '\\09' , 
chr
 ( 0 ) + '9' , '0' , 
ascii
 ( 
chr
 ( 0 ) + '9' ) ) ,

1790 ( '\\141' , 'a' , '0' , 
ascii
 ( 'a' ) ) ,

1792 , 
ascii
 ( ( 'abcdefghijklk9' , 'k' ) ) ) ,

1795 ( r'\0' , '\0' , '0' , 
ascii
 ( '\0' ) ) ,

1796 ( r'[\0a]' , '\0' , '0' , 
ascii
 ( '\0' ) ) ,

1797 ( r'[a\0]' , '\0' , '0' , 
ascii
 ( '\0' ) ) ,

1798 ( r'[^a\0]' , '\0' , '' , 
ascii
 ( None ) ) ,

1802 
ascii
 ( '\a\b\f\n\r\t\v' ) ) ,

1804 
ascii
 ( '\a\b\f\n\r\t\v' ) ) ,

1806 
ascii
 ( 'ceghijkopqyz' ) ) ,

1807 ( r'\xff' , '\377' , '0' , 
ascii
 ( 
chr
 ( 255 ) ) ) ,

1810 ( r'\x00ffffffffffffff' , '\377' , '' , 
ascii
 ( None ) ) ,

1811 ( r'\x00f' , '\017' , '' , 
ascii
 ( None ) ) ,

1812 ( r'\x00fe' , '\376' , '' , 
ascii
 ( None ) ) ,

1814 ( r'\x00ff' , '\377' , '' , 
ascii
 ( None ) ) ,

1815 ( r'\t\n\v\r\f\a\g' , '\t\n\v\r\f\ag' , '0' , 
ascii
 ( '\t\n\v\r\f\ag' ) ) ,

1816 ( '\t\n\v\r\f\a\\g' , '\t\n\v\r\f\ag' , '0' , 
ascii
 ( '\t\n\v\r\f\ag' ) ) ,

1817 ( r'\t\n\v\r\f\a' , '\t\n\v\r\f\a' , '0' , 
ascii
 ( 
chr
 ( 9 ) + 
chr
 ( 10 ) +

1818 
chr
 ( 11 ) + 
chr
 ( 13 ) + 
chr
 ( 12 ) + 
chr
 ( 7 ) ) ) ,

1820 
ascii
 ( '\t\n\v\r\f\b' ) ) ,

1824 
ascii
 ( "SRC=eval.c g.c blah blah blah \\\\" ) ) ,

1827 ( 'a.b' , 'acb' , '0' , 
ascii
 ( 'acb' ) ) ,

1828 ( 'a.b' , 'a\nb' , '' , 
ascii
 ( None ) ) ,

1829 ( 'a.*b' , 'acc\nccb' , '' , 
ascii
 ( None ) ) ,

1830 ( 'a.{4,5}b' , 'acc\nccb' , '' , 
ascii
 ( None ) ) ,

1831 ( 'a.b' , 'a\rb' , '0' , 
ascii
 ( 'a\rb' ) ) ,

1833 ( 'a.b(?s)' , 'a\nb' , '0' , 
ascii
 ( 'a\nb' ) ) ,

1834 ( 'a.b(?sV1)' , 'a\nb' , '' , 
ascii
 ( None ) ) ,

1835 ( '(?s)a.b' , 'a\nb' , '0' , 
ascii
 ( 'a\nb' ) ) ,

1836 ( 'a.*(?s)b' , 'acc\nccb' , '0' , 
ascii
 ( 'acc\nccb' ) ) ,

1837 ( 'a.*(?sV1)b' , 'acc\nccb' , '' , 
ascii
 ( None ) ) ,

1838 ( '(?s)a.*b' , 'acc\nccb' , '0' , 
ascii
 ( 'acc\nccb' ) ) ,

1839 ( '(?s)a.{4,5}b' , 'acc\nccb' , '0' , 
ascii
 ( 'acc\nccb' ) ) ,

1841 ( ')' , '' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

1843 ( 'abc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1844 ( 'abc' , 'xbc' , '' , 
ascii
 ( None ) ) ,

1845 ( 'abc' , 'axc' , '' , 
ascii
 ( None ) ) ,

1846 ( 'abc' , 'abx' , '' , 
ascii
 ( None ) ) ,

1847 ( 'abc' , 'xabcy' , '0' , 
ascii
 ( 'abc' ) ) ,

1848 ( 'abc' , 'ababc' , '0' , 
ascii
 ( 'abc' ) ) ,

1849 ( 'ab*c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1850 ( 'ab*bc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1852 ( 'ab*bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

1853 ( 'ab*bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

1854 ( 'ab+bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

1855 ( 'ab+bc' , 'abc' , '' , 
ascii
 ( None ) ) ,

1856 ( 'ab+bc' , 'abq' , '' , 
ascii
 ( None ) ) ,

1857 ( 'ab+bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

1858 ( 'ab?bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

1859 ( 'ab?bc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1860 ( 'ab?bc' , 'abbbbc' , '' , 
ascii
 ( None ) ) ,

1861 ( 'ab?c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1863 ( '^abc$' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1864 ( '^abc$' , 'abcc' , '' , 
ascii
 ( None ) ) ,

1865 ( '^abc' , 'abcc' , '0' , 
ascii
 ( 'abc' ) ) ,

1866 ( '^abc$' , 'aabc' , '' , 
ascii
 ( None ) ) ,

1867 ( 'abc$' , 'aabc' , '0' , 
ascii
 ( 'abc' ) ) ,

1868 ( '^' , 'abc' , '0' , 
ascii
 ( '' ) ) ,

1869 ( '$' , 'abc' , '0' , 
ascii
 ( '' ) ) ,

1870 ( 'a.c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

1871 ( 'a.c' , 'axc' , '0' , 
ascii
 ( 'axc' ) ) ,

1872 ( 'a.*c' , 'axyzc' , '0' , 
ascii
 ( 'axyzc' ) ) ,

1874 ( 'a.*c' , 'axyzd' , '' , 
ascii
 ( None ) ) ,

1875 ( 'a[bc]d' , 'abc' , '' , 
ascii
 ( None ) ) ,

1876 ( 'a[bc]d' , 'abd' , '0' , 
ascii
 ( 'abd' ) ) ,

1877 ( 'a[b-d]e' , 'abd' , '' , 
ascii
 ( None ) ) ,

1878 ( 'a[b-d]e' , 'ace' , '0' , 
ascii
 ( 'ace' ) ) ,

1879 ( 'a[b-d]' , 'aac' , '0' , 
ascii
 ( 'ac' ) ) ,

1880 ( 'a[-b]' , 'a-' , '0' , 
ascii
 ( 'a-' ) ) ,

1881 ( 'a[\\-b]' , 'a-' , '0' , 
ascii
 ( 'a-' ) ) ,

1882 ( 'a[b-]' , 'a-' , '0' , 
ascii
 ( 'a-' ) ) ,

1883 ( 'a[]b' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

1885 ( 'a[' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

1886 ( 'a\\' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_ESCAPE
 ) ,

1887 ( 'abc)' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

1888 ( '(abc' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_RPAREN
 ) ,

1889 ( 'a]' , 'a]' , '0' , 
ascii
 ( 'a]' ) ) ,

1890 ( 'a[]]b' , 'a]b' , '0' , 
ascii
 ( 'a]b' ) ) ,

1891 ( 'a[]]b' , 'a]b' , '0' , 
ascii
 ( 'a]b' ) ) ,

1892 ( 'a[^bc]d' , 'aed' , '0' , 
ascii
 ( 'aed' ) ) ,

1893 ( 'a[^bc]d' , 'abd' , '' , 
ascii
 ( None ) ) ,

1894 ( 'a[^-b]c' , 'adc' , '0' , 
ascii
 ( 'adc' ) ) ,

1896 ( 'a[^-b]c' , 'a-c' , '' , 
ascii
 ( None ) ) ,

1897 ( 'a[^]b]c' , 'a]c' , '' , 
ascii
 ( None ) ) ,

1898 ( 'a[^]b]c' , 'adc' , '0' , 
ascii
 ( 'adc' ) ) ,

1899 ( '\\ba\\b' , 'a-' , '0' , 
ascii
 ( 'a' ) ) ,

1900 ( '\\ba\\b' , '-a' , '0' , 
ascii
 ( 'a' ) ) ,

1901 ( '\\ba\\b' , '-a-' , '0' , 
ascii
 ( 'a' ) ) ,

1902 ( '\\by\\b' , 'xy' , '' , 
ascii
 ( None ) ) ,

1903 ( '\\by\\b' , 'yz' , '' , 
ascii
 ( None ) ) ,

1904 ( '\\by\\b' , 'xyz' , '' , 
ascii
 ( None ) ) ,

1905 ( 'x\\b' , 'xyz' , '' , 
ascii
 ( None ) ) ,

1907 ( 'x\\B' , 'xyz' , '0' , 
ascii
 ( 'x' ) ) ,

1908 ( '\\Bz' , 'xyz' , '0' , 
ascii
 ( 'z' ) ) ,

1909 ( 'z\\B' , 'xyz' , '' , 
ascii
 ( None ) ) ,

1910 ( '\\Bx' , 'xyz' , '' , 
ascii
 ( None ) ) ,

1911 ( '\\Ba\\B' , 'a-' , '' , 
ascii
 ( None ) ) ,

1912 ( '\\Ba\\B' , '-a' , '' , 
ascii
 ( None ) ) ,

1913 ( '\\Ba\\B' , '-a-' , '' , 
ascii
 ( None ) ) ,

1914 ( '\\By\\B' , 'xy' , '' , 
ascii
 ( None ) ) ,

1915 ( '\\By\\B' , 'yz' , '' , 
ascii
 ( None ) ) ,

1916 ( '\\By\\b' , 'xy' , '0' , 
ascii
 ( 'y' ) ) ,

1918 ( '\\by\\B' , 'yz' , '0' , 
ascii
 ( 'y' ) ) ,

1919 ( '\\By\\B' , 'xyz' , '0' , 
ascii
 ( 'y' ) ) ,

1920 ( 'ab|cd' , 'abc' , '0' , 
ascii
 ( 'ab' ) ) ,

1921 ( 'ab|cd' , 'abcd' , '0' , 
ascii
 ( 'ab' ) ) ,

1922 ( '()ef' , 'def' , '0,1' , 
ascii
 ( ( 'ef' , '' ) ) ) ,

1923 ( '$b' , 'b' , '' , 
ascii
 ( None ) ) ,

1924 ( 'a\\(b' , 'a(b' , '' , 
ascii
 ( ( 'a(b' , ) ) ) ,

1925 ( 'a\\(*b' , 'ab' , '0' , 
ascii
 ( 'ab' ) ) ,

1926 ( 'a\\(*b' , 'a((b' , '0' , 
ascii
 ( 'a((b' ) ) ,

1927 ( 'a\\\\b' , 'a\\b' , '0' , 
ascii
 ( 'a\\b' ) ) ,

1929 ( '((a))' , 'abc' , '0,1,2' , 
ascii
 ( ( 'a' , 'a' , 'a' ) ) ) ,

1930 ( '(a)b(c)' , 'abc' , '0,1,2' , 
ascii
 ( ( 'abc' , 'a' , 'c' ) ) ) ,

1931 ( 'a+b+c' , 'aabbabc' , '0' , 
ascii
 ( 'abc' ) ) ,

1932 ( '(a+|b)*' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

1933 ( '(a+|b)+' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

1934 ( '(a+|b)?' , 'ab' , '0,1' , 
ascii
 ( ( 'a' , 'a' ) ) ) ,

1935 ( ')(' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

1936 ( '[^ab]*' , 'cde' , '0' , 
ascii
 ( 'cde' ) ) ,

1937 ( 'abc' , '' , '' , 
ascii
 ( None ) ) ,

1938 ( 'a*' , '' , '0' , 
ascii
 ( '' ) ) ,

1940 ( 'a|b|c|d|e' , 'e' , '0' , 
ascii
 ( 'e' ) ) ,

1941 ( '(a|b|c|d|e)f' , 'ef' , '0,1' , 
ascii
 ( ( 'ef' , 'e' ) ) ) ,

1942 ( 'abcd*efg' , 'abcdefg' , '0' , 
ascii
 ( 'abcdefg' ) ) ,

1943 ( 'ab*' , 'xabyabbbz' , '0' , 
ascii
 ( 'ab' ) ) ,

1944 ( 'ab*' , 'xayabbbz' , '0' , 
ascii
 ( 'a' ) ) ,

1945 ( '(ab|cd)e' , 'abcde' , '0,1' , 
ascii
 ( ( 'cde' , 'cd' ) ) ) ,

1946 ( '[abhgefdc]ij' , 'hij' , '0' , 
ascii
 ( 'hij' ) ) ,

1947 ( '^(ab|cd)e' , 'abcde' , '' , 
ascii
 ( None ) ) ,

1948 ( '(abc|)ef' , 'abcdef' , '0,1' , 
ascii
 ( ( 'ef' , '' ) ) ) ,

1949 ( '(a|b)c*d' , 'abcd' , '0,1' , 
ascii
 ( ( 'bcd' , 'b' ) ) ) ,

1951 ( '(ab|ab*)bc' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'a' ) ) ) ,

1952 ( 'a([bc]*)c*' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'bc' ) ) ) ,

1953 ( 'a([bc]*)(c*d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'bc' , 'd' ) ) ) ,

1954 ( 'a([bc]+)(c*d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'bc' , 'd' ) ) ) ,

1955 ( 'a([bc]*)(c+d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'b' , 'cd' ) ) ) ,

1956 ( 'a[bcd]*dcdcde' , 'adcdcde' , '0' , 
ascii
 ( 'adcdcde' ) ) ,

1957 ( 'a[bcd]+dcdcde' , 'adcdcde' , '' , 
ascii
 ( None ) ) ,

1958 ( '(ab|a)b*c' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'ab' ) ) ) ,

1959 ( '((a)(b)c)(d)' , 'abcd' , '1,2,3,4' , 
ascii
 ( ( 'abc' , 'a' , 'b' , 'd' ) ) ) ,

1960 ( '[a-zA-Z_][a-zA-Z0-9_]*' , 'alpha' , '0' , 
ascii
 ( 'alpha' ) ) ,

1962 ( '^a(bc+|b[eh])g|.h$' , 'abh' , '0,1' , 
ascii
 ( ( 'bh' , None ) ) ) ,

1963 ( '(bc+d$|ef*g.|h?i(j|k))' , 'effgz' , '0,1,2' , 
ascii
 ( ( 'effgz' , 'effgz'

1965 ( '(bc+d$|ef*g.|h?i(j|k))' , 'ij' , '0,1,2' , 
ascii
 ( ( 'ij' , 'ij' , 'j'

1967 ( '(bc+d$|ef*g.|h?i(j|k))' , 'effg' , '' , 
ascii
 ( None ) ) ,

1968 ( '(bc+d$|ef*g.|h?i(j|k))' , 'bcdd' , '' , 
ascii
 ( None ) ) ,

1969 ( '(bc+d$|ef*g.|h?i(j|k))' , 'reffgz' , '0,1,2' , 
ascii
 ( ( 'effgz' , 'effgz'

1971 ( '(((((((((a)))))))))' , 'a' , '0' , 
ascii
 ( 'a' ) ) ,

1972 ( 'multiple words of text' , 'uh-uh' , '' , 
ascii
 ( None ) ) ,

1974 
ascii
 ( 'multiple words' ) ) ,

1975 ( '(.*)c(.*)' , 'abcde' , '0,1,2' , 
ascii
 ( ( 'abcde' , 'ab' , 'de' ) ) ) ,

1977 ( '\\((.*), (.*)\\)' , '(a, b)' , '2,1' , 
ascii
 ( ( 'b' , 'a' ) ) ) ,

1978 ( '[k]' , 'ab' , '' , 
ascii
 ( None ) ) ,

1979 ( 'a[-]?c' , 'ac' , '0' , 
ascii
 ( 'ac' ) ) ,

1980 ( '(abc)\\1' , 'abcabc' , '1' , 
ascii
 ( 'abc' ) ) ,

1981 ( '([a-c]*)\\1' , 'abcabc' , '1' , 
ascii
 ( 'abc' ) ) ,

1982 ( '^(.+)?B' , 'AB' , '1' , 
ascii
 ( 'A' ) ) ,

1983 ( '(a+).\\1$' , 'aaaaa' , '0,1' , 
ascii
 ( ( 'aaaaa' , 'aa' ) ) ) ,

1984 ( '^(a+).\\1$' , 'aaaa' , '' , 
ascii
 ( None ) ) ,

1985 ( '(abc)\\1' , 'abcabc' , '0,1' , 
ascii
 ( ( 'abcabc' , 'abc' ) ) ) ,

1986 ( '([a-c]+)\\1' , 'abcabc' , '0,1' , 
ascii
 ( ( 'abcabc' , 'abc' ) ) ) ,

1988 ( '(a)\\1' , 'aa' , '0,1' , 
ascii
 ( ( 'aa' , 'a' ) ) ) ,

1989 ( '(a+)\\1' , 'aa' , '0,1' , 
ascii
 ( ( 'aa' , 'a' ) ) ) ,

1990 ( '(a+)+\\1' , 'aa' , '0,1' , 
ascii
 ( ( 'aa' , 'a' ) ) ) ,

1991 ( '(a).+\\1' , 'aba' , '0,1' , 
ascii
 ( ( 'aba' , 'a' ) ) ) ,

1992 ( '(a)ba*\\1' , 'aba' , '0,1' , 
ascii
 ( ( 'aba' , 'a' ) ) ) ,

1993 ( '(aa|a)a\\1$' , 'aaa' , '0,1' , 
ascii
 ( ( 'aaa' , 'a' ) ) ) ,

1994 ( '(a|aa)a\\1$' , 'aaa' , '0,1' , 
ascii
 ( ( 'aaa' , 'a' ) ) ) ,

1995 ( '(a+)a\\1$' , 'aaa' , '0,1' , 
ascii
 ( ( 'aaa' , 'a' ) ) ) ,

1996 ( '([abc]*)\\1' , 'abcabc' , '0,1' , 
ascii
 ( ( 'abcabc' , 'abc' ) ) ) ,

1997 ( '(a)(b)c|ab' , 'ab' , '0,1,2' , 
ascii
 ( ( 'ab' , None , None ) ) ) ,

1999 ( '(a)+x' , 'aaax' , '0,1' , 
ascii
 ( ( 'aaax' , 'a' ) ) ) ,

2000 ( '([ac])+x' , 'aacx' , '0,1' , 
ascii
 ( ( 'aacx' , 'c' ) ) ) ,

2002 
ascii
 ( ( 'd:msgs/tdir/sub1/' , 'tdir/' ) ) ) ,

2004 , 
ascii
 ( ( 'track1.title:TBlah blah blah' , 'track1' , 'title'

2006 ( '([^N]*N)+' , 'abNNxyzN' , '0,1' , 
ascii
 ( ( 'abNNxyzN' , 'xyzN' ) ) ) ,

2007 ( '([^N]*N)+' , 'abNNxyz' , '0,1' , 
ascii
 ( ( 'abNN' , 'N' ) ) ) ,

2008 ( '([abc]*)x' , 'abcx' , '0,1' , 
ascii
 ( ( 'abcx' , 'abc' ) ) ) ,

2009 ( '([abc]*)x' , 'abc' , '' , 
ascii
 ( None ) ) ,

2010 ( '([xyz]*)x' , 'abcx' , '0,1' , 
ascii
 ( ( 'x' , '' ) ) ) ,

2011 ( '(a)+b|aac' , 'aac' , '0,1' , 
ascii
 ( ( 'aac' , None ) ) ) ,

2014 ( '(?P<i d>aaa)a' , 'aaaa' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_GROUP_NAME
 ) ,

2015 ( '(?P<id>aaa)a' , 'aaaa' , '0,id' , 
ascii
 ( ( 'aaaa' , 'aaa' ) ) ) ,

2016 ( '(?P<id>aa)(?P=id)' , 'aaaa' , '0,id' , 
ascii
 ( ( 'aaaa' , 'aa' ) ) ) ,

2017 ( '(?P<id>aa)(?P=xd)' , 'aaaa' , '' , 
regex
 . 
error
 , 
self
 . 
UNKNOWN_GROUP
 ) ,

2020 ( r"\g" , "g" , '0' , 
ascii
 ( 'g' ) ) ,

2021 ( r"\g<1>" , "g" , '' , 
regex
 . 
error
 , 
self
 . 
INVALID_GROUP_REF
 ) ,

2022 ( r"(.)\g<1>" , "gg" , '0' , 
ascii
 ( 'gg' ) ) ,

2023 ( r"(.)\g<1>" , "gg" , '' , 
ascii
 ( ( 'gg' , 'g' ) ) ) ,

2024 ( r"\N" , "N" , '0' , 
ascii
 ( 'N' ) ) ,

2025 ( r"\N{LATIN SMALL LETTER A}" , "a" , '0' , 
ascii
 ( 'a' ) ) ,

2026 ( r"\p" , "p" , '0' , 
ascii
 ( 'p' ) ) ,

2027 ( r"\p{Ll}" , "a" , '0' , 
ascii
 ( 'a' ) ) ,

2028 ( r"\P" , "P" , '0' , 
ascii
 ( 'P' ) ) ,

2029 ( r"\P{Lu}" , "p" , '0' , 
ascii
 ( 'p' ) ) ,

2032 ( 'abc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2033 ( 'abc' , 'xbc' , '' , 
ascii
 ( None ) ) ,

2034 ( 'abc' , 'axc' , '' , 
ascii
 ( None ) ) ,

2035 ( 'abc' , 'abx' , '' , 
ascii
 ( None ) ) ,

2036 ( 'abc' , 'xabcy' , '0' , 
ascii
 ( 'abc' ) ) ,

2037 ( 'abc' , 'ababc' , '0' , 
ascii
 ( 'abc' ) ) ,

2039 ( 'ab*c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2040 ( 'ab*bc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2041 ( 'ab*bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

2042 ( 'ab*bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2043 ( 'ab{0,}bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2044 ( 'ab+bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

2045 ( 'ab+bc' , 'abc' , '' , 
ascii
 ( None ) ) ,

2046 ( 'ab+bc' , 'abq' , '' , 
ascii
 ( None ) ) ,

2047 ( 'ab{1,}bc' , 'abq' , '' , 
ascii
 ( None ) ) ,

2048 ( 'ab+bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2050 ( 'ab{1,}bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2051 ( 'ab{1,3}bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2052 ( 'ab{3,4}bc' , 'abbbbc' , '0' , 
ascii
 ( 'abbbbc' ) ) ,

2053 ( 'ab{4,5}bc' , 'abbbbc' , '' , 
ascii
 ( None ) ) ,

2054 ( 'ab?bc' , 'abbc' , '0' , 
ascii
 ( 'abbc' ) ) ,

2055 ( 'ab?bc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2056 ( 'ab{0,1}bc' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2057 ( 'ab?bc' , 'abbbbc' , '' , 
ascii
 ( None ) ) ,

2058 ( 'ab?c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2059 ( 'ab{0,1}c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2061 ( '^abc$' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2062 ( '^abc$' , 'abcc' , '' , 
ascii
 ( None ) ) ,

2063 ( '^abc' , 'abcc' , '0' , 
ascii
 ( 'abc' ) ) ,

2064 ( '^abc$' , 'aabc' , '' , 
ascii
 ( None ) ) ,

2065 ( 'abc$' , 'aabc' , '0' , 
ascii
 ( 'abc' ) ) ,

2066 ( '^' , 'abc' , '0' , 
ascii
 ( '' ) ) ,

2067 ( '$' , 'abc' , '0' , 
ascii
 ( '' ) ) ,

2068 ( 'a.c' , 'abc' , '0' , 
ascii
 ( 'abc' ) ) ,

2069 ( 'a.c' , 'axc' , '0' , 
ascii
 ( 'axc' ) ) ,

2070 ( 'a.*c' , 'axyzc' , '0' , 
ascii
 ( 'axyzc' ) ) ,

2072 ( 'a.*c' , 'axyzd' , '' , 
ascii
 ( None ) ) ,

2073 ( 'a[bc]d' , 'abc' , '' , 
ascii
 ( None ) ) ,

2074 ( 'a[bc]d' , 'abd' , '0' , 
ascii
 ( 'abd' ) ) ,

2075 ( 'a[b-d]e' , 'abd' , '' , 
ascii
 ( None ) ) ,

2076 ( 'a[b-d]e' , 'ace' , '0' , 
ascii
 ( 'ace' ) ) ,

2077 ( 'a[b-d]' , 'aac' , '0' , 
ascii
 ( 'ac' ) ) ,

2078 ( 'a[-b]' , 'a-' , '0' , 
ascii
 ( 'a-' ) ) ,

2079 ( 'a[b-]' , 'a-' , '0' , 
ascii
 ( 'a-' ) ) ,

2080 ( 'a[b-a]' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_CHAR_RANGE
 ) ,

2081 ( 'a[]b' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

2083 ( 'a[' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

2084 ( 'a]' , 'a]' , '0' , 
ascii
 ( 'a]' ) ) ,

2085 ( 'a[]]b' , 'a]b' , '0' , 
ascii
 ( 'a]b' ) ) ,

2086 ( 'a[^bc]d' , 'aed' , '0' , 
ascii
 ( 'aed' ) ) ,

2087 ( 'a[^bc]d' , 'abd' , '' , 
ascii
 ( None ) ) ,

2088 ( 'a[^-b]c' , 'adc' , '0' , 
ascii
 ( 'adc' ) ) ,

2089 ( 'a[^-b]c' , 'a-c' , '' , 
ascii
 ( None ) ) ,

2090 ( 'a[^]b]c' , 'a]c' , '' , 
ascii
 ( None ) ) ,

2091 ( 'a[^]b]c' , 'adc' , '0' , 
ascii
 ( 'adc' ) ) ,

2092 ( 'ab|cd' , 'abc' , '0' , 
ascii
 ( 'ab' ) ) ,

2094 ( 'ab|cd' , 'abcd' , '0' , 
ascii
 ( 'ab' ) ) ,

2095 ( '()ef' , 'def' , '0,1' , 
ascii
 ( ( 'ef' , '' ) ) ) ,

2096 ( '*a' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
NOTHING_TO_REPEAT
 ) ,

2097 ( '(*)b' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
NOTHING_TO_REPEAT
 ) ,

2098 ( '$b' , 'b' , '' , 
ascii
 ( None ) ) ,

2099 ( 'a\\' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_ESCAPE
 ) ,

2100 ( 'a\\(b' , 'a(b' , '' , 
ascii
 ( ( 'a(b' , ) ) ) ,

2101 ( 'a\\(*b' , 'ab' , '0' , 
ascii
 ( 'ab' ) ) ,

2102 ( 'a\\(*b' , 'a((b' , '0' , 
ascii
 ( 'a((b' ) ) ,

2103 ( 'a\\\\b' , 'a\\b' , '0' , 
ascii
 ( 'a\\b' ) ) ,

2105 ( 'abc)' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

2106 ( '(abc' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_RPAREN
 ) ,

2107 ( '((a))' , 'abc' , '0,1,2' , 
ascii
 ( ( 'a' , 'a' , 'a' ) ) ) ,

2108 ( '(a)b(c)' , 'abc' , '0,1,2' , 
ascii
 ( ( 'abc' , 'a' , 'c' ) ) ) ,

2109 ( 'a+b+c' , 'aabbabc' , '0' , 
ascii
 ( 'abc' ) ) ,

2110 ( 'a{1,}b{1,}c' , 'aabbabc' , '0' , 
ascii
 ( 'abc' ) ) ,

2111 ( 'a**' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
MULTIPLE_REPEAT
 ) ,

2112 ( 'a.+?c' , 'abcabc' , '0' , 
ascii
 ( 'abc' ) ) ,

2113 ( '(a+|b)*' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

2114 ( '(a+|b){0,}' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

2116 ( '(a+|b)+' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

2117 ( '(a+|b){1,}' , 'ab' , '0,1' , 
ascii
 ( ( 'ab' , 'b' ) ) ) ,

2118 ( '(a+|b)?' , 'ab' , '0,1' , 
ascii
 ( ( 'a' , 'a' ) ) ) ,

2119 ( '(a+|b){0,1}' , 'ab' , '0,1' , 
ascii
 ( ( 'a' , 'a' ) ) ) ,

2120 ( ')(' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

2121 ( '[^ab]*' , 'cde' , '0' , 
ascii
 ( 'cde' ) ) ,

2122 ( 'abc' , '' , '' , 
ascii
 ( None ) ) ,

2123 ( 'a*' , '' , '0' , 
ascii
 ( '' ) ) ,

2124 ( '([abc])*d' , 'abbbcd' , '0,1' , 
ascii
 ( ( 'abbbcd' , 'c' ) ) ) ,

2125 ( '([abc])*bcd' , 'abcd' , '0,1' , 
ascii
 ( ( 'abcd' , 'a' ) ) ) ,

2127 ( 'a|b|c|d|e' , 'e' , '0' , 
ascii
 ( 'e' ) ) ,

2128 ( '(a|b|c|d|e)f' , 'ef' , '0,1' , 
ascii
 ( ( 'ef' , 'e' ) ) ) ,

2129 ( 'abcd*efg' , 'abcdefg' , '0' , 
ascii
 ( 'abcdefg' ) ) ,

2130 ( 'ab*' , 'xabyabbbz' , '0' , 
ascii
 ( 'ab' ) ) ,

2131 ( 'ab*' , 'xayabbbz' , '0' , 
ascii
 ( 'a' ) ) ,

2132 ( '(ab|cd)e' , 'abcde' , '0,1' , 
ascii
 ( ( 'cde' , 'cd' ) ) ) ,

2133 ( '[abhgefdc]ij' , 'hij' , '0' , 
ascii
 ( 'hij' ) ) ,

2134 ( '^(ab|cd)e' , 'abcde' , '' , 
ascii
 ( None ) ) ,

2135 ( '(abc|)ef' , 'abcdef' , '0,1' , 
ascii
 ( ( 'ef' , '' ) ) ) ,

2136 ( '(a|b)c*d' , 'abcd' , '0,1' , 
ascii
 ( ( 'bcd' , 'b' ) ) ) ,

2138 ( '(ab|ab*)bc' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'a' ) ) ) ,

2139 ( 'a([bc]*)c*' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'bc' ) ) ) ,

2140 ( 'a([bc]*)(c*d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'bc' , 'd' ) ) ) ,

2141 ( 'a([bc]+)(c*d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'bc' , 'd' ) ) ) ,

2142 ( 'a([bc]*)(c+d)' , 'abcd' , '0,1,2' , 
ascii
 ( ( 'abcd' , 'b' , 'cd' ) ) ) ,

2143 ( 'a[bcd]*dcdcde' , 'adcdcde' , '0' , 
ascii
 ( 'adcdcde' ) ) ,

2144 ( 'a[bcd]+dcdcde' , 'adcdcde' , '' , 
ascii
 ( None ) ) ,

2145 ( '(ab|a)b*c' , 'abc' , '0,1' , 
ascii
 ( ( 'abc' , 'ab' ) ) ) ,

2146 ( '((a)(b)c)(d)' , 'abcd' , '1,2,3,4' , 
ascii
 ( ( 'abc' , 'a' , 'b' , 'd' ) ) ) ,

2147 ( '[a-zA-Z_][a-zA-Z0-9_]*' , 'alpha' , '0' , 
ascii
 ( 'alpha' ) ) ,

2149 ( '^a(bc+|b[eh])g|.h$' , 'abh' , '0,1' , 
ascii
 ( ( 'bh' , None ) ) ) ,

2150 ( '(bc+d$|ef*g.|h?i(j|k))' , 'effgz' , '0,1,2' , 
ascii
 ( ( 'effgz' , 'effgz'

2152 ( '(bc+d$|ef*g.|h?i(j|k))' , 'ij' , '0,1,2' , 
ascii
 ( ( 'ij' , 'ij' , 'j'

2154 ( '(bc+d$|ef*g.|h?i(j|k))' , 'effg' , '' , 
ascii
 ( None ) ) ,

2155 ( '(bc+d$|ef*g.|h?i(j|k))' , 'bcdd' , '' , 
ascii
 ( None ) ) ,

2156 ( '(bc+d$|ef*g.|h?i(j|k))' , 'reffgz' , '0,1,2' , 
ascii
 ( ( 'effgz' , 'effgz'

2158 ( '((((((((((a))))))))))' , 'a' , '10' , 
ascii
 ( 'a' ) ) ,

2159 ( '((((((((((a))))))))))\\10' , 'aa' , '0' , 
ascii
 ( 'aa' ) ) ,

2164 ( '((((((((((a))))))))))\\41' , '' , '' , 
regex
 . 
error
 ,

2165 
self
 . 
INVALID_GROUP_REF
 ) ,

2166 ( '(?i)((((((((((a))))))))))\\41' , '' , '' , 
regex
 . 
error
 ,

2167 
self
 . 
INVALID_GROUP_REF
 ) ,

2169 ( '(((((((((a)))))))))' , 'a' , '0' , 
ascii
 ( 'a' ) ) ,

2170 ( 'multiple words of text' , 'uh-uh' , '' , 
ascii
 ( None ) ) ,

2172 
ascii
 ( 'multiple words' ) ) ,

2173 ( '(.*)c(.*)' , 'abcde' , '0,1,2' , 
ascii
 ( ( 'abcde' , 'ab' , 'de' ) ) ) ,

2174 ( '\\((.*), (.*)\\)' , '(a, b)' , '2,1' , 
ascii
 ( ( 'b' , 'a' ) ) ) ,

2175 ( '[k]' , 'ab' , '' , 
ascii
 ( None ) ) ,

2176 ( 'a[-]?c' , 'ac' , '0' , 
ascii
 ( 'ac' ) ) ,

2177 ( '(abc)\\1' , 'abcabc' , '1' , 
ascii
 ( 'abc' ) ) ,

2178 ( '([a-c]*)\\1' , 'abcabc' , '1' , 
ascii
 ( 'abc' ) ) ,

2179 ( '(?i)abc' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2181 ( '(?i)abc' , 'XBC' , '' , 
ascii
 ( None ) ) ,

2182 ( '(?i)abc' , 'AXC' , '' , 
ascii
 ( None ) ) ,

2183 ( '(?i)abc' , 'ABX' , '' , 
ascii
 ( None ) ) ,

2184 ( '(?i)abc' , 'XABCY' , '0' , 
ascii
 ( 'ABC' ) ) ,

2185 ( '(?i)abc' , 'ABABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2186 ( '(?i)ab*c' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2187 ( '(?i)ab*bc' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2188 ( '(?i)ab*bc' , 'ABBC' , '0' , 
ascii
 ( 'ABBC' ) ) ,

2189 ( '(?i)ab*?bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2190 ( '(?i)ab{0,}?bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2192 ( '(?i)ab+?bc' , 'ABBC' , '0' , 
ascii
 ( 'ABBC' ) ) ,

2193 ( '(?i)ab+bc' , 'ABC' , '' , 
ascii
 ( None ) ) ,

2194 ( '(?i)ab+bc' , 'ABQ' , '' , 
ascii
 ( None ) ) ,

2195 ( '(?i)ab{1,}bc' , 'ABQ' , '' , 
ascii
 ( None ) ) ,

2196 ( '(?i)ab+bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2197 ( '(?i)ab{1,}?bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2198 ( '(?i)ab{1,3}?bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2199 ( '(?i)ab{3,4}?bc' , 'ABBBBC' , '0' , 
ascii
 ( 'ABBBBC' ) ) ,

2200 ( '(?i)ab{4,5}?bc' , 'ABBBBC' , '' , 
ascii
 ( None ) ) ,

2201 ( '(?i)ab??bc' , 'ABBC' , '0' , 
ascii
 ( 'ABBC' ) ) ,

2203 ( '(?i)ab??bc' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2204 ( '(?i)ab{0,1}?bc' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2205 ( '(?i)ab??bc' , 'ABBBBC' , '' , 
ascii
 ( None ) ) ,

2206 ( '(?i)ab??c' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2207 ( '(?i)ab{0,1}?c' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2208 ( '(?i)^abc$' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2209 ( '(?i)^abc$' , 'ABCC' , '' , 
ascii
 ( None ) ) ,

2210 ( '(?i)^abc' , 'ABCC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2211 ( '(?i)^abc$' , 'AABC' , '' , 
ascii
 ( None ) ) ,

2212 ( '(?i)abc$' , 'AABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2214 ( '(?i)^' , 'ABC' , '0' , 
ascii
 ( '' ) ) ,

2215 ( '(?i)$' , 'ABC' , '0' , 
ascii
 ( '' ) ) ,

2216 ( '(?i)a.c' , 'ABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2217 ( '(?i)a.c' , 'AXC' , '0' , 
ascii
 ( 'AXC' ) ) ,

2218 ( '(?i)a.*?c' , 'AXYZC' , '0' , 
ascii
 ( 'AXYZC' ) ) ,

2219 ( '(?i)a.*c' , 'AXYZD' , '' , 
ascii
 ( None ) ) ,

2220 ( '(?i)a[bc]d' , 'ABC' , '' , 
ascii
 ( None ) ) ,

2221 ( '(?i)a[bc]d' , 'ABD' , '0' , 
ascii
 ( 'ABD' ) ) ,

2222 ( '(?i)a[b-d]e' , 'ABD' , '' , 
ascii
 ( None ) ) ,

2223 ( '(?i)a[b-d]e' , 'ACE' , '0' , 
ascii
 ( 'ACE' ) ) ,

2225 ( '(?i)a[b-d]' , 'AAC' , '0' , 
ascii
 ( 'AC' ) ) ,

2226 ( '(?i)a[-b]' , 'A-' , '0' , 
ascii
 ( 'A-' ) ) ,

2227 ( '(?i)a[b-]' , 'A-' , '0' , 
ascii
 ( 'A-' ) ) ,

2228 ( '(?i)a[b-a]' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_CHAR_RANGE
 ) ,

2229 ( '(?i)a[]b' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

2230 ( '(?i)a[' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_SET
 ) ,

2231 ( '(?i)a]' , 'A]' , '0' , 
ascii
 ( 'A]' ) ) ,

2232 ( '(?i)a[]]b' , 'A]B' , '0' , 
ascii
 ( 'A]B' ) ) ,

2233 ( '(?i)a[^bc]d' , 'AED' , '0' , 
ascii
 ( 'AED' ) ) ,

2234 ( '(?i)a[^bc]d' , 'ABD' , '' , 
ascii
 ( None ) ) ,

2236 ( '(?i)a[^-b]c' , 'ADC' , '0' , 
ascii
 ( 'ADC' ) ) ,

2237 ( '(?i)a[^-b]c' , 'A-C' , '' , 
ascii
 ( None ) ) ,

2238 ( '(?i)a[^]b]c' , 'A]C' , '' , 
ascii
 ( None ) ) ,

2239 ( '(?i)a[^]b]c' , 'ADC' , '0' , 
ascii
 ( 'ADC' ) ) ,

2240 ( '(?i)ab|cd' , 'ABC' , '0' , 
ascii
 ( 'AB' ) ) ,

2241 ( '(?i)ab|cd' , 'ABCD' , '0' , 
ascii
 ( 'AB' ) ) ,

2242 ( '(?i)()ef' , 'DEF' , '0,1' , 
ascii
 ( ( 'EF' , '' ) ) ) ,

2243 ( '(?i)*a' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
NOTHING_TO_REPEAT
 ) ,

2244 ( '(?i)(*)b' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
NOTHING_TO_REPEAT
 ) ,

2245 ( '(?i)$b' , 'B' , '' , 
ascii
 ( None ) ) ,

2247 ( '(?i)a\\' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
BAD_ESCAPE
 ) ,

2248 ( '(?i)a\\(b' , 'A(B' , '' , 
ascii
 ( ( 'A(B' , ) ) ) ,

2249 ( '(?i)a\\(*b' , 'AB' , '0' , 
ascii
 ( 'AB' ) ) ,

2250 ( '(?i)a\\(*b' , 'A((B' , '0' , 
ascii
 ( 'A((B' ) ) ,

2251 ( '(?i)a\\\\b' , 'A\\B' , '0' , 
ascii
 ( 'A\\B' ) ) ,

2252 ( '(?i)abc)' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

2253 ( '(?i)(abc' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_RPAREN
 ) ,

2254 ( '(?i)((a))' , 'ABC' , '0,1,2' , 
ascii
 ( ( 'A' , 'A' , 'A' ) ) ) ,

2255 ( '(?i)(a)b(c)' , 'ABC' , '0,1,2' , 
ascii
 ( ( 'ABC' , 'A' , 'C' ) ) ) ,

2256 ( '(?i)a+b+c' , 'AABBABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2258 ( '(?i)a{1,}b{1,}c' , 'AABBABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2259 ( '(?i)a**' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
MULTIPLE_REPEAT
 ) ,

2260 ( '(?i)a.+?c' , 'ABCABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2261 ( '(?i)a.*?c' , 'ABCABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2262 ( '(?i)a.{0,5}?c' , 'ABCABC' , '0' , 
ascii
 ( 'ABC' ) ) ,

2263 ( '(?i)(a+|b)*' , 'AB' , '0,1' , 
ascii
 ( ( 'AB' , 'B' ) ) ) ,

2264 ( '(?i)(a+|b){0,}' , 'AB' , '0,1' , 
ascii
 ( ( 'AB' , 'B' ) ) ) ,

2265 ( '(?i)(a+|b)+' , 'AB' , '0,1' , 
ascii
 ( ( 'AB' , 'B' ) ) ) ,

2266 ( '(?i)(a+|b){1,}' , 'AB' , '0,1' , 
ascii
 ( ( 'AB' , 'B' ) ) ) ,

2267 ( '(?i)(a+|b)?' , 'AB' , '0,1' , 
ascii
 ( ( 'A' , 'A' ) ) ) ,

2269 ( '(?i)(a+|b){0,1}' , 'AB' , '0,1' , 
ascii
 ( ( 'A' , 'A' ) ) ) ,

2270 ( '(?i)(a+|b){0,1}?' , 'AB' , '0,1' , 
ascii
 ( ( '' , None ) ) ) ,

2271 ( '(?i))(' , '-' , '' , 
regex
 . 
error
 , 
self
 . 
TRAILING_CHARS
 ) ,

2272 ( '(?i)[^ab]*' , 'CDE' , '0' , 
ascii
 ( 'CDE' ) ) ,

2273 ( '(?i)abc' , '' , '' , 
ascii
 ( None ) ) ,

2274 ( '(?i)a*' , '' , '0' , 
ascii
 ( '' ) ) ,

2275 ( '(?i)([abc])*d' , 'ABBBCD' , '0,1' , 
ascii
 ( ( 'ABBBCD' , 'C' ) ) ) ,

2276 ( '(?i)([abc])*bcd' , 'ABCD' , '0,1' , 
ascii
 ( ( 'ABCD' , 'A' ) ) ) ,

2277 ( '(?i)a|b|c|d|e' , 'E' , '0' , 
ascii
 ( 'E' ) ) ,

2278 ( '(?i)(a|b|c|d|e)f' , 'EF' , '0,1' , 
ascii
 ( ( 'EF' , 'E' ) ) ) ,

2280 ( '(?i)abcd*efg' , 'ABCDEFG' , '0' , 
ascii
 ( 'ABCDEFG' ) ) ,

2281 ( '(?i)ab*' , 'XABYABBBZ' , '0' , 
ascii
 ( 'AB' ) ) ,

2282 ( '(?i)ab*' , 'XAYABBBZ' , '0' , 
ascii
 ( 'A' ) ) ,

2283 ( '(?i)(ab|cd)e' , 'ABCDE' , '0,1' , 
ascii
 ( ( 'CDE' , 'CD' ) ) ) ,

2284 ( '(?i)[abhgefdc]ij' , 'HIJ' , '0' , 
ascii
 ( 'HIJ' ) ) ,

2285 ( '(?i)^(ab|cd)e' , 'ABCDE' , '' , 
ascii
 ( None ) ) ,

2286 ( '(?i)(abc|)ef' , 'ABCDEF' , '0,1' , 
ascii
 ( ( 'EF' , '' ) ) ) ,

2287 ( '(?i)(a|b)c*d' , 'ABCD' , '0,1' , 
ascii
 ( ( 'BCD' , 'B' ) ) ) ,

2288 ( '(?i)(ab|ab*)bc' , 'ABC' , '0,1' , 
ascii
 ( ( 'ABC' , 'A' ) ) ) ,

2289 ( '(?i)a([bc]*)c*' , 'ABC' , '0,1' , 
ascii
 ( ( 'ABC' , 'BC' ) ) ) ,

2291 ( '(?i)a([bc]*)(c*d)' , 'ABCD' , '0,1,2' , 
ascii
 ( ( 'ABCD' , 'BC' , 'D' ) ) ) ,

2292 ( '(?i)a([bc]+)(c*d)' , 'ABCD' , '0,1,2' , 
ascii
 ( ( 'ABCD' , 'BC' , 'D' ) ) ) ,

2293 ( '(?i)a([bc]*)(c+d)' , 'ABCD' , '0,1,2' , 
ascii
 ( ( 'ABCD' , 'B' , 'CD' ) ) ) ,

2294 ( '(?i)a[bcd]*dcdcde' , 'ADCDCDE' , '0' , 
ascii
 ( 'ADCDCDE' ) ) ,

2295 ( '(?i)a[bcd]+dcdcde' , 'ADCDCDE' , '' , 
ascii
 ( None ) ) ,

2296 ( '(?i)(ab|a)b*c' , 'ABC' , '0,1' , 
ascii
 ( ( 'ABC' , 'AB' ) ) ) ,

2297 ( '(?i)((a)(b)c)(d)' , 'ABCD' , '1,2,3,4' , 
ascii
 ( ( 'ABC' , 'A' , 'B' , 'D'

2299 ( '(?i)[a-zA-Z_][a-zA-Z0-9_]*' , 'ALPHA' , '0' , 
ascii
 ( 'ALPHA' ) ) ,

2300 ( '(?i)^a(bc+|b[eh])g|.h$' , 'ABH' , '0,1' , 
ascii
 ( ( 'BH' , None ) ) ) ,

2301 ( '(?i)(bc+d$|ef*g.|h?i(j|k))' , 'EFFGZ' , '0,1,2' , 
ascii
 ( ( 'EFFGZ' , 'EFFGZ'

2304 ( '(?i)(bc+d$|ef*g.|h?i(j|k))' , 'IJ' , '0,1,2' , 
ascii
 ( ( 'IJ' , 'IJ' , 'J'

2306 ( '(?i)(bc+d$|ef*g.|h?i(j|k))' , 'EFFG' , '' , 
ascii
 ( None ) ) ,

2307 ( '(?i)(bc+d$|ef*g.|h?i(j|k))' , 'BCDD' , '' , 
ascii
 ( None ) ) ,

2308 ( '(?i)(bc+d$|ef*g.|h?i(j|k))' , 'REFFGZ' , '0,1,2' , 
ascii
 ( ( 'EFFGZ' , 'EFFGZ'

2310 ( '(?i)((((((((((a))))))))))' , 'A' , '10' , 
ascii
 ( 'A' ) ) ,

2311 ( '(?i)((((((((((a))))))))))\\10' , 'AA' , '0' , 
ascii
 ( 'AA' ) ) ,

2314 ( '(?i)(((((((((a)))))))))' , 'A' , '0' , 
ascii
 ( 'A' ) ) ,

2316 
ascii
 ( 'A' ) ) ,

2318 
ascii
 ( 'C' ) ) ,

2319 ( '(?i)multiple words of text' , 'UH-UH' , '' , 
ascii
 ( None ) ) ,

2322 
ascii
 ( 'MULTIPLE WORDS' ) ) ,

2323 ( '(?i)(.*)c(.*)' , 'ABCDE' , '0,1,2' , 
ascii
 ( ( 'ABCDE' , 'AB' , 'DE' ) ) ) ,

2324 ( '(?i)\\((.*), (.*)\\)' , '(A, B)' , '2,1' , 
ascii
 ( ( 'B' , 'A' ) ) ) ,

2325 ( '(?i)[k]' , 'AB' , '' , 
ascii
 ( None ) ) ,

2328 ( '(?i)a[-]?c' , 'AC' , '0' , 
ascii
 ( 'AC' ) ) ,

2329 ( '(?i)(abc)\\1' , 'ABCABC' , '1' , 
ascii
 ( 'ABC' ) ) ,

2330 ( '(?i)([a-c]*)\\1' , 'ABCABC' , '1' , 
ascii
 ( 'ABC' ) ) ,

2331 ( 'a(?!b).' , 'abad' , '0' , 
ascii
 ( 'ad' ) ) ,

2332 ( 'a(?=d).' , 'abad' , '0' , 
ascii
 ( 'ad' ) ) ,

2333 ( 'a(?=c|d).' , 'abad' , '0' , 
ascii
 ( 'ad' ) ) ,

2335 ( 'a(?:b|c|d)(.)' , 'ace' , '1' , 
ascii
 ( 'e' ) ) ,

2336 ( 'a(?:b|c|d)*(.)' , 'ace' , '1' , 
ascii
 ( 'e' ) ) ,

2337 ( 'a(?:b|c|d)+?(.)' , 'ace' , '1' , 
ascii
 ( 'e' ) ) ,

2338 ( 'a(?:b|(c|e){1,2}?|d)+?(.)' , 'ace' , '1,2' , 
ascii
 ( ( 'c' , 'e' ) ) ) ,

2341 ( '(?<!-):(.*?)(?<!-):' , 'a:bc-:de:f' , '1' , 
ascii
 ( 'bc-:de' ) ) ,

2343 ( '(?<!\\\\):(.*?)(?<!\\\\):' , 'a:bc\\:de:f' , '1' , 
ascii
 ( 'bc\\:de' ) ) ,

2345 ( "(?<!\\?)'(.*?)(?<!\\?)'" , "a'bc?'de'f" , '1' , 
ascii
 ( "bc?'de" ) ) ,

2349 ( 'w(?# comment' , 'w' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_RPAREN
 ) ,

2350 ( 'w(?# comment 1)xy(?# comment 2)z' , 'wxyz' , '0' , 
ascii
 ( 'wxyz' ) ) ,

2357 ( 'w(?i)' , 'W' , '0' , 
ascii
 ( 'W' ) ) ,

2358 ( 'w(?iV1)' , 'W' , '0' , 
ascii
 ( None ) ) ,

2359 ( 'w(?i)' , 'w' , '0' , 
ascii
 ( 'w' ) ) ,

2360 ( 'w(?iV1)' , 'w' , '0' , 
ascii
 ( 'w' ) ) ,

2361 ( '(?i)w' , 'W' , '0' , 
ascii
 ( 'W' ) ) ,

2362 ( '(?iV1)w' , 'W' , '0' , 
ascii
 ( 'W' ) ) ,

2368 , 'wxyz' , '0' , 
ascii
 ( 'wxyz' ) ) ,

2373 , '' , 
ascii
 ( None ) ) ,

2376 , '0' , 
ascii
 ( 'abc' ) ) ,

2380 , '0' , 
ascii
 ( 'abc' ) ) ,

2383 ( 'a.b' , 'a\nb' , '' , 
ascii
 ( None ) ) ,

2384 ( '(?s)a.b' , 'a\nb' , '0' , 
ascii
 ( 'a\nb' ) ) ,

2387 ( '\\w+' , '--ab_cd0123--' , '0' , 
ascii
 ( 'ab_cd0123' ) ) ,

2388 ( '[\\w]+' , '--ab_cd0123--' , '0' , 
ascii
 ( 'ab_cd0123' ) ) ,

2389 ( '\\D+' , '1234abc5678' , '0' , 
ascii
 ( 'abc' ) ) ,

2390 ( '[\\D]+' , '1234abc5678' , '0' , 
ascii
 ( 'abc' ) ) ,

2391 ( '[\\da-fA-F]+' , '123abc' , '0' , 
ascii
 ( '123abc' ) ) ,

2394 ( r'([\s]*)([\S]*)([\s]*)' , ' testing!1972' , '3,2,1' , 
ascii
 ( ( '' , 'testing!1972'

2396 ( r'(\s*)(\S*)(\s*)' , ' testing!1972' , '3,2,1' , 
ascii
 ( ( '' , 'testing!1972'

2403 ( r'(([a-z]+):)?([a-z]+)$' , 'smil' , '1,2,3' , 
ascii
 ( ( None , None , 'smil'

2406 ( r'((.)\1+)' , '' , '' , 
regex
 . 
error
 , 
self
 . 
OPEN_GROUP
 ) ,

2408 ( r'.*d' , 'abc\nabd' , '0' , 
ascii
 ( 'abd' ) ) ,

2410 ( r'(' , '' , '' , 
regex
 . 
error
 , 
self
 . 
MISSING_RPAREN
 ) ,

2411 ( r'[\41]' , '!' , '0' , 
ascii
 ( '!' ) ) ,

2413 ( r'(x?)?' , 'x' , '0' , 
ascii
 ( 'x' ) ) ,

2417 ( r' (?x)foo ' , 'foo' , '0' , 
ascii
 ( 'foo' ) ) ,

2418 ( r' (?V1x)foo ' , 'foo' , '0' , 
ascii
 ( None ) ) ,

2419 ( r'(?x) foo ' , 'foo' , '0' , 
ascii
 ( 'foo' ) ) ,

2420 ( r'(?V1x) foo ' , 'foo' , '0' , 
ascii
 ( 'foo' ) ) ,

2421 ( r'(?x)foo ' , 'foo' , '0' , 
ascii
 ( 'foo' ) ) ,

2422 ( r'(?V1x)foo ' , 'foo' , '0' , 
ascii
 ( 'foo' ) ) ,

2424 ( r'(?<!abc)(d.f)' , 'abcdefdof' , '0' , 
ascii
 ( 'dof' ) ) ,

2426 ( r'[\w-]+' , 'laser_beam' , '0' , 
ascii
 ( 'laser_beam' ) ) ,

2428 ( r'.*?\S *:' , 'xx:' , '0' , 
ascii
 ( 'xx:' ) ) ,

2429 ( r'a[ ]*?\ (\d+).*' , 'a   10' , '0' , 
ascii
 ( 'a   10' ) ) ,

2430 ( r'a[ ]*?\ (\d+).*' , 'a    10' , '0' , 
ascii
 ( 'a    10' ) ) ,

2432 ( r'(?ms).*?x\s*\Z(.*)' , 'xx\nx\n' , '1' , 
ascii
 ( '' ) ) ,

2434 ( r'(?i)M+' , 'MMM' , '0' , 
ascii
 ( 'MMM' ) ) ,

2435 ( r'(?i)m+' , 'MMM' , '0' , 
ascii
 ( 'MMM' ) ) ,

2436 ( r'(?i)[M]+' , 'MMM' , '0' , 
ascii
 ( 'MMM' ) ) ,

2437 ( r'(?i)[m]+' , 'MMM' , '0' , 
ascii
 ( 'MMM' ) ) ,

2442 ( r'"(?:\\"|[^"])*?"' , r'"\""' , '0' , 
ascii
 ( r'"\""' ) ) ,

2444 ( r'^.*?$' , 'one\ntwo\nthree\n' , '' , 
ascii
 ( None ) ) ,

2446 ( r'a[^>]*?b' , 'a>b' , '' , 
ascii
 ( None ) ) ,

2448 ( r'^a*?$' , 'foo' , '' , 
ascii
 ( None ) ) ,

2450 ( r'^((a)c)?(ab)$' , 'ab' , '1,2,3' , 
ascii
 ( ( None , None , 'ab' ) ) ) ,

2452 ( '^([ab]*?)(?=(b)?)c' , 'abc' , '1,2' , 
ascii
 ( ( 'ab' , None ) ) ) ,

2453 ( '^([ab]*?)(?!(b))c' , 'abc' , '1,2' , 
ascii
 ( ( 'ab' , None ) ) ) ,

2454 ( '^([ab]*?)(?<!(a))c' , 'abc' , '1,2' , 
ascii
 ( ( 'ab' , None ) ) ) ,

2456 ( r'\b.\b' , 'a' , '0' , 
ascii
 ( 'a' ) ) ,

2458 
ascii
 ( '\xc4' ) ) ,

2460 
ascii
 ( '\xc4' ) ) ,

2463 for 
t
 in 
tests
 :

2464 
excval
 = None

2466 if 
len
 ( 
t
 ) == 4 :

2467 
pattern
 , 
string
 , 
groups
 , 
expected
 = 
t

2469 
pattern
 , 
string
 , 
groups
 , 
expected
 , 
excval
 = 
t

2470 except 
ValueError
 :

2471 
fields
 = ", " . 
join
 ( [ 
ascii
 ( 
f
 ) for 
f
 in 
t
 [ : 3 ] ] + [ "..." ] )

2472 
self
 . 
fail
 ( "Incorrect number of test fields: ({})" . 
format
 ( 
fields
 ) )

2474 
group_list
 = [ ]

2475 if 
groups
 :

2476 for 
group
 in 
groups
 . 
split
 ( "," ) :

2478 
group_list
 . 
append
 ( 
int
 ( 
group
 ) )

2479 except 
ValueError
 :

2480 
group_list
 . 
append
 ( 
group
 )

2482 if 
excval
 is not None :

2483 if ( 
sys
 . 
version_info
 . 
major
 , 
sys
 . 
version_info
 . 
minor
 ) >= ( 3 , 4 ) :

2484 with 
self
 . 
subTest
 ( 
pattern
 = 
pattern
 , 
string
 = 
string
 ) :

2485 
self
 . 
assertRaisesRegex
 ( 
expected
 , 
excval
 , 
regex
 . 
search
 ,

2486 
pattern
 , 
string
 )

2488 
m
 = 
regex
 . 
search
 ( 
pattern
 , 
string
 )

2489 if 
m
 :

2490 if 
group_list
 :

2491 
actual
 = 
ascii
 ( 
m
 . 
group
 ( * 
group_list
 ) )

2493 
actual
 = 
ascii
 ( 
m
 [ : ] )

2495 
actual
 = 
ascii
 ( 
m
 )

2497 
self
 . 
assertEqual
 ( 
actual
 , 
expected
 ) 
	}

2499 def 
	$test_replacement
 ( 
self
 ) :

2500 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r"test\?" , "result\\?\\.\a\\q\\m\n" , "test?" ) , "result\\?\\.\a\\q\\m\n"

2503 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(.)' , r"\1\1" , 'x' ) , 'xx' )

2504 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(.)' , 
regex
 . 
escape
 ( r"\1\1" ) , 'x' ) , r"\1\1" )

2505 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(.)' , r"\\1\\1" , 'x' ) , r"\1\1" )

2506 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(.)' , lambda 
m
 : r"\1\1" , 'x' ) , r"\1\1" ) 
	}

2508 def 
	$test_common_prefix
 ( 
self
 ) :

2510 
all
 = 
string
 . 
ascii_lowercase
 + 
string
 . 
digits
 + 
string
 . 
ascii_uppercase

2511 
side
 = 
all
 * 4

2512 
regexp
 = '(' + 
side
 + '|' + 
side
 + ')'

2513 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( 
regexp
 ) ) ) , 
self
 . 
PATTERN_CLASS
 ) 
	}

2515 def 
	$test_captures
 ( 
self
 ) :

2516 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)+" , "abc" ) . 
captures
 ( 1 ) , [ 'a' , 'b' , 'c'

2518 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w{3})+" , "abcdef" ) . 
captures
 ( 0 , 1 ) ,

2520 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^(\d{1,3})(?:\.(\d{1,3})){3}$" , "192.168.0.1"

2521 ) . 
captures
 ( 1 , 2 ) , ( [ '192' , ] , [ '168' , '0' , '1' ] ) )

2522 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"^([0-9A-F]{2}){4} ([a-z]\d){5}$" , "3FB52A0C a2c4g3k9d3"

2523 ) . 
captures
 ( 1 , 2 ) , ( [ '3F' , 'B5' , '2A' , '0C' ] ,

2525 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( "([a-z]W)([a-z]X)+([a-z]Y)" , "aWbXcXdXeXfY"

2526 ) . 
captures
 ( 1 , 2 , 3 ) , ( [ 'aW' ] , [ 'bX' , 'cX' , 'dX' , 'eX' ] ,

2529 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r".*?(?=(.)+)b" , "ab" ) . 
captures
 ( 1 ) ,

2531 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r".*?(?>(.){0,2})d" , "abcd" ) . 
captures
 ( 1 ) ,

2533 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(.)+" , "a" ) . 
captures
 ( 1 ) , [ 'a' ] ) 
	}

2535 def 
	$test_guards
 ( 
self
 ) :

2536 
m
 = 
regex
 . 
search
 ( r"(X.*?Y\s*){3}(X\s*)+AB:" , "XY\nX Y\nX  Y\nXY\nXX AB:"

2538 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( 0 , 1 , 2 ) , ( ( 3 , 21 ) , ( 12 , 15 ) , ( 16 , 18 ) ) )

2540 
m
 = 
regex
 . 
search
 ( r"(X.*?Y\s*){3,}(X\s*)+AB:" , "XY\nX Y\nX  Y\nXY\nXX AB:"

2542 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( 0 , 1 , 2 ) , ( ( 0 , 21 ) , ( 12 , 15 ) , ( 16 , 18 ) ) )

2544 
m
 = 
regex
 . 
search
 ( r'\d{4}(\s*\w)?\W*((?!\d)\w){2}' , "9999XX" )

2545 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( 0 , 1 , 2 ) , ( ( 0 , 6 ) , ( - 1 , - 1 ) , ( 5 , 6 ) ) )

2547 
m
 = 
regex
 . 
search
 ( r'A\s*?.*?(\n+.*?\s*?){0,2}\(X' , 'A\n1\nS\n1 (X' )

2548 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( 0 , 1 ) , ( ( 0 , 10 ) , ( 5 , 8 ) ) )

2550 
m
 = 
regex
 . 
search
 ( r'Derde\s*:' , 'aaaaaa:\nDerde:' )

2551 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( ) , ( 8 , 14 ) )

2552 
m
 = 
regex
 . 
search
 ( r'Derde\s*:' , 'aaaaa:\nDerde:' )

2553 
self
 . 
assertEqual
 ( 
m
 . 
span
 ( ) , ( 7 , 13 ) ) 
	}

2555 def 
	$test_turkic
 ( 
self
 ) :

2557 
pairs
 = "I=i;I=\u0131;i=\u0130"

2559 
all_chars
 = 
set
 ( )

2560 
matching
 = 
set
 ( )

2561 for 
pair
 in 
pairs
 . 
split
 ( ";" ) :

2562 
ch1
 , 
ch2
 = 
pair
 . 
split
 ( "=" )

2563 
all_chars
 . 
update
 ( ( 
ch1
 , 
ch2
 ) )

2564 
matching
 . 
add
 ( ( 
ch1
 , 
ch1
 ) )

2565 
matching
 . 
add
 ( ( 
ch1
 , 
ch2
 ) )

2566 
matching
 . 
add
 ( ( 
ch2
 , 
ch1
 ) )

2567 
matching
 . 
add
 ( ( 
ch2
 , 
ch2
 ) )

2569 for 
ch1
 in 
all_chars
 :

2570 for 
ch2
 in 
all_chars
 :

2571 
m
 = 
regex
 . 
match
 ( r"(?i)\A" + 
ch1
 + r"\Z" , 
ch2
 )

2572 if 
m
 :

2573 if ( 
ch1
 , 
ch2
 ) not in 
matching
 :

2574 
self
 . 
fail
 ( "{} matching {}" . 
format
 ( 
ascii
 ( 
ch1
 ) ,

2575 
ascii
 ( 
ch2
 ) ) )

2577 if ( 
ch1
 , 
ch2
 ) in 
matching
 :

2578 
self
 . 
fail
 ( "{} not matching {}" . 
format
 ( 
ascii
 ( 
ch1
 ) ,

2579 
ascii
 ( 
ch2
 ) ) ) 
	}

2581 def 
	$test_named_lists
 ( 
self
 ) :

2582 
options
 = [ "one" , "two" , "three" ]

2583 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"333\L<bar>444" , "333one444" ,

2584 
bar
 = 
options
 ) . 
group
 ( ) , "333one444" )

2585 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?i)333\L<bar>444" , "333TWO444" ,

2586 
bar
 = 
options
 ) . 
group
 ( ) , "333TWO444" )

2587 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"333\L<bar>444" , "333four444" ,

2588 
bar
 = 
options
 ) , None )

2590 
options
 = [ b"one" , b"two" , b"three" ]

2591 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br"333\L<bar>444" , b"333one444" ,

2592 
bar
 = 
options
 ) . 
group
 ( ) , b"333one444" )

2593 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br"(?i)333\L<bar>444" , b"333TWO444" ,

2594 
bar
 = 
options
 ) . 
group
 ( ) , b"333TWO444" )

2595 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( br"333\L<bar>444" , b"333four444" ,

2596 
bar
 = 
options
 ) , None )

2598 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( r"3\L<bar>4\L<bar>+5" ,

2599 
bar
 = [ "one" , "two" , "three" ] ) ) ) , 
self
 . 
PATTERN_CLASS
 )

2601 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"^\L<options>" , "solid QWERT" ,

2602 
options
 = 
set
 ( [ 'good' , 'brilliant' , '+s\\ol[i}d' ] ) ) , [ ] )

2603 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"^\L<options>" , "+solid QWERT" ,

2604 
options
 = 
set
 ( [ 'good' , 'brilliant' , '+solid' ] ) ) , [ '+solid' ] )

2606 
options
 = [ "STRASSE" ]

2607 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?fi)\L<words>" , "stra\N{LATIN SMALL LETTER SHARP S}e"

2608 , 
words
 = 
options
 ) . 
span
 ( ) , ( 0 ,

2611 
options
 = [ "STRASSE" , "stress" ]

2612 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?fi)\L<words>" , "stra\N{LATIN SMALL LETTER SHARP S}e"

2613 , 
words
 = 
options
 ) . 
span
 ( ) , ( 0 ,

2616 
options
 = [ "stra\N{LATIN SMALL LETTER SHARP S}e" ]

2617 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?fi)\L<words>" , "STRASSE" ,

2618 
words
 = 
options
 ) . 
span
 ( ) , ( 0 , 7 ) )

2620 
options
 = [ "kit" ]

2621 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?i)\L<words>" , "SKITS" ,

2622 
words
 = 
options
 ) . 
span
 ( ) , ( 1 , 4 ) )

2623 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?i)\L<words>" , "SK\N{LATIN CAPITAL LETTER I WITH DOT ABOVE}TS"

2625 
words
 = 
options
 ) . 
span
 ( ) , ( 1 , 4 ) )

2627 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\b(\w+) +\1\b" , " stra\N{LATIN SMALL LETTER SHARP S}e STRASSE "

2628 ) . 
span
 ( ) , ( 1 , 15 ) )

2629 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?fi)\b(\w+) +\1\b" , " STRASSE stra\N{LATIN SMALL LETTER SHARP S}e "

2630 ) . 
span
 ( ) , ( 1 , 15 ) )

2632 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^\L<options>$" , "" , 
options
 = [ ] ) . 
span
 ( ) ,

2633 ( 0 , 0 ) ) 
	}

2635 def 
	$test_fuzzy
 ( 
self
 ) :

2637 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(fou){s,e<=1}' ) ) ) ,

2638 
self
 . 
PATTERN_CLASS
 )

2639 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(fuu){s}' ) ) ) ,

2640 
self
 . 
PATTERN_CLASS
 )

2641 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(fuu){s,e}' ) ) ) ,

2642 
self
 . 
PATTERN_CLASS
 )

2643 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(anaconda){1i+1d<1,s<=1}' ) ) ) ,

2644 
self
 . 
PATTERN_CLASS
 )

2645 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(anaconda){1i+1d<1,s<=1,e<=10}' ) ) ) ,

2646 
self
 . 
PATTERN_CLASS
 )

2647 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(anaconda){s<=1,e<=1,1i+1d<1}' ) ) ) ,

2648 
self
 . 
PATTERN_CLASS
 )

2650 
text
 = 'molasses anaconda foo bar baz smith anderson '

2651 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(znacnda){s<=1,e<=3,1i+1d<1}' , 
text
 ) ,

2653 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(znacnda){s<=1,e<=3,1i+1d<2}' ,

2654 
text
 ) . 
span
 ( 0 , 1 ) , ( ( 9 , 17 ) , ( 9 , 17 ) ) )

2655 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(ananda){1i+1d<2}' , 
text
 ) , None )

2656 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:\bznacnda){e<=2}" , 
text
 ) [ 0 ] , "anaconda"

2658 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:\bnacnda){e<=2}" , 
text
 ) [ 0 ] , "anaconda"

2661 
text
 = 'anaconda foo bar baz smith anderson'

2662 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(fuu){i<=3,d<=3,e<=5}' , 
text
 ) . 
span
 ( 0 ,

2664 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?b)(fuu){i<=3,d<=3,e<=5}' ,

2665 
text
 ) . 
span
 ( 0 , 1 ) , ( ( 9 , 10 ) , ( 9 , 10 ) ) )

2666 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(fuu){i<=2,d<=2,e<=5}' , 
text
 ) . 
span
 ( 0 ,

2668 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?e)(fuu){i<=2,d<=2,e<=5}' ,

2669 
text
 ) . 
span
 ( 0 , 1 ) , ( ( 9 , 10 ) , ( 9 , 10 ) ) )

2670 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(fuu){i<=3,d<=3,e}' , 
text
 ) . 
span
 ( 0 , 1 ) ,

2672 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?b)(fuu){i<=3,d<=3,e}' , 
text
 ) . 
span
 ( 0 ,

2675 
self
 . 
assertEqual
 ( 
repr
 ( 
type
 ( 
regex
 . 
compile
 ( '(approximate){s<=3,1i+1d<3}' ) ) ) ,

2676 
self
 . 
PATTERN_CLASS
 )

2679 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(foobar){e}' , 'xirefoabralfobarxie'

2680 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 6 ) , ( 0 , 6 ) ) )

2681 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?e)(foobar){e}' , 'xirefoabralfobarxie'

2682 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 3 ) , ( 0 , 3 ) ) )

2683 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?b)(foobar){e}' , 'xirefoabralfobarxie'

2684 ) . 
span
 ( 0 , 1 ) , ( ( 11 , 16 ) , ( 11 , 16 ) ) )

2687 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(foobar){e<=2}' , 'xirefoabrzlfd'

2688 ) . 
span
 ( 0 , 1 ) , ( ( 4 , 9 ) , ( 4 , 9 ) ) )

2689 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(foobar){e<=2}' , 'xirefoabzlfd' ) , None )

2692 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(foobar){i<=2,s<=2,e<=2}' , 'oobargoobaploowap'

2693 ) . 
span
 ( 0 , 1 ) , ( ( 5 , 11 ) , ( 5 , 11 ) ) )

2696 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '\\b(foobar){e}\\b' , 'zfoobarz' ) . 
span
 ( 0 ,

2698 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '\\b(foobar){e}\\b' , 'boing zfoobarz goobar woop'

2699 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 6 ) , ( 0 , 6 ) ) )

2700 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?b)\\b(foobar){e}\\b' , 'boing zfoobarz goobar woop'

2701 ) . 
span
 ( 0 , 1 ) , ( ( 15 , 21 ) , ( 15 , 21 ) ) )

2704 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foobar' ) . 
span
 ( 0 , 1 ) ,

2706 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'xfoobar' ) . 
span
 ( 0 ,

2708 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foobarx' ) . 
span
 ( 0 ,

2710 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'fooxbar' ) . 
span
 ( 0 ,

2712 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foxbar' ) . 
span
 ( 0 , 1 ) ,

2714 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'xoobar' ) . 
span
 ( 0 , 1 ) ,

2716 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foobax' ) . 
span
 ( 0 , 1 ) ,

2718 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'oobar' ) . 
span
 ( 0 , 1 ) ,

2720 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'fobar' ) . 
span
 ( 0 , 1 ) ,

2722 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'fooba' ) . 
span
 ( 0 , 1 ) ,

2724 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'xfoobarx' ) , None )

2725 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foobarxx' ) , None )

2726 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'xxfoobar' ) , None )

2727 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'xfoxbar' ) , None )

2728 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^(foobar){e<=1}$' , 'foxbarx' ) , None )

2733 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(foobar){i<=1,d<=2,s<=3,2d+1s<4}' , '3oifaowefbaoraofuiebofasebfaobfaorfeoaro'

2734 ) . 
span
 ( 0 , 1 ) , ( ( 6 , 13 ) , ( 6 ,

2736 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?b)(foobar){i<=1,d<=2,s<=3,2d+1s<4}' , '3oifaowefbaoraofuiebofasebfaobfaorfeoaro'

2737 ) . 
span
 ( 0 , 1 ) , ( ( 34 , 39 ) ,

2741 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'foo(bar){e<=1}zap' , 'foobarzap' ) . 
span
 ( 0 ,

2743 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'foo(bar){e<=1}zap' , 'fobarzap' ) , None )

2744 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'foo(bar){e<=1}zap' , 'foobrzap' ) . 
span
 ( 0 ,

2747 
text
 = ( 'www.cnn.com 64.236.16.20\nwww.slashdot.org 66.35.250.150\n' 'For useful information, use www.slashdot.org\nthis is demo data!\n'

2749 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?s)^.*(dot.org){e}.*$' , 
text
 ) . 
span
 ( 0 ,

2751 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?es)^.*(dot.org){e}.*$' , 
text
 ) . 
span
 ( 0 ,

2753 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'^.*(dot.org){e}.*$' , 
text
 ) . 
span
 ( 0 , 1 ) ,

2758 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\b\L<words>{e<=1}\b" , " book cot dog desk "

2759 , 
words
 = "cat dog" . 
split
 ( ) ) , [ "cot" , "dog" ] )

2760 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\b\L<words>{e<=1}\b" , " book dog cot desk "

2761 , 
words
 = "cat dog" . 
split
 ( ) ) , [ " dog" , "cot" ] )

2762 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?e)\b\L<words>{e<=1}\b" , " book dog cot desk "

2763 , 
words
 = "cat dog" . 
split
 ( ) ) , [ "dog" , "cot" ] )

2764 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)\b\L<words>{e<=1}\b" , " book cot dog desk "

2765 , 
words
 = "cat dog" . 
split
 ( ) ) , [ "dog " , "cot" ] )

2766 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?er)\b\L<words>{e<=1}\b" , " book cot dog desk "

2767 , 
words
 = "cat dog" . 
split
 ( ) ) , [ "dog" , "cot" ] )

2768 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)\b\L<words>{e<=1}\b" , " book dog cot desk "

2769 , 
words
 = "cat dog" . 
split
 ( ) ) , [ "cot" , "dog" ] )

2770 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"\b\L<words>{e<=1}\b" , b" book cot dog desk "

2771 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b"cot" , b"dog" ] )

2772 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"\b\L<words>{e<=1}\b" , b" book dog cot desk "

2773 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b" dog" , b"cot" ] )

2774 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"(?e)\b\L<words>{e<=1}\b" , b" book dog cot desk "

2775 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b"dog" , b"cot" ] )

2776 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"(?r)\b\L<words>{e<=1}\b" , b" book cot dog desk "

2777 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b"dog " , b"cot" ] )

2778 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"(?er)\b\L<words>{e<=1}\b" , b" book cot dog desk "

2779 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b"dog" , b"cot" ] )

2780 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( br"(?r)\b\L<words>{e<=1}\b" , b" book dog cot desk "

2781 , 
words
 = b"cat dog" . 
split
 ( ) ) , [ b"cot" , b"dog" ] )

2783 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w+) (\1{e<=1})" , "foo fou" ) . 
groups
 ( ) ,

2785 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)(\2{e<=1}) (\w+)" , "foo fou"

2786 ) . 
groups
 ( ) , ( "foo" , "fou" ) )

2787 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( br"(\w+) (\1{e<=1})" , b"foo fou"

2788 ) . 
groups
 ( ) , ( b"foo" , b"fou" ) )

2790 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?:(?:QR)+){e}" , "abcde" ) , [ "abcde" , ""

2792 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?:Q+){e}" , "abc" ) , [ "abc" , "" ] )

2795 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:service detection){0<e<5}" , "servic detection"

2796 ) . 
span
 ( ) , ( 0 , 16 ) )

2797 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:service detection){0<e<5}" , "service detect"

2798 ) . 
span
 ( ) , ( 0 , 14 ) )

2799 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:service detection){0<e<5}" , "service detecti"

2800 ) . 
span
 ( ) , ( 0 , 15 ) )

2801 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:service detection){0<e<5}" , "service detection"

2803 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:service detection){0<e<5}" , "in service detection"

2804 ) . 
span
 ( ) , ( 0 , 20 ) )

2807 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( r"(?:cats|cat){e<=1}" , "cat"

2808 ) . 
fuzzy_counts
 , ( 0 , 0 , 1 ) )

2809 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( r"(?e)(?:cats|cat){e<=1}" , "cat"

2810 ) . 
fuzzy_counts
 , ( 0 , 0 , 0 ) )

2812 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( r"(?:cat|cats){e<=1}" , "cats"

2813 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

2814 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( r"(?e)(?:cat|cats){e<=1}" , "cats"

2815 ) . 
fuzzy_counts
 , ( 0 , 0 , 0 ) )

2817 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( r"(?:cat){e<=1} (?:cat){e<=1}" , "cat cot"

2818 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

2821 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?e)(GTTTTCATTCCTCATA){i<=4,d<=4,s<=4,i+d+s<=8}" , "ATTATTTATTTTTCATA"

2822 ) . 
fuzzy_changes
 , ( [ 0 , 6 , 10 , 11 ] , [ 3 ] , [ ] ) )

2825 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( '(?:fo){e<=1}|(?:fo){e<=2}' , 'FO' ) ) ,

2826 True ) 
	}

2828 def 
	$test_recursive
 ( 
self
 ) :

2829 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "xx" ) [ : ] ,

2831 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "aba" ) [ : ] ,

2833 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "abba" ) [ : ] ,

2835 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "kayak" ) [ : ] ,

2837 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "paper" ) [ : ] ,

2839 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\w)(?:(?R)|(\w?))\1" , "dontmatchme" ) ,

2842 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "xx" ) [ : ] ,

2844 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "aba" ) [ : ] ,

2846 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "abba" ) [ :

2848 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "kayak" ) [ :

2850 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "paper" ) [ :

2852 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\2(?:(\w?)|(?R))(\w)" , "dontmatchme"

2855 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\(((?>[^()]+)|(?R))*\)" , "(ab(cd)ef)" ) [

2857 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\(((?>[^()]+)|(?R))*\)" , "(ab(cd)ef)"

2858 ) . 
captures
 ( 1 ) , [ "ab" , "cd" , "(cd)" , "ef" ] )

2860 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\(((?R)|(?>[^()]+))*\)" , "(ab(cd)ef)"

2862 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\(((?R)|(?>[^()]+))*\)" , "(ab(cd)ef)"

2863 ) . 
captures
 ( 1 ) , [ "ef" , "cd" , "(cd)" , "ab" ] )

2865 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"\(([^()]+|(?R))*\)" , "some text (a(b(c)d)e) more text"

2868 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)\(((?R)|[^()]+)*\)" , "some text (a(b(c)d)e) more text"

2871 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(foo(\(((?:(?>[^()]+)|(?2))*)\)))" , "foo(bar(baz)+baz(bop))"

2876 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?r)(foo(\(((?:(?2)|(?>[^()]+))*)\)))" , "foo(bar(baz)+baz(bop))"

2881 
rgx
 = 
regex
 . 
compile
 ( r"""^\s*(<\s*([a-zA-Z:]+)(?:\s*[a-zA-Z:]*\s*=\s*(?:'[^']*'|"[^"]*"))*\s*(/\s*)?>(?:[^<>]*|(?1))*(?(3)|<\s*/\s*\2\s*>))\s*$""" )

2882 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo><bar></bar></foo>' ) ) , True )

2883 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo><bar></foo></bar>' ) ) , False )

2884 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo><bar/></foo>' ) ) , True )

2885 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo><bar></foo>' ) ) , False )

2886 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo bar=baz/>' ) ) , False )

2888 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo bar="baz">' ) ) , False )

2889 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo bar="baz"/>' ) ) , True )

2890 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<    fooo   /  >' ) ) , True )

2893 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( 'foo<foo/>' ) ) , False )

2895 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo>foo</foo>' ) ) , True )

2896 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<foo><bar/>foo</foo>' ) ) , True )

2897 
self
 . 
assertEqual
 ( 
bool
 ( 
rgx
 . 
search
 ( '<a><b><c></c></b></a>' ) ) , True ) 
	}

2899 def 
	$test_copy
 ( 
self
 ) :

2901 
r
 = 
regex
 . 
compile
 ( "a" )

2902 
self
 . 
assertTrue
 ( 
copy
 . 
copy
 ( 
r
 ) is 
r
 )

2903 
self
 . 
assertTrue
 ( 
copy
 . 
deepcopy
 ( 
r
 ) is 
r
 )

2908 
m
 = 
r
 . 
match
 ( "a" )

2909 
self
 . 
assertTrue
 ( 
copy
 . 
copy
 ( 
m
 ) is not 
m
 )

2910 
self
 . 
assertTrue
 ( 
copy
 . 
deepcopy
 ( 
m
 ) is not 
m
 )

2912 
self
 . 
assertTrue
 ( 
m
 . 
string
 is not None )

2913 
m2
 = 
copy
 . 
copy
 ( 
m
 )

2914 
m2
 . 
detach_string
 ( )

2915 
self
 . 
assertTrue
 ( 
m
 . 
string
 is not None )

2916 
self
 . 
assertTrue
 ( 
m2
 . 
string
 is None )

2919 
it
 = 
regex
 . 
finditer
 ( "." , "ab" )

2920 
it2
 = 
copy
 . 
copy
 ( 
it
 )

2921 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) . 
group
 ( ) , "a" )

2922 
self
 . 
assertEqual
 ( 
next
 ( 
it2
 ) . 
group
 ( ) , "b" )

2925 
it
 = 
regex
 . 
finditer
 ( "." , "ab" )

2926 
it2
 = 
copy
 . 
deepcopy
 ( 
it
 )

2927 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) . 
group
 ( ) , "a" )

2928 
self
 . 
assertEqual
 ( 
next
 ( 
it2
 ) . 
group
 ( ) , "b" )

2931 
it
 = 
regex
 . 
splititer
 ( " " , "a b" )

2932 
it2
 = 
copy
 . 
copy
 ( 
it
 )

2933 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) , "a" )

2934 
self
 . 
assertEqual
 ( 
next
 ( 
it2
 ) , "b" )

2937 
it
 = 
regex
 . 
splititer
 ( " " , "a b" )

2938 
it2
 = 
copy
 . 
deepcopy
 ( 
it
 )

2939 
self
 . 
assertEqual
 ( 
next
 ( 
it
 ) , "a" )

2940 
self
 . 
assertEqual
 ( 
next
 ( 
it2
 ) , "b" ) 
	}

2942 def 
	$test_format
 ( 
self
 ) :

2943 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r"(\w+) (\w+)" , "{0} => {2} {1}" , "foo bar"

2945 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r"(?<word1>\w+) (?<word2>\w+)" , "{word2} {word1}"

2948 
self
 . 
assertEqual
 ( 
regex
 . 
subfn
 ( r"(\w+) (\w+)" , "{0} => {2} {1}" , "foo bar"

2950 
self
 . 
assertEqual
 ( 
regex
 . 
subfn
 ( r"(?<word1>\w+) (?<word2>\w+)" , "{word2} {word1}"

2953 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(\w+) (\w+)" , "foo bar"

2954 ) . 
expandf
 ( "{0} => {2} {1}" ) , "foo bar => bar foo" ) 
	}

2956 def 
	$test_fullmatch
 ( 
self
 ) :

2957 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "abc" ) ) , True )

2958 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "abcx" ) ) , False )

2959 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "abcx" , 
endpos
 = 3 ) ) , True )

2961 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "xabc" , 
pos
 = 1 ) ) , True )

2962 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "xabcy" , 
pos
 = 1 ) ) , False )

2963 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"abc" , "xabcy" , 
pos
 = 1 ,

2964 
endpos
 = 4 ) ) , True )

2966 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "abc" ) ) , True )

2967 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "abcx" ) ) , False )

2968 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "abcx" , 
endpos
 = 3 ) ) ,

2971 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "xabc" , 
pos
 = 1 ) ) ,

2973 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "xabcy" , 
pos
 = 1 ) ) ,

2975 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
fullmatch
 ( r"(?r)abc" , "xabcy" , 
pos
 = 1 ,

2976 
endpos
 = 4 ) ) , True ) 
	}

2978 def 
	$test_issue_18468
 ( 
self
 ) :

2980 if ( 
sys
 . 
version_info
 . 
major
 , 
sys
 . 
version_info
 . 
minor
 ) < ( 3 , 4 ) :

2983 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( 'y' , 'a' , 'xyz' ) , 'xaz' )

2984 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( 'y' , 
StrSubclass
 ( 'a' ) ,

2985 
StrSubclass
 ( 'xyz' ) ) , 'xaz' )

2986 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( b'y' , b'a' , b'xyz' ) , b'xaz' )

2987 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( b'y' , 
BytesSubclass
 ( b'a' ) ,

2988 
BytesSubclass
 ( b'xyz' ) ) , b'xaz' )

2989 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( b'y' , 
bytearray
 ( b'a' ) ,

2990 
bytearray
 ( b'xyz' ) ) , b'xaz' )

2991 
self
 . 
assertTypedEqual
 ( 
regex
 . 
sub
 ( b'y' , 
memoryview
 ( b'a' ) ,

2992 
memoryview
 ( b'xyz' ) ) , b'xaz' )

2994 for 
string
 in ":a:b::c" , 
StrSubclass
 ( ":a:b::c" ) :

2995 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( ":" , 
string
 ) , [ '' , 'a' , 'b' , '' , 'c'

2997 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

2998 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( ":*" , 
string
 ) , [ '' , '' , 'a' , ''

3000 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( "(:*)" , 
string
 ) , [ '' , ':' , ''

3003 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( ":*" , 
string
 ) , [ '' , 'a' , 'b' , 'c'

3005 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( "(:*)" , 
string
 ) , [ '' , ':' , 'a'

3008 for 
string
 in ( b":a:b::c" , 
BytesSubclass
 ( b":a:b::c" ) ,

3009 
bytearray
 ( b":a:b::c" ) , 
memoryview
 ( b":a:b::c" ) ) :

3010 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( b":" , 
string
 ) , [ b'' , b'a' , b'b' , b''

3012 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

3013 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( b":*" , 
string
 ) , [ b'' , b'' , b'a'

3015 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( b"(:*)" , 
string
 ) , [ b'' , b':' , b''

3019 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( b":*" , 
string
 ) , [ b'' , b'a' , b'b'

3021 
self
 . 
assertTypedEqual
 ( 
regex
 . 
split
 ( b"(:*)" , 
string
 ) , [ b'' , b':' , b'a'

3024 for 
string
 in "a:b::c:::d" , 
StrSubclass
 ( "a:b::c:::d" ) :

3025 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( ":+" , 
string
 ) , [ ":" , "::" , ":::"

3027 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( "(:+)" , 
string
 ) , [ ":" , "::" , ":::"

3029 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( "(:)(:*)" , 
string
 ) , [ ( ":" , "" ) ,

3032 for 
string
 in ( b"a:b::c:::d" , 
BytesSubclass
 ( b"a:b::c:::d" ) ,

3033 
bytearray
 ( b"a:b::c:::d" ) , 
memoryview
 ( b"a:b::c:::d" ) ) :

3034 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( b":+" , 
string
 ) , [ b":" , b"::" , b":::"

3036 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( b"(:+)" , 
string
 ) , [ b":" , b"::" , b":::"

3038 
self
 . 
assertTypedEqual
 ( 
regex
 . 
findall
 ( b"(:)(:*)" , 
string
 ) , [ ( b":" , b""

3041 for 
string
 in 'a' , 
StrSubclass
 ( 'a' ) :

3042 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a' , 
string
 ) . 
groups
 ( ) , ( ) )

3043 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)' , 
string
 ) . 
groups
 ( ) , ( 'a' , ) )

3044 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)' , 
string
 ) . 
group
 ( 0 ) , 'a' )

3045 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)' , 
string
 ) . 
group
 ( 1 ) , 'a' )

3046 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(a)' , 
string
 ) . 
group
 ( 1 , 1 ) , ( 'a' , 'a'

3049 for 
string
 in ( b'a' , 
BytesSubclass
 ( b'a' ) , 
bytearray
 ( b'a' ) ,

3050 
memoryview
 ( b'a' ) ) :

3051 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'a' , 
string
 ) . 
groups
 ( ) , ( ) )

3052 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'(a)' , 
string
 ) . 
groups
 ( ) , ( b'a' , ) )

3053 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'(a)' , 
string
 ) . 
group
 ( 0 ) , b'a' )

3054 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'(a)' , 
string
 ) . 
group
 ( 1 ) , b'a' )

3055 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( b'(a)' , 
string
 ) . 
group
 ( 1 , 1 ) , ( b'a' , b'a'

3056 ) ) 
	}

3058 def 
	$test_partial
 ( 
self
 ) :

3059 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'ab' , 'a' , 
partial
 = True ) . 
partial
 , True )

3060 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'ab' , 'a' , 
partial
 = True ) . 
span
 ( ) , ( 0 , 1 ) )

3061 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'cats' , 'cat' , 
partial
 = True ) . 
partial
 ,

3063 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'cats' , 'cat' , 
partial
 = True ) . 
span
 ( ) , ( 0 ,

3065 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'cats' , 'catch' , 
partial
 = True ) , None )

3066 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'abc\w{3}' , 'abcdef' ,

3067 
partial
 = True ) . 
partial
 , False )

3068 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'abc\w{3}' , 'abcdef' ,

3069 
partial
 = True ) . 
span
 ( ) , ( 0 , 6 ) )

3070 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'abc\w{3}' , 'abcde' ,

3071 
partial
 = True ) . 
partial
 , True )

3072 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'abc\w{3}' , 'abcde' ,

3073 
partial
 = True ) . 
span
 ( ) , ( 0 , 5 ) )

3075 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\d{4}$' , '1234' , 
partial
 = True ) . 
partial
 ,

3078 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\L<words>' , 'post' , 
partial
 = True ,

3079 
words
 = [ 'post' ] ) . 
partial
 , False )

3080 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\L<words>' , 'post' , 
partial
 = True ,

3081 
words
 = [ 'post' ] ) . 
span
 ( ) , ( 0 , 4 ) )

3082 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\L<words>' , 'pos' , 
partial
 = True ,

3083 
words
 = [ 'post' ] ) . 
partial
 , True )

3084 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\L<words>' , 'pos' , 
partial
 = True ,

3085 
words
 = [ 'post' ] ) . 
span
 ( ) , ( 0 , 3 ) )

3087 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?fi)\L<words>' , 'POST' , 
partial
 = True ,

3088 
words
 = [ 'po\uFB06' ] ) . 
partial
 , False )

3089 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?fi)\L<words>' , 'POST' , 
partial
 = True ,

3090 
words
 = [ 'po\uFB06' ] ) . 
span
 ( ) , ( 0 , 4 ) )

3091 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?fi)\L<words>' , 'POS' , 
partial
 = True ,

3092 
words
 = [ 'po\uFB06' ] ) . 
partial
 , True )

3093 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?fi)\L<words>' , 'POS' , 
partial
 = True ,

3094 
words
 = [ 'po\uFB06' ] ) . 
span
 ( ) , ( 0 , 3 ) )

3095 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?fi)\L<words>' , 'po\uFB06' ,

3096 
partial
 = True , 
words
 = [ 'POS' ] ) , None )

3098 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'a' , 
partial
 = True ) . 
span
 ( ) ,

3100 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'ab' , 
partial
 = True ) . 
span
 ( ) ,

3102 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'ab4' , 
partial
 = True ) . 
span
 ( ) ,

3104 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'a4' , 
partial
 = True ) . 
span
 ( ) ,

3106 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'a4R' , 
partial
 = True ) . 
span
 ( ) ,

3108 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , '4a' , 
partial
 = True ) , None )

3109 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'[a-z]*4R$' , 'a44' , 
partial
 = True ) , None ) 
	}

3111 def 
	$test_hg_bugs
 ( 
self
 ) :

3114 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
compile
 ( "(?>b)" , 
flags
 = 
regex
 . 
V1
 ) ) , True )

3118 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
compile
 ( r"^((?>\w+)|(?>\s+))*$" ,

3119 
flags
 = 
regex
 . 
V1
 ) ) , True )

3122 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?:(?>[^()]+)|(?R))*\)" , "a(bcd(e)f)g(h)"

3124 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?:(?:[^()]+)|(?R))*\)" , "a(bcd(e)f)g(h)"

3126 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?:(?>[^()]+)|(?R))*\)" , "a(b(cd)e)f)g)h"

3128 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"\((?:(?>[^()]+)|(?R))*\)" , "a(bc(d(e)f)gh"

3130 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?r)\((?:(?>[^()]+)|(?R))*\)" , "a(bc(d(e)f)gh"

3132 
self
 . 
assertEqual
 ( [ 
m
 . 
group
 ( ) for 
m
 in

3133 
regex
 . 
finditer
 ( r"\((?:[^()]*+|(?0))*\)" , "a(b(c(de)fg)h" ) ] ,

3138 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "a(bc)d" , "abcd" , 
regex
 . 
I
 |

3139 
regex
 . 
V1
 ) . 
group
 ( 0 ) , "abcd" )

3143 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"([\da-f:]+)$" , "E" , 
regex
 . 
I
 |

3144 
regex
 . 
V1
 ) . 
group
 ( 0 ) , "E" )

3145 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"([\da-f:]+)$" , "e" , 
regex
 . 
I
 |

3146 
regex
 . 
V1
 ) . 
group
 ( 0 ) , "e" )

3150 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "^(?=ab(de))(abd)(e)" , "abde" ) . 
groups
 ( ) ,

3155 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r"\ " , " " , 
flags
 = 
regex
 . 
X
 ) ) , True )

3158 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"^(a|)\1{2}b" , "b" ) . 
group
 ( 0 , 1 ) , ( 'b' , ''

3163 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "^(a){0,0}" , "abc" ) . 
group
 ( 0 , 1 ) , ( '' ,

3167 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?>.*/)b" , "a/b" ) . 
group
 ( 0 ) , "a/b" )

3171 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V0)((?i)blah)\s+\1" , "blah BLAH"

3172 ) . 
group
 ( 0 , 1 ) , ( "blah BLAH" , "blah" ) )

3173 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)((?i)blah)\s+\1" , "blah BLAH" ) ,

3178 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(\()?[^()]+(?(1)\)|)" , "(abcd"

3179 ) . 
group
 ( 0 ) , "abcd" )

3183 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(a*)*" , "a" ) . 
span
 ( 1 ) , ( 1 , 1 ) )

3184 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(a*)*" , "aa" ) . 
span
 ( 1 ) , ( 2 , 2 ) )

3185 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(a*)*" , "aaa" ) . 
span
 ( 1 ) , ( 3 , 3 ) )

3189 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "a(?#xxx)*" , "aaa" ) . 
group
 ( ) , "aaa" )

3193 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?=abc){3}abc" , "abcabcabc" ) . 
span
 ( ) , ( 0 ,

3198 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "^(?:a(?:(?:))+)+" , "a" ) . 
span
 ( ) , ( 0 , 1 ) )

3199 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "^(?:a(?:(?:))+)+" , "aa" ) . 
span
 ( ) , ( 0 , 2 ) )

3203 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "a(?x: b c )d" , "abcd" ) . 
group
 ( 0 ) , "abcd" )

3207 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "a#comment\n*" , "aaa" ,

3208 
flags
 = 
regex
 . 
X
 ) . 
group
 ( 0 ) , "aaa" )

3212 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)(a(?(1)\1)){1}" , "aaaaaaaaaa"

3213 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 1 ) , ( 0 , 1 ) ) )

3214 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)(a(?(1)\1)){2}" , "aaaaaaaaaa"

3215 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 3 ) , ( 1 , 3 ) ) )

3216 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)(a(?(1)\1)){3}" , "aaaaaaaaaa"

3217 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 6 ) , ( 3 , 6 ) ) )

3218 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)(a(?(1)\1)){4}" , "aaaaaaaaaa"

3219 ) . 
span
 ( 0 , 1 ) , ( ( 0 , 10 ) , ( 6 , 10 ) ) )

3223 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?V1)(a)(?<=b(?1))" , "baz" ) . 
group
 ( 0 ) , "a"

3228 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?fi)\L<keywords>' , 'POST, Post, post, po\u017Ft, po\uFB06, and po\uFB05'

3230 
keywords
 = [ 'post' , 'pos' ] ) , [ 'POST' , 'Post' , 'post' , 'po\u017Ft' , 'po\uFB06'

3232 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?fi)pos|post' , 'POST, Post, post, po\u017Ft, po\uFB06, and po\uFB05'

3235 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?fi)post|pos' , 'POST, Post, post, po\u017Ft, po\uFB06, and po\uFB05'

3238 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?fi)post|another' , 'POST, Post, post, po\u017Ft, po\uFB06, and po\uFB05'

3244 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?V1)((a)(?1)|(?2))" , "a" ) . 
group
 ( 0 , 1 ,

3249 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?V1)(\1xx|){6}" , "xx" ) . 
span
 ( 0 , 1 ) ,

3253 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(a|)+" , "a" ) . 
group
 ( 0 , 1 ) , ( "a" , "" ) )

3256 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(a|)*\d" , "a" * 80 ) , None )

3259 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "^(?:a?b?)*$" , "ac" ) , None )

3263 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
UNDEF_CHAR_NAME
 , lambda :

3264 
regex
 . 
compile
 ( "\\N{1}" ) )

3267 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "\\Z" , "a\na\n" ) . 
span
 ( 0 ) , ( 4 , 4 ) )

3271 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(q1|.)*(q2|.)*(x(a|bc)*y){2,}" , "xayxay"

3272 ) . 
group
 ( 0 ) , "xayxay" )

3276 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?i)[^a]" , "A" ) , None )

3280 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "(?i)[[:ascii:]]" , "\N{KELVIN SIGN}" ) ,

3285 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "((a|b(?1)c){3,5})" , "baaaaca" ) . 
group
 ( 0 ,

3289 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?<=:\S+ )\w+" , ":9 abc :10 def" ) ,

3291 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?<=:\S* )\w+" , ":9 abc :10 def" ) ,

3293 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?<=:\S+? )\w+" , ":9 abc :10 def" ) ,

3295 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"(?<=:\S*? )\w+" , ":9 abc :10 def" ) ,

3299 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r"(?:fe)?male" , "female" ) . 
group
 ( ) , "female"

3301 
self
 . 
assertEqual
 ( [ 
m
 . 
group
 ( ) for 
m
 in

3302 
regex
 . 
finditer
 ( r"(fe)?male: h(?(1)(er)|(is)) (\w+)" , "female: her dog; male: his cat. asdsasda"

3307 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?<rec>\((?:[^()]++|(?&rec))*\))' , 'aaa(((1+0)+1)+1)bbb'

3308 ) . 
captures
 ( 'rec' ) , [ '(1+0)' , '((1+0)+1)' , '(((1+0)+1)+1)'

3312 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
BAD_ESCAPE
 , lambda :

3313 
regex
 . 
sub
 ( 'x' , '\\' , 'x' ) , )

3316 
fz
 = "(CAGCCTCCCATTTCAGAATATACATCC){1<e<=2}"

3317 
seq
 = "tcagacgagtgcgttgtaaaacgacggccagtCAGCCTCCCATTCAGAATATACATCCcgacggccagttaaaaacaatgccaaggaggtcatagctgtttcctgccagttaaaaacaatgccaaggaggtcatagctgtttcctgacgcactcgtctgagcgggctggcaagg"

3318 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 
fz
 , 
seq
 , 
regex
 . 
BESTMATCH
 ) [ 0 ] , "tCAGCCTCCCATTCAGAATATACATCC"

3322 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r"c..+/c" , "cA/c\ncAb/c" ) , [ 'cAb/c' ] )

3325 
self
 . 
assertEqual
 ( 
ascii
 ( 
regex
 . 
sub
 ( r"(\w+)" , r"[\1]" , '\u0905\u0928\u094d\u200d\u0928 \u0d28\u0d4d\u200d \u0915\u093f\u0928'

3327 
regex
 . 
WORD
 ) ) ,

3328 
ascii
 ( '[\u0905\u0928\u094d\u200d\u0928] [\u0d28\u0d4d\u200d] [\u0915\u093f\u0928]' ) )

3331 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r".*a.*ba.*aa" , "ababba" ) , None )

3334 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?<x>a(?<x>b))' , "ab" ) . 
spans
 ( "x" ) , [ ( 1 ,

3339 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(-)' , lambda 
m
 : 
m
 . 
expand
 ( r'x' ) , 'a-b-c' ) , 'axbxc'

3344 
rx
 = 
regex
 . 
compile
 ( r'\bt(est){i<2}' , 
flags
 = 
regex
 . 
V1
 )

3345 
self
 . 
assertEqual
 ( 
rx
 . 
search
 ( "Some text" ) , None )

3346 
self
 . 
assertEqual
 ( 
rx
 . 
findall
 ( "Some text" ) , [ ] )

3349 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , 
self
 . 
MULTIPLE_REPEAT
 , lambda :

3350 
regex
 . 
compile
 ( r'.???' ) )

3356 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( 'foo!?' , 
special_only
 = False ) , 'foo\\!\\?' )

3357 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( 'foo!?' , 
special_only
 = True ) , 'foo!\\?' )

3358 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( 'foo!?' ) , 'foo!\\?' )

3360 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( b'foo!?' , 
special_only
 = False ) , b'foo\\!\\?' )

3361 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( b'foo!?' , 
special_only
 = True ) , b'foo!\\?'

3363 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( b'foo!?' ) , b'foo!\\?' )

3366 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^([^z]*(?:WWWi|W))?$' , 'WWWi'

3367 ) . 
groups
 ( ) , ( 'WWWi' , ) )

3368 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^([^z]*(?:WWWi|w))?$' , 'WWWi'

3369 ) . 
groups
 ( ) , ( 'WWWi' , ) )

3370 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '^([^z]*?(?:WWWi|W))?$' , 'WWWi'

3371 ) . 
groups
 ( ) , ( 'WWWi' , ) )

3374 
pat
 = 
regex
 . 
compile
 ( r'xxx' , 
flags
 = 
regex
 . 
FULLCASE
 | 
regex
 . 
UNICODE
 )

3375 
self
 . 
assertEqual
 ( [ 
x
 . 
group
 ( ) for 
x
 in 
pat
 . 
finditer
 ( 'yxxx' ) ] , [ 'xxx' ] )

3376 
self
 . 
assertEqual
 ( 
pat
 . 
findall
 ( 'yxxx' ) , [ 'xxx' ] )

3378 
raw
 = 'yxxx'

3379 
self
 . 
assertEqual
 ( [ 
x
 . 
group
 ( ) for 
x
 in 
pat
 . 
finditer
 ( 
raw
 ) ] , [ 'xxx' ] )

3380 
self
 . 
assertEqual
 ( 
pat
 . 
findall
 ( 
raw
 ) , [ 'xxx' ] )

3382 
pat
 = 
regex
 . 
compile
 ( r'xxx' , 
flags
 = 
regex
 . 
FULLCASE
 | 
regex
 . 
IGNORECASE
 |

3383 
regex
 . 
UNICODE
 )

3384 
self
 . 
assertEqual
 ( [ 
x
 . 
group
 ( ) for 
x
 in 
pat
 . 
finditer
 ( 'yxxx' ) ] , [ 'xxx' ] )

3385 
self
 . 
assertEqual
 ( 
pat
 . 
findall
 ( 'yxxx' ) , [ 'xxx' ] )

3387 
raw
 = 'yxxx'

3388 
self
 . 
assertEqual
 ( [ 
x
 . 
group
 ( ) for 
x
 in 
pat
 . 
finditer
 ( 
raw
 ) ] , [ 'xxx' ] )

3389 
self
 . 
assertEqual
 ( 
pat
 . 
findall
 ( 
raw
 ) , [ 'xxx' ] )

3392 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

3393 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0).*' , 'x' , 'test' ) , 'xx' )

3395 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0).*' , 'x' , 'test' ) , 'x' )

3396 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V1).*' , 'x' , 'test' ) , 'xx' )

3398 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

3399 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0).*?' , '|' , 'test' ) , '|||||||||' )

3401 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V0).*?' , '|' , 'test' ) , '|t|e|s|t|' )

3402 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( '(?V1).*?' , '|' , 'test' ) , '|||||||||' )

3405 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'^(@)\n(?!.*?@)(.*)' , r'\1\n==========\n\2'

3406 , '@\n' , 
flags
 = 
regex
 . 
DOTALL
 ) , '@\n==========\n' )

3409 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:cats|cat){e<=1}' , 'caz'

3410 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

3411 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?e)(?:cats|cat){e<=1}' , 'caz'

3412 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

3413 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?b)(?:cats|cat){e<=1}' , 'caz'

3414 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

3416 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:cat){e<=1}' , 'caz' ) . 
fuzzy_counts
 ,

3418 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?e)(?:cat){e<=1}' , 'caz'

3419 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

3420 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?b)(?:cat){e<=1}' , 'caz'

3421 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

3423 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:cats){e<=2}' , 'c ats' ) . 
fuzzy_counts
 ,

3425 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?e)(?:cats){e<=2}' , 'c ats'

3426 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3427 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?b)(?:cats){e<=2}' , 'c ats'

3428 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3430 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:cats){e<=2}' , 'c a ts'

3431 ) . 
fuzzy_counts
 , ( 0 , 2 , 0 ) )

3432 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?e)(?:cats){e<=2}' , 'c a ts'

3433 ) . 
fuzzy_counts
 , ( 0 , 2 , 0 ) )

3434 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?b)(?:cats){e<=2}' , 'c a ts'

3435 ) . 
fuzzy_counts
 , ( 0 , 2 , 0 ) )

3437 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:cats){e<=1}' , 'c ats' ) . 
fuzzy_counts
 ,

3439 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?e)(?:cats){e<=1}' , 'c ats'

3440 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3441 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?b)(?:cats){e<=1}' , 'c ats'

3442 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3445 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'\bof ([a-z]+) of \1\b' , 'To make use of one of these modules'

3450 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'x' , r'\g<0>' , 'x' ) , 'x' )

3453 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'a' , 'a' , 
regex
 . 
DEBUG
 ) ) , True )

3456 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?V1)[[b-e]--cd]' , 'abcdef' ) , [ 'b' , 'e'

3458 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?V1)[b-e--cd]' , 'abcdef' ) , [ 'b' , 'e'

3460 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?V1)[[bcde]--cd]' , 'abcdef' ) , [ 'b' , 'e'

3462 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?V1)[bcde--cd]' , 'abcdef' ) , [ 'b' , 'e'

3466 
self
 . 
assertRaisesRegex
 ( 
regex
 . 
error
 , '^unknown property at position 4$' ,

3467 lambda : 
regex
 . 
compile
 ( r'\p{}' ) )

3470 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:()|(?(1)()|z)){2}(?(2)a|z)' , 'a'

3471 ) . 
group
 ( 0 , 1 , 2 ) , ( 'a' , '' , '' ) )

3472 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:()|(?(1)()|z)){0,2}(?(2)a|z)' , 'a'

3473 ) . 
group
 ( 0 , 1 , 2 ) , ( 'a' , '' , '' ) )

3482 
chars
 = '' . 
join
 ( 
chr
 ( 
c
 ) for 
c
 in 
range
 ( 0x10000 ) )

3484 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:alnum:]]+''' ,

3485 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[\p{Alpha}\p{PosixDigit}]+''' ,

3486 
chars
 ) ) ) )

3487 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:alpha:]]+''' ,

3488 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''\p{Alpha}+''' ,

3489 
chars
 ) ) ) )

3490 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:ascii:]]+''' ,

3491 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[\p{InBasicLatin}]+''' ,

3492 
chars
 ) ) ) )

3493 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:blank:]]+''' ,

3494 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[\p{gc=Space_Separator}\t]+''' ,

3495 
chars
 ) ) ) )

3496 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:cntrl:]]+''' ,

3497 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''\p{gc=Control}+''' , 
chars
 ) ) ) )

3498 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:digit:]]+''' ,

3499 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[0-9]+''' , 
chars
 ) ) ) )

3500 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:graph:]]+''' ,

3501 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[^\p{Space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}]+''' ,

3502 
chars
 ) ) ) )

3503 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:lower:]]+''' ,

3504 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''\p{Lower}+''' ,

3505 
chars
 ) ) ) )

3506 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:print:]]+''' ,

3507 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''(?V1)[\p{Graph}\p{Blank}--\p{Cntrl}]+''' , 
chars
 ) ) ) )

3508 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:punct:]]+''' ,

3509 
chars
 ) ) ) ,

3510 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''(?V1)[\p{gc=Punctuation}\p{gc=Symbol}--\p{Alpha}]+''' ,

3511 
chars
 ) ) ) )

3512 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:space:]]+''' ,

3513 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''\p{Whitespace}+''' ,

3514 
chars
 ) ) ) )

3515 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:upper:]]+''' ,

3516 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''\p{Upper}+''' ,

3517 
chars
 ) ) ) )

3518 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:word:]]+''' ,

3519 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[\p{Alpha}\p{gc=Mark}\p{Digit}\p{gc=Connector_Punctuation}\p{Join_Control}]+''' ,

3520 
chars
 ) ) ) )

3521 
self
 . 
assertEqual
 ( 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[[:xdigit:]]+''' ,

3522 
chars
 ) ) ) , 
ascii
 ( '' . 
join
 ( 
regex
 . 
findall
 ( r'''[0-9A-Fa-f]+''' ,

3523 
chars
 ) ) ) )

3526 
chars
 = 
bytes
 ( 
range
 ( 0x100 ) )

3528 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:alnum:]]+''' ,

3529 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[\p{Alpha}\p{PosixDigit}]+''' ,

3530 
chars
 ) ) ) )

3531 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:alpha:]]+''' ,

3532 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)\p{Alpha}+''' , 
chars
 ) ) ) )

3533 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:ascii:]]+''' ,

3534 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[\x00-\x7F]+''' , 
chars
 ) ) ) )

3535 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:blank:]]+''' ,

3536 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[\p{gc=Space_Separator}\t]+''' ,

3537 
chars
 ) ) ) )

3538 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:cntrl:]]+''' ,

3539 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)\p{gc=Control}+''' ,

3540 
chars
 ) ) ) )

3541 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:digit:]]+''' ,

3542 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[0-9]+''' , 
chars
 ) ) ) )

3543 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:graph:]]+''' ,

3544 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[^\p{Space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}]+''' , 
chars
 ) ) ) )

3545 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:lower:]]+''' ,

3546 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)\p{Lower}+''' , 
chars
 ) ) ) )

3547 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:print:]]+''' ,

3548 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?aV1)[\p{Graph}\p{Blank}--\p{Cntrl}]+''' , 
chars
 ) ) ) )

3549 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:punct:]]+''' ,

3550 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?aV1)[\p{gc=Punctuation}\p{gc=Symbol}--\p{Alpha}]+''' ,

3551 
chars
 ) ) ) )

3552 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:space:]]+''' ,

3553 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)\p{Whitespace}+''' , 
chars
 ) ) ) )

3554 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:upper:]]+''' ,

3555 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)\p{Upper}+''' , 
chars
 ) ) ) )

3556 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:word:]]+''' ,

3557 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[\p{Alpha}\p{gc=Mark}\p{Digit}\p{gc=Connector_Punctuation}\p{Join_Control}]+''' , 
chars
 ) ) ) )

3558 
self
 . 
assertEqual
 ( 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[[:xdigit:]]+''' ,

3559 
chars
 ) ) ) , 
ascii
 ( b'' . 
join
 ( 
regex
 . 
findall
 ( br'''(?a)[0-9A-Fa-f]+''' , 
chars
 ) ) ) )

3562 
self
 . 
assertEqual
 ( 
ascii
 ( 
regex
 . 
search
 ( r'\X$' , 'ab\u2103' ) . 
group
 ( ) ) ,

3563 
ascii
 ( '\u2103' ) )

3567 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( "([^L]*)([^R]*R)" , "LtR" ) . 
groups
 ( ) , ( '' , 'LtR'

3572 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(.)' , r'x\1y' , 'ab' ) , 'xayxby' )

3573 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(?r)(.)' , r'x\1y' , 'ab' ) , 'xayxby' )

3574 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r'(.)' , 'x{1}y' , 'ab' ) , 'xayxby' )

3575 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r'(?r)(.)' , 'x{1}y' , 'ab' ) , 'xayxby' )

3578 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(a)*abc' , 'ab' ,

3579 
partial
 = True ) . 
span
 ( ) , ( 0 , 2 ) )

3580 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(a)*abc' , 'ab' ,

3581 
partial
 = True ) . 
partial
 , True )

3585 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'OXRG' , 'OOGOX' , 
partial
 = True ) . 
span
 ( ) ,

3587 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '.XRG' , 'OOGOX' , 
partial
 = True ) . 
span
 ( ) ,

3589 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '.{1,3}XRG' , 'OOGOX' ,

3590 
partial
 = True ) . 
span
 ( ) , ( 1 , 5 ) )

3593 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'R|R' , 'R' ) . 
span
 ( ) , ( 0 , 1 ) )

3596 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(.)(?(1)(?!))' , 'xy' ) , None )

3599 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(y)?(\d)(?(1)\b\B)' , 'ax1y2z3b' ) ,

3601 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(y)?+(\d)(?(1)\b\B)' , 'ax1y2z3b' ) ,

3605 
self
 . 
assertEqual
 ( [ 
m
 . 
span
 ( ) for 
m
 in 
regex
 . 
finditer
 ( r'(?i)(?:error){e}' , 'regex failure'

3607 
self
 . 
assertEqual
 ( [ 
m
 . 
span
 ( ) for 
m
 in

3608 
regex
 . 
finditer
 ( r'(?fi)(?:error){e}' , 'regex failure' ) ] , [ ( 0 , 5 ) , ( 5 ,

3613 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)\d+(\w(\d*)?|[eE]([+-]\d+))' , '10b12'

3615 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)\d+(\w(\d*)?|[eE]([+-]\d+))' , '10E+12'

3618 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)(\w|ae|oe|ue|ss)' , 'ae' ) [ 0 ] , 'ae' )

3619 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)one(self)?(selfsufficient)?' , 'oneselfsufficient'

3623 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(ab\Kcd)' , 'abcd' ) . 
group
 ( 0 , 1 ) , ( 'cd' , 'abcd'

3625 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'\w\w\K\w\w' , 'abcdefgh' ) , [ 'cd' , 'gh'

3627 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(\w\w\K\w\w)' , 'abcdefgh' ) , [ 'abcd' , 'efgh'

3630 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)(ab\Kcd)' , 'abcd' ) . 
group
 ( 0 , 1 ) ,

3632 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?r)\w\w\K\w\w' , 'abcdefgh' ) , [ 'ef' , 'ab'

3634 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?r)(\w\w\K\w\w)' , 'abcdefgh' ) ,

3638 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<quant>\d+)(?<item>\w+))(?&quant) (?&item)' , '5 elephants'

3642 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'12(*FAIL)|3' , '123' ) [ 0 ] , '3' )

3643 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)12(*FAIL)|3' , '123' ) [ 0 ] , '3' )

3645 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(*PRUNE)\d' , '123' ) , None )

3646 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(?=(*PRUNE))\d' , '123' ) [ 0 ] , '123' )

3647 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(*PRUNE)bcd|[3d]' , '123bcd' ) [ 0 ] , '123bcd'

3649 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(*PRUNE)bcd|[3d]' , '123zzd' ) [ 0 ] , 'd'

3651 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+?(*PRUNE)bcd|[3d]' , '123bcd' ) [ 0 ] , '3bcd'

3653 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+?(*PRUNE)bcd|[3d]' , '123zzd' ) [ 0 ] , 'd'

3655 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=3(*PRUNE))zzd|[4d]$' , '123zzd'

3657 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=3(*PRUNE))zzd|[4d]$' , '124zzd'

3659 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=(*PRUNE)3)zzd|[4d]$' , '124zzd'

3661 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=2(*PRUNE)3)zzd|[3d]$' , '124zzd'

3664 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d(*PRUNE)\d+' , '123' ) , None )

3665 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d(?<=(*PRUNE))\d+' , '123' ) [ 0 ] , '123'

3667 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d+(*PRUNE)bcd|[3d]' , '123bcd'

3669 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d+(*PRUNE)bcd|[3d]' , '123zzd'

3671 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=3(*PRUNE))zzd|[4d]$' , '123zzd'

3673 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=3(*PRUNE))zzd|[4d]$' , '124zzd'

3675 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=(*PRUNE)3)zzd|[4d]$' , '124zzd'

3677 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=2(*PRUNE)3)zzd|[3d]$' , '124zzd'

3680 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(*SKIP)bcd|[3d]' , '123bcd' ) [ 0 ] , '123bcd'

3682 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+(*SKIP)bcd|[3d]' , '123zzd' ) [ 0 ] , 'd'

3684 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+?(*SKIP)bcd|[3d]' , '123bcd' ) [ 0 ] , '3bcd'

3686 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d+?(*SKIP)bcd|[3d]' , '123zzd' ) [ 0 ] , 'd'

3688 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=3(*SKIP))zzd|[4d]$' , '123zzd'

3690 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=3(*SKIP))zzd|[4d]$' , '124zzd'

3692 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=(*SKIP)3)zzd|[4d]$' , '124zzd'

3694 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d++(?<=2(*SKIP)3)zzd|[3d]$' , '124zzd'

3697 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d+(*SKIP)bcd|[3d]' , '123bcd' ) [ 0 ] , '123bcd'

3699 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d+(*SKIP)bcd|[3d]' , '123zzd' ) [ 0 ] , 'd'

3701 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=3(*SKIP))zzd|[4d]$' , '123zzd'

3703 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=3(*SKIP))zzd|[4d]$' , '124zzd'

3705 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=(*SKIP)3)zzd|[4d]$' , '124zzd'

3707 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\d++(?<=2(*SKIP)3)zzd|[3d]$' , '124zzd'

3711 
text
 = """June 30, December 31, 2013 2012\nsome words follow:\nmore words and numbers 1,234,567 9,876,542\nmore words and numbers 1,234,567 9,876,542"""

3715 
self
 . 
assertEqual
 ( 
len
 ( 
regex
 . 
findall
 ( r'(?<!\d)(?>2014|2013 ?2012)' , 
text
 ) ) , 1 )

3718 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '1(?>2)' , '12' ) . 
span
 ( ) , ( 0 , 2 ) )

3721 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?V1w)(?=(?=[^A-Z]*+[A-Z])(?=[^a-z]*+[a-z]))(?=\D*+\d)(?=\p{Alphanumeric}*+\P{Alphanumeric})\A(?s:.){8,255}+\Z' , 'AAaa11!!'

3725 
TEST_REGEX
 = 
regex
 . 
compile
 ( r'''(?smx)\n(?(DEFINE)\n  (?<subcat>\n   ^,[^,]+,\n   )\n)\n\n# Group 2 is defined on this line\n^,([^,]+),\n\n(?:(?!(?&subcat)[\r\n]+(?&subcat)).)+\n'''

3738 
TEST_DATA
 = '''\n,Cat 1,\n,Brand 1,\nsome\nthing\n,Brand 2,\nother\nthings\n,Cat 2,\n,Brand,\nSome\nthing\n'''

3752 
self
 . 
assertEqual
 ( [ 
m
 . 
span
 ( 1 , 2 ) for 
m
 in

3753 
TEST_REGEX
 . 
finditer
 ( 
TEST_DATA
 ) ] , [ ( ( - 1 , - 1 ) , ( 2 , 7 ) ) , ( ( - 1 , - 1 ) , ( 54 ,

3757 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(abcdefgh){e}' , '******abcdefghijklmnopqrtuvwxyz'

3758 , 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 6 , 14 ) )

3759 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(abcdefghi){e}' , '******abcdefghijklmnopqrtuvwxyz'

3760 , 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 6 , 15 ) )

3763 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?:(?=\d)\d+\b|\w+)' , '123abc' ) . 
span
 ( ) ,

3765 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?(?=\d)\d+\b|\w+)' , '123abc' ) , None )

3766 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?<=love\s)you|(?<=hate\s)her)' , "I love you"

3767 ) . 
span
 ( ) , ( 7 , 10 ) )

3768 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?(?<=love\s)you|(?<=hate\s)her)' , "I love you but I don't hate her either"

3772 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)a*(.*?)' , 'aaabbb' ) . 
group
 ( 0 , 1 ) ,

3774 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?p)a*(.*)' , 'aaabbb' ) . 
group
 ( 0 , 1 ) ,

3776 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(?p)a*(.*?)' , r'\1' , 'aaabbb' ) , 'bbb' )

3777 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'(?p)a*(.*)' , r'\1' , 'aaabbb' ) , 'bbb' )

3781 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?irV0)\L<kw>' , '21' , 
kw
 = [ '1' ] ) . 
span
 ( ) ,

3783 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?irV1)\L<kw>' , '21' , 
kw
 = [ '1' ] ) . 
span
 ( ) ,

3787 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( 'a|b' , '111a222' ) . 
span
 ( ) , ( 3 , 4 ) )

3788 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(?r)a|b' , '111a222' ) . 
span
 ( ) , ( 3 , 4 ) )

3791 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?if)<(CLI)><\1>' , '<cli><cli>'

3792 ) . 
span
 ( ) , ( 0 , 10 ) )

3793 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?if)<(CLI)><\1>' , '<cli><clI>'

3794 ) . 
span
 ( ) , ( 0 , 10 ) )

3795 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?ifr)<\1><(CLI)>' , '<cli><clI>'

3796 ) . 
span
 ( ) , ( 0 , 10 ) )

3799 
r
 = 
regex
 . 
compile
 ( r'\L<options>' , 
options
 = [ 'foo' , 'bar' ] )

3800 
p
 = 
pickle
 . 
dumps
 ( 
r
 )

3801 
r
 = 
pickle
 . 
loads
 ( 
p
 )

3802 
self
 . 
assertEqual
 ( 
r
 . 
match
 ( 'foo' ) . 
span
 ( ) , ( 0 , 3 ) )

3806 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x{6}){e<=1}' , 'xxxxxx' ,

3807 
flags
 = 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 6 ) )

3808 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x{6}){e<=1}' , 'xxxxx' ,

3809 
flags
 = 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 5 ) )

3810 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(x{6}){e<=1}' , 'x' ,

3811 
flags
 = 
regex
 . 
BESTMATCH
 ) , None )

3812 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(x{6}){e<=1}' , 'xxxxxx' ,

3813 
flags
 = 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 6 ) )

3814 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(x{6}){e<=1}' , 'xxxxx' ,

3815 
flags
 = 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 5 ) )

3816 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(x{6}){e<=1}' , 'x' ,

3817 
flags
 = 
regex
 . 
BESTMATCH
 ) , None )

3820 
self
 . 
assertRaises
 ( 
regex
 . 
error
 , lambda :

3821 
regex
 . 
compile
 ( b'00000\\0\\00\\^\50\\00\\U05000000' ) )

3824 
self
 . 
assertRaises
 ( 
regex
 . 
error
 , lambda : 
regex
 . 
compile
 ( b"{e<l" ) )

3827 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
compile
 ( '((?0)){e}' ) ) , True )

3830 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
compile
 ( '\x00?(?0){e}' ) ) , True )

3833 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'((brown)|(lazy)){1<=e<=3} ((dog)|(fox)){1<=e<=3}' , 'The quick borwn fax jumped over the lzy hog'

3834 , 
regex
 . 
ENHANCEMATCH
 ) ,

3839 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'\d\d\d-\d\d-\d\d\d\d' , "My SSN is 999-89-76, but don't tell."

3840 , 
partial
 = True ) . 
span
 ( ) , ( 36 ,

3844 
upper_i
 = '\N{CYRILLIC CAPITAL LETTER SHORT I}'

3845 
lower_i
 = '\N{CYRILLIC SMALL LETTER SHORT I}'

3847 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?ui)' + 
upper_i
 ,

3848 
lower_i
 ) ) , True )

3849 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?ui)' + 
lower_i
 ,

3850 
upper_i
 ) ) , True )

3852 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?ai)' + 
upper_i
 ,

3853 
lower_i
 ) ) , False )

3854 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?ai)' + 
lower_i
 ,

3855 
upper_i
 ) ) , False )

3857 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?afi)' + 
upper_i
 ,

3858 
lower_i
 ) ) , False )

3859 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?afi)' + 
lower_i
 ,

3860 
upper_i
 ) ) , False )

3863 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?i)\L<aa>' , '22' , 
aa
 = [ '121' , '22'

3865 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?ri)\L<aa>' , '22' , 
aa
 = [ '121' , '22'

3867 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?fi)\L<aa>' , '22' , 
aa
 = [ '121' , '22'

3869 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?fri)\L<aa>' , '22' , 
aa
 = [ '121' , '22'

3873 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)\1dog..(?<=(\L<aa>))$' , 'ccdogcc' ,

3874 
aa
 = [ 'bcb' , 'cc' ] ) . 
span
 ( ) , ( 0 , 7 ) )

3875 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?ir)\1dog..(?<=(\L<aa>))$' , 'ccdogcc'

3876 , 
aa
 = [ 'bcb' , 'cc' ] ) . 
span
 ( ) , ( 0 , 7 ) )

3879 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(2)(?:\1{5}){e<=1}' , '3222212'

3880 ) . 
span
 ( ) , ( 1 , 7 ) )

3881 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(\d)(?:\1{5}){e<=1}' , '3222212'

3882 ) . 
span
 ( ) , ( 1 , 7 ) )

3886 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'''\A(?P<whole>(?>\((?&whole)\)|[+\-]))\Z''' , '((-))'

3887 ) . 
span
 ( ) , ( 0 , 5 ) )

3888 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'''\A(?P<whole>(?>\((?&whole)\)|[+\-]))\Z''' , '((-)+)'

3893 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"x.*? (.).*\1(.*)\1" , 'x  |y| z|'

3894 ) . 
span
 ( ) , ( 0 , 9 ) )

3895 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"\.sr (.*?) (.)(.*)\2(.*)\2(.*)" , r'.sr  h |<nw>|<span class="locked">|'

3896 ) . 
span
 ( ) , ( 0 , 35 ) )

3899 
a
 = '"\\xF9\\x80\\xAEqdz\\x95L\\xA7\\x89[\\xFE \\x91)\\xF9]\\xDB\'\\x99\\x09=\\x00\\xFD\\x98\\x22\\xDD\\xF1\\xB6\\xC3 Z\\xB6gv\\xA5x\\x93P\\xE1r\\x14\\x8Cv\\x0C\\xC0w\\x15r\\xFFc%" '

3900 
py_regex_pattern
 = r'''(?P<http_referer>((?>(?<!\\)(?>"(?>\\.|[^\\"]+)+"|""|(?>'(?>\\.|[^\\']+)+')|''|(?>`(?>\\.|[^\\`]+)+`)|``)))) (?P<useragent>((?>(?<!\\)(?>"(?>\\.|[^\\"]+)+"|""|(?>'(?>\\.|[^\\']+)+')|''|(?>`(?>\\.|[^\\`]+)+`)|``))))'''

3901 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
search
 ( 
py_regex_pattern
 , 
a
 ) ) , False )

3904 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 'foo(?<=foo)' , 'foo' ) ) , True )

3905 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 'foo(?<!foo)' , 'foo' ) ) , False )

3906 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 'foo(?<=foo|x)' , 'foo' ) ) , True )

3907 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( 'foo(?<!foo|x)' , 'foo' ) ) , False )

3911 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?(?=.*\!.*)(?P<true>.*\!\w*\:.*)|(?P<false>.*))' , '!'

3915 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'\w*(ea)\w*|\w*e(?!a)\w*' , 'easier'

3916 ) . 
groups
 ( ) , ( 'ea' , ) )

3919 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^1234$){i,d}' , '12234' ,

3920 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 5 ) )

3921 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^1234$){i,d}' , '12234' ,

3922 
regex
 . 
BESTMATCH
 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3924 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^1234$){s,i,d}' , '12234' ,

3925 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 5 ) )

3926 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^1234$){s,i,d}' , '12234' ,

3927 
regex
 . 
BESTMATCH
 ) . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

3930 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^123$){s,i,d}' , 'xxxxxxxx123' ,

3931 
regex
 . 
BESTMATCH
 ) . 
span
 ( ) , ( 0 , 11 ) )

3932 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( '(^123$){s,i,d}' , 'xxxxxxxx123' ,

3933 
regex
 . 
BESTMATCH
 ) . 
fuzzy_counts
 , ( 0 , 8 , 0 ) )

3937 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'a?yz' , 'xxxxyz' , 
flags
 = 
regex
 . 
FULLCASE
 |

3938 
regex
 . 
IGNORECASE
 ) . 
span
 ( ) , ( 4 , 6 ) )

3941 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'(?:(?![a-d]).)+' , 'abcdefgh' ) ,

3943 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'''(?(DEFINE)(?P<mydef>(?:(?![a-d]).)))(?&mydef)+''' , 'abcdefgh'

3947 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'((\w{1,3})(\.{2,10})){1,3}' , '"Erm....yes. T..T...Thank you for that."'

3950 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'((\w{1,3})(\.{2,10})){3}' , '"Erm....yes. T..T...Thank you for that."'

3952 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'((\w{1,3})(\.{2,10})){2}' , '"Erm....yes. T..T...Thank you for that."'

3954 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'((\w{1,3})(\.{2,10})){1}' , '"Erm....yes. T..T...Thank you for that."'

3960 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:ESTONIA(?!\w)){e<=1}' , 'ESTONIAN WORKERS'

3961 ) . 
group
 ( ) , 'ESTONIAN' )

3962 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:ESTONIA(?=\W)){e<=1}' , 'ESTONIAN WORKERS'

3963 ) . 
group
 ( ) , 'ESTONIAN' )

3965 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:(?<!\w)ESTONIA){e<=1}' , 'BLUB NESTONIA'

3966 ) . 
group
 ( ) , 'NESTONIA' )

3967 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:(?<=\W)ESTONIA){e<=1}' , 'BLUB NESTONIA'

3968 ) . 
group
 ( ) , 'NESTONIA' )

3970 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)(?:ESTONIA(?!\w)){e<=1}' , 'ESTONIAN WORKERS'

3971 ) . 
group
 ( ) , 'ESTONIAN' )

3972 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)(?:ESTONIA(?=\W)){e<=1}' , 'ESTONIAN WORKERS'

3973 ) . 
group
 ( ) , 'ESTONIAN' )

3975 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)(?:(?<!\w)ESTONIA){e<=1}' , 'BLUB NESTONIA'

3976 ) . 
group
 ( ) , 'NESTONIA' )

3977 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r)(?:(?<=\W)ESTONIA){e<=1}' , 'BLUB NESTONIA'

3978 ) . 
group
 ( ) , 'NESTONIA' )

3982 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:A.*B.*CDE){e<=2}' , 'A B CYZ'

3983 ) . 
group
 ( ) , 'A B CYZ' )

3984 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:A.*B.*?CDE){e<=2}' , 'A B CYZ'

3985 ) . 
group
 ( ) , 'A B CYZ' )

3986 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:A.*?B.*CDE){e<=2}' , 'A B CYZ'

3987 ) . 
group
 ( ) , 'A B CYZ' )

3988 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?:A.*?B.*?CDE){e<=2}' , 'A B CYZ'

3989 ) . 
group
 ( ) , 'A B CYZ' )

3992 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( ' ,0A[' , 
special_only
 = False , 
literal_spaces
 = False ) , '\\ \\,0A\\[' )

3993 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( ' ,0A[' , 
special_only
 = False , 
literal_spaces
 = True ) , ' \\,0A\\[' )

3994 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( ' ,0A[' , 
special_only
 = True , 
literal_spaces
 = False ) , '\\ ,0A\\[' )

3995 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( ' ,0A[' , 
special_only
 = True , 
literal_spaces
 = True ) , ' ,0A\\[' )

3997 
self
 . 
assertEqual
 ( 
regex
 . 
escape
 ( ' ,0A[' ) , '\\ ,0A\\[' )

4000 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?=A)A|B)' , 'A' ) . 
span
 ( ) , ( 0 , 1 ) )

4001 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?=A)A|B)' , 'B' ) . 
span
 ( ) , ( 0 , 1 ) )

4002 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?=A)A|)' , 'B' ) . 
span
 ( ) , ( 0 , 0 ) )

4003 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?=X)X|)' , '' ) . 
span
 ( ) , ( 0 , 0 ) )

4004 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(?=X))' , '' ) . 
span
 ( ) , ( 0 , 0 ) )

4008 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?&func)' , 'abc'

4009 ) . 
groups
 ( ) , ( None , ) )

4010 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?&func)' , 'abc'

4011 ) . 
groupdict
 ( ) , { 'func' : None } )

4012 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?&func)' , 'abc'

4013 ) . 
capturesdict
 ( ) , { 'func' : [ 'a' ] } )

4015 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?=(?&func))' , 'abc'

4016 ) . 
groups
 ( ) , ( None , ) )

4017 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?=(?&func))' , 'abc'

4018 ) . 
groupdict
 ( ) , { 'func' : None } )

4019 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.))(?=(?&func))' , 'abc'

4020 ) . 
capturesdict
 ( ) , { 'func' : [ 'a' ] } )

4022 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.)).(?<=(?&func))' , 'abc'

4023 ) . 
groups
 ( ) , ( None , ) )

4024 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.)).(?<=(?&func))' , 'abc'

4025 ) . 
groupdict
 ( ) , { 'func' : None } )

4026 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?(DEFINE)(?<func>.)).(?<=(?&func))' , 'abc'

4027 ) . 
capturesdict
 ( ) , { 'func' : [ 'a' ] } )

4030 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'ab(?#comment\))cd' , 'abcd' ) ) , True )

4033 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'[a-z]+ [a-z]*?:' , 'foo bar' ,

4034 
partial
 = True ) . 
span
 ( ) , ( 0 , 7 ) )

4035 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?r):[a-z]*? [a-z]+' , 'foo bar' ,

4036 
partial
 = True ) . 
span
 ( ) , ( 0 , 7 ) )

4039 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script:Beng}' , '\u09EF'

4041 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script:Bengali}' , '\u09EF'

4043 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script_Extensions:Bengali}' , '\u09EF'

4045 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script_Extensions:Beng}' , '\u09EF'

4047 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script_Extensions:Cakm}' , '\u09EF'

4049 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{Script_Extensions:Sylo}' , '\u09EF'

4054 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Latin}' , 'P' ) ) , True )

4055 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Ahom}' , 'P' ) ) , False )

4056 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Common}' , '4' ) ) , True )

4057 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Caucasian_Albanian}' , '4' ) ) ,

4059 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Arabic}' , '\u062A' ) ) , True )

4060 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Balinese}' , '\u062A' ) ) ,

4062 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Devanagari}' , '\u091C' ) ) ,

4064 
self
 . 
assertEqual
 ( 
bool
 ( 
regex
 . 
match
 ( r'(?u)\p{scx:Batak}' , '\u091C' ) ) , False )

4067 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(?P<x>.)*(?&x)' , 'abc' ) . 
captures
 ( 'x' ) ,

4069 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(?P<x>.)*(?&x)' , 'abc' ) . 
group
 ( 'x' ) , 'b'

4072 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(?P<x>.)(?P<x>.)(?P<x>.)' , 'abc'

4073 ) . 
captures
 ( 'x' ) , [ 'a' , 'b' , 'c' ] )

4074 
self
 . 
assertEqual
 ( 
regex
 . 
fullmatch
 ( '(?P<x>.)(?P<x>.)(?P<x>.)' , 'abc'

4075 ) . 
group
 ( 'x' ) , 'c' )

4078 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)*' , 'ab' , 
partial
 = True ) . 
partial
 ,

4080 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)*' , 'abab' , 
partial
 = True ) . 
partial
 ,

4082 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)*?' , '' , 
partial
 = True ) . 
partial
 ,

4084 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)*+' , 'ab' , 
partial
 = True ) . 
partial
 ,

4086 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)*+' , 'abab' , 
partial
 = True ) . 
partial
 ,

4088 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)+' , 'ab' , 
partial
 = True ) . 
partial
 ,

4090 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)+' , 'abab' , 
partial
 = True ) . 
partial
 ,

4092 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)+?' , 'ab' , 
partial
 = True ) . 
partial
 ,

4094 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)++' , 'ab' , 
partial
 = True ) . 
partial
 ,

4096 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?:ab)++' , 'abab' , 
partial
 = True ) . 
partial
 ,

4099 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)*' , 'ab' , 
partial
 = True ) . 
partial
 ,

4101 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)*' , 'abab' , 
partial
 = True ) . 
partial
 ,

4103 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)*?' , '' , 
partial
 = True ) . 
partial
 ,

4105 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)*+' , 'ab' , 
partial
 = True ) . 
partial
 ,

4107 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)*+' , 'abab' , 
partial
 = True ) . 
partial
 ,

4109 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)+' , 'ab' , 
partial
 = True ) . 
partial
 ,

4111 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)+' , 'abab' , 
partial
 = True ) . 
partial
 ,

4113 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)+?' , 'ab' , 
partial
 = True ) . 
partial
 ,

4115 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)++' , 'ab' , 
partial
 = True ) . 
partial
 ,

4117 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)(?:ab)++' , 'abab' , 
partial
 = True ) . 
partial
 ,

4120 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a*' , '' , 
partial
 = True ) . 
partial
 , False )

4121 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a*?' , '' , 
partial
 = True ) . 
partial
 , False )

4122 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a*+' , '' , 
partial
 = True ) . 
partial
 , False )

4123 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a+' , '' , 
partial
 = True ) . 
partial
 , True )

4124 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a+?' , '' , 
partial
 = True ) . 
partial
 , True )

4125 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a++' , '' , 
partial
 = True ) . 
partial
 , True )

4126 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a+' , 'a' , 
partial
 = True ) . 
partial
 , False )

4127 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a+?' , 'a' , 
partial
 = True ) . 
partial
 , False )

4128 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( 'a++' , 'a' , 
partial
 = True ) . 
partial
 , False )

4130 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a*' , '' , 
partial
 = True ) . 
partial
 , False )

4131 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a*?' , '' , 
partial
 = True ) . 
partial
 , False )

4132 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a*+' , '' , 
partial
 = True ) . 
partial
 , False )

4133 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a+' , '' , 
partial
 = True ) . 
partial
 , True )

4134 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a+?' , '' , 
partial
 = True ) . 
partial
 , True )

4135 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a++' , '' , 
partial
 = True ) . 
partial
 , True )

4136 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a+' , 'a' , 
partial
 = True ) . 
partial
 , False )

4137 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a+?' , 'a' , 
partial
 = True ) . 
partial
 , False )

4138 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( '(?r)a++' , 'a' , 
partial
 = True ) . 
partial
 , False )

4140 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r"(?:\s*\w+'*)+" , 'whatever' , 
partial
 = True ) . 
partial
 ,

4144 
pattern
 = ( '(?P<termini5>GGCGTCACACTTTGCTATGCCATAGCAT[AG]TTTATCCATAAGA' 'TTAGCGGATCCTACCTGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATAACAGAACATATTGA' 'CTATCCGGTATTACCCGGCATGACAGGAGTAAAA){e<=1}' '(?P<gene>[ACGT]{1059}){e<=2}' '(?P<spacer>TAATCGTCTTGTTTGATACACAAGGGTCGCATCTGCGGCCCTTTTGCTTTTTTAAG' 'TTGTAAGGATATGCCATTCTAGA){e<=0}' '(?P<barcode>[ACGT]{18}){e<=0}' '(?P<termini3>AGATCGG[CT]AGAGCGTCGTGTAGGGAAAGAGTGTGG){e<=1}'

4153 
text
 = ( 'GCACGGCGTCACACTTTGCTATGCCATAGCATATTTATCCATAAGATTAGCGGATCCTACC' 'TGACGCTTTTTATCGCAACTCTCTACTGTTTCTCCATAACAGAACATATTGACTATCCGGTATTACC' 'CGGCATGACAGGAGTAAAAATGGCTATCGACGAAAACAAACAGAAAGCGTTGGCGGCAGCACTGGGC' 'CAGATTGAGAAACAATTTGGTAAAGGCTCCATCATGCGCCTGGGTGAAGACCGTTCCATGGATGTGG' 'AAACCATCTCTACCGGTTCGCTTTCACTGGATATCGCGCTTGGGGCAGGTGGTCTGCCGATGGGCCG' 'TATCGTCGAAATCTACGGACCGGAATCTTCCGGTAAAACCACGCTGACGCTGCAGGTGATCGCCGCA' 'GCGCAGCGTGAAGGTAAAACCTGTGCGTTTATCGATGCTGAACACGCGCTGGACCCAATCTACGCAC' 'GTAAACTGGGCGTCGATATCGACAACCTGCTGTGCTCCCAGCCGGACACCGGCGAGCAGGCACTGGA' 'AATCTGTGACGCCCTGGCGCGTTCTGGCGCAGTAGACGTTATCGTCGTTGACTCCGTGGCGGCACTG' 'ACGCCGAAAGCGGAAATCGAAGGCGAAATCGGCGACTCTCATATGGGCCTTGCGGCACGTATGATGA' 'GCCAGGCGATGCGTAAGCTGGCGGGTAACCTGAAGCAGTCCAACACGCTGCTGATCTTCATCAACCC' 'CATCCGTATGAAAATTGGTGTGATGTTCGGCAACCCGGAAACCACTTACCGGTGGTAACGCGCTGAA' 'ATTCTACGCCTCTGTTCGTCTCGACATCCGTTAAATCGGCGCGGTGAAAGAGGGCGAAAACGTGGTG' 'GGTAGCGAAACCCGCGTGAAAGTGGTGAAGAACAAAATCGCTGCGCCGTTTAAACAGGCTGAATTCC' 'AGATCCTCTACGGCGAAGGTATCAACTTCTACCCCGAACTGGTTGACCTGGGCGTAAAAGAGAAGCT' 'GATCGAGAAAGCAGGCGCGTGGTACAGCTACAAAGGTGAGAAGATCGGTCAGGGTAAAGCGAATGCG' 'ACTGCCTGGCTGAAATTTAACCCGGAAACCGCGAAAGAGATCGAGTGAAAAGTACGTGAGTTGCTGC' 'TGAGCAACCCGAACTCAACGCCGGATTTCTCTGTAGATGATAGCGAAGGCGTAGCAGAAACTAACGA' 'AGATTTTTAATCGTCTTGTTTGATACACAAGGGTCGCATCTGCGGCCCTTTTGCTTTTTTAAGTTGT' 'AAGGATATGCCATTCTAGACAGTTAACACACCAACAAAGATCGGTAGAGCGTCGTGTAGGGAAAGAG' 'TGTGGTACC'

4175 
m
 = 
regex
 . 
search
 ( 
pattern
 , 
text
 , 
flags
 = 
regex
 . 
BESTMATCH
 )

4176 
self
 . 
assertEqual
 ( 
m
 . 
fuzzy_counts
 , ( 0 , 1 , 0 ) )

4177 
self
 . 
assertEqual
 ( 
m
 . 
fuzzy_changes
 , ( [ ] , [ 1206 ] , [ ] ) )

4180 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?e)(dogf(((oo){e<1})|((00){e<1}))d){e<2}' , 'dogfood'

4181 ) . 
fuzzy_counts
 , ( 0 , 0 , 0 ) )

4182 
self
 . 
assertEqual
 ( 
regex
 . 
search
 ( r'(?e)(dogf(((oo){e<1})|((00){e<1}))d){e<2}' , 'dogfoot'

4183 ) . 
fuzzy_counts
 , ( 1 , 0 , 0 ) )

4186 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'\X' , '\U0001F468\u200D\U0001F469\u200D\U0001F467\u200D\U0001F466'

4191 
self
 . 
assertEquals
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?=a)a' , 'a' ) ) , True )

4192 
self
 . 
assertEquals
 ( 
bool
 ( 
regex
 . 
search
 ( r'(?!b)a' , 'a' ) ) , True )

4195 
self
 . 
assertEquals
 ( 
regex
 . 
fullmatch
 ( r'((\d)*?)*?' , '123' ) . 
span
 ( ) , ( 0 , 3 ) )

4198 
self
 . 
assertEquals
 ( 
regex
 . 
search
 ( r'''(?(DEFINE)(?<mydef>(?<wrong>THIS_SHOULD_NOT_MATCHx?)|(?<right>right))).*(?<=(?&mydef).*)''' , 'x right'

4199 ) . 
capturesdict
 ( ) , { 'mydef' : [ 'right' ] , 'wrong' : [ ] , 'right' :

4200 [ 'right' ] } ) 
	}

4202 def 
	$test_subscripted_captures
 ( 
self
 ) :

4203 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?P<x>.)+' , 'abc'

4204 ) . 
expandf
 ( '{0} {0[0]} {0[-1]}' ) , 'abc abc abc' )

4205 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?P<x>.)+' , 'abc'

4206 ) . 
expandf
 ( '{1} {1[0]} {1[1]} {1[2]} {1[-1]} {1[-2]} {1[-3]}' ) , 'c a b c c b a'

4208 
self
 . 
assertEqual
 ( 
regex
 . 
match
 ( r'(?P<x>.)+' , 'abc'

4209 ) . 
expandf
 ( '{x} {x[0]} {x[1]} {x[2]} {x[-1]} {x[-2]} {x[-3]}' ) , 'c a b c c b a'

4212 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r'(?P<x>.)+' , r'{0} {0[0]} {0[-1]}' , 'abc'

4214 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r'(?P<x>.)+' , '{1} {1[0]} {1[1]} {1[2]} {1[-1]} {1[-2]} {1[-3]}'

4217 
self
 . 
assertEqual
 ( 
regex
 . 
subf
 ( r'(?P<x>.)+' , '{x} {x[0]} {x[1]} {x[2]} {x[-1]} {x[-2]} {x[-3]}'

4219 ) 
	}

4221 def 
	$test_more_zerowidth
 ( 
self
 ) :

4222 if 
sys
 . 
version_info
 >= ( 3 , 7 , 0 ) :

4223 
self
 . 
assertEqual
 ( 
regex
 . 
split
 ( r'\b|:+' , 'a::bc' ) , [ '' , 'a' , '' , '' , 'bc'

4225 
self
 . 
assertEqual
 ( 
regex
 . 
sub
 ( r'\b|:+' , '-' , 'a::bc' ) , '-a---bc-' )

4226 
self
 . 
assertEqual
 ( 
regex
 . 
findall
 ( r'\b|:+' , 'a::bc' ) , [ '' , '' , '::' , ''

4228 
self
 . 
assertEqual
 ( [ 
m
 . 
span
 ( ) for 
m
 in 
regex
 . 
finditer
 ( r'\b|:+' , 'a::bc'

4230 
self
 . 
assertEqual
 ( [ 
m
 . 
span
 ( ) for 
m
 in 
regex
 . 
finditer
 ( r'(?m)^\s*?$' , 'foo\n\n\nbar'

4231 ) ] , [ ( 4 , 4 ) , ( 4 , 5 ) , ( 5 , 5 ) ] ) 
	}

4233 if 
sys
 . 
version_info
 < ( 3 , 2 , 0 ) :

4235 
RegexTests
 . 
assertRaisesRegex
 = 
RegexTests
 . 
assertRaisesRegexp

4237 def 
	$test_main
 ( ) :

4238 
run_unittest
 ( 
RegexTests
 ) 
	}

4240 if 
__name__
 == "__main__" :

4241 
test_main
 ( )


	@./env/lib/python3.7/site-packages/regex/test/__init__.py


	@./env/lib/python3.7/site-packages/regex/regex.py

234 
__all__
 = [ "compile" , "DEFAULT_VERSION" , "escape" , "findall" , "finditer" , "fullmatch"

242 
__version__
 = "2.5.33"

247 def 
	$match
 ( 
pattern
 , 
string
 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None , 
partial
 = False ,

248 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

251 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
match
 ( 
string
 , 
pos
 , 
endpos
 ,

252 
concurrent
 , 
partial
 , 
timeout
 ) 
	}

254 def 
	$fullmatch
 ( 
pattern
 , 
string
 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None , 
partial
 = False ,

255 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

258 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
fullmatch
 ( 
string
 , 
pos
 , 
endpos
 ,

259 
concurrent
 , 
partial
 , 
timeout
 ) 
	}

261 def 
	$search
 ( 
pattern
 , 
string
 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None , 
partial
 = False ,

262 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

265 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
search
 ( 
string
 , 
pos
 , 
endpos
 ,

266 
concurrent
 , 
partial
 , 
timeout
 ) 
	}

268 def 
	$sub
 ( 
pattern
 , 
repl
 , 
string
 , 
count
 = 0 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None ,

269 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

275 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
sub
 ( 
repl
 , 
string
 , 
count
 , 
pos
 ,

276 
endpos
 , 
concurrent
 , 
timeout
 ) 
	}

278 def 
	$subf
 ( 
pattern
 , 
format
 , 
string
 , 
count
 = 0 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None ,

279 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

285 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
subf
 ( 
format
 , 
string
 , 
count
 , 
pos
 ,

286 
endpos
 , 
concurrent
 , 
timeout
 ) 
	}

288 def 
	$subn
 ( 
pattern
 , 
repl
 , 
string
 , 
count
 = 0 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None ,

289 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

297 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
subn
 ( 
repl
 , 
string
 , 
count
 , 
pos
 ,

298 
endpos
 , 
concurrent
 , 
timeout
 ) 
	}

300 def 
	$subfn
 ( 
pattern
 , 
format
 , 
string
 , 
count
 = 0 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None ,

301 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

309 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
subfn
 ( 
format
 , 
string
 , 
count
 , 
pos
 ,

310 
endpos
 , 
concurrent
 , 
timeout
 ) 
	}

312 def 
	$split
 ( 
pattern
 , 
string
 , 
maxsplit
 = 0 , 
flags
 = 0 , 
concurrent
 = None , 
timeout
 = None ,

313 ** 
kwargs
 ) :

320 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
split
 ( 
string
 , 
maxsplit
 , 
concurrent
 , 
timeout
 ) 
	}

322 def 
	$splititer
 ( 
pattern
 , 
string
 , 
maxsplit
 = 0 , 
flags
 = 0 , 
concurrent
 = None , 
timeout
 = None ,

323 ** 
kwargs
 ) :

325 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
splititer
 ( 
string
 , 
maxsplit
 ,

326 
concurrent
 , 
timeout
 ) 
	}

328 def 
	$findall
 ( 
pattern
 , 
string
 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None , 
overlapped
 = False ,

329 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

334 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
findall
 ( 
string
 , 
pos
 , 
endpos
 ,

335 
overlapped
 , 
concurrent
 , 
timeout
 ) 
	}

337 def 
	$finditer
 ( 
pattern
 , 
string
 , 
flags
 = 0 , 
pos
 = None , 
endpos
 = None , 
overlapped
 = False ,

338 
partial
 = False , 
concurrent
 = None , 
timeout
 = None , ** 
kwargs
 ) :

342 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) . 
finditer
 ( 
string
 , 
pos
 , 
endpos
 ,

343 
overlapped
 , 
concurrent
 , 
partial
 , 
timeout
 ) 
	}

345 def 
	$compile
 ( 
pattern
 , 
flags
 = 0 , ** 
kwargs
 ) :

347 return 
_compile
 ( 
pattern
 , 
flags
 , 
kwargs
 ) 
	}

349 def 
	$purge
 ( ) :

351 
_cache
 . 
clear
 ( )

352 
_locale_sensitive
 . 
clear
 ( ) 
	}

354 def 
	$template
 ( 
pattern
 , 
flags
 = 0 ) :

356 return 
_compile
 ( 
pattern
 , 
flags
 | 
TEMPLATE
 ) 
	}

358 def 
	$escape
 ( 
pattern
 , 
special_only
 = True , 
literal_spaces
 = False ) :

363 if 
isinstance
 ( 
pattern
 , 
bytes
 ) :

364 
p
 = 
pattern
 . 
decode
 ( "latin-1" )

366 
p
 = 
pattern

368 
s
 = [ ]

369 if 
special_only
 :

370 for 
c
 in 
p
 :

371 if 
c
 == " " and 
literal_spaces
 :

372 
s
 . 
append
 ( 
c
 )

373 elif 
c
 in 
_METACHARS
 or 
c
 . 
isspace
 ( ) :

374 
s
 . 
append
 ( "\\" )

375 
s
 . 
append
 ( 
c
 )

376 elif 
c
 == "\x00" :

377 
s
 . 
append
 ( "\\000" )

379 
s
 . 
append
 ( 
c
 )

381 for 
c
 in 
p
 :

382 if 
c
 == " " and 
literal_spaces
 :

383 
s
 . 
append
 ( 
c
 )

384 elif 
c
 in 
_ALNUM
 :

385 
s
 . 
append
 ( 
c
 )

386 elif 
c
 == "\x00" :

387 
s
 . 
append
 ( "\\000" )

389 
s
 . 
append
 ( "\\" )

390 
s
 . 
append
 ( 
c
 )

392 
r
 = "" . 
join
 ( 
s
 )

394 if 
isinstance
 ( 
pattern
 , 
bytes
 ) :

395 
r
 = 
r
 . 
encode
 ( "latin-1" )

397 return 
r
 
	}

402 import 
	~regex._regex_core
 as 
_regex_core

403 import 
	~regex._regex
 as 
_regex

404 from 
	~threading
 import 
RLock
 as 
_RLock

405 from 
	~locale
 import 
getpreferredencoding
 as 
_getpreferredencoding

406 from 
	~regex._regex_core
 import *

407 from 
	~regex._regex_core
 import ( 
_ALL_VERSIONS
 , 
_ALL_ENCODINGS
 , 
_FirstSetError
 ,

408 
_UnscopedFlagSet
 , 
_check_group_features
 , 
_compile_firstset
 ,

409 
_compile_replacement
 , 
_flatten_code
 , 
_fold_case
 , 
_get_required_string
 ,

410 
_parse_pattern
 , 
_shrink_cache
 )

411 from 
	~regex._regex_core
 import ( 
ALNUM
 as 
_ALNUM
 , 
Info
 as 
_Info
 , 
OP
 as 
_OP
 , 
Source

412 as 
_Source
 , 
Fuzzy
 as 
_Fuzzy
 )

417 
DEFAULT_VERSION
 = 
VERSION0

419 
_METACHARS
 = 
frozenset
 ( "()[]{}?*+|^$\\.-#&~" )

421 
_regex_core
 . 
DEFAULT_VERSION
 = 
DEFAULT_VERSION

424 
_cache
 = { }

425 
_cache_lock
 = 
_RLock
 ( )

426 
_named_args
 = { }

427 
_replacement_cache
 = { }

428 
_locale_sensitive
 = { }

431 
_MAXCACHE
 = 500

432 
_MAXREPCACHE
 = 500

434 def 
	$_compile
 ( 
pattern
 , 
flags
 = 0 , 
kwargs
 = { } ) :

437 global 
	gDEFAULT_VERSION

439 from 
	~regex
 import 
DEFAULT_VERSION

440 except 
ImportError
 :

444 
debugging
 = ( 
flags
 & 
DEBUG
 ) != 0

447 
locale_key
 = ( 
type
 ( 
pattern
 ) , 
pattern
 )

448 if 
_locale_sensitive
 . 
get
 ( 
locale_key
 , True ) or ( 
flags
 & 
LOCALE
 ) != 0 :

450 
pattern_locale
 = 
_getpreferredencoding
 ( )

453 
pattern_locale
 = None

455 if not 
debugging
 :

458 
args_key
 = 
pattern
 , 
type
 ( 
pattern
 ) , 
flags

459 
args_needed
 = 
_named_args
 [ 
args_key
 ]

462 
args_supplied
 = 
set
 ( )

463 if 
args_needed
 :

464 for 
k
 , 
v
 in 
args_needed
 :

466 
args_supplied
 . 
add
 ( ( 
k
 , 
frozenset
 ( 
kwargs
 [ 
k
 ] ) ) )

467 except 
KeyError
 :

468 raise 
error
 ( "missing named list: {!r}" . 
format
 ( 
k
 ) )

470 
args_supplied
 = 
frozenset
 ( 
args_supplied
 )

473 
pattern_key
 = ( 
pattern
 , 
type
 ( 
pattern
 ) , 
flags
 , 
args_supplied
 ,

474 
DEFAULT_VERSION
 , 
pattern_locale
 )

475 return 
_cache
 [ 
pattern_key
 ]

476 except 
KeyError
 :

481 if 
isinstance
 ( 
pattern
 , 
str
 ) :

482 
guess_encoding
 = 
UNICODE

483 elif 
isinstance
 ( 
pattern
 , 
bytes
 ) :

484 
guess_encoding
 = 
ASCII

485 elif 
isinstance
 ( 
pattern
 , 
Pattern
 ) :

486 if 
flags
 :

487 raise 
ValueError
 ( "cannot process flags argument with a compiled pattern" )

489 return 
pattern

491 raise 
TypeError
 ( "first argument must be a string or compiled pattern" )

494 
_regex_core
 . 
DEFAULT_VERSION
 = 
DEFAULT_VERSION

496 
global_flags
 = 
flags

499 
caught_exception
 = None

501 
source
 = 
_Source
 ( 
pattern
 )

502 
info
 = 
_Info
 ( 
global_flags
 , 
source
 . 
char_type
 , 
kwargs
 )

503 
info
 . 
guess_encoding
 = 
guess_encoding

504 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

505 
parsed
 = 
_parse_pattern
 ( 
source
 , 
info
 )

507 except 
_UnscopedFlagSet
 :

509 
global_flags
 = 
info
 . 
global_flags

510 except 
error
 as 
e
 :

511 
caught_exception
 = 
e

513 if 
caught_exception
 :

514 raise 
error
 ( 
caught_exception
 . 
msg
 , 
caught_exception
 . 
pattern
 ,

515 
caught_exception
 . 
pos
 )

517 if not 
source
 . 
at_end
 ( ) :

518 raise 
error
 ( "unbalanced parenthesis" , 
pattern
 , 
source
 . 
pos
 )

521 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

522 if 
version
 not in ( 0 , 
VERSION0
 , 
VERSION1
 ) :

523 raise 
ValueError
 ( "VERSION0 and VERSION1 flags are mutually incompatible" )

525 if ( 
info
 . 
flags
 & 
_ALL_ENCODINGS
 ) not in ( 0 , 
ASCII
 , 
LOCALE
 , 
UNICODE
 ) :

526 raise 
ValueError
 ( "ASCII, LOCALE and UNICODE flags are mutually incompatible" )

528 if 
isinstance
 ( 
pattern
 , 
bytes
 ) and ( 
info
 . 
flags
 & 
UNICODE
 ) :

529 raise 
ValueError
 ( "cannot use UNICODE flag with a bytes pattern" )

531 if not ( 
info
 . 
flags
 & 
_ALL_ENCODINGS
 ) :

532 if 
isinstance
 ( 
pattern
 , 
str
 ) :

533 
info
 . 
flags
 |= 
UNICODE

535 
info
 . 
flags
 |= 
ASCII

537 
reverse
 = 
bool
 ( 
info
 . 
flags
 & 
REVERSE
 )

538 
fuzzy
 = 
isinstance
 ( 
parsed
 , 
_Fuzzy
 )

541 
_locale_sensitive
 [ 
locale_key
 ] = 
info
 . 
inline_locale

544 
caught_exception
 = None

546 
parsed
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , False )

547 except 
error
 as 
e
 :

548 
caught_exception
 = 
e

550 if 
caught_exception
 :

551 raise 
error
 ( 
caught_exception
 . 
msg
 , 
caught_exception
 . 
pattern
 ,

552 
caught_exception
 . 
pos
 )

555 if 
flags
 & 
DEBUG
 :

556 
parsed
 . 
dump
 ( 
indent
 = 0 , 
reverse
 = 
reverse
 )

559 
parsed
 = 
parsed
 . 
optimise
 ( 
info
 , 
reverse
 )

560 
parsed
 = 
parsed
 . 
pack_characters
 ( 
info
 )

563 
req_offset
 , 
req_chars
 , 
req_flags
 = 
_get_required_string
 ( 
parsed
 , 
info
 . 
flags
 )

566 
named_lists
 = { }

567 
named_list_indexes
 = [ None ] * 
len
 ( 
info
 . 
named_lists_used
 )

568 
args_needed
 = 
set
 ( )

569 for 
key
 , 
index
 in 
info
 . 
named_lists_used
 . 
items
 ( ) :

570 
name
 , 
case_flags
 = 
key

571 
values
 = 
frozenset
 ( 
kwargs
 [ 
name
 ] )

572 if 
case_flags
 :

573 
items
 = 
frozenset
 ( 
_fold_case
 ( 
info
 , 
v
 ) for 
v
 in 
values
 )

575 
items
 = 
values

576 
named_lists
 [ 
name
 ] = 
values

577 
named_list_indexes
 [ 
index
 ] = 
items

578 
args_needed
 . 
add
 ( ( 
name
 , 
values
 ) )

581 
_check_group_features
 ( 
info
 , 
parsed
 )

584 
code
 = 
parsed
 . 
compile
 ( 
reverse
 )

587 
key
 = ( 0 , 
reverse
 , 
fuzzy
 )

588 
ref
 = 
info
 . 
call_refs
 . 
get
 ( 
key
 )

589 if 
ref
 is not None :

590 
code
 = [ ( 
_OP
 . 
CALL_REF
 , 
ref
 ) ] + 
code
 + [ ( 
_OP
 . 
END
 , ) ]

593 
code
 += [ ( 
_OP
 . 
SUCCESS
 , ) ]

596 for 
group
 , 
rev
 , 
fuz
 in 
info
 . 
additional_groups
 :

597 
code
 += 
group
 . 
compile
 ( 
rev
 , 
fuz
 )

600 
code
 = 
_flatten_code
 ( 
code
 )

602 if not 
parsed
 . 
has_simple_start
 ( ) :

605 
fs_code
 = 
_compile_firstset
 ( 
info
 , 
parsed
 . 
get_firstset
 ( 
reverse
 ) )

606 
fs_code
 = 
_flatten_code
 ( 
fs_code
 )

607 
code
 = 
fs_code
 + 
code

608 except 
_FirstSetError
 :

612 
index_group
 = 
dict
 ( ( 
v
 , 
n
 ) for 
n
 , 
v
 in 
info
 . 
group_index
 . 
items
 ( ) )

619 
compiled_pattern
 = 
_regex
 . 
compile
 ( 
pattern
 , 
info
 . 
flags
 | 
version
 , 
code
 ,

620 
info
 . 
group_index
 , 
index_group
 , 
named_lists
 , 
named_list_indexes
 ,

621 
req_offset
 , 
req_chars
 , 
req_flags
 , 
info
 . 
group_count
 )

624 if 
len
 ( 
_cache
 ) >= 
_MAXCACHE
 :

625 with 
_cache_lock
 :

626 
_shrink_cache
 ( 
_cache
 , 
_named_args
 , 
_locale_sensitive
 , 
_MAXCACHE
 )

628 if not 
debugging
 :

629 if ( 
info
 . 
flags
 & 
LOCALE
 ) == 0 :

630 
pattern_locale
 = None

632 
args_needed
 = 
frozenset
 ( 
args_needed
 )

635 
pattern_key
 = ( 
pattern
 , 
type
 ( 
pattern
 ) , 
flags
 , 
args_needed
 ,

636 
DEFAULT_VERSION
 , 
pattern_locale
 )

637 
_cache
 [ 
pattern_key
 ] = 
compiled_pattern

640 
_named_args
 [ 
args_key
 ] = 
args_needed

642 return 
compiled_pattern
 
	}

644 def 
	$_compile_replacement_helper
 ( 
pattern
 , 
template
 ) :

649 
key
 = 
pattern
 . 
pattern
 , 
pattern
 . 
flags
 , 
template

650 
compiled
 = 
_replacement_cache
 . 
get
 ( 
key
 )

651 if 
compiled
 is not None :

652 return 
compiled

654 if 
len
 ( 
_replacement_cache
 ) >= 
_MAXREPCACHE
 :

655 
_replacement_cache
 . 
clear
 ( )

657 
is_unicode
 = 
isinstance
 ( 
template
 , 
str
 )

658 
source
 = 
_Source
 ( 
template
 )

659 if 
is_unicode
 :

660 def 
make_string
 ( 
char_codes
 ) :

661 return "" . 
join
 ( 
chr
 ( 
c
 ) for 
c
 in 
char_codes
 )

663 def 
make_string
 ( 
char_codes
 ) :

664 return 
bytes
 ( 
char_codes
 )

666 
compiled
 = [ ]

667 
literal
 = [ ]

669 
ch
 = 
source
 . 
get
 ( )

670 if not 
ch
 :

672 if 
ch
 == "\\" :

676 
is_group
 , 
items
 = 
_compile_replacement
 ( 
source
 , 
pattern
 , 
is_unicode
 )

677 if 
is_group
 :

679 if 
literal
 :

680 
compiled
 . 
append
 ( 
make_string
 ( 
literal
 ) )

681 
literal
 = [ ]

682 
compiled
 . 
extend
 ( 
items
 )

684 
literal
 . 
extend
 ( 
items
 )

686 
literal
 . 
append
 ( 
ord
 ( 
ch
 ) )

689 if 
literal
 :

690 
compiled
 . 
append
 ( 
make_string
 ( 
literal
 ) )

692 
_replacement_cache
 [ 
key
 ] = 
compiled

694 return 
compiled
 
	}

697 
Pattern
 = 
type
 ( 
_compile
 ( '' , 0 , { } ) )

698 
Match
 = 
type
 ( 
_compile
 ( '' , 0 ) . 
match
 ( '' ) )

702 
Regex
 = 
compile

705 import 
	~copyreg
 as 
_copy_reg

707 def 
	$_pickle
 ( 
pattern
 ) :

708 return 
_regex
 . 
compile
 , 
pattern
 . 
_pickled_data
 
	}

710 
_copy_reg
 . 
pickle
 ( 
Pattern
 , 
_pickle
 )


	@./env/lib/python3.7/site-packages/regex/_regex_core.py

16 import 
	~string

17 import 
	~sys

18 import 
	~unicodedata

19 from 
	~collections
 import 
defaultdict

21 import 
	~regex._regex
 as 
_regex

23 
__all__
 = [ "A" , "ASCII" , "B" , "BESTMATCH" , "D" , "DEBUG" , "E" , "ENHANCEMATCH" , "F"

30 class 
	cerror
 ( 
Exception
 ) :

42 def 
	$__init__
 ( 
self
 , 
message
 , 
pattern
 = None , 
pos
 = None ) :

43 
newline
 = '\n' if 
isinstance
 ( 
pattern
 , 
str
 ) else b'\n'

44 
self
 . 
msg
 = 
message

45 
self
 . 
pattern
 = 
pattern

46 
self
 . 
pos
 = 
pos

47 if 
pattern
 is not None and 
pos
 is not None :

48 
self
 . 
lineno
 = 
pattern
 . 
count
 ( 
newline
 , 0 , 
pos
 ) + 1

49 
self
 . 
colno
 = 
pos
 - 
pattern
 . 
rfind
 ( 
newline
 , 0 , 
pos
 )

51 
message
 = "{} at position {}" . 
format
 ( 
message
 , 
pos
 )

53 if 
newline
 in 
pattern
 :

54 
message
 += " (line {}, column {})" . 
format
 ( 
self
 . 
lineno
 ,

55 
self
 . 
colno
 )

57 
Exception
 . 
__init__
 ( 
self
 , 
message
 ) 
	}

61 class 
	c_UnscopedFlagSet
 ( 
Exception
 ) :

65 class 
	cParseError
 ( 
Exception
 ) :

69 class 
	c_FirstSetError
 ( 
Exception
 ) :

73 
A
 = 
ASCII
 = 0x80

74 
B
 = 
BESTMATCH
 = 0x1000

75 
D
 = 
DEBUG
 = 0x200

76 
E
 = 
ENHANCEMATCH
 = 0x8000

78 
F
 = 
FULLCASE
 = 0x4000

79 
I
 = 
IGNORECASE
 = 0x2

80 
L
 = 
LOCALE
 = 0x4

81 
M
 = 
MULTILINE
 = 0x8

82 
P
 = 
POSIX
 = 0x10000

83 
R
 = 
REVERSE
 = 0x400

84 
S
 = 
DOTALL
 = 0x10

85 
U
 = 
UNICODE
 = 0x20

86 
V0
 = 
VERSION0
 = 0x2000

87 
V1
 = 
VERSION1
 = 0x100

88 
W
 = 
WORD
 = 0x800

89 
X
 = 
VERBOSE
 = 0x40

90 
T
 = 
TEMPLATE
 = 0x1

92 
DEFAULT_VERSION
 = 
VERSION1

94 
_ALL_VERSIONS
 = 
VERSION0
 | 
VERSION1

95 
_ALL_ENCODINGS
 = 
ASCII
 | 
LOCALE
 | 
UNICODE

98 
DEFAULT_FLAGS
 = { 
VERSION0
 : 0 , 
VERSION1
 : 
FULLCASE
 }

101 
GLOBAL_FLAGS
 = ( 
_ALL_ENCODINGS
 | 
_ALL_VERSIONS
 | 
BESTMATCH
 | 
DEBUG
 |

102 
ENHANCEMATCH
 | 
POSIX
 | 
REVERSE
 )

103 
SCOPED_FLAGS
 = 
FULLCASE
 | 
IGNORECASE
 | 
MULTILINE
 | 
DOTALL
 | 
WORD
 | 
VERBOSE

105 
ALPHA
 = 
frozenset
 ( 
string
 . 
ascii_letters
 )

106 
DIGITS
 = 
frozenset
 ( 
string
 . 
digits
 )

107 
ALNUM
 = 
ALPHA
 | 
DIGITS

108 
OCT_DIGITS
 = 
frozenset
 ( 
string
 . 
octdigits
 )

109 
HEX_DIGITS
 = 
frozenset
 ( 
string
 . 
hexdigits
 )

110 
SPECIAL_CHARS
 = 
frozenset
 ( "()|?*+{^$.[\\#" ) | 
frozenset
 ( [ "" ] )

111 
NAMED_CHAR_PART
 = 
ALNUM
 | 
frozenset
 ( " -" )

112 
PROPERTY_NAME_PART
 = 
ALNUM
 | 
frozenset
 ( " &_-." )

113 
SET_OPS
 = ( "||" , "~~" , "&&" , "--" )

116 
BYTES_PER_CODE
 = 
_regex
 . 
get_code_size
 ( )

117 
BITS_PER_CODE
 = 
BYTES_PER_CODE
 * 8

120 
UNLIMITED
 = ( 1 << 
BITS_PER_CODE
 ) - 1

123 
REGEX_FLAGS
 = { "a" : 
ASCII
 , "b" : 
BESTMATCH
 , "e" : 
ENHANCEMATCH
 , "f" : 
FULLCASE
 , "i"

124 : 
IGNORECASE
 , "L" : 
LOCALE
 , "m" : 
MULTILINE
 , "p" : 
POSIX
 , "r" : 
REVERSE
 , "s"

125 : 
DOTALL
 , "u" : 
UNICODE
 , "V0" : 
VERSION0
 , "V1" : 
VERSION1
 , "w" : 
WORD
 , "x" :

126 
VERBOSE
 }

129 
CASE_FLAGS
 = 
FULLCASE
 | 
IGNORECASE

130 
NOCASE
 = 0

131 
FULLIGNORECASE
 = 
FULLCASE
 | 
IGNORECASE

133 
FULL_CASE_FOLDING
 = 
UNICODE
 | 
FULLIGNORECASE

135 
CASE_FLAGS_COMBINATIONS
 = { 0 : 0 , 
FULLCASE
 : 0 , 
IGNORECASE
 : 
IGNORECASE
 ,

136 
FULLIGNORECASE
 : 
FULLIGNORECASE
 }

139 
HEX_ESCAPES
 = { "x" : 2 , "u" : 4 , "U" : 8 }

142 
OPCODES
 = """\nFAILURE\nSUCCESS\nANY\nANY_ALL\nANY_ALL_REV\nANY_REV\nANY_U\nANY_U_REV\nATOMIC\nBOUNDARY\nBRANCH\nCALL_REF\nCHARACTER\nCHARACTER_IGN\nCHARACTER_IGN_REV\nCHARACTER_REV\nCONDITIONAL\nDEFAULT_BOUNDARY\nDEFAULT_END_OF_WORD\nDEFAULT_START_OF_WORD\nEND\nEND_OF_LINE\nEND_OF_LINE_U\nEND_OF_STRING\nEND_OF_STRING_LINE\nEND_OF_STRING_LINE_U\nEND_OF_WORD\nFUZZY\nGRAPHEME_BOUNDARY\nGREEDY_REPEAT\nGROUP\nGROUP_CALL\nGROUP_EXISTS\nKEEP\nLAZY_REPEAT\nLOOKAROUND\nNEXT\nPROPERTY\nPROPERTY_IGN\nPROPERTY_IGN_REV\nPROPERTY_REV\nPRUNE\nRANGE\nRANGE_IGN\nRANGE_IGN_REV\nRANGE_REV\nREF_GROUP\nREF_GROUP_FLD\nREF_GROUP_FLD_REV\nREF_GROUP_IGN\nREF_GROUP_IGN_REV\nREF_GROUP_REV\nSEARCH_ANCHOR\nSET_DIFF\nSET_DIFF_IGN\nSET_DIFF_IGN_REV\nSET_DIFF_REV\nSET_INTER\nSET_INTER_IGN\nSET_INTER_IGN_REV\nSET_INTER_REV\nSET_SYM_DIFF\nSET_SYM_DIFF_IGN\nSET_SYM_DIFF_IGN_REV\nSET_SYM_DIFF_REV\nSET_UNION\nSET_UNION_IGN\nSET_UNION_IGN_REV\nSET_UNION_REV\nSKIP\nSTART_OF_LINE\nSTART_OF_LINE_U\nSTART_OF_STRING\nSTART_OF_WORD\nSTRING\nSTRING_FLD\nSTRING_FLD_REV\nSTRING_IGN\nSTRING_IGN_REV\nSTRING_REV\nSTRING_SET\nSTRING_SET_FLD\nSTRING_SET_FLD_REV\nSTRING_SET_IGN\nSTRING_SET_IGN_REV\nSTRING_SET_REV\n"""

232 class 
	cNamespace
 :

235 
OP
 = 
Namespace
 ( )

236 for 
i
 , 
op
 in 
enumerate
 ( 
OPCODES
 . 
split
 ( ) ) :

237 
setattr
 ( 
OP
 , 
op
 , 
i
 )

239 def 
	$_shrink_cache
 ( 
cache_dict
 , 
args_dict
 , 
locale_sensitive
 , 
max_length
 , 
divisor
 = 5 ) :

253 
cache_keys
 = 
tuple
 ( 
cache_dict
 . 
keys
 ( ) )

254 
overage
 = 
len
 ( 
cache_keys
 ) - 
max_length

255 if 
overage
 < 0 :

260 
number_to_toss
 = 
max_length
 // 
divisor
 + 
overage

263 import 
	~random

264 if not 
hasattr
 ( 
random
 , 'sample' ) :

269 for 
doomed_key
 in 
random
 . 
sample
 ( 
cache_keys
 , 
number_to_toss
 ) :

271 del 
cache_dict
 [ 
doomed_key
 ]

272 except 
KeyError
 :

277 
args_dict
 . 
clear
 ( )

278 
sensitivity_dict
 = { }

279 for 
pattern
 , 
pattern_type
 , 
flags
 , 
args
 , 
default_version
 , 
locale
 in 
tuple
 ( 
cache_dict
 ) :

280 
args_dict
 [ 
pattern
 , 
pattern_type
 , 
flags
 , 
default_version
 , 
locale
 ] = 
args

282 
sensitivity_dict
 [ 
pattern_type
 , 
pattern
 ] = 
locale_sensitive
 [ 
pattern_type
 , 
pattern
 ]

283 except 
KeyError
 :

286 
locale_sensitive
 . 
clear
 ( )

287 
locale_sensitive
 . 
update
 ( 
sensitivity_dict
 ) 
	}

289 def 
	$_fold_case
 ( 
info
 , 
string
 ) :

291 
flags
 = 
info
 . 
flags

292 if ( 
flags
 & 
_ALL_ENCODINGS
 ) == 0 :

293 
flags
 |= 
info
 . 
guess_encoding

295 return 
_regex
 . 
fold_case
 ( 
flags
 , 
string
 ) 
	}

297 def 
	$is_cased_i
 ( 
info
 , 
char
 ) :

299 return 
len
 ( 
_regex
 . 
get_all_cases
 ( 
info
 . 
flags
 , 
char
 ) ) > 1 
	}

301 def 
	$is_cased_f
 ( 
flags
 , 
char
 ) :

303 return 
len
 ( 
_regex
 . 
get_all_cases
 ( 
flags
 , 
char
 ) ) > 1 
	}

305 def 
	$_compile_firstset
 ( 
info
 , 
fs
 ) :

307 
reverse
 = 
bool
 ( 
info
 . 
flags
 & 
REVERSE
 )

308 
fs
 = 
_check_firstset
 ( 
info
 , 
reverse
 , 
fs
 )

309 if not 
fs
 :

313 return 
fs
 . 
compile
 ( 
reverse
 ) 
	}

315 def 
	$_check_firstset
 ( 
info
 , 
reverse
 , 
fs
 ) :

317 if not 
fs
 or None in 
fs
 :

321 
members
 = 
set
 ( )

322 
case_flags
 = 
NOCASE

323 for 
i
 in 
fs
 :

324 if 
isinstance
 ( 
i
 , 
Character
 ) and not 
i
 . 
positive
 :

333 
case_flags
 |= 
i
 . 
case_flags

334 
members
 . 
add
 ( 
i
 . 
with_flags
 ( 
case_flags
 = 
NOCASE
 ) )

336 if 
case_flags
 == ( 
FULLCASE
 | 
IGNORECASE
 ) :

340 
fs
 = 
SetUnion
 ( 
info
 , 
list
 ( 
members
 ) , 
case_flags
 = 
case_flags
 & ~ 
FULLCASE
 ,

341 
zerowidth
 = True )

342 
fs
 = 
fs
 . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 = True )

344 return 
fs
 
	}

346 def 
	$_flatten_code
 ( 
code
 ) :

348 
flat_code
 = [ ]

349 for 
c
 in 
code
 :

350 
flat_code
 . 
extend
 ( 
c
 )

352 return 
flat_code
 
	}

354 def 
	$make_case_flags
 ( 
info
 ) :

356 
flags
 = 
info
 . 
flags
 & 
CASE_FLAGS

359 if 
info
 . 
flags
 & 
ASCII
 :

360 
flags
 &= ~ 
FULLCASE

362 return 
flags
 
	}

364 def 
	$make_character
 ( 
info
 , 
value
 , 
in_set
 = False ) :

366 if 
in_set
 :

368 return 
Character
 ( 
value
 )

370 return 
Character
 ( 
value
 , 
case_flags
 = 
make_case_flags
 ( 
info
 ) ) 
	}

372 def 
	$make_ref_group
 ( 
info
 , 
name
 , 
position
 ) :

374 return 
RefGroup
 ( 
info
 , 
name
 , 
position
 , 
case_flags
 = 
make_case_flags
 ( 
info
 ) ) 
	}

376 def 
	$make_string_set
 ( 
info
 , 
name
 ) :

378 return 
StringSet
 ( 
info
 , 
name
 , 
case_flags
 = 
make_case_flags
 ( 
info
 ) ) 
	}

380 def 
	$make_property
 ( 
info
 , 
prop
 , 
in_set
 ) :

382 if 
in_set
 :

383 return 
prop

385 return 
prop
 . 
with_flags
 ( 
case_flags
 = 
make_case_flags
 ( 
info
 ) ) 
	}

387 def 
	$_parse_pattern
 ( 
source
 , 
info
 ) :

389 
branches
 = [ 
parse_sequence
 ( 
source
 , 
info
 ) ]

390 while 
source
 . 
match
 ( "|" ) :

391 
branches
 . 
append
 ( 
parse_sequence
 ( 
source
 , 
info
 ) )

393 if 
len
 ( 
branches
 ) == 1 :

394 return 
branches
 [ 0 ]

395 return 
Branch
 ( 
branches
 ) 
	}

397 def 
	$parse_sequence
 ( 
source
 , 
info
 ) :

399 
sequence
 = [ None ]

400 
case_flags
 = 
make_case_flags
 ( 
info
 )

402 
saved_pos
 = 
source
 . 
pos

403 
ch
 = 
source
 . 
get
 ( )

404 if 
ch
 in 
SPECIAL_CHARS
 :

405 if 
ch
 in ")|" :

407 
source
 . 
pos
 = 
saved_pos

409 elif 
ch
 == "\\" :

411 
sequence
 . 
append
 ( 
parse_escape
 ( 
source
 , 
info
 , False ) )

412 elif 
ch
 == "(" :

414 
element
 = 
parse_paren
 ( 
source
 , 
info
 )

415 if 
element
 is None :

416 
case_flags
 = 
make_case_flags
 ( 
info
 )

418 
sequence
 . 
append
 ( 
element
 )

419 elif 
ch
 == "." :

421 if 
info
 . 
flags
 & 
DOTALL
 :

422 
sequence
 . 
append
 ( 
AnyAll
 ( ) )

423 elif 
info
 . 
flags
 & 
WORD
 :

424 
sequence
 . 
append
 ( 
AnyU
 ( ) )

426 
sequence
 . 
append
 ( 
Any
 ( ) )

427 elif 
ch
 == "[" :

429 
sequence
 . 
append
 ( 
parse_set
 ( 
source
 , 
info
 ) )

430 elif 
ch
 == "^" :

432 if 
info
 . 
flags
 & 
MULTILINE
 :

433 if 
info
 . 
flags
 & 
WORD
 :

434 
sequence
 . 
append
 ( 
StartOfLineU
 ( ) )

436 
sequence
 . 
append
 ( 
StartOfLine
 ( ) )

438 
sequence
 . 
append
 ( 
StartOfString
 ( ) )

439 elif 
ch
 == "$" :

441 if 
info
 . 
flags
 & 
MULTILINE
 :

442 if 
info
 . 
flags
 & 
WORD
 :

443 
sequence
 . 
append
 ( 
EndOfLineU
 ( ) )

445 
sequence
 . 
append
 ( 
EndOfLine
 ( ) )

447 if 
info
 . 
flags
 & 
WORD
 :

448 
sequence
 . 
append
 ( 
EndOfStringLineU
 ( ) )

450 
sequence
 . 
append
 ( 
EndOfStringLine
 ( ) )

451 elif 
ch
 in "?*+{" :

453 
counts
 = 
parse_quantifier
 ( 
source
 , 
info
 , 
ch
 )

454 if 
counts
 :

456 
apply_quantifier
 ( 
source
 , 
info
 , 
counts
 , 
case_flags
 , 
ch
 ,

457 
saved_pos
 , 
sequence
 )

458 
sequence
 . 
append
 ( None )

461 
constraints
 = 
parse_fuzzy
 ( 
source
 , 
ch
 )

462 if 
constraints
 :

464 
apply_constraint
 ( 
source
 , 
info
 , 
constraints
 , 
case_flags
 ,

465 
saved_pos
 , 
sequence
 )

466 
sequence
 . 
append
 ( None )

469 
sequence
 . 
append
 ( 
Character
 ( 
ord
 ( 
ch
 ) ,

470 
case_flags
 = 
case_flags
 ) )

473 
sequence
 . 
append
 ( 
Character
 ( 
ord
 ( 
ch
 ) , 
case_flags
 = 
case_flags
 ) )

476 
sequence
 . 
append
 ( 
Character
 ( 
ord
 ( 
ch
 ) , 
case_flags
 = 
case_flags
 ) )

478 
sequence
 = [ 
item
 for 
item
 in 
sequence
 if 
item
 is not None ]

479 return 
Sequence
 ( 
sequence
 ) 
	}

481 def 
	$apply_quantifier
 ( 
source
 , 
info
 , 
counts
 , 
case_flags
 , 
ch
 , 
saved_pos
 ,

482 
sequence
 ) :

483 
element
 = 
sequence
 . 
pop
 ( )

484 if 
element
 is None :

485 if 
sequence
 :

486 raise 
error
 ( "multiple repeat" , 
source
 . 
string
 , 
saved_pos
 )

487 raise 
error
 ( "nothing to repeat" , 
source
 . 
string
 , 
saved_pos
 )

489 if 
isinstance
 ( 
element
 , ( 
GreedyRepeat
 , 
LazyRepeat
 , 
PossessiveRepeat
 ) ) :

490 raise 
error
 ( "multiple repeat" , 
source
 . 
string
 , 
saved_pos
 )

492 
min_count
 , 
max_count
 = 
counts

493 
saved_pos
 = 
source
 . 
pos

494 
ch
 = 
source
 . 
get
 ( )

495 if 
ch
 == "?" :

497 
repeated
 = 
LazyRepeat

498 elif 
ch
 == "+" :

500 
repeated
 = 
PossessiveRepeat

503 
source
 . 
pos
 = 
saved_pos

504 
repeated
 = 
GreedyRepeat

508 if not 
element
 . 
is_empty
 ( ) and ( 
min_count
 != 1 or 
max_count
 != 1 ) :

509 
element
 = 
repeated
 ( 
element
 , 
min_count
 , 
max_count
 )

511 
sequence
 . 
append
 ( 
element
 ) 
	}

513 def 
	$apply_constraint
 ( 
source
 , 
info
 , 
constraints
 , 
case_flags
 , 
saved_pos
 ,

514 
sequence
 ) :

515 
element
 = 
sequence
 . 
pop
 ( )

516 if 
element
 is None :

517 raise 
error
 ( "nothing for fuzzy constraint" , 
source
 . 
string
 , 
saved_pos
 )

521 if 
isinstance
 ( 
element
 , 
Group
 ) :

522 
element
 . 
subpattern
 = 
Fuzzy
 ( 
element
 . 
subpattern
 , 
constraints
 )

523 
sequence
 . 
append
 ( 
element
 )

525 
sequence
 . 
append
 ( 
Fuzzy
 ( 
element
 , 
constraints
 ) ) 
	}

527 
_QUANTIFIERS
 = { "?" : ( 0 , 1 ) , "*" : ( 0 , None ) , "+" : ( 1 , None ) }

529 def 
	$parse_quantifier
 ( 
source
 , 
info
 , 
ch
 ) :

531 
q
 = 
_QUANTIFIERS
 . 
get
 ( 
ch
 )

532 if 
q
 :

534 return 
q

536 if 
ch
 == "{" :

538 
counts
 = 
parse_limited_quantifier
 ( 
source
 )

539 if 
counts
 :

540 return 
counts

542 return None 
	}

544 def 
	$is_above_limit
 ( 
count
 ) :

546 return 
count
 is not None and 
count
 >= 
UNLIMITED
 
	}

548 def 
	$parse_limited_quantifier
 ( 
source
 ) :

550 
saved_pos
 = 
source
 . 
pos

551 
min_count
 = 
parse_count
 ( 
source
 )

552 if 
source
 . 
match
 ( "," ) :

553 
max_count
 = 
parse_count
 ( 
source
 )

556 
min_count
 = 
int
 ( 
min_count
 or 0 )

557 
max_count
 = 
int
 ( 
max_count
 ) if 
max_count
 else None

559 if not 
min_count
 :

560 
source
 . 
pos
 = 
saved_pos

563 
min_count
 = 
max_count
 = 
int
 ( 
min_count
 )

565 if not 
source
 . 
match
 ( "}" ) :

566 
source
 . 
pos
 = 
saved_pos

569 if 
is_above_limit
 ( 
min_count
 ) or 
is_above_limit
 ( 
max_count
 ) :

570 raise 
error
 ( "repeat count too big" , 
source
 . 
string
 , 
saved_pos
 )

572 if 
max_count
 is not None and 
min_count
 > 
max_count
 :

573 raise 
error
 ( "min repeat greater than max repeat" , 
source
 . 
string
 ,

574 
saved_pos
 )

576 return 
min_count
 , 
max_count
 
	}

578 def 
	$parse_fuzzy
 ( 
source
 , 
ch
 ) :

580 
saved_pos
 = 
source
 . 
pos

582 if 
ch
 != "{" :

585 
constraints
 = { }

587 
parse_fuzzy_item
 ( 
source
 , 
constraints
 )

588 while 
source
 . 
match
 ( "," ) :

589 
parse_fuzzy_item
 ( 
source
 , 
constraints
 )

590 except 
ParseError
 :

591 
source
 . 
pos
 = 
saved_pos

594 if not 
source
 . 
match
 ( "}" ) :

595 raise 
error
 ( "expected }" , 
source
 . 
string
 , 
source
 . 
pos
 )

597 return 
constraints
 
	}

599 def 
	$parse_fuzzy_item
 ( 
source
 , 
constraints
 ) :

601 
saved_pos
 = 
source
 . 
pos

603 
parse_cost_constraint
 ( 
source
 , 
constraints
 )

604 except 
ParseError
 :

605 
source
 . 
pos
 = 
saved_pos

607 
parse_cost_equation
 ( 
source
 , 
constraints
 ) 
	}

609 def 
	$parse_cost_constraint
 ( 
source
 , 
constraints
 ) :

611 
saved_pos
 = 
source
 . 
pos

612 
ch
 = 
source
 . 
get
 ( )

613 if 
ch
 in 
ALPHA
 :

615 
constraint
 = 
parse_constraint
 ( 
source
 , 
constraints
 , 
ch
 )

617 
max_inc
 = 
parse_fuzzy_compare
 ( 
source
 )

619 if 
max_inc
 is None :

621 
constraints
 [ 
constraint
 ] = 0 , None

624 
cost_pos
 = 
source
 . 
pos

625 
max_cost
 = 
parse_cost_limit
 ( 
source
 )

628 if not 
max_inc
 :

629 
max_cost
 -= 1

631 if 
max_cost
 < 0 :

632 raise 
error
 ( "bad fuzzy cost limit" , 
source
 . 
string
 , 
cost_pos
 )

634 
constraints
 [ 
constraint
 ] = 0 , 
max_cost

635 elif 
ch
 in 
DIGITS
 :

637 
source
 . 
pos
 = 
saved_pos

640 
cost_pos
 = 
source
 . 
pos

641 
min_cost
 = 
parse_cost_limit
 ( 
source
 )

643 
min_inc
 = 
parse_fuzzy_compare
 ( 
source
 )

644 if 
min_inc
 is None :

645 raise 
ParseError
 ( )

647 
constraint
 = 
parse_constraint
 ( 
source
 , 
constraints
 , 
source
 . 
get
 ( ) )

649 
max_inc
 = 
parse_fuzzy_compare
 ( 
source
 )

650 if 
max_inc
 is None :

651 raise 
ParseError
 ( )

654 
cost_pos
 = 
source
 . 
pos

655 
max_cost
 = 
parse_cost_limit
 ( 
source
 )

658 if not 
min_inc
 :

659 
min_cost
 += 1

660 if not 
max_inc
 :

661 
max_cost
 -= 1

663 if not 0 <= 
min_cost
 <= 
max_cost
 :

664 raise 
error
 ( "bad fuzzy cost limit" , 
source
 . 
string
 , 
cost_pos
 )

666 
constraints
 [ 
constraint
 ] = 
min_cost
 , 
max_cost

668 raise 
ParseError
 ( ) 
	}

670 def 
	$parse_cost_limit
 ( 
source
 ) :

672 
cost_pos
 = 
source
 . 
pos

673 
digits
 = 
parse_count
 ( 
source
 )

676 return 
int
 ( 
digits
 )

677 except 
ValueError
 :

680 raise 
error
 ( "bad fuzzy cost limit" , 
source
 . 
string
 , 
cost_pos
 ) 
	}

682 def 
	$parse_constraint
 ( 
source
 , 
constraints
 , 
ch
 ) :

684 if 
ch
 not in "deis" :

685 raise 
ParseError
 ( )

687 if 
ch
 in 
constraints
 :

688 raise 
ParseError
 ( )

690 return 
ch
 
	}

692 def 
	$parse_fuzzy_compare
 ( 
source
 ) :

694 if 
source
 . 
match
 ( "<=" ) :

696 elif 
source
 . 
match
 ( "<" ) :

699 return None 
	}

701 def 
	$parse_cost_equation
 ( 
source
 , 
constraints
 ) :

703 if "cost" in 
constraints
 :

704 raise 
error
 ( "more than one cost equation" , 
source
 . 
string
 , 
source
 . 
pos
 )

706 
cost
 = { }

708 
parse_cost_term
 ( 
source
 , 
cost
 )

709 while 
source
 . 
match
 ( "+" ) :

710 
parse_cost_term
 ( 
source
 , 
cost
 )

712 
max_inc
 = 
parse_fuzzy_compare
 ( 
source
 )

713 if 
max_inc
 is None :

714 raise 
ParseError
 ( )

716 
max_cost
 = 
int
 ( 
parse_count
 ( 
source
 ) )

718 if not 
max_inc
 :

719 
max_cost
 -= 1

721 if 
max_cost
 < 0 :

722 raise 
error
 ( "bad fuzzy cost limit" , 
source
 . 
string
 , 
source
 . 
pos
 )

724 
cost
 [ "max" ] = 
max_cost

726 
constraints
 [ "cost" ] = 
cost
 
	}

728 def 
	$parse_cost_term
 ( 
source
 , 
cost
 ) :

730 
coeff
 = 
parse_count
 ( 
source
 )

731 
ch
 = 
source
 . 
get
 ( )

732 if 
ch
 not in "dis" :

733 raise 
ParseError
 ( )

735 if 
ch
 in 
cost
 :

736 raise 
error
 ( "repeated fuzzy cost" , 
source
 . 
string
 , 
source
 . 
pos
 )

738 
cost
 [ 
ch
 ] = 
int
 ( 
coeff
 or 1 ) 
	}

740 def 
	$parse_count
 ( 
source
 ) :

742 return 
source
 . 
get_while
 ( 
DIGITS
 ) 
	}

744 def 
	$parse_paren
 ( 
source
 , 
info
 ) :

748 
saved_pos
 = 
source
 . 
pos

749 
ch
 = 
source
 . 
get
 ( )

750 if 
ch
 == "?" :

752 
saved_pos_2
 = 
source
 . 
pos

753 
ch
 = 
source
 . 
get
 ( )

754 if 
ch
 == "<" :

756 
saved_pos_3
 = 
source
 . 
pos

757 
ch
 = 
source
 . 
get
 ( )

758 if 
ch
 in ( "=" , "!" ) :

760 return 
parse_lookaround
 ( 
source
 , 
info
 , True , 
ch
 == "=" )

763 
source
 . 
pos
 = 
saved_pos_3

764 
name
 = 
parse_name
 ( 
source
 )

765 
group
 = 
info
 . 
open_group
 ( 
name
 )

766 
source
 . 
expect
 ( ">" )

767 
saved_flags
 = 
info
 . 
flags

769 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

770 
source
 . 
expect
 ( ")" )

772 
info
 . 
flags
 = 
saved_flags

773 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

775 
info
 . 
close_group
 ( )

776 return 
Group
 ( 
info
 , 
group
 , 
subpattern
 )

777 if 
ch
 in ( "=" , "!" ) :

779 return 
parse_lookaround
 ( 
source
 , 
info
 , False , 
ch
 == "=" )

780 if 
ch
 == "P" :

782 return 
parse_extension
 ( 
source
 , 
info
 )

783 if 
ch
 == "#" :

785 return 
parse_comment
 ( 
source
 )

786 if 
ch
 == "(" :

788 return 
parse_conditional
 ( 
source
 , 
info
 )

789 if 
ch
 == ">" :

791 return 
parse_atomic
 ( 
source
 , 
info
 )

792 if 
ch
 == "|" :

794 return 
parse_common
 ( 
source
 , 
info
 )

795 if 
ch
 == "R" or "0" <= 
ch
 <= "9" :

797 return 
parse_call_group
 ( 
source
 , 
info
 , 
ch
 , 
saved_pos_2
 )

798 if 
ch
 == "&" :

800 return 
parse_call_named_group
 ( 
source
 , 
info
 , 
saved_pos_2
 )

803 
source
 . 
pos
 = 
saved_pos_2

804 return 
parse_flags_subpattern
 ( 
source
 , 
info
 )

806 if 
ch
 == "*" :

808 
saved_pos_2
 = 
source
 . 
pos

809 
word
 = 
source
 . 
get_while
 ( 
set
 ( ")>" ) , 
include
 = False )

810 if 
word
 [ : 1 ] . 
isalpha
 ( ) :

811 
verb
 = 
VERBS
 . 
get
 ( 
word
 )

812 if not 
verb
 :

813 raise 
error
 ( "unknown verb" , 
source
 . 
string
 , 
saved_pos_2
 )

815 
source
 . 
expect
 ( ")" )

817 return 
verb

820 
source
 . 
pos
 = 
saved_pos

821 
group
 = 
info
 . 
open_group
 ( )

822 
saved_flags
 = 
info
 . 
flags

824 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

825 
source
 . 
expect
 ( ")" )

827 
info
 . 
flags
 = 
saved_flags

828 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

830 
info
 . 
close_group
 ( )

832 return 
Group
 ( 
info
 , 
group
 , 
subpattern
 ) 
	}

834 def 
	$parse_extension
 ( 
source
 , 
info
 ) :

836 
saved_pos
 = 
source
 . 
pos

837 
ch
 = 
source
 . 
get
 ( )

838 if 
ch
 == "<" :

840 
name
 = 
parse_name
 ( 
source
 )

841 
group
 = 
info
 . 
open_group
 ( 
name
 )

842 
source
 . 
expect
 ( ">" )

843 
saved_flags
 = 
info
 . 
flags

845 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

846 
source
 . 
expect
 ( ")" )

848 
info
 . 
flags
 = 
saved_flags

849 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

851 
info
 . 
close_group
 ( )

853 return 
Group
 ( 
info
 , 
group
 , 
subpattern
 )

854 if 
ch
 == "=" :

856 
name
 = 
parse_name
 ( 
source
 , 
allow_numeric
 = True )

857 
source
 . 
expect
 ( ")" )

858 if 
info
 . 
is_open_group
 ( 
name
 ) :

859 raise 
error
 ( "cannot refer to an open group" , 
source
 . 
string
 ,

860 
saved_pos
 )

862 return 
make_ref_group
 ( 
info
 , 
name
 , 
saved_pos
 )

863 if 
ch
 == ">" or 
ch
 == "&" :

865 return 
parse_call_named_group
 ( 
source
 , 
info
 , 
saved_pos
 )

867 
source
 . 
pos
 = 
saved_pos

868 raise 
error
 ( "unknown extension" , 
source
 . 
string
 , 
saved_pos
 ) 
	}

870 def 
	$parse_comment
 ( 
source
 ) :

873 
saved_pos
 = 
source
 . 
pos

874 
c
 = 
source
 . 
get
 ( )

876 if not 
c
 or 
c
 == ")" :

879 if 
c
 == "\\" :

880 
c
 = 
source
 . 
get
 ( )

882 
source
 . 
pos
 = 
saved_pos

883 
source
 . 
expect
 ( ")" )

885 return None 
	}

887 def 
	$parse_lookaround
 ( 
source
 , 
info
 , 
behind
 , 
positive
 ) :

889 
saved_flags
 = 
info
 . 
flags

891 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

892 
source
 . 
expect
 ( ")" )

894 
info
 . 
flags
 = 
saved_flags

895 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

897 return 
LookAround
 ( 
behind
 , 
positive
 , 
subpattern
 ) 
	}

899 def 
	$parse_conditional
 ( 
source
 , 
info
 ) :

901 
saved_flags
 = 
info
 . 
flags

902 
saved_pos
 = 
source
 . 
pos

903 
ch
 = 
source
 . 
get
 ( )

904 if 
ch
 == "?" :

906 
ch
 = 
source
 . 
get
 ( )

907 if 
ch
 in ( "=" , "!" ) :

909 return 
parse_lookaround_conditional
 ( 
source
 , 
info
 , False , 
ch
 == "=" )

910 if 
ch
 == "<" :

912 
ch
 = 
source
 . 
get
 ( )

913 if 
ch
 in ( "=" , "!" ) :

915 return 
parse_lookaround_conditional
 ( 
source
 , 
info
 , True , 
ch
 == "="

918 
source
 . 
pos
 = 
saved_pos

919 raise 
error
 ( "expected lookaround conditional" , 
source
 . 
string
 ,

920 
source
 . 
pos
 )

922 
source
 . 
pos
 = 
saved_pos

924 
group
 = 
parse_name
 ( 
source
 , True )

925 
source
 . 
expect
 ( ")" )

926 
yes_branch
 = 
parse_sequence
 ( 
source
 , 
info
 )

927 if 
source
 . 
match
 ( "|" ) :

928 
no_branch
 = 
parse_sequence
 ( 
source
 , 
info
 )

930 
no_branch
 = 
Sequence
 ( )

932 
source
 . 
expect
 ( ")" )

934 
info
 . 
flags
 = 
saved_flags

935 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

937 if 
yes_branch
 . 
is_empty
 ( ) and 
no_branch
 . 
is_empty
 ( ) :

938 return 
Sequence
 ( )

940 return 
Conditional
 ( 
info
 , 
group
 , 
yes_branch
 , 
no_branch
 , 
saved_pos
 ) 
	}

942 def 
	$parse_lookaround_conditional
 ( 
source
 , 
info
 , 
behind
 , 
positive
 ) :

943 
saved_flags
 = 
info
 . 
flags

945 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

946 
source
 . 
expect
 ( ")" )

948 
info
 . 
flags
 = 
saved_flags

949 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

951 
yes_branch
 = 
parse_sequence
 ( 
source
 , 
info
 )

952 if 
source
 . 
match
 ( "|" ) :

953 
no_branch
 = 
parse_sequence
 ( 
source
 , 
info
 )

955 
no_branch
 = 
Sequence
 ( )

957 
source
 . 
expect
 ( ")" )

959 return 
LookAroundConditional
 ( 
behind
 , 
positive
 , 
subpattern
 , 
yes_branch
 ,

960 
no_branch
 ) 
	}

962 def 
	$parse_atomic
 ( 
source
 , 
info
 ) :

964 
saved_flags
 = 
info
 . 
flags

966 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

967 
source
 . 
expect
 ( ")" )

969 
info
 . 
flags
 = 
saved_flags

970 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

972 return 
Atomic
 ( 
subpattern
 ) 
	}

974 def 
	$parse_common
 ( 
source
 , 
info
 ) :

977 
initial_group_count
 = 
info
 . 
group_count

978 
branches
 = [ 
parse_sequence
 ( 
source
 , 
info
 ) ]

979 
final_group_count
 = 
info
 . 
group_count

980 while 
source
 . 
match
 ( "|" ) :

981 
info
 . 
group_count
 = 
initial_group_count

982 
branches
 . 
append
 ( 
parse_sequence
 ( 
source
 , 
info
 ) )

983 
final_group_count
 = 
max
 ( 
final_group_count
 , 
info
 . 
group_count
 )

985 
info
 . 
group_count
 = 
final_group_count

986 
source
 . 
expect
 ( ")" )

988 if 
len
 ( 
branches
 ) == 1 :

989 return 
branches
 [ 0 ]

990 return 
Branch
 ( 
branches
 ) 
	}

992 def 
	$parse_call_group
 ( 
source
 , 
info
 , 
ch
 , 
pos
 ) :

994 if 
ch
 == "R" :

995 
group
 = "0"

997 
group
 = 
ch
 + 
source
 . 
get_while
 ( 
DIGITS
 )

999 
source
 . 
expect
 ( ")" )

1001 return 
CallGroup
 ( 
info
 , 
group
 , 
pos
 ) 
	}

1003 def 
	$parse_call_named_group
 ( 
source
 , 
info
 , 
pos
 ) :

1005 
group
 = 
parse_name
 ( 
source
 )

1006 
source
 . 
expect
 ( ")" )

1008 return 
CallGroup
 ( 
info
 , 
group
 , 
pos
 ) 
	}

1010 def 
	$parse_flag_set
 ( 
source
 ) :

1012 
flags
 = 0

1016 
saved_pos
 = 
source
 . 
pos

1017 
ch
 = 
source
 . 
get
 ( )

1018 if 
ch
 == "V" :

1019 
ch
 += 
source
 . 
get
 ( )

1020 
flags
 |= 
REGEX_FLAGS
 [ 
ch
 ]

1021 except 
KeyError
 :

1022 
source
 . 
pos
 = 
saved_pos

1024 return 
flags
 
	}

1026 def 
	$parse_flags
 ( 
source
 , 
info
 ) :

1028 
flags_on
 = 
parse_flag_set
 ( 
source
 )

1029 if 
source
 . 
match
 ( "-" ) :

1030 
flags_off
 = 
parse_flag_set
 ( 
source
 )

1031 if not 
flags_off
 :

1032 raise 
error
 ( "bad inline flags: no flags after '-'" , 
source
 . 
string
 ,

1033 
source
 . 
pos
 )

1035 
flags_off
 = 0

1037 if 
flags_on
 & 
LOCALE
 :

1039 
info
 . 
inline_locale
 = True

1041 return 
flags_on
 , 
flags_off
 
	}

1043 def 
	$parse_subpattern
 ( 
source
 , 
info
 , 
flags_on
 , 
flags_off
 ) :

1045 
saved_flags
 = 
info
 . 
flags

1046 
info
 . 
flags
 = ( 
info
 . 
flags
 | 
flags_on
 ) & ~ 
flags_off

1047 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

1049 
subpattern
 = 
_parse_pattern
 ( 
source
 , 
info
 )

1050 
source
 . 
expect
 ( ")" )

1052 
info
 . 
flags
 = 
saved_flags

1053 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

1055 return 
subpattern
 
	}

1057 def 
	$parse_flags_subpattern
 ( 
source
 , 
info
 ) :

1062 
flags_on
 , 
flags_off
 = 
parse_flags
 ( 
source
 , 
info
 )

1064 if 
flags_off
 & 
GLOBAL_FLAGS
 :

1065 raise 
error
 ( "bad inline flags: cannot turn off global flag" ,

1066 
source
 . 
string
 , 
source
 . 
pos
 )

1068 if 
flags_on
 & 
flags_off
 :

1069 raise 
error
 ( "bad inline flags: flag turned on and off" , 
source
 . 
string
 ,

1070 
source
 . 
pos
 )

1073 
new_global_flags
 = ( 
flags_on
 & ~ 
info
 . 
global_flags
 ) & 
GLOBAL_FLAGS

1074 if 
new_global_flags
 :

1075 
info
 . 
global_flags
 |= 
new_global_flags

1078 raise 
_UnscopedFlagSet
 ( 
info
 . 
global_flags
 )

1081 
flags_on
 &= ~ 
GLOBAL_FLAGS

1083 if 
source
 . 
match
 ( ":" ) :

1084 return 
parse_subpattern
 ( 
source
 , 
info
 , 
flags_on
 , 
flags_off
 )

1086 if 
source
 . 
match
 ( ")" ) :

1087 
parse_positional_flags
 ( 
source
 , 
info
 , 
flags_on
 , 
flags_off
 )

1090 raise 
error
 ( "unknown extension" , 
source
 . 
string
 , 
source
 . 
pos
 ) 
	}

1092 def 
	$parse_positional_flags
 ( 
source
 , 
info
 , 
flags_on
 , 
flags_off
 ) :

1094 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

1095 if 
version
 == 
VERSION0
 :

1097 if 
flags_off
 :

1098 raise 
error
 ( "bad inline flags: cannot turn flags off" ,

1099 
source
 . 
string
 , 
source
 . 
pos
 )

1101 
new_global_flags
 = 
flags_on
 & ~ 
info
 . 
global_flags

1102 if 
new_global_flags
 :

1103 
info
 . 
global_flags
 |= 
new_global_flags

1106 raise 
_UnscopedFlagSet
 ( 
info
 . 
global_flags
 )

1108 
info
 . 
flags
 = ( 
info
 . 
flags
 | 
flags_on
 ) & ~ 
flags_off

1110 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 ) 
	}

1112 def 
	$parse_name
 ( 
source
 , 
allow_numeric
 = False , 
allow_group_0
 = False ) :

1114 
name
 = 
source
 . 
get_while
 ( 
set
 ( ")>" ) , 
include
 = False )

1116 if not 
name
 :

1117 raise 
error
 ( "missing group name" , 
source
 . 
string
 , 
source
 . 
pos
 )

1119 if 
name
 . 
isdigit
 ( ) :

1120 
min_group
 = 0 if 
allow_group_0
 else 1

1121 if not 
allow_numeric
 or 
int
 ( 
name
 ) < 
min_group
 :

1122 raise 
error
 ( "bad character in group name" , 
source
 . 
string
 ,

1123 
source
 . 
pos
 )

1125 if not 
name
 . 
isidentifier
 ( ) :

1126 raise 
error
 ( "bad character in group name" , 
source
 . 
string
 ,

1127 
source
 . 
pos
 )

1129 return 
name
 
	}

1131 def 
	$is_octal
 ( 
string
 ) :

1133 return 
all
 ( 
ch
 in 
OCT_DIGITS
 for 
ch
 in 
string
 ) 
	}

1135 def 
	$is_decimal
 ( 
string
 ) :

1137 return 
all
 ( 
ch
 in 
DIGITS
 for 
ch
 in 
string
 ) 
	}

1139 def 
	$is_hexadecimal
 ( 
string
 ) :

1141 return 
all
 ( 
ch
 in 
HEX_DIGITS
 for 
ch
 in 
string
 ) 
	}

1143 def 
	$parse_escape
 ( 
source
 , 
info
 , 
in_set
 ) :

1145 
saved_ignore
 = 
source
 . 
ignore_space

1146 
source
 . 
ignore_space
 = False

1147 
ch
 = 
source
 . 
get
 ( )

1148 
source
 . 
ignore_space
 = 
saved_ignore

1149 if not 
ch
 :

1151 raise 
error
 ( "bad escape (end of pattern)" , 
source
 . 
string
 , 
source
 . 
pos
 )

1152 if 
ch
 in 
HEX_ESCAPES
 :

1154 return 
parse_hex_escape
 ( 
source
 , 
info
 , 
ch
 , 
HEX_ESCAPES
 [ 
ch
 ] , 
in_set
 , 
ch
 )

1155 elif 
ch
 == "g" and not 
in_set
 :

1157 
saved_pos
 = 
source
 . 
pos

1159 return 
parse_group_ref
 ( 
source
 , 
info
 )

1160 except 
error
 :

1162 
source
 . 
pos
 = 
saved_pos

1164 return 
make_character
 ( 
info
 , 
ord
 ( 
ch
 ) , 
in_set
 )

1165 elif 
ch
 == "G" and not 
in_set
 :

1167 return 
SearchAnchor
 ( )

1168 elif 
ch
 == "L" and not 
in_set
 :

1170 return 
parse_string_set
 ( 
source
 , 
info
 )

1171 elif 
ch
 == "N" :

1173 return 
parse_named_char
 ( 
source
 , 
info
 , 
in_set
 )

1174 elif 
ch
 in "pP" :

1176 return 
parse_property
 ( 
source
 , 
info
 , 
ch
 == "p" , 
in_set
 )

1177 elif 
ch
 == "X" and not 
in_set
 :

1179 return 
Grapheme
 ( )

1180 elif 
ch
 in 
ALPHA
 :

1183 if not 
in_set
 :

1184 if 
info
 . 
flags
 & 
WORD
 :

1185 
value
 = 
WORD_POSITION_ESCAPES
 . 
get
 ( 
ch
 )

1187 
value
 = 
POSITION_ESCAPES
 . 
get
 ( 
ch
 )

1189 if 
value
 :

1190 return 
value

1192 
value
 = 
CHARSET_ESCAPES
 . 
get
 ( 
ch
 )

1193 if 
value
 :

1194 return 
value

1196 
value
 = 
CHARACTER_ESCAPES
 . 
get
 ( 
ch
 )

1197 if 
value
 :

1198 return 
Character
 ( 
ord
 ( 
value
 ) )

1200 return 
make_character
 ( 
info
 , 
ord
 ( 
ch
 ) , 
in_set
 )

1201 elif 
ch
 in 
DIGITS
 :

1203 return 
parse_numeric_escape
 ( 
source
 , 
info
 , 
ch
 , 
in_set
 )

1206 return 
make_character
 ( 
info
 , 
ord
 ( 
ch
 ) , 
in_set
 ) 
	}

1208 def 
	$parse_numeric_escape
 ( 
source
 , 
info
 , 
ch
 , 
in_set
 ) :

1210 if 
in_set
 or 
ch
 == "0" :

1212 return 
parse_octal_escape
 ( 
source
 , 
info
 , [ 
ch
 ] , 
in_set
 )

1215 
digits
 = 
ch

1216 
saved_pos
 = 
source
 . 
pos

1217 
ch
 = 
source
 . 
get
 ( )

1218 if 
ch
 in 
DIGITS
 :

1220 
digits
 += 
ch

1221 
saved_pos
 = 
source
 . 
pos

1222 
ch
 = 
source
 . 
get
 ( )

1223 if 
is_octal
 ( 
digits
 ) and 
ch
 in 
OCT_DIGITS
 :

1225 
encoding
 = 
info
 . 
flags
 & 
_ALL_ENCODINGS

1226 if 
encoding
 == 
ASCII
 or 
encoding
 == 
LOCALE
 :

1227 
octal_mask
 = 0xFF

1229 
octal_mask
 = 0x1FF

1231 
value
 = 
int
 ( 
digits
 + 
ch
 , 8 ) & 
octal_mask

1232 return 
make_character
 ( 
info
 , 
value
 )

1235 
source
 . 
pos
 = 
saved_pos

1236 if 
info
 . 
is_open_group
 ( 
digits
 ) :

1237 raise 
error
 ( "cannot refer to an open group" , 
source
 . 
string
 , 
source
 . 
pos
 )

1239 return 
make_ref_group
 ( 
info
 , 
digits
 , 
source
 . 
pos
 ) 
	}

1241 def 
	$parse_octal_escape
 ( 
source
 , 
info
 , 
digits
 , 
in_set
 ) :

1243 
saved_pos
 = 
source
 . 
pos

1244 
ch
 = 
source
 . 
get
 ( )

1245 while 
len
 ( 
digits
 ) < 3 and 
ch
 in 
OCT_DIGITS
 :

1246 
digits
 . 
append
 ( 
ch
 )

1247 
saved_pos
 = 
source
 . 
pos

1248 
ch
 = 
source
 . 
get
 ( )

1250 
source
 . 
pos
 = 
saved_pos

1252 
value
 = 
int
 ( "" . 
join
 ( 
digits
 ) , 8 )

1253 return 
make_character
 ( 
info
 , 
value
 , 
in_set
 )

1254 except 
ValueError
 :

1255 if 
digits
 [ 0 ] in 
OCT_DIGITS
 :

1256 raise 
error
 ( "incomplete escape \\%s" % '' . 
join
 ( 
digits
 ) ,

1257 
source
 . 
string
 , 
source
 . 
pos
 )

1259 raise 
error
 ( "bad escape \\%s" % 
digits
 [ 0 ] , 
source
 . 
string
 ,

1260 
source
 . 
pos
 ) 
	}

1262 def 
	$parse_hex_escape
 ( 
source
 , 
info
 , 
esc
 , 
expected_len
 , 
in_set
 , 
type
 ) :

1264 
saved_pos
 = 
source
 . 
pos

1265 
digits
 = [ ]

1266 for 
i
 in 
range
 ( 
expected_len
 ) :

1267 
ch
 = 
source
 . 
get
 ( )

1268 if 
ch
 not in 
HEX_DIGITS
 :

1269 raise 
error
 ( "incomplete escape \\%s%s" % ( 
type
 , '' . 
join
 ( 
digits
 ) ) ,

1270 
source
 . 
string
 , 
saved_pos
 )

1271 
digits
 . 
append
 ( 
ch
 )

1274 
value
 = 
int
 ( "" . 
join
 ( 
digits
 ) , 16 )

1275 except 
ValueError
 :

1278 if 
value
 < 0x110000 :

1279 return 
make_character
 ( 
info
 , 
value
 , 
in_set
 )

1282 raise 
error
 ( "bad hex escape \\%s%s" % ( 
esc
 , '' . 
join
 ( 
digits
 ) ) ,

1283 
source
 . 
string
 , 
saved_pos
 ) 
	}

1285 def 
	$parse_group_ref
 ( 
source
 , 
info
 ) :

1287 
source
 . 
expect
 ( "<" )

1288 
saved_pos
 = 
source
 . 
pos

1289 
name
 = 
parse_name
 ( 
source
 , True )

1290 
source
 . 
expect
 ( ">" )

1291 if 
info
 . 
is_open_group
 ( 
name
 ) :

1292 raise 
error
 ( "cannot refer to an open group" , 
source
 . 
string
 , 
source
 . 
pos
 )

1294 return 
make_ref_group
 ( 
info
 , 
name
 , 
saved_pos
 ) 
	}

1296 def 
	$parse_string_set
 ( 
source
 , 
info
 ) :

1298 
source
 . 
expect
 ( "<" )

1299 
name
 = 
parse_name
 ( 
source
 , True )

1300 
source
 . 
expect
 ( ">" )

1301 if 
name
 is None or 
name
 not in 
info
 . 
kwargs
 :

1302 raise 
error
 ( "undefined named list" , 
source
 . 
string
 , 
source
 . 
pos
 )

1304 return 
make_string_set
 ( 
info
 , 
name
 ) 
	}

1306 def 
	$parse_named_char
 ( 
source
 , 
info
 , 
in_set
 ) :

1308 
saved_pos
 = 
source
 . 
pos

1309 if 
source
 . 
match
 ( "{" ) :

1310 
name
 = 
source
 . 
get_while
 ( 
NAMED_CHAR_PART
 )

1311 if 
source
 . 
match
 ( "}" ) :

1313 
value
 = 
unicodedata
 . 
lookup
 ( 
name
 )

1314 return 
make_character
 ( 
info
 , 
ord
 ( 
value
 ) , 
in_set
 )

1315 except 
KeyError
 :

1316 raise 
error
 ( "undefined character name" , 
source
 . 
string
 ,

1317 
source
 . 
pos
 )

1319 
source
 . 
pos
 = 
saved_pos

1320 return 
make_character
 ( 
info
 , 
ord
 ( "N" ) , 
in_set
 ) 
	}

1322 def 
	$parse_property
 ( 
source
 , 
info
 , 
positive
 , 
in_set
 ) :

1324 
saved_pos
 = 
source
 . 
pos

1325 
ch
 = 
source
 . 
get
 ( )

1326 if 
ch
 == "{" :

1327 
negate
 = 
source
 . 
match
 ( "^" )

1328 
prop_name
 , 
name
 = 
parse_property_name
 ( 
source
 )

1329 if 
source
 . 
match
 ( "}" ) :

1331 
prop
 = 
lookup_property
 ( 
prop_name
 , 
name
 , 
positive
 != 
negate
 , 
source
 )

1332 return 
make_property
 ( 
info
 , 
prop
 , 
in_set
 )

1333 elif 
ch
 and 
ch
 in "CLMNPSZ" :

1335 
prop
 = 
lookup_property
 ( None , 
ch
 , 
positive
 , 
source
 )

1336 return 
make_property
 ( 
info
 , 
prop
 , 
in_set
 )

1339 
source
 . 
pos
 = 
saved_pos

1340 
ch
 = "p" if 
positive
 else "P"

1341 return 
make_character
 ( 
info
 , 
ord
 ( 
ch
 ) , 
in_set
 ) 
	}

1343 def 
	$parse_property_name
 ( 
source
 ) :

1345 
name
 = 
source
 . 
get_while
 ( 
PROPERTY_NAME_PART
 )

1346 
saved_pos
 = 
source
 . 
pos

1348 
ch
 = 
source
 . 
get
 ( )

1349 if 
ch
 and 
ch
 in ":=" :

1350 
prop_name
 = 
name

1351 
name
 = 
source
 . 
get_while
 ( 
ALNUM
 | 
set
 ( " &_-./" ) ) . 
strip
 ( )

1353 if 
name
 :

1355 
saved_pos
 = 
source
 . 
pos

1358 
prop_name
 , 
name
 = None , 
prop_name

1360 
prop_name
 = None

1362 
source
 . 
pos
 = 
saved_pos

1363 return 
prop_name
 , 
name
 
	}

1365 def 
	$parse_set
 ( 
source
 , 
info
 ) :

1367 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

1369 
saved_ignore
 = 
source
 . 
ignore_space

1370 
source
 . 
ignore_space
 = False

1372 
negate
 = 
source
 . 
match
 ( "^" )

1374 if 
version
 == 
VERSION0
 :

1375 
item
 = 
parse_set_imp_union
 ( 
source
 , 
info
 )

1377 
item
 = 
parse_set_union
 ( 
source
 , 
info
 )

1379 if not 
source
 . 
match
 ( "]" ) :

1380 raise 
error
 ( "missing ]" , 
source
 . 
string
 , 
source
 . 
pos
 )

1382 
source
 . 
ignore_space
 = 
saved_ignore

1384 if 
negate
 :

1385 
item
 = 
item
 . 
with_flags
 ( 
positive
 = not 
item
 . 
positive
 )

1387 
item
 = 
item
 . 
with_flags
 ( 
case_flags
 = 
make_case_flags
 ( 
info
 ) )

1389 return 
item
 
	}

1391 def 
	$parse_set_union
 ( 
source
 , 
info
 ) :

1393 
items
 = [ 
parse_set_symm_diff
 ( 
source
 , 
info
 ) ]

1394 while 
source
 . 
match
 ( "||" ) :

1395 
items
 . 
append
 ( 
parse_set_symm_diff
 ( 
source
 , 
info
 ) )

1397 if 
len
 ( 
items
 ) == 1 :

1398 return 
items
 [ 0 ]

1399 return 
SetUnion
 ( 
info
 , 
items
 ) 
	}

1401 def 
	$parse_set_symm_diff
 ( 
source
 , 
info
 ) :

1403 
items
 = [ 
parse_set_inter
 ( 
source
 , 
info
 ) ]

1404 while 
source
 . 
match
 ( "~~" ) :

1405 
items
 . 
append
 ( 
parse_set_inter
 ( 
source
 , 
info
 ) )

1407 if 
len
 ( 
items
 ) == 1 :

1408 return 
items
 [ 0 ]

1409 return 
SetSymDiff
 ( 
info
 , 
items
 ) 
	}

1411 def 
	$parse_set_inter
 ( 
source
 , 
info
 ) :

1413 
items
 = [ 
parse_set_diff
 ( 
source
 , 
info
 ) ]

1414 while 
source
 . 
match
 ( "&&" ) :

1415 
items
 . 
append
 ( 
parse_set_diff
 ( 
source
 , 
info
 ) )

1417 if 
len
 ( 
items
 ) == 1 :

1418 return 
items
 [ 0 ]

1419 return 
SetInter
 ( 
info
 , 
items
 ) 
	}

1421 def 
	$parse_set_diff
 ( 
source
 , 
info
 ) :

1423 
items
 = [ 
parse_set_imp_union
 ( 
source
 , 
info
 ) ]

1424 while 
source
 . 
match
 ( "--" ) :

1425 
items
 . 
append
 ( 
parse_set_imp_union
 ( 
source
 , 
info
 ) )

1427 if 
len
 ( 
items
 ) == 1 :

1428 return 
items
 [ 0 ]

1429 return 
SetDiff
 ( 
info
 , 
items
 ) 
	}

1431 def 
	$parse_set_imp_union
 ( 
source
 , 
info
 ) :

1433 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

1435 
items
 = [ 
parse_set_member
 ( 
source
 , 
info
 ) ]

1437 
saved_pos
 = 
source
 . 
pos

1438 if 
source
 . 
match
 ( "]" ) :

1440 
source
 . 
pos
 = 
saved_pos

1443 if 
version
 == 
VERSION1
 and 
any
 ( 
source
 . 
match
 ( 
op
 ) for 
op
 in 
SET_OPS
 ) :

1445 
source
 . 
pos
 = 
saved_pos

1448 
items
 . 
append
 ( 
parse_set_member
 ( 
source
 , 
info
 ) )

1450 if 
len
 ( 
items
 ) == 1 :

1451 return 
items
 [ 0 ]

1452 return 
SetUnion
 ( 
info
 , 
items
 ) 
	}

1454 def 
	$parse_set_member
 ( 
source
 , 
info
 ) :

1457 
start
 = 
parse_set_item
 ( 
source
 , 
info
 )

1458 
saved_pos1
 = 
source
 . 
pos

1459 if ( not 
isinstance
 ( 
start
 , 
Character
 ) or not 
start
 . 
positive
 or not

1460 
source
 . 
match
 ( "-" ) ) :

1462 return 
start

1464 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

1467 
saved_pos2
 = 
source
 . 
pos

1468 if 
version
 == 
VERSION1
 and 
source
 . 
match
 ( "-" ) :

1471 
source
 . 
pos
 = 
saved_pos1

1472 return 
start

1474 if 
source
 . 
match
 ( "]" ) :

1477 
source
 . 
pos
 = 
saved_pos2

1478 return 
SetUnion
 ( 
info
 , [ 
start
 , 
Character
 ( 
ord
 ( "-" ) ) ] )

1481 
end
 = 
parse_set_item
 ( 
source
 , 
info
 )

1482 if not 
isinstance
 ( 
end
 , 
Character
 ) or not 
end
 . 
positive
 :

1484 return 
SetUnion
 ( 
info
 , [ 
start
 , 
Character
 ( 
ord
 ( "-" ) ) , 
end
 ] )

1487 if 
start
 . 
value
 > 
end
 . 
value
 :

1488 raise 
error
 ( "bad character range" , 
source
 . 
string
 , 
source
 . 
pos
 )

1490 if 
start
 . 
value
 == 
end
 . 
value
 :

1491 return 
start

1493 return 
Range
 ( 
start
 . 
value
 , 
end
 . 
value
 ) 
	}

1495 def 
	$parse_set_item
 ( 
source
 , 
info
 ) :

1497 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

1499 if 
source
 . 
match
 ( "\\" ) :

1501 return 
parse_escape
 ( 
source
 , 
info
 , True )

1503 
saved_pos
 = 
source
 . 
pos

1504 if 
source
 . 
match
 ( "[:" ) :

1507 return 
parse_posix_class
 ( 
source
 , 
info
 )

1508 except 
ParseError
 :

1510 
source
 . 
pos
 = 
saved_pos

1512 if 
version
 == 
VERSION1
 and 
source
 . 
match
 ( "[" ) :

1516 
negate
 = 
source
 . 
match
 ( "^" )

1517 
item
 = 
parse_set_union
 ( 
source
 , 
info
 )

1519 if not 
source
 . 
match
 ( "]" ) :

1520 raise 
error
 ( "missing ]" , 
source
 . 
string
 , 
source
 . 
pos
 )

1522 if 
negate
 :

1523 
item
 = 
item
 . 
with_flags
 ( 
positive
 = not 
item
 . 
positive
 )

1525 return 
item

1527 
ch
 = 
source
 . 
get
 ( )

1528 if not 
ch
 :

1529 raise 
error
 ( "unterminated character set" , 
source
 . 
string
 , 
source
 . 
pos
 )

1531 return 
Character
 ( 
ord
 ( 
ch
 ) ) 
	}

1533 def 
	$parse_posix_class
 ( 
source
 , 
info
 ) :

1535 
negate
 = 
source
 . 
match
 ( "^" )

1536 
prop_name
 , 
name
 = 
parse_property_name
 ( 
source
 )

1537 if not 
source
 . 
match
 ( ":]" ) :

1538 raise 
ParseError
 ( )

1540 return 
lookup_property
 ( 
prop_name
 , 
name
 , not 
negate
 , 
source
 , 
posix
 = True ) 
	}

1542 def 
	$float_to_rational
 ( 
flt
 ) :

1544 
int_part
 = 
int
 ( 
flt
 )

1545 
error
 = 
flt
 - 
int_part

1546 if 
abs
 ( 
error
 ) < 0.0001 :

1547 return 
int_part
 , 1

1549 
den
 , 
num
 = 
float_to_rational
 ( 1.0 / 
error
 )

1551 return 
int_part
 * 
den
 + 
num
 , 
den
 
	}

1553 def 
	$numeric_to_rational
 ( 
numeric
 ) :

1555 if 
numeric
 [ : 1 ] == "-" :

1556 
sign
 , 
numeric
 = 
numeric
 [ 0 ] , 
numeric
 [ 1 : ]

1558 
sign
 = ""

1560 
parts
 = 
numeric
 . 
split
 ( "/" )

1561 if 
len
 ( 
parts
 ) == 2 :

1562 
num
 , 
den
 = 
float_to_rational
 ( 
float
 ( 
parts
 [ 0 ] ) / 
float
 ( 
parts
 [ 1 ] ) )

1563 elif 
len
 ( 
parts
 ) == 1 :

1564 
num
 , 
den
 = 
float_to_rational
 ( 
float
 ( 
parts
 [ 0 ] ) )

1566 raise 
ValueError
 ( )

1568 
result
 = "{}{}/{}" . 
format
 ( 
sign
 , 
num
 , 
den
 )

1569 if 
result
 . 
endswith
 ( "/1" ) :

1570 return 
result
 [ : - 2 ]

1572 return 
result
 
	}

1574 def 
	$standardise_name
 ( 
name
 ) :

1577 return 
numeric_to_rational
 ( "" . 
join
 ( 
name
 ) )

1578 except ( 
ValueError
 , 
ZeroDivisionError
 ) :

1579 return "" . 
join
 ( 
ch
 for 
ch
 in 
name
 if 
ch
 not in "_- " ) . 
upper
 ( ) 
	}

1581 
_POSIX_CLASSES
 = 
set
 ( 'ALNUM DIGIT PUNCT XDIGIT' . 
split
 ( ) )

1583 
_BINARY_VALUES
 = 
set
 ( 'YES Y NO N TRUE T FALSE F' . 
split
 ( ) )

1585 def 
	$lookup_property
 ( 
property
 , 
value
 , 
positive
 , 
source
 = None , 
posix
 = False ) :

1588 
property
 = 
standardise_name
 ( 
property
 ) if 
property
 else None

1589 
value
 = 
standardise_name
 ( 
value
 )

1591 if ( 
property
 , 
value
 ) == ( "GENERALCATEGORY" , "ASSIGNED" ) :

1592 
property
 , 
value
 , 
positive
 = "GENERALCATEGORY" , "UNASSIGNED" , not 
positive

1594 if 
posix
 and not 
property
 and 
value
 . 
upper
 ( ) in 
_POSIX_CLASSES
 :

1595 
value
 = 'POSIX' + 
value

1597 if 
property
 :

1599 
prop
 = 
PROPERTIES
 . 
get
 ( 
property
 )

1600 if not 
prop
 :

1601 if not 
source
 :

1602 raise 
error
 ( "unknown property" )

1604 raise 
error
 ( "unknown property" , 
source
 . 
string
 , 
source
 . 
pos
 )

1606 
prop_id
 , 
value_dict
 = 
prop

1607 
val_id
 = 
value_dict
 . 
get
 ( 
value
 )

1608 if 
val_id
 is None :

1609 if not 
source
 :

1610 raise 
error
 ( "unknown property value" )

1612 raise 
error
 ( "unknown property value" , 
source
 . 
string
 , 
source
 . 
pos
 )

1614 return 
Property
 ( ( 
prop_id
 << 16 ) | 
val_id
 , 
positive
 )

1618 for 
property
 in ( "GC" , "SCRIPT" , "BLOCK" ) :

1619 
prop_id
 , 
value_dict
 = 
PROPERTIES
 . 
get
 ( 
property
 )

1620 
val_id
 = 
value_dict
 . 
get
 ( 
value
 )

1621 if 
val_id
 is not None :

1622 return 
Property
 ( ( 
prop_id
 << 16 ) | 
val_id
 , 
positive
 )

1625 
prop
 = 
PROPERTIES
 . 
get
 ( 
value
 )

1626 if 
prop
 :

1627 
prop_id
 , 
value_dict
 = 
prop

1628 if 
set
 ( 
value_dict
 ) == 
_BINARY_VALUES
 :

1629 return 
Property
 ( ( 
prop_id
 << 16 ) | 1 , 
positive
 )

1631 return 
Property
 ( 
prop_id
 << 16 , not 
positive
 )

1634 if 
value
 . 
startswith
 ( "IS" ) :

1635 
prop
 = 
PROPERTIES
 . 
get
 ( 
value
 [ 2 : ] )

1636 if 
prop
 :

1637 
prop_id
 , 
value_dict
 = 
prop

1638 if "YES" in 
value_dict
 :

1639 return 
Property
 ( ( 
prop_id
 << 16 ) | 1 , 
positive
 )

1642 for 
prefix
 , 
property
 in ( ( "IS" , "SCRIPT" ) , ( "IN" , "BLOCK" ) ) :

1643 if 
value
 . 
startswith
 ( 
prefix
 ) :

1644 
prop_id
 , 
value_dict
 = 
PROPERTIES
 . 
get
 ( 
property
 )

1645 
val_id
 = 
value_dict
 . 
get
 ( 
value
 [ 2 : ] )

1646 if 
val_id
 is not None :

1647 return 
Property
 ( ( 
prop_id
 << 16 ) | 
val_id
 , 
positive
 )

1650 if not 
source
 :

1651 raise 
error
 ( "unknown property" )

1653 raise 
error
 ( "unknown property" , 
source
 . 
string
 , 
source
 . 
pos
 ) 
	}

1655 def 
	$_compile_replacement
 ( 
source
 , 
pattern
 , 
is_unicode
 ) :

1657 
ch
 = 
source
 . 
get
 ( )

1658 if 
ch
 in 
ALPHA
 :

1660 
value
 = 
CHARACTER_ESCAPES
 . 
get
 ( 
ch
 )

1661 if 
value
 :

1662 return False , [ 
ord
 ( 
value
 ) ]

1664 if 
ch
 in 
HEX_ESCAPES
 and ( 
ch
 == "x" or 
is_unicode
 ) :

1666 return False , [ 
parse_repl_hex_escape
 ( 
source
 , 
HEX_ESCAPES
 [ 
ch
 ] , 
ch
 ) ]

1668 if 
ch
 == "g" :

1670 return True , [ 
compile_repl_group
 ( 
source
 , 
pattern
 ) ]

1672 if 
ch
 == "N" and 
is_unicode
 :

1674 
value
 = 
parse_repl_named_char
 ( 
source
 )

1675 if 
value
 is not None :

1676 return False , [ 
value
 ]

1678 return False , [ 
ord
 ( "\\" ) , 
ord
 ( 
ch
 ) ]

1680 if 
isinstance
 ( 
source
 . 
sep
 , 
bytes
 ) :

1681 
octal_mask
 = 0xFF

1683 
octal_mask
 = 0x1FF

1685 if 
ch
 == "0" :

1687 
digits
 = 
ch

1688 while 
len
 ( 
digits
 ) < 3 :

1689 
saved_pos
 = 
source
 . 
pos

1690 
ch
 = 
source
 . 
get
 ( )

1691 if 
ch
 not in 
OCT_DIGITS
 :

1692 
source
 . 
pos
 = 
saved_pos

1694 
digits
 += 
ch

1696 return False , [ 
int
 ( 
digits
 , 8 ) & 
octal_mask
 ]

1698 if 
ch
 in 
DIGITS
 :

1701 
digits
 = 
ch

1702 
saved_pos
 = 
source
 . 
pos

1703 
ch
 = 
source
 . 
get
 ( )

1704 if 
ch
 in 
DIGITS
 :

1705 
digits
 += 
ch

1706 
saved_pos
 = 
source
 . 
pos

1707 
ch
 = 
source
 . 
get
 ( )

1708 if 
ch
 and 
is_octal
 ( 
digits
 + 
ch
 ) :

1710 return False , [ 
int
 ( 
digits
 + 
ch
 , 8 ) & 
octal_mask
 ]

1713 
source
 . 
pos
 = 
saved_pos

1714 return True , [ 
int
 ( 
digits
 ) ]

1716 if 
ch
 == "\\" :

1718 return False , [ 
ord
 ( "\\" ) ]

1720 if not 
ch
 :

1722 raise 
error
 ( "bad escape (end of pattern)" , 
source
 . 
string
 , 
source
 . 
pos
 )

1725 return False , [ 
ord
 ( "\\" ) , 
ord
 ( 
ch
 ) ] 
	}

1727 def 
	$parse_repl_hex_escape
 ( 
source
 , 
expected_len
 , 
type
 ) :

1729 
digits
 = [ ]

1730 for 
i
 in 
range
 ( 
expected_len
 ) :

1731 
ch
 = 
source
 . 
get
 ( )

1732 if 
ch
 not in 
HEX_DIGITS
 :

1733 raise 
error
 ( "incomplete escape \\%s%s" % ( 
type
 , '' . 
join
 ( 
digits
 ) ) ,

1734 
source
 . 
string
 , 
source
 . 
pos
 )

1735 
digits
 . 
append
 ( 
ch
 )

1737 return 
int
 ( "" . 
join
 ( 
digits
 ) , 16 ) 
	}

1739 def 
	$parse_repl_named_char
 ( 
source
 ) :

1741 
saved_pos
 = 
source
 . 
pos

1742 if 
source
 . 
match
 ( "{" ) :

1743 
name
 = 
source
 . 
get_while
 ( 
ALPHA
 | 
set
 ( " " ) )

1745 if 
source
 . 
match
 ( "}" ) :

1747 
value
 = 
unicodedata
 . 
lookup
 ( 
name
 )

1748 return 
ord
 ( 
value
 )

1749 except 
KeyError
 :

1750 raise 
error
 ( "undefined character name" , 
source
 . 
string
 ,

1751 
source
 . 
pos
 )

1753 
source
 . 
pos
 = 
saved_pos

1754 return None 
	}

1756 def 
	$compile_repl_group
 ( 
source
 , 
pattern
 ) :

1758 
source
 . 
expect
 ( "<" )

1759 
name
 = 
parse_name
 ( 
source
 , True , True )

1761 
source
 . 
expect
 ( ">" )

1762 if 
name
 . 
isdigit
 ( ) :

1763 
index
 = 
int
 ( 
name
 )

1764 if not 0 <= 
index
 <= 
pattern
 . 
groups
 :

1765 raise 
error
 ( "invalid group reference" , 
source
 . 
string
 , 
source
 . 
pos
 )

1767 return 
index

1770 return 
pattern
 . 
groupindex
 [ 
name
 ]

1771 except 
KeyError
 :

1772 raise 
IndexError
 ( "unknown group" ) 
	}

1777 
INDENT
 = "  "

1778 
POSITIVE_OP
 = 0x1

1779 
ZEROWIDTH_OP
 = 0x2

1780 
FUZZY_OP
 = 0x4

1781 
REVERSE_OP
 = 0x8

1782 
REQUIRED_OP
 = 0x10

1784 
POS_TEXT
 = { False : "NON-MATCH" , True : "MATCH" }

1785 
CASE_TEXT
 = { 
NOCASE
 : "" , 
IGNORECASE
 : " SIMPLE_IGNORE_CASE" , 
FULLCASE
 : "" ,

1786 
FULLIGNORECASE
 : " FULL_IGNORE_CASE" }

1788 def 
	$make_sequence
 ( 
items
 ) :

1789 if 
len
 ( 
items
 ) == 1 :

1790 return 
items
 [ 0 ]

1791 return 
Sequence
 ( 
items
 ) 
	}

1794 class 
	cRegexBase
 :

1795 def 
	$__init__
 ( 
self
 ) :

1796 
self
 . 
_key
 = 
self
 . 
__class__
 
	}

1798 def 
	$with_flags
 ( 
self
 , 
positive
 = None , 
case_flags
 = None , 
zerowidth
 = None ) :

1799 if 
positive
 is None :

1800 
positive
 = 
self
 . 
positive

1802 
positive
 = 
bool
 ( 
positive
 )

1803 if 
case_flags
 is None :

1804 
case_flags
 = 
self
 . 
case_flags

1806 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 & 
CASE_FLAGS
 ]

1807 if 
zerowidth
 is None :

1808 
zerowidth
 = 
self
 . 
zerowidth

1810 
zerowidth
 = 
bool
 ( 
zerowidth
 )

1812 if ( 
positive
 == 
self
 . 
positive
 and 
case_flags
 == 
self
 . 
case_flags
 and

1813 
zerowidth
 == 
self
 . 
zerowidth
 ) :

1814 return 
self

1816 return 
self
 . 
rebuild
 ( 
positive
 , 
case_flags
 , 
zerowidth
 ) 
	}

1818 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

1819 pass 
	}

1821 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

1822 return 
self
 
	}

1824 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

1825 return 
self
 
	}

1827 def 
	$remove_captures
 ( 
self
 ) :

1828 return 
self
 
	}

1830 def 
	$is_atomic
 ( 
self
 ) :

1831 return True 
	}

1833 def 
	$can_be_affix
 ( 
self
 ) :

1834 return True 
	}

1836 def 
	$contains_group
 ( 
self
 ) :

1837 return False 
	}

1839 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

1840 raise 
_FirstSetError
 ( ) 
	}

1842 def 
	$has_simple_start
 ( 
self
 ) :

1843 return False 
	}

1845 def 
	$compile
 ( 
self
 , 
reverse
 = False , 
fuzzy
 = False ) :

1846 return 
self
 . 
_compile
 ( 
reverse
 , 
fuzzy
 ) 
	}

1848 def 
	$is_empty
 ( 
self
 ) :

1849 return False 
	}

1851 def 
	$__hash__
 ( 
self
 ) :

1852 return 
hash
 ( 
self
 . 
_key
 ) 
	}

1854 def 
	$__eq__
 ( 
self
 , 
other
 ) :

1855 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
_key
 == 
other
 . 
_key
 
	}

1857 def 
	$__ne__
 ( 
self
 , 
other
 ) :

1858 return not 
self
 . 
__eq__
 ( 
other
 ) 
	}

1860 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

1861 return 
self
 . 
max_width
 ( ) , None 
	}

1864 class 
	cZeroWidthBase
 ( 
RegexBase
 ) :

1865 def 
	$__init__
 ( 
self
 , 
positive
 = True ) :

1866 
RegexBase
 . 
__init__
 ( 
self
 )

1867 
self
 . 
positive
 = 
bool
 ( 
positive
 )

1869 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
positive
 
	}

1871 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

1872 return 
set
 ( [ None ] ) 
	}

1874 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

1875 
flags
 = 0

1876 if 
self
 . 
positive
 :

1877 
flags
 |= 
POSITIVE_OP

1878 if 
fuzzy
 :

1879 
flags
 |= 
FUZZY_OP

1880 if 
reverse
 :

1881 
flags
 |= 
REVERSE_OP

1882 return [ ( 
self
 . 
_opcode
 , 
flags
 ) ] 
	}

1884 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

1885 
print
 ( "{}{} {}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
_op_name
 ,

1886 
POS_TEXT
 [ 
self
 . 
positive
 ] ) ) 
	}

1888 def 
	$max_width
 ( 
self
 ) :

1889 return 0 
	}

1891 class 
	cAny
 ( 
RegexBase
 ) :

1892 
_opcode
 = { False : 
OP
 . 
ANY
 , True : 
OP
 . 
ANY_REV
 }

1893 
_op_name
 = "ANY"

1895 def 
	$has_simple_start
 ( 
self
 ) :

1896 return True 
	}

1898 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

1899 
flags
 = 0

1900 if 
fuzzy
 :

1901 
flags
 |= 
FUZZY_OP

1902 return [ ( 
self
 . 
_opcode
 [ 
reverse
 ] , 
flags
 ) ] 
	}

1904 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

1905 
print
 ( "{}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
_op_name
 ) ) 
	}

1907 def 
	$max_width
 ( 
self
 ) :

1908 return 1 
	}

1910 class 
	cAnyAll
 ( 
Any
 ) :

1911 
_opcode
 = { False : 
OP
 . 
ANY_ALL
 , True : 
OP
 . 
ANY_ALL_REV
 }

1912 
_op_name
 = "ANY_ALL"

1914 class 
	cAnyU
 ( 
Any
 ) :

1915 
_opcode
 = { False : 
OP
 . 
ANY_U
 , True : 
OP
 . 
ANY_U_REV
 }

1916 
_op_name
 = "ANY_U"

1918 class 
	cAtomic
 ( 
RegexBase
 ) :

1919 def 
	$__init__
 ( 
self
 , 
subpattern
 ) :

1920 
RegexBase
 . 
__init__
 ( 
self
 )

1921 
self
 . 
subpattern
 = 
subpattern
 
	}

1923 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

1924 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

1926 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

1927 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
optimise
 ( 
info
 , 
reverse
 )

1929 if 
self
 . 
subpattern
 . 
is_empty
 ( ) :

1930 return 
self
 . 
subpattern

1931 return 
self
 
	}

1933 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

1934 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

1935 return 
self
 
	}

1937 def 
	$remove_captures
 ( 
self
 ) :

1938 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
remove_captures
 ( )

1939 return 
self
 
	}

1941 def 
	$can_be_affix
 ( 
self
 ) :

1942 return 
self
 . 
subpattern
 . 
can_be_affix
 ( ) 
	}

1944 def 
	$contains_group
 ( 
self
 ) :

1945 return 
self
 . 
subpattern
 . 
contains_group
 ( ) 
	}

1947 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

1948 return 
self
 . 
subpattern
 . 
get_firstset
 ( 
reverse
 ) 
	}

1950 def 
	$has_simple_start
 ( 
self
 ) :

1951 return 
self
 . 
subpattern
 . 
has_simple_start
 ( ) 
	}

1953 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

1954 return ( [ ( 
OP
 . 
ATOMIC
 , ) ] + 
self
 . 
subpattern
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) +

1955 [ ( 
OP
 . 
END
 , ) ] ) 
	}

1957 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

1958 
print
 ( "{}ATOMIC" . 
format
 ( 
INDENT
 * 
indent
 ) )

1959 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

1961 def 
	$is_empty
 ( 
self
 ) :

1962 return 
self
 . 
subpattern
 . 
is_empty
 ( ) 
	}

1964 def 
	$__eq__
 ( 
self
 , 
other
 ) :

1965 return ( 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
subpattern
 ==

1966 
other
 . 
subpattern
 ) 
	}

1968 def 
	$max_width
 ( 
self
 ) :

1969 return 
self
 . 
subpattern
 . 
max_width
 ( ) 
	}

1971 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

1972 return 
self
 . 
subpattern
 . 
get_required_string
 ( 
reverse
 ) 
	}

1974 class 
	cBoundary
 ( 
ZeroWidthBase
 ) :

1975 
_opcode
 = 
OP
 . 
BOUNDARY

1976 
_op_name
 = "BOUNDARY"

1978 class 
	cBranch
 ( 
RegexBase
 ) :

1979 def 
	$__init__
 ( 
self
 , 
branches
 ) :

1980 
RegexBase
 . 
__init__
 ( 
self
 )

1981 
self
 . 
branches
 = 
branches
 
	}

1983 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

1984 for 
b
 in 
self
 . 
branches
 :

1985 
b
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

1987 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

1989 
branches
 = 
Branch
 . 
_flatten_branches
 ( 
info
 , 
reverse
 , 
self
 . 
branches
 )

1992 if 
reverse
 :

1993 
suffix
 , 
branches
 = 
Branch
 . 
_split_common_suffix
 ( 
info
 , 
branches
 )

1994 
prefix
 = [ ]

1996 
prefix
 , 
branches
 = 
Branch
 . 
_split_common_prefix
 ( 
info
 , 
branches
 )

1997 
suffix
 = [ ]

2000 
branches
 = 
Branch
 . 
_reduce_to_set
 ( 
info
 , 
reverse
 , 
branches
 )

2002 if 
len
 ( 
branches
 ) > 1 :

2003 
sequence
 = [ 
Branch
 ( 
branches
 ) ]

2005 if not 
prefix
 or not 
suffix
 :

2007 
firstset
 = 
self
 . 
_add_precheck
 ( 
info
 , 
reverse
 , 
branches
 )

2009 if 
firstset
 :

2010 if 
reverse
 :

2011 
sequence
 . 
append
 ( 
firstset
 )

2013 
sequence
 . 
insert
 ( 0 , 
firstset
 )

2015 
sequence
 = 
branches

2017 return 
make_sequence
 ( 
prefix
 + 
sequence
 + 
suffix
 ) 
	}

2019 def 
	$_add_precheck
 ( 
self
 , 
info
 , 
reverse
 , 
branches
 ) :

2020 
charset
 = 
set
 ( )

2021 
pos
 = - 1 if 
reverse
 else 0

2023 for 
branch
 in 
branches
 :

2024 if 
type
 ( 
branch
 ) is 
Literal
 and 
branch
 . 
case_flags
 == 
NOCASE
 :

2025 
charset
 . 
add
 ( 
branch
 . 
characters
 [ 
pos
 ] )

2029 if not 
charset
 :

2032 return 
_check_firstset
 ( 
info
 , 
reverse
 , [ 
Character
 ( 
c
 ) for 
c
 in 
charset
 ] ) 
	}

2034 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2035 
self
 . 
branches
 = [ 
b
 . 
pack_characters
 ( 
info
 ) for 
b
 in 
self
 . 
branches
 ]

2036 return 
self
 
	}

2038 def 
	$remove_captures
 ( 
self
 ) :

2039 
self
 . 
branches
 = [ 
b
 . 
remove_captures
 ( ) for 
b
 in 
self
 . 
branches
 ]

2040 return 
self
 
	}

2042 def 
	$is_atomic
 ( 
self
 ) :

2043 return 
all
 ( 
b
 . 
is_atomic
 ( ) for 
b
 in 
self
 . 
branches
 ) 
	}

2045 def 
	$can_be_affix
 ( 
self
 ) :

2046 return 
all
 ( 
b
 . 
can_be_affix
 ( ) for 
b
 in 
self
 . 
branches
 ) 
	}

2048 def 
	$contains_group
 ( 
self
 ) :

2049 return 
any
 ( 
b
 . 
contains_group
 ( ) for 
b
 in 
self
 . 
branches
 ) 
	}

2051 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

2052 
fs
 = 
set
 ( )

2053 for 
b
 in 
self
 . 
branches
 :

2054 
fs
 |= 
b
 . 
get_firstset
 ( 
reverse
 )

2056 return 
fs
 or 
set
 ( [ None ] ) 
	}

2058 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2059 
code
 = [ ( 
OP
 . 
BRANCH
 , ) ]

2060 for 
b
 in 
self
 . 
branches
 :

2061 
code
 . 
extend
 ( 
b
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) )

2062 
code
 . 
append
 ( ( 
OP
 . 
NEXT
 , ) )

2064 
code
 [ - 1 ] = ( 
OP
 . 
END
 , )

2066 return 
code
 
	}

2068 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2069 
print
 ( "{}BRANCH" . 
format
 ( 
INDENT
 * 
indent
 ) )

2070 
self
 . 
branches
 [ 0 ] . 
dump
 ( 
indent
 + 1 , 
reverse
 )

2071 for 
b
 in 
self
 . 
branches
 [ 1 : ] :

2072 
print
 ( "{}OR" . 
format
 ( 
INDENT
 * 
indent
 ) )

2073 
b
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

2075 @ 
	`staticmethod

2076 def 
	$_flatten_branches
 ( 
info
 , 
reverse
 , 
branches
 ) :

2078 
new_branches
 = [ ]

2079 for 
b
 in 
branches
 :

2080 
b
 = 
b
 . 
optimise
 ( 
info
 , 
reverse
 )

2081 if 
isinstance
 ( 
b
 , 
Branch
 ) :

2082 
new_branches
 . 
extend
 ( 
b
 . 
branches
 )

2084 
new_branches
 . 
append
 ( 
b
 )

2086 return 
new_branches
 
	}

2088 @ 
	`staticmethod

2089 def 
	$_split_common_prefix
 ( 
info
 , 
branches
 ) :

2092 
alternatives
 = [ ]

2093 for 
b
 in 
branches
 :

2094 if 
isinstance
 ( 
b
 , 
Sequence
 ) :

2095 
alternatives
 . 
append
 ( 
b
 . 
items
 )

2097 
alternatives
 . 
append
 ( [ 
b
 ] )

2100 
max_count
 = 
min
 ( 
len
 ( 
a
 ) for 
a
 in 
alternatives
 )

2103 
prefix
 = 
alternatives
 [ 0 ]

2104 
pos
 = 0

2105 
end_pos
 = 
max_count

2106 while 
pos
 < 
end_pos
 and 
prefix
 [ 
pos
 ] . 
can_be_affix
 ( ) and 
all
 ( 
a
 [ 
pos
 ] ==

2107 
prefix
 [ 
pos
 ] for 
a
 in 
alternatives
 ) :

2108 
pos
 += 1

2109 
count
 = 
pos

2111 if 
info
 . 
flags
 & 
UNICODE
 :

2114 
count
 = 
pos

2115 while 
count
 > 0 and not 
all
 ( 
Branch
 . 
_can_split
 ( 
a
 , 
count
 ) for 
a
 in

2116 
alternatives
 ) :

2117 
count
 -= 1

2120 if 
count
 == 0 :

2121 return [ ] , 
branches

2124 
new_branches
 = [ ]

2125 for 
a
 in 
alternatives
 :

2126 
new_branches
 . 
append
 ( 
make_sequence
 ( 
a
 [ 
count
 : ] ) )

2128 return 
prefix
 [ : 
count
 ] , 
new_branches
 
	}

2130 @ 
	`staticmethod

2131 def 
	$_split_common_suffix
 ( 
info
 , 
branches
 ) :

2134 
alternatives
 = [ ]

2135 for 
b
 in 
branches
 :

2136 if 
isinstance
 ( 
b
 , 
Sequence
 ) :

2137 
alternatives
 . 
append
 ( 
b
 . 
items
 )

2139 
alternatives
 . 
append
 ( [ 
b
 ] )

2142 
max_count
 = 
min
 ( 
len
 ( 
a
 ) for 
a
 in 
alternatives
 )

2145 
suffix
 = 
alternatives
 [ 0 ]

2146 
pos
 = - 1

2147 
end_pos
 = - 1 - 
max_count

2148 while 
pos
 > 
end_pos
 and 
suffix
 [ 
pos
 ] . 
can_be_affix
 ( ) and 
all
 ( 
a
 [ 
pos
 ] ==

2149 
suffix
 [ 
pos
 ] for 
a
 in 
alternatives
 ) :

2150 
pos
 -= 1

2151 
count
 = - 1 - 
pos

2153 if 
info
 . 
flags
 & 
UNICODE
 :

2156 while 
count
 > 0 and not 
all
 ( 
Branch
 . 
_can_split_rev
 ( 
a
 , 
count
 ) for 
a

2157 in 
alternatives
 ) :

2158 
count
 -= 1

2161 if 
count
 == 0 :

2162 return [ ] , 
branches

2165 
new_branches
 = [ ]

2166 for 
a
 in 
alternatives
 :

2167 
new_branches
 . 
append
 ( 
make_sequence
 ( 
a
 [ : - 
count
 ] ) )

2169 return 
suffix
 [ - 
count
 : ] , 
new_branches
 
	}

2171 @ 
	`staticmethod

2172 def 
	$_can_split
 ( 
items
 , 
count
 ) :

2174 if not 
Branch
 . 
_is_full_case
 ( 
items
 , 
count
 - 1 ) :

2177 if not 
Branch
 . 
_is_full_case
 ( 
items
 , 
count
 ) :

2181 if 
Branch
 . 
_is_folded
 ( 
items
 [ 
count
 - 1 : 
count
 + 1 ] ) :

2185 if ( 
Branch
 . 
_is_full_case
 ( 
items
 , 
count
 + 2 ) and

2186 
Branch
 . 
_is_folded
 ( 
items
 [ 
count
 - 1 : 
count
 + 2 ] ) ) :

2190 if ( 
Branch
 . 
_is_full_case
 ( 
items
 , 
count
 - 2 ) and

2191 
Branch
 . 
_is_folded
 ( 
items
 [ 
count
 - 2 : 
count
 + 1 ] ) ) :

2194 return True 
	}

2196 @ 
	`staticmethod

2197 def 
	$_can_split_rev
 ( 
items
 , 
count
 ) :

2198 
end
 = 
len
 ( 
items
 )

2201 if not 
Branch
 . 
_is_full_case
 ( 
items
 , 
end
 - 
count
 ) :

2204 if not 
Branch
 . 
_is_full_case
 ( 
items
 , 
end
 - 
count
 - 1 ) :

2208 if 
Branch
 . 
_is_folded
 ( 
items
 [ 
end
 - 
count
 - 1 : 
end
 - 
count
 + 1 ] ) :

2212 if ( 
Branch
 . 
_is_full_case
 ( 
items
 , 
end
 - 
count
 + 2 ) and

2213 
Branch
 . 
_is_folded
 ( 
items
 [ 
end
 - 
count
 - 1 : 
end
 - 
count
 + 2 ] ) ) :

2217 if ( 
Branch
 . 
_is_full_case
 ( 
items
 , 
end
 - 
count
 - 2 ) and

2218 
Branch
 . 
_is_folded
 ( 
items
 [ 
end
 - 
count
 - 2 : 
end
 - 
count
 + 1 ] ) ) :

2221 return True 
	}

2223 @ 
	`staticmethod

2224 def 
	$_merge_common_prefixes
 ( 
info
 , 
reverse
 , 
branches
 ) :

2228 
prefixed
 = 
defaultdict
 ( 
list
 )

2229 
order
 = { }

2230 
new_branches
 = [ ]

2231 for 
b
 in 
branches
 :

2232 if 
Branch
 . 
_is_simple_character
 ( 
b
 ) :

2234 
prefixed
 [ 
b
 . 
value
 ] . 
append
 ( [ 
b
 ] )

2235 
order
 . 
setdefault
 ( 
b
 . 
value
 , 
len
 ( 
order
 ) )

2236 elif ( 
isinstance
 ( 
b
 , 
Sequence
 ) and 
b
 . 
items
 and

2237 
Branch
 . 
_is_simple_character
 ( 
b
 . 
items
 [ 0 ] ) ) :

2239 
prefixed
 [ 
b
 . 
items
 [ 0 ] . 
value
 ] . 
append
 ( 
b
 . 
items
 )

2240 
order
 . 
setdefault
 ( 
b
 . 
items
 [ 0 ] . 
value
 , 
len
 ( 
order
 ) )

2242 
Branch
 . 
_flush_char_prefix
 ( 
info
 , 
reverse
 , 
prefixed
 , 
order
 ,

2243 
new_branches
 )

2245 
new_branches
 . 
append
 ( 
b
 )

2247 
Branch
 . 
_flush_char_prefix
 ( 
info
 , 
prefixed
 , 
order
 , 
new_branches
 )

2249 return 
new_branches
 
	}

2251 @ 
	`staticmethod

2252 def 
	$_is_simple_character
 ( 
c
 ) :

2253 return 
isinstance
 ( 
c
 , 
Character
 ) and 
c
 . 
positive
 and not 
c
 . 
case_flags
 
	}

2255 @ 
	`staticmethod

2256 def 
	$_reduce_to_set
 ( 
info
 , 
reverse
 , 
branches
 ) :

2258 
new_branches
 = [ ]

2259 
items
 = 
set
 ( )

2260 
case_flags
 = 
NOCASE

2261 for 
b
 in 
branches
 :

2262 if 
isinstance
 ( 
b
 , ( 
Character
 , 
Property
 , 
SetBase
 ) ) :

2264 if 
b
 . 
case_flags
 != 
case_flags
 :

2266 
Branch
 . 
_flush_set_members
 ( 
info
 , 
reverse
 , 
items
 , 
case_flags
 ,

2267 
new_branches
 )

2269 
case_flags
 = 
b
 . 
case_flags

2271 
items
 . 
add
 ( 
b
 . 
with_flags
 ( 
case_flags
 = 
NOCASE
 ) )

2273 
Branch
 . 
_flush_set_members
 ( 
info
 , 
reverse
 , 
items
 , 
case_flags
 ,

2274 
new_branches
 )

2276 
new_branches
 . 
append
 ( 
b
 )

2278 
Branch
 . 
_flush_set_members
 ( 
info
 , 
reverse
 , 
items
 , 
case_flags
 ,

2279 
new_branches
 )

2281 return 
new_branches
 
	}

2283 @ 
	`staticmethod

2284 def 
	$_flush_char_prefix
 ( 
info
 , 
reverse
 , 
prefixed
 , 
order
 , 
new_branches
 ) :

2286 if not 
prefixed
 :

2289 for 
value
 , 
branches
 in 
sorted
 ( 
prefixed
 . 
items
 ( ) , 
key
 = lambda 
pair
 :

2290 
order
 [ 
pair
 [ 0 ] ] ) :

2291 if 
len
 ( 
branches
 ) == 1 :

2292 
new_branches
 . 
append
 ( 
make_sequence
 ( 
branches
 [ 0 ] ) )

2294 
subbranches
 = [ ]

2295 
optional
 = False

2296 for 
b
 in 
branches
 :

2297 if 
len
 ( 
b
 ) > 1 :

2298 
subbranches
 . 
append
 ( 
make_sequence
 ( 
b
 [ 1 : ] ) )

2299 elif not 
optional
 :

2300 
subbranches
 . 
append
 ( 
Sequence
 ( ) )

2301 
optional
 = True

2303 
sequence
 = 
Sequence
 ( [ 
Character
 ( 
value
 ) , 
Branch
 ( 
subbranches
 ) ] )

2304 
new_branches
 . 
append
 ( 
sequence
 . 
optimise
 ( 
info
 , 
reverse
 ) )

2306 
prefixed
 . 
clear
 ( )

2307 
order
 . 
clear
 ( ) 
	}

2309 @ 
	`staticmethod

2310 def 
	$_flush_set_members
 ( 
info
 , 
reverse
 , 
items
 , 
case_flags
 , 
new_branches
 ) :

2312 if not 
items
 :

2315 if 
len
 ( 
items
 ) == 1 :

2316 
item
 = 
list
 ( 
items
 ) [ 0 ]

2318 
item
 = 
SetUnion
 ( 
info
 , 
list
 ( 
items
 ) ) . 
optimise
 ( 
info
 , 
reverse
 )

2320 
new_branches
 . 
append
 ( 
item
 . 
with_flags
 ( 
case_flags
 = 
case_flags
 ) )

2322 
items
 . 
clear
 ( ) 
	}

2324 @ 
	`staticmethod

2325 def 
	$_is_full_case
 ( 
items
 , 
i
 ) :

2326 if not 0 <= 
i
 < 
len
 ( 
items
 ) :

2329 
item
 = 
items
 [ 
i
 ]

2330 return ( 
isinstance
 ( 
item
 , 
Character
 ) and 
item
 . 
positive
 and

2331 ( 
item
 . 
case_flags
 & 
FULLIGNORECASE
 ) == 
FULLIGNORECASE
 ) 
	}

2333 @ 
	`staticmethod

2334 def 
	$_is_folded
 ( 
items
 ) :

2335 if 
len
 ( 
items
 ) < 2 :

2338 for 
i
 in 
items
 :

2339 if ( not 
isinstance
 ( 
i
 , 
Character
 ) or not 
i
 . 
positive
 or not

2340 
i
 . 
case_flags
 ) :

2343 
folded
 = "" . 
join
 ( 
chr
 ( 
i
 . 
value
 ) for 
i
 in 
items
 )

2344 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
folded
 )

2347 
expanding_chars
 = 
_regex
 . 
get_expand_on_folding
 ( )

2349 for 
c
 in 
expanding_chars
 :

2350 if 
folded
 == 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
c
 ) :

2353 return False 
	}

2355 def 
	$is_empty
 ( 
self
 ) :

2356 return 
all
 ( 
b
 . 
is_empty
 ( ) for 
b
 in 
self
 . 
branches
 ) 
	}

2358 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2359 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
branches
 == 
other
 . 
branches
 
	}

2361 def 
	$max_width
 ( 
self
 ) :

2362 return 
max
 ( 
b
 . 
max_width
 ( ) for 
b
 in 
self
 . 
branches
 ) 
	}

2364 class 
	cCallGroup
 ( 
RegexBase
 ) :

2365 def 
	$__init__
 ( 
self
 , 
info
 , 
group
 , 
position
 ) :

2366 
RegexBase
 . 
__init__
 ( 
self
 )

2367 
self
 . 
info
 = 
info

2368 
self
 . 
group
 = 
group

2369 
self
 . 
position
 = 
position

2371 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
group
 
	}

2373 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2375 
self
 . 
group
 = 
int
 ( 
self
 . 
group
 )

2376 except 
ValueError
 :

2378 
self
 . 
group
 = 
self
 . 
info
 . 
group_index
 [ 
self
 . 
group
 ]

2379 except 
KeyError
 :

2380 raise 
error
 ( "invalid group reference" , 
pattern
 , 
self
 . 
position
 )

2382 if not 0 <= 
self
 . 
group
 <= 
self
 . 
info
 . 
group_count
 :

2383 raise 
error
 ( "unknown group" , 
pattern
 , 
self
 . 
position
 )

2385 if 
self
 . 
group
 > 0 and 
self
 . 
info
 . 
open_group_count
 [ 
self
 . 
group
 ] > 1 :

2386 raise 
error
 ( "ambiguous group reference" , 
pattern
 , 
self
 . 
position
 )

2388 
self
 . 
info
 . 
group_calls
 . 
append
 ( ( 
self
 , 
reverse
 , 
fuzzy
 ) )

2390 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
group
 
	}

2392 def 
	$remove_captures
 ( 
self
 ) :

2393 raise 
error
 ( "group reference not allowed" , 
pattern
 , 
self
 . 
position
 ) 
	}

2395 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2396 return [ ( 
OP
 . 
GROUP_CALL
 , 
self
 . 
call_ref
 ) ] 
	}

2398 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2399 
print
 ( "{}GROUP_CALL {}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
group
 ) ) 
	}

2401 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2402 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
group
 == 
other
 . 
group
 
	}

2404 def 
	$max_width
 ( 
self
 ) :

2405 return 
UNLIMITED
 
	}

2407 class 
	cCallRef
 ( 
RegexBase
 ) :

2408 def 
	$__init__
 ( 
self
 , 
ref
 , 
parsed
 ) :

2409 
self
 . 
ref
 = 
ref

2410 
self
 . 
parsed
 = 
parsed
 
	}

2412 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2413 return ( [ ( 
OP
 . 
CALL_REF
 , 
self
 . 
ref
 ) ] + 
self
 . 
parsed
 . 
_compile
 ( 
reverse
 ,

2414 
fuzzy
 ) + [ ( 
OP
 . 
END
 , ) ] ) 
	}

2416 class 
	cCharacter
 ( 
RegexBase
 ) :

2417 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
CHARACTER
 , ( 
IGNORECASE
 , False ) :

2418 
OP
 . 
CHARACTER_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
CHARACTER
 , ( 
FULLIGNORECASE
 ,

2419 False ) : 
OP
 . 
CHARACTER_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
CHARACTER_REV
 , ( 
IGNORECASE
 ,

2420 True ) : 
OP
 . 
CHARACTER_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
CHARACTER_REV
 ,

2421 ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
CHARACTER_IGN_REV
 }

2423 def 
	$__init__
 ( 
self
 , 
value
 , 
positive
 = True , 
case_flags
 = 
NOCASE
 ,

2424 
zerowidth
 = False ) :

2425 
RegexBase
 . 
__init__
 ( 
self
 )

2426 
self
 . 
value
 = 
value

2427 
self
 . 
positive
 = 
bool
 ( 
positive
 )

2428 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

2429 
self
 . 
zerowidth
 = 
bool
 ( 
zerowidth
 )

2431 if ( 
self
 . 
positive
 and ( 
self
 . 
case_flags
 & 
FULLIGNORECASE
 ) ==

2432 
FULLIGNORECASE
 ) :

2433 
self
 . 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
chr
 ( 
self
 . 
value
 ) )

2435 
self
 . 
folded
 = 
chr
 ( 
self
 . 
value
 )

2437 
self
 . 
_key
 = ( 
self
 . 
__class__
 , 
self
 . 
value
 , 
self
 . 
positive
 ,

2438 
self
 . 
case_flags
 , 
self
 . 
zerowidth
 ) 
	}

2440 def 
	$rebuild
 ( 
self
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) :

2441 return 
Character
 ( 
self
 . 
value
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) 
	}

2443 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

2444 return 
self
 
	}

2446 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

2447 return 
set
 ( [ 
self
 ] ) 
	}

2449 def 
	$has_simple_start
 ( 
self
 ) :

2450 return True 
	}

2452 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2453 
flags
 = 0

2454 if 
self
 . 
positive
 :

2455 
flags
 |= 
POSITIVE_OP

2456 if 
self
 . 
zerowidth
 :

2457 
flags
 |= 
ZEROWIDTH_OP

2458 if 
fuzzy
 :

2459 
flags
 |= 
FUZZY_OP

2461 
code
 = 
PrecompiledCode
 ( [ 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 ,

2462 
self
 . 
value
 ] )

2464 if 
len
 ( 
self
 . 
folded
 ) > 1 :

2466 
code
 = 
Branch
 ( [ 
code
 , 
String
 ( [ 
ord
 ( 
c
 ) for 
c
 in 
self
 . 
folded
 ] ,

2467 
case_flags
 = 
self
 . 
case_flags
 ) ] )

2469 return 
code
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) 
	}

2471 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2472 
display
 = 
ascii
 ( 
chr
 ( 
self
 . 
value
 ) ) . 
lstrip
 ( "bu" )

2473 
print
 ( "{}CHARACTER {} {}{}" . 
format
 ( 
INDENT
 * 
indent
 ,

2474 
POS_TEXT
 [ 
self
 . 
positive
 ] , 
display
 , 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

2476 def 
	$matches
 ( 
self
 , 
ch
 ) :

2477 return ( 
ch
 == 
self
 . 
value
 ) == 
self
 . 
positive
 
	}

2479 def 
	$max_width
 ( 
self
 ) :

2480 return 
len
 ( 
self
 . 
folded
 ) 
	}

2482 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

2483 if not 
self
 . 
positive
 :

2486 
self
 . 
folded_characters
 = 
tuple
 ( 
ord
 ( 
c
 ) for 
c
 in 
self
 . 
folded
 )

2488 return 0 , 
self
 
	}

2490 class 
	cConditional
 ( 
RegexBase
 ) :

2491 def 
	$__init__
 ( 
self
 , 
info
 , 
group
 , 
yes_item
 , 
no_item
 , 
position
 ) :

2492 
RegexBase
 . 
__init__
 ( 
self
 )

2493 
self
 . 
info
 = 
info

2494 
self
 . 
group
 = 
group

2495 
self
 . 
yes_item
 = 
yes_item

2496 
self
 . 
no_item
 = 
no_item

2497 
self
 . 
position
 = 
position
 
	}

2499 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2501 
self
 . 
group
 = 
int
 ( 
self
 . 
group
 )

2502 except 
ValueError
 :

2504 
self
 . 
group
 = 
self
 . 
info
 . 
group_index
 [ 
self
 . 
group
 ]

2505 except 
KeyError
 :

2506 if 
self
 . 
group
 == 'DEFINE' :

2509 
self
 . 
group
 = 0

2511 raise 
error
 ( "unknown group" , 
pattern
 , 
self
 . 
position
 )

2513 if not 0 <= 
self
 . 
group
 <= 
self
 . 
info
 . 
group_count
 :

2514 raise 
error
 ( "invalid group reference" , 
pattern
 , 
self
 . 
position
 )

2516 
self
 . 
yes_item
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 )

2517 
self
 . 
no_item
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

2519 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

2520 
yes_item
 = 
self
 . 
yes_item
 . 
optimise
 ( 
info
 , 
reverse
 )

2521 
no_item
 = 
self
 . 
no_item
 . 
optimise
 ( 
info
 , 
reverse
 )

2523 return 
Conditional
 ( 
info
 , 
self
 . 
group
 , 
yes_item
 , 
no_item
 , 
self
 . 
position
 ) 
	}

2525 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2526 
self
 . 
yes_item
 = 
self
 . 
yes_item
 . 
pack_characters
 ( 
info
 )

2527 
self
 . 
no_item
 = 
self
 . 
no_item
 . 
pack_characters
 ( 
info
 )

2528 return 
self
 
	}

2530 def 
	$remove_captures
 ( 
self
 ) :

2531 
self
 . 
yes_item
 = 
self
 . 
yes_item
 . 
remove_captures
 ( )

2532 
self
 . 
no_item
 = 
self
 . 
no_item
 . 
remove_captures
 ( ) 
	}

2534 def 
	$is_atomic
 ( 
self
 ) :

2535 return 
self
 . 
yes_item
 . 
is_atomic
 ( ) and 
self
 . 
no_item
 . 
is_atomic
 ( ) 
	}

2537 def 
	$can_be_affix
 ( 
self
 ) :

2538 return 
self
 . 
yes_item
 . 
can_be_affix
 ( ) and 
self
 . 
no_item
 . 
can_be_affix
 ( ) 
	}

2540 def 
	$contains_group
 ( 
self
 ) :

2541 return 
self
 . 
yes_item
 . 
contains_group
 ( ) or 
self
 . 
no_item
 . 
contains_group
 ( ) 
	}

2543 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

2544 return ( 
self
 . 
yes_item
 . 
get_firstset
 ( 
reverse
 ) |

2545 
self
 . 
no_item
 . 
get_firstset
 ( 
reverse
 ) ) 
	}

2547 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2548 
code
 = [ ( 
OP
 . 
GROUP_EXISTS
 , 
self
 . 
group
 ) ]

2549 
code
 . 
extend
 ( 
self
 . 
yes_item
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) )

2550 
add_code
 = 
self
 . 
no_item
 . 
compile
 ( 
reverse
 , 
fuzzy
 )

2551 if 
add_code
 :

2552 
code
 . 
append
 ( ( 
OP
 . 
NEXT
 , ) )

2553 
code
 . 
extend
 ( 
add_code
 )

2555 
code
 . 
append
 ( ( 
OP
 . 
END
 , ) )

2557 return 
code
 
	}

2559 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2560 
print
 ( "{}GROUP_EXISTS {}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
group
 ) )

2561 
self
 . 
yes_item
 . 
dump
 ( 
indent
 + 1 , 
reverse
 )

2562 if not 
self
 . 
no_item
 . 
is_empty
 ( ) :

2563 
print
 ( "{}OR" . 
format
 ( 
INDENT
 * 
indent
 ) )

2564 
self
 . 
no_item
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

2566 def 
	$is_empty
 ( 
self
 ) :

2567 return 
self
 . 
yes_item
 . 
is_empty
 ( ) and 
self
 . 
no_item
 . 
is_empty
 ( ) 
	}

2569 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2570 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and ( 
self
 . 
group
 , 
self
 . 
yes_item
 ,

2571 
self
 . 
no_item
 ) == ( 
other
 . 
group
 , 
other
 . 
yes_item
 , 
other
 . 
no_item
 ) 
	}

2573 def 
	$max_width
 ( 
self
 ) :

2574 return 
max
 ( 
self
 . 
yes_item
 . 
max_width
 ( ) , 
self
 . 
no_item
 . 
max_width
 ( ) ) 
	}

2576 class 
	cDefaultBoundary
 ( 
ZeroWidthBase
 ) :

2577 
_opcode
 = 
OP
 . 
DEFAULT_BOUNDARY

2578 
_op_name
 = "DEFAULT_BOUNDARY"

2580 class 
	cDefaultEndOfWord
 ( 
ZeroWidthBase
 ) :

2581 
_opcode
 = 
OP
 . 
DEFAULT_END_OF_WORD

2582 
_op_name
 = "DEFAULT_END_OF_WORD"

2584 class 
	cDefaultStartOfWord
 ( 
ZeroWidthBase
 ) :

2585 
_opcode
 = 
OP
 . 
DEFAULT_START_OF_WORD

2586 
_op_name
 = "DEFAULT_START_OF_WORD"

2588 class 
	cEndOfLine
 ( 
ZeroWidthBase
 ) :

2589 
_opcode
 = 
OP
 . 
END_OF_LINE

2590 
_op_name
 = "END_OF_LINE"

2592 class 
	cEndOfLineU
 ( 
EndOfLine
 ) :

2593 
_opcode
 = 
OP
 . 
END_OF_LINE_U

2594 
_op_name
 = "END_OF_LINE_U"

2596 class 
	cEndOfString
 ( 
ZeroWidthBase
 ) :

2597 
_opcode
 = 
OP
 . 
END_OF_STRING

2598 
_op_name
 = "END_OF_STRING"

2600 class 
	cEndOfStringLine
 ( 
ZeroWidthBase
 ) :

2601 
_opcode
 = 
OP
 . 
END_OF_STRING_LINE

2602 
_op_name
 = "END_OF_STRING_LINE"

2604 class 
	cEndOfStringLineU
 ( 
EndOfStringLine
 ) :

2605 
_opcode
 = 
OP
 . 
END_OF_STRING_LINE_U

2606 
_op_name
 = "END_OF_STRING_LINE_U"

2608 class 
	cEndOfWord
 ( 
ZeroWidthBase
 ) :

2609 
_opcode
 = 
OP
 . 
END_OF_WORD

2610 
_op_name
 = "END_OF_WORD"

2612 class 
	cFailure
 ( 
ZeroWidthBase
 ) :

2613 
_op_name
 = "FAILURE"

2615 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2616 return [ ( 
OP
 . 
FAILURE
 , ) ] 
	}

2618 class 
	cFuzzy
 ( 
RegexBase
 ) :

2619 def 
	$__init__
 ( 
self
 , 
subpattern
 , 
constraints
 = None ) :

2620 
RegexBase
 . 
__init__
 ( 
self
 )

2621 if 
constraints
 is None :

2622 
constraints
 = { }

2623 
self
 . 
subpattern
 = 
subpattern

2624 
self
 . 
constraints
 = 
constraints

2628 if "cost" in 
constraints
 :

2629 for 
e
 in "dis" :

2630 if 
e
 in 
constraints
 [ "cost" ] :

2631 
constraints
 . 
setdefault
 ( 
e
 , ( 0 , None ) )

2635 if 
set
 ( 
constraints
 ) & 
set
 ( "dis" ) :

2636 for 
e
 in "dis" :

2637 
constraints
 . 
setdefault
 ( 
e
 , ( 0 , 0 ) )

2639 for 
e
 in "dis" :

2640 
constraints
 . 
setdefault
 ( 
e
 , ( 0 , None ) )

2643 
constraints
 . 
setdefault
 ( "e" , ( 0 , None ) )

2647 if "cost" in 
constraints
 :

2648 for 
e
 in "dis" :

2649 
constraints
 [ "cost" ] . 
setdefault
 ( 
e
 , 0 )

2651 
constraints
 [ "cost" ] = { "d" : 1 , "i" : 1 , "s" : 1 , "max" :

2652 
constraints
 [ "e" ] [ 1 ] } 
	}

2654 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2655 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , True ) 
	}

2657 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2658 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

2659 return 
self
 
	}

2661 def 
	$remove_captures
 ( 
self
 ) :

2662 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
remove_captures
 ( )

2663 return 
self
 
	}

2665 def 
	$is_atomic
 ( 
self
 ) :

2666 return 
self
 . 
subpattern
 . 
is_atomic
 ( ) 
	}

2668 def 
	$contains_group
 ( 
self
 ) :

2669 return 
self
 . 
subpattern
 . 
contains_group
 ( ) 
	}

2671 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2673 
arguments
 = [ ]

2674 for 
e
 in "dise" :

2675 
v
 = 
self
 . 
constraints
 [ 
e
 ]

2676 
arguments
 . 
append
 ( 
v
 [ 0 ] )

2677 
arguments
 . 
append
 ( 
UNLIMITED
 if 
v
 [ 1 ] is None else 
v
 [ 1 ] )

2680 for 
e
 in "dis" :

2681 
arguments
 . 
append
 ( 
self
 . 
constraints
 [ "cost" ] [ 
e
 ] )

2684 
v
 = 
self
 . 
constraints
 [ "cost" ] [ "max" ]

2685 
arguments
 . 
append
 ( 
UNLIMITED
 if 
v
 is None else 
v
 )

2687 
flags
 = 0

2688 if 
reverse
 :

2689 
flags
 |= 
REVERSE_OP

2691 return ( [ ( 
OP
 . 
FUZZY
 , 
flags
 ) + 
tuple
 ( 
arguments
 ) ] +

2692 
self
 . 
subpattern
 . 
compile
 ( 
reverse
 , True ) + [ ( 
OP
 . 
END
 , ) ] ) 
	}

2694 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2695 
constraints
 = 
self
 . 
_constraints_to_string
 ( )

2696 if 
constraints
 :

2697 
constraints
 = " " + 
constraints

2698 
print
 ( "{}FUZZY{}" . 
format
 ( 
INDENT
 * 
indent
 , 
constraints
 ) )

2699 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

2701 def 
	$is_empty
 ( 
self
 ) :

2702 return 
self
 . 
subpattern
 . 
is_empty
 ( ) 
	}

2704 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2705 return ( 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
subpattern
 ==

2706 
other
 . 
subpattern
 and 
self
 . 
constraints
 == 
other
 . 
constraints
 ) 
	}

2708 def 
	$max_width
 ( 
self
 ) :

2709 return 
UNLIMITED
 
	}

2711 def 
	$_constraints_to_string
 ( 
self
 ) :

2712 
constraints
 = [ ]

2714 for 
name
 in "ids" :

2715 
min
 , 
max
 = 
self
 . 
constraints
 [ 
name
 ]

2716 if 
max
 == 0 :

2719 
con
 = ""

2721 if 
min
 > 0 :

2722 
con
 = "{}<=" . 
format
 ( 
min
 )

2724 
con
 += 
name

2726 if 
max
 is not None :

2727 
con
 += "<={}" . 
format
 ( 
max
 )

2729 
constraints
 . 
append
 ( 
con
 )

2731 
cost
 = [ ]

2732 for 
name
 in "ids" :

2733 
coeff
 = 
self
 . 
constraints
 [ "cost" ] [ 
name
 ]

2734 if 
coeff
 > 0 :

2735 
cost
 . 
append
 ( "{}{}" . 
format
 ( 
coeff
 , 
name
 ) )

2737 
limit
 = 
self
 . 
constraints
 [ "cost" ] [ "max" ]

2738 if 
limit
 is not None and 
limit
 > 0 :

2739 
cost
 = "{}<={}" . 
format
 ( "+" . 
join
 ( 
cost
 ) , 
limit
 )

2740 
constraints
 . 
append
 ( 
cost
 )

2742 return "," . 
join
 ( 
constraints
 ) 
	}

2744 class 
	cGrapheme
 ( 
RegexBase
 ) :

2745 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2748 
grapheme_matcher
 = 
Atomic
 ( 
Sequence
 ( [ 
LazyRepeat
 ( 
AnyAll
 ( ) , 1 , None ) ,

2749 
GraphemeBoundary
 ( ) ] ) )

2751 return 
grapheme_matcher
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) 
	}

2753 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2754 
print
 ( "{}GRAPHEME" . 
format
 ( 
INDENT
 * 
indent
 ) ) 
	}

2756 def 
	$max_width
 ( 
self
 ) :

2757 return 
UNLIMITED
 
	}

2759 class 
	cGraphemeBoundary
 :

2760 def 
	$compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2761 return [ ( 
OP
 . 
GRAPHEME_BOUNDARY
 , 1 ) ] 
	}

2763 class 
	cGreedyRepeat
 ( 
RegexBase
 ) :

2764 
_opcode
 = 
OP
 . 
GREEDY_REPEAT

2765 
_op_name
 = "GREEDY_REPEAT"

2767 def 
	$__init__
 ( 
self
 , 
subpattern
 , 
min_count
 , 
max_count
 ) :

2768 
RegexBase
 . 
__init__
 ( 
self
 )

2769 
self
 . 
subpattern
 = 
subpattern

2770 
self
 . 
min_count
 = 
min_count

2771 
self
 . 
max_count
 = 
max_count
 
	}

2773 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2774 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

2776 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

2777 
subpattern
 = 
self
 . 
subpattern
 . 
optimise
 ( 
info
 , 
reverse
 )

2779 return 
type
 ( 
self
 ) ( 
subpattern
 , 
self
 . 
min_count
 , 
self
 . 
max_count
 ) 
	}

2781 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2782 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

2783 return 
self
 
	}

2785 def 
	$remove_captures
 ( 
self
 ) :

2786 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
remove_captures
 ( )

2787 return 
self
 
	}

2789 def 
	$is_atomic
 ( 
self
 ) :

2790 return 
self
 . 
min_count
 == 
self
 . 
max_count
 and 
self
 . 
subpattern
 . 
is_atomic
 ( ) 
	}

2792 def 
	$can_be_affix
 ( 
self
 ) :

2793 return False 
	}

2795 def 
	$contains_group
 ( 
self
 ) :

2796 return 
self
 . 
subpattern
 . 
contains_group
 ( ) 
	}

2798 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

2799 
fs
 = 
self
 . 
subpattern
 . 
get_firstset
 ( 
reverse
 )

2800 if 
self
 . 
min_count
 == 0 :

2801 
fs
 . 
add
 ( None )

2803 return 
fs
 
	}

2805 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2806 
repeat
 = [ 
self
 . 
_opcode
 , 
self
 . 
min_count
 ]

2807 if 
self
 . 
max_count
 is None :

2808 
repeat
 . 
append
 ( 
UNLIMITED
 )

2810 
repeat
 . 
append
 ( 
self
 . 
max_count
 )

2812 
subpattern
 = 
self
 . 
subpattern
 . 
compile
 ( 
reverse
 , 
fuzzy
 )

2813 if not 
subpattern
 :

2816 return ( [ 
tuple
 ( 
repeat
 ) ] + 
subpattern
 + [ ( 
OP
 . 
END
 , ) ] ) 
	}

2818 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2819 if 
self
 . 
max_count
 is None :

2820 
limit
 = "INF"

2822 
limit
 = 
self
 . 
max_count

2823 
print
 ( "{}{} {} {}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
_op_name
 ,

2824 
self
 . 
min_count
 , 
limit
 ) )

2826 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

2828 def 
	$is_empty
 ( 
self
 ) :

2829 return 
self
 . 
subpattern
 . 
is_empty
 ( ) 
	}

2831 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2832 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and ( 
self
 . 
subpattern
 , 
self
 . 
min_count
 ,

2833 
self
 . 
max_count
 ) == ( 
other
 . 
subpattern
 , 
other
 . 
min_count
 ,

2834 
other
 . 
max_count
 ) 
	}

2836 def 
	$max_width
 ( 
self
 ) :

2837 if 
self
 . 
max_count
 is None :

2838 return 
UNLIMITED

2840 return 
self
 . 
subpattern
 . 
max_width
 ( ) * 
self
 . 
max_count
 
	}

2842 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

2843 
max_count
 = 
UNLIMITED
 if 
self
 . 
max_count
 is None else 
self
 . 
max_count

2844 if 
self
 . 
min_count
 == 0 :

2845 
w
 = 
self
 . 
subpattern
 . 
max_width
 ( ) * 
max_count

2846 return 
min
 ( 
w
 , 
UNLIMITED
 ) , None

2848 
ofs
 , 
req
 = 
self
 . 
subpattern
 . 
get_required_string
 ( 
reverse
 )

2849 if 
req
 :

2850 return 
ofs
 , 
req

2852 
w
 = 
self
 . 
subpattern
 . 
max_width
 ( ) * 
max_count

2853 return 
min
 ( 
w
 , 
UNLIMITED
 ) , None 
	}

2855 class 
	cPossessiveRepeat
 ( 
GreedyRepeat
 ) :

2856 def 
	$is_atomic
 ( 
self
 ) :

2857 return True 
	}

2859 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2860 
subpattern
 = 
self
 . 
subpattern
 . 
compile
 ( 
reverse
 , 
fuzzy
 )

2861 if not 
subpattern
 :

2864 
repeat
 = [ 
self
 . 
_opcode
 , 
self
 . 
min_count
 ]

2865 if 
self
 . 
max_count
 is None :

2866 
repeat
 . 
append
 ( 
UNLIMITED
 )

2868 
repeat
 . 
append
 ( 
self
 . 
max_count
 )

2870 return ( [ ( 
OP
 . 
ATOMIC
 , ) , 
tuple
 ( 
repeat
 ) ] + 
subpattern
 + [ ( 
OP
 . 
END
 , ) ,

2871 ( 
OP
 . 
END
 , ) ] ) 
	}

2873 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2874 
print
 ( "{}ATOMIC" . 
format
 ( 
INDENT
 * 
indent
 ) )

2876 if 
self
 . 
max_count
 is None :

2877 
limit
 = "INF"

2879 
limit
 = 
self
 . 
max_count

2880 
print
 ( "{}{} {} {}" . 
format
 ( 
INDENT
 * ( 
indent
 + 1 ) , 
self
 . 
_op_name
 ,

2881 
self
 . 
min_count
 , 
limit
 ) )

2883 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 2 , 
reverse
 ) 
	}

2885 class 
	cGroup
 ( 
RegexBase
 ) :

2886 def 
	$__init__
 ( 
self
 , 
info
 , 
group
 , 
subpattern
 ) :

2887 
RegexBase
 . 
__init__
 ( 
self
 )

2888 
self
 . 
info
 = 
info

2889 
self
 . 
group
 = 
group

2890 
self
 . 
subpattern
 = 
subpattern

2892 
self
 . 
call_ref
 = None 
	}

2894 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2895 
self
 . 
info
 . 
defined_groups
 [ 
self
 . 
group
 ] = ( 
self
 , 
reverse
 , 
fuzzy
 )

2896 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

2898 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

2899 
subpattern
 = 
self
 . 
subpattern
 . 
optimise
 ( 
info
 , 
reverse
 )

2901 return 
Group
 ( 
self
 . 
info
 , 
self
 . 
group
 , 
subpattern
 ) 
	}

2903 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2904 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

2905 return 
self
 
	}

2907 def 
	$remove_captures
 ( 
self
 ) :

2908 return 
self
 . 
subpattern
 . 
remove_captures
 ( ) 
	}

2910 def 
	$is_atomic
 ( 
self
 ) :

2911 return 
self
 . 
subpattern
 . 
is_atomic
 ( ) 
	}

2913 def 
	$can_be_affix
 ( 
self
 ) :

2914 return False 
	}

2916 def 
	$contains_group
 ( 
self
 ) :

2917 return True 
	}

2919 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

2920 return 
self
 . 
subpattern
 . 
get_firstset
 ( 
reverse
 ) 
	}

2922 def 
	$has_simple_start
 ( 
self
 ) :

2923 return 
self
 . 
subpattern
 . 
has_simple_start
 ( ) 
	}

2925 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

2926 
code
 = [ ]

2928 
key
 = 
self
 . 
group
 , 
reverse
 , 
fuzzy

2929 
ref
 = 
self
 . 
info
 . 
call_refs
 . 
get
 ( 
key
 )

2930 if 
ref
 is not None :

2931 
code
 += [ ( 
OP
 . 
CALL_REF
 , 
ref
 ) ]

2933 
public_group
 = 
private_group
 = 
self
 . 
group

2934 if 
private_group
 < 0 :

2935 
public_group
 = 
self
 . 
info
 . 
private_groups
 [ 
private_group
 ]

2936 
private_group
 = 
self
 . 
info
 . 
group_count
 - 
private_group

2938 
code
 += ( [ ( 
OP
 . 
GROUP
 , 
int
 ( not 
reverse
 ) , 
private_group
 , 
public_group
 ) ] +

2939 
self
 . 
subpattern
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) + [ ( 
OP
 . 
END
 , ) ] )

2941 if 
ref
 is not None :

2942 
code
 += [ ( 
OP
 . 
END
 , ) ]

2944 return 
code
 
	}

2946 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

2947 
group
 = 
self
 . 
group

2948 if 
group
 < 0 :

2949 
group
 = 
private_groups
 [ 
group
 ]

2950 
print
 ( "{}GROUP {}" . 
format
 ( 
INDENT
 * 
indent
 , 
group
 ) )

2951 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

2953 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2954 return ( 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and ( 
self
 . 
group
 , 
self
 . 
subpattern
 ) ==

2955 ( 
other
 . 
group
 , 
other
 . 
subpattern
 ) ) 
	}

2957 def 
	$max_width
 ( 
self
 ) :

2958 return 
self
 . 
subpattern
 . 
max_width
 ( ) 
	}

2960 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

2961 return 
self
 . 
subpattern
 . 
get_required_string
 ( 
reverse
 ) 
	}

2963 class 
	cKeep
 ( 
ZeroWidthBase
 ) :

2964 
_opcode
 = 
OP
 . 
KEEP

2965 
_op_name
 = "KEEP"

2967 class 
	cLazyRepeat
 ( 
GreedyRepeat
 ) :

2968 
_opcode
 = 
OP
 . 
LAZY_REPEAT

2969 
_op_name
 = "LAZY_REPEAT"

2971 class 
	cLookAround
 ( 
RegexBase
 ) :

2972 
_dir_text
 = { False : "AHEAD" , True : "BEHIND" }

2974 def 
	$__init__
 ( 
self
 , 
behind
 , 
positive
 , 
subpattern
 ) :

2975 
RegexBase
 . 
__init__
 ( 
self
 )

2976 
self
 . 
behind
 = 
bool
 ( 
behind
 )

2977 
self
 . 
positive
 = 
bool
 ( 
positive
 )

2978 
self
 . 
subpattern
 = 
subpattern
 
	}

2980 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

2981 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
self
 . 
behind
 , 
fuzzy
 ) 
	}

2983 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

2984 
subpattern
 = 
self
 . 
subpattern
 . 
optimise
 ( 
info
 , 
self
 . 
behind
 )

2985 if 
self
 . 
positive
 and 
subpattern
 . 
is_empty
 ( ) :

2986 return 
subpattern

2988 return 
LookAround
 ( 
self
 . 
behind
 , 
self
 . 
positive
 , 
subpattern
 ) 
	}

2990 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

2991 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

2992 return 
self
 
	}

2994 def 
	$remove_captures
 ( 
self
 ) :

2995 return 
self
 . 
subpattern
 . 
remove_captures
 ( ) 
	}

2997 def 
	$is_atomic
 ( 
self
 ) :

2998 return 
self
 . 
subpattern
 . 
is_atomic
 ( ) 
	}

3000 def 
	$can_be_affix
 ( 
self
 ) :

3001 return 
self
 . 
subpattern
 . 
can_be_affix
 ( ) 
	}

3003 def 
	$contains_group
 ( 
self
 ) :

3004 return 
self
 . 
subpattern
 . 
contains_group
 ( ) 
	}

3006 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

3007 if 
self
 . 
positive
 and 
self
 . 
behind
 == 
reverse
 :

3008 return 
self
 . 
subpattern
 . 
get_firstset
 ( 
reverse
 )

3010 return 
set
 ( [ None ] ) 
	}

3012 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3013 
flags
 = 0

3014 if 
self
 . 
positive
 :

3015 
flags
 |= 
POSITIVE_OP

3016 if 
fuzzy
 :

3017 
flags
 |= 
FUZZY_OP

3018 if 
reverse
 :

3019 
flags
 |= 
REVERSE_OP

3021 return ( [ ( 
OP
 . 
LOOKAROUND
 , 
flags
 , 
int
 ( not 
self
 . 
behind
 ) ) ] +

3022 
self
 . 
subpattern
 . 
compile
 ( 
self
 . 
behind
 ) + [ ( 
OP
 . 
END
 , ) ] ) 
	}

3024 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3025 
print
 ( "{}LOOK{} {}" . 
format
 ( 
INDENT
 * 
indent
 ,

3026 
self
 . 
_dir_text
 [ 
self
 . 
behind
 ] , 
POS_TEXT
 [ 
self
 . 
positive
 ] ) )

3027 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
self
 . 
behind
 ) 
	}

3029 def 
	$is_empty
 ( 
self
 ) :

3030 return 
self
 . 
positive
 and 
self
 . 
subpattern
 . 
is_empty
 ( ) 
	}

3032 def 
	$__eq__
 ( 
self
 , 
other
 ) :

3033 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and ( 
self
 . 
behind
 , 
self
 . 
positive
 ,

3034 
self
 . 
subpattern
 ) == ( 
other
 . 
behind
 , 
other
 . 
positive
 , 
other
 . 
subpattern
 ) 
	}

3036 def 
	$max_width
 ( 
self
 ) :

3037 return 0 
	}

3039 class 
	cLookAroundConditional
 ( 
RegexBase
 ) :

3040 
_dir_text
 = { False : "AHEAD" , True : "BEHIND" }

3042 def 
	$__init__
 ( 
self
 , 
behind
 , 
positive
 , 
subpattern
 , 
yes_item
 , 
no_item
 ) :

3043 
RegexBase
 . 
__init__
 ( 
self
 )

3044 
self
 . 
behind
 = 
bool
 ( 
behind
 )

3045 
self
 . 
positive
 = 
bool
 ( 
positive
 )

3046 
self
 . 
subpattern
 = 
subpattern

3047 
self
 . 
yes_item
 = 
yes_item

3048 
self
 . 
no_item
 = 
no_item
 
	}

3050 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

3051 
self
 . 
subpattern
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 )

3052 
self
 . 
yes_item
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 )

3053 
self
 . 
no_item
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

3055 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

3056 
subpattern
 = 
self
 . 
subpattern
 . 
optimise
 ( 
info
 , 
self
 . 
behind
 )

3057 
yes_item
 = 
self
 . 
yes_item
 . 
optimise
 ( 
info
 , 
self
 . 
behind
 )

3058 
no_item
 = 
self
 . 
no_item
 . 
optimise
 ( 
info
 , 
self
 . 
behind
 )

3060 return 
LookAroundConditional
 ( 
self
 . 
behind
 , 
self
 . 
positive
 , 
subpattern
 ,

3061 
yes_item
 , 
no_item
 ) 
	}

3063 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

3064 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
pack_characters
 ( 
info
 )

3065 
self
 . 
yes_item
 = 
self
 . 
yes_item
 . 
pack_characters
 ( 
info
 )

3066 
self
 . 
no_item
 = 
self
 . 
no_item
 . 
pack_characters
 ( 
info
 )

3067 return 
self
 
	}

3069 def 
	$remove_captures
 ( 
self
 ) :

3070 
self
 . 
subpattern
 = 
self
 . 
subpattern
 . 
remove_captures
 ( )

3071 
self
 . 
yes_item
 = 
self
 . 
yes_item
 . 
remove_captures
 ( )

3072 
self
 . 
no_item
 = 
self
 . 
no_item
 . 
remove_captures
 ( ) 
	}

3074 def 
	$is_atomic
 ( 
self
 ) :

3075 return ( 
self
 . 
subpattern
 . 
is_atomic
 ( ) and 
self
 . 
yes_item
 . 
is_atomic
 ( ) and

3076 
self
 . 
no_item
 . 
is_atomic
 ( ) ) 
	}

3078 def 
	$can_be_affix
 ( 
self
 ) :

3079 return ( 
self
 . 
subpattern
 . 
can_be_affix
 ( ) and 
self
 . 
yes_item
 . 
can_be_affix
 ( )

3080 and 
self
 . 
no_item
 . 
can_be_affix
 ( ) ) 
	}

3082 def 
	$contains_group
 ( 
self
 ) :

3083 return ( 
self
 . 
subpattern
 . 
contains_group
 ( ) or

3084 
self
 . 
yes_item
 . 
contains_group
 ( ) or 
self
 . 
no_item
 . 
contains_group
 ( ) ) 
	}

3086 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3087 
code
 = [ ( 
OP
 . 
CONDITIONAL
 , 
int
 ( 
self
 . 
positive
 ) , 
int
 ( not 
self
 . 
behind
 ) ) ]

3088 
code
 . 
extend
 ( 
self
 . 
subpattern
 . 
compile
 ( 
self
 . 
behind
 , 
fuzzy
 ) )

3089 
code
 . 
append
 ( ( 
OP
 . 
NEXT
 , ) )

3090 
code
 . 
extend
 ( 
self
 . 
yes_item
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) )

3091 
add_code
 = 
self
 . 
no_item
 . 
compile
 ( 
reverse
 , 
fuzzy
 )

3092 if 
add_code
 :

3093 
code
 . 
append
 ( ( 
OP
 . 
NEXT
 , ) )

3094 
code
 . 
extend
 ( 
add_code
 )

3096 
code
 . 
append
 ( ( 
OP
 . 
END
 , ) )

3098 return 
code
 
	}

3100 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3101 
print
 ( "{}CONDITIONAL {} {}" . 
format
 ( 
INDENT
 * 
indent
 ,

3102 
self
 . 
_dir_text
 [ 
self
 . 
behind
 ] , 
POS_TEXT
 [ 
self
 . 
positive
 ] ) )

3103 
self
 . 
subpattern
 . 
dump
 ( 
indent
 + 1 , 
self
 . 
behind
 )

3104 
print
 ( "{}EITHER" . 
format
 ( 
INDENT
 * 
indent
 ) )

3105 
self
 . 
yes_item
 . 
dump
 ( 
indent
 + 1 , 
reverse
 )

3106 if not 
self
 . 
no_item
 . 
is_empty
 ( ) :

3107 
print
 ( "{}OR" . 
format
 ( 
INDENT
 * 
indent
 ) )

3108 
self
 . 
no_item
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

3110 def 
	$is_empty
 ( 
self
 ) :

3111 return ( 
self
 . 
subpattern
 . 
is_empty
 ( ) and 
self
 . 
yes_item
 . 
is_empty
 ( ) or

3112 
self
 . 
no_item
 . 
is_empty
 ( ) ) 
	}

3114 def 
	$__eq__
 ( 
self
 , 
other
 ) :

3115 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and ( 
self
 . 
subpattern
 , 
self
 . 
yes_item
 ,

3116 
self
 . 
no_item
 ) == ( 
other
 . 
subpattern
 , 
other
 . 
yes_item
 , 
other
 . 
no_item
 ) 
	}

3118 def 
	$max_width
 ( 
self
 ) :

3119 return 
max
 ( 
self
 . 
yes_item
 . 
max_width
 ( ) , 
self
 . 
no_item
 . 
max_width
 ( ) ) 
	}

3121 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

3122 return 
self
 . 
max_width
 ( ) , None 
	}

3124 class 
	cPrecompiledCode
 ( 
RegexBase
 ) :

3125 def 
	$__init__
 ( 
self
 , 
code
 ) :

3126 
self
 . 
code
 = 
code
 
	}

3128 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3129 return [ 
tuple
 ( 
self
 . 
code
 ) ] 
	}

3131 class 
	cProperty
 ( 
RegexBase
 ) :

3132 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
PROPERTY
 , ( 
IGNORECASE
 , False ) :

3133 
OP
 . 
PROPERTY_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
PROPERTY
 , ( 
FULLIGNORECASE
 , False ) :

3134 
OP
 . 
PROPERTY_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
PROPERTY_REV
 , ( 
IGNORECASE
 , True ) :

3135 
OP
 . 
PROPERTY_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
PROPERTY_REV
 , ( 
FULLIGNORECASE
 ,

3136 True ) : 
OP
 . 
PROPERTY_IGN_REV
 }

3138 def 
	$__init__
 ( 
self
 , 
value
 , 
positive
 = True , 
case_flags
 = 
NOCASE
 ,

3139 
zerowidth
 = False ) :

3140 
RegexBase
 . 
__init__
 ( 
self
 )

3141 
self
 . 
value
 = 
value

3142 
self
 . 
positive
 = 
bool
 ( 
positive
 )

3143 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3144 
self
 . 
zerowidth
 = 
bool
 ( 
zerowidth
 )

3146 
self
 . 
_key
 = ( 
self
 . 
__class__
 , 
self
 . 
value
 , 
self
 . 
positive
 ,

3147 
self
 . 
case_flags
 , 
self
 . 
zerowidth
 ) 
	}

3149 def 
	$rebuild
 ( 
self
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) :

3150 return 
Property
 ( 
self
 . 
value
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) 
	}

3152 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3153 return 
self
 
	}

3155 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

3156 return 
set
 ( [ 
self
 ] ) 
	}

3158 def 
	$has_simple_start
 ( 
self
 ) :

3159 return True 
	}

3161 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3162 
flags
 = 0

3163 if 
self
 . 
positive
 :

3164 
flags
 |= 
POSITIVE_OP

3165 if 
self
 . 
zerowidth
 :

3166 
flags
 |= 
ZEROWIDTH_OP

3167 if 
fuzzy
 :

3168 
flags
 |= 
FUZZY_OP

3169 return [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 , 
self
 . 
value
 ) ] 
	}

3171 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3172 
prop
 = 
PROPERTY_NAMES
 [ 
self
 . 
value
 >> 16 ]

3173 
name
 , 
value
 = 
prop
 [ 0 ] , 
prop
 [ 1 ] [ 
self
 . 
value
 & 0xFFFF ]

3174 
print
 ( "{}PROPERTY {} {}:{}{}" . 
format
 ( 
INDENT
 * 
indent
 ,

3175 
POS_TEXT
 [ 
self
 . 
positive
 ] , 
name
 , 
value
 , 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3177 def 
	$matches
 ( 
self
 , 
ch
 ) :

3178 return 
_regex
 . 
has_property_value
 ( 
self
 . 
value
 , 
ch
 ) == 
self
 . 
positive
 
	}

3180 def 
	$max_width
 ( 
self
 ) :

3181 return 1 
	}

3183 class 
	cPrune
 ( 
ZeroWidthBase
 ) :

3184 
_op_name
 = "PRUNE"

3186 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3187 return [ ( 
OP
 . 
PRUNE
 , ) ] 
	}

3189 class 
	cRange
 ( 
RegexBase
 ) :

3190 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
RANGE
 , ( 
IGNORECASE
 , False ) : 
OP
 . 
RANGE_IGN
 ,

3191 ( 
FULLCASE
 , False ) : 
OP
 . 
RANGE
 , ( 
FULLIGNORECASE
 , False ) : 
OP
 . 
RANGE_IGN
 ,

3192 ( 
NOCASE
 , True ) : 
OP
 . 
RANGE_REV
 , ( 
IGNORECASE
 , True ) : 
OP
 . 
RANGE_IGN_REV
 ,

3193 ( 
FULLCASE
 , True ) : 
OP
 . 
RANGE_REV
 , ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
RANGE_IGN_REV
 }

3194 
_op_name
 = "RANGE"

3196 def 
	$__init__
 ( 
self
 , 
lower
 , 
upper
 , 
positive
 = True , 
case_flags
 = 
NOCASE
 ,

3197 
zerowidth
 = False ) :

3198 
RegexBase
 . 
__init__
 ( 
self
 )

3199 
self
 . 
lower
 = 
lower

3200 
self
 . 
upper
 = 
upper

3201 
self
 . 
positive
 = 
bool
 ( 
positive
 )

3202 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3203 
self
 . 
zerowidth
 = 
bool
 ( 
zerowidth
 )

3205 
self
 . 
_key
 = ( 
self
 . 
__class__
 , 
self
 . 
lower
 , 
self
 . 
upper
 , 
self
 . 
positive
 ,

3206 
self
 . 
case_flags
 , 
self
 . 
zerowidth
 ) 
	}

3208 def 
	$rebuild
 ( 
self
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) :

3209 return 
Range
 ( 
self
 . 
lower
 , 
self
 . 
upper
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) 
	}

3211 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3213 if not 
self
 . 
positive
 or not ( 
self
 . 
case_flags
 & 
IGNORECASE
 ) or 
in_set
 :

3214 return 
self

3217 if ( not ( 
info
 . 
flags
 & 
UNICODE
 ) or ( 
self
 . 
case_flags
 & 
FULLIGNORECASE
 ) !=

3218 
FULLIGNORECASE
 ) :

3219 return 
self

3222 
expanding_chars
 = 
_regex
 . 
get_expand_on_folding
 ( )

3225 
items
 = [ ]

3226 for 
ch
 in 
expanding_chars
 :

3227 if 
self
 . 
lower
 <= 
ord
 ( 
ch
 ) <= 
self
 . 
upper
 :

3228 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
ch
 )

3229 
items
 . 
append
 ( 
String
 ( [ 
ord
 ( 
c
 ) for 
c
 in 
folded
 ] ,

3230 
case_flags
 = 
self
 . 
case_flags
 ) )

3232 if not 
items
 :

3234 return 
self

3236 if 
len
 ( 
items
 ) < 
self
 . 
upper
 - 
self
 . 
lower
 + 1 :

3238 
items
 . 
insert
 ( 0 , 
self
 )

3240 return 
Branch
 ( 
items
 ) 
	}

3242 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3243 
flags
 = 0

3244 if 
self
 . 
positive
 :

3245 
flags
 |= 
POSITIVE_OP

3246 if 
self
 . 
zerowidth
 :

3247 
flags
 |= 
ZEROWIDTH_OP

3248 if 
fuzzy
 :

3249 
flags
 |= 
FUZZY_OP

3250 return [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 , 
self
 . 
lower
 ,

3251 
self
 . 
upper
 ) ] 
	}

3253 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3254 
display_lower
 = 
ascii
 ( 
chr
 ( 
self
 . 
lower
 ) ) . 
lstrip
 ( "bu" )

3255 
display_upper
 = 
ascii
 ( 
chr
 ( 
self
 . 
upper
 ) ) . 
lstrip
 ( "bu" )

3256 
print
 ( "{}RANGE {} {} {}{}" . 
format
 ( 
INDENT
 * 
indent
 ,

3257 
POS_TEXT
 [ 
self
 . 
positive
 ] , 
display_lower
 , 
display_upper
 ,

3258 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3260 def 
	$matches
 ( 
self
 , 
ch
 ) :

3261 return ( 
self
 . 
lower
 <= 
ch
 <= 
self
 . 
upper
 ) == 
self
 . 
positive
 
	}

3263 def 
	$max_width
 ( 
self
 ) :

3264 return 1 
	}

3266 class 
	cRefGroup
 ( 
RegexBase
 ) :

3267 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
REF_GROUP
 , ( 
IGNORECASE
 , False ) :

3268 
OP
 . 
REF_GROUP_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
REF_GROUP
 , ( 
FULLIGNORECASE
 ,

3269 False ) : 
OP
 . 
REF_GROUP_FLD
 , ( 
NOCASE
 , True ) : 
OP
 . 
REF_GROUP_REV
 , ( 
IGNORECASE
 ,

3270 True ) : 
OP
 . 
REF_GROUP_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
REF_GROUP_REV
 ,

3271 ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
REF_GROUP_FLD_REV
 }

3273 def 
	$__init__
 ( 
self
 , 
info
 , 
group
 , 
position
 , 
case_flags
 = 
NOCASE
 ) :

3274 
RegexBase
 . 
__init__
 ( 
self
 )

3275 
self
 . 
info
 = 
info

3276 
self
 . 
group
 = 
group

3277 
self
 . 
position
 = 
position

3278 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3280 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
group
 , 
self
 . 
case_flags
 
	}

3282 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

3284 
self
 . 
group
 = 
int
 ( 
self
 . 
group
 )

3285 except 
ValueError
 :

3287 
self
 . 
group
 = 
self
 . 
info
 . 
group_index
 [ 
self
 . 
group
 ]

3288 except 
KeyError
 :

3289 raise 
error
 ( "unknown group" , 
pattern
 , 
self
 . 
position
 )

3291 if not 1 <= 
self
 . 
group
 <= 
self
 . 
info
 . 
group_count
 :

3292 raise 
error
 ( "invalid group reference" , 
pattern
 , 
self
 . 
position
 )

3294 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
group
 , 
self
 . 
case_flags
 
	}

3296 def 
	$remove_captures
 ( 
self
 ) :

3297 raise 
error
 ( "group reference not allowed" , 
pattern
 , 
self
 . 
position
 ) 
	}

3299 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3300 
flags
 = 0

3301 if 
fuzzy
 :

3302 
flags
 |= 
FUZZY_OP

3303 return [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 , 
self
 . 
group
 ) ] 
	}

3305 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3306 
print
 ( "{}REF_GROUP {}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
group
 ,

3307 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3309 def 
	$max_width
 ( 
self
 ) :

3310 return 
UNLIMITED
 
	}

3312 class 
	cSearchAnchor
 ( 
ZeroWidthBase
 ) :

3313 
_opcode
 = 
OP
 . 
SEARCH_ANCHOR

3314 
_op_name
 = "SEARCH_ANCHOR"

3316 class 
	cSequence
 ( 
RegexBase
 ) :

3317 def 
	$__init__
 ( 
self
 , 
items
 = None ) :

3318 
RegexBase
 . 
__init__
 ( 
self
 )

3319 if 
items
 is None :

3320 
items
 = [ ]

3322 
self
 . 
items
 = 
items
 
	}

3324 def 
	$fix_groups
 ( 
self
 , 
pattern
 , 
reverse
 , 
fuzzy
 ) :

3325 for 
s
 in 
self
 . 
items
 :

3326 
s
 . 
fix_groups
 ( 
pattern
 , 
reverse
 , 
fuzzy
 ) 
	}

3328 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 ) :

3330 
items
 = [ ]

3331 for 
s
 in 
self
 . 
items
 :

3332 
s
 = 
s
 . 
optimise
 ( 
info
 , 
reverse
 )

3333 if 
isinstance
 ( 
s
 , 
Sequence
 ) :

3334 
items
 . 
extend
 ( 
s
 . 
items
 )

3336 
items
 . 
append
 ( 
s
 )

3338 return 
make_sequence
 ( 
items
 ) 
	}

3340 def 
	$pack_characters
 ( 
self
 , 
info
 ) :

3342 
items
 = [ ]

3343 
characters
 = [ ]

3344 
case_flags
 = 
NOCASE

3345 for 
s
 in 
self
 . 
items
 :

3346 if 
type
 ( 
s
 ) is 
Character
 and 
s
 . 
positive
 and not 
s
 . 
zerowidth
 :

3347 if 
s
 . 
case_flags
 != 
case_flags
 :

3350 if 
s
 . 
case_flags
 or 
is_cased_i
 ( 
info
 , 
s
 . 
value
 ) :

3351 
Sequence
 . 
_flush_characters
 ( 
info
 , 
characters
 ,

3352 
case_flags
 , 
items
 )

3354 
case_flags
 = 
s
 . 
case_flags

3356 
characters
 . 
append
 ( 
s
 . 
value
 )

3357 elif 
type
 ( 
s
 ) is 
String
 or 
type
 ( 
s
 ) is 
Literal
 :

3358 if 
s
 . 
case_flags
 != 
case_flags
 :

3361 if 
s
 . 
case_flags
 or 
any
 ( 
is_cased_i
 ( 
info
 , 
c
 ) for 
c
 in

3362 
characters
 ) :

3363 
Sequence
 . 
_flush_characters
 ( 
info
 , 
characters
 ,

3364 
case_flags
 , 
items
 )

3366 
case_flags
 = 
s
 . 
case_flags

3368 
characters
 . 
extend
 ( 
s
 . 
characters
 )

3370 
Sequence
 . 
_flush_characters
 ( 
info
 , 
characters
 , 
case_flags
 , 
items
 )

3372 
items
 . 
append
 ( 
s
 . 
pack_characters
 ( 
info
 ) )

3374 
Sequence
 . 
_flush_characters
 ( 
info
 , 
characters
 , 
case_flags
 , 
items
 )

3376 return 
make_sequence
 ( 
items
 ) 
	}

3378 def 
	$remove_captures
 ( 
self
 ) :

3379 
self
 . 
items
 = [ 
s
 . 
remove_captures
 ( ) for 
s
 in 
self
 . 
items
 ]

3380 return 
self
 
	}

3382 def 
	$is_atomic
 ( 
self
 ) :

3383 return 
all
 ( 
s
 . 
is_atomic
 ( ) for 
s
 in 
self
 . 
items
 ) 
	}

3385 def 
	$can_be_affix
 ( 
self
 ) :

3386 return False 
	}

3388 def 
	$contains_group
 ( 
self
 ) :

3389 return 
any
 ( 
s
 . 
contains_group
 ( ) for 
s
 in 
self
 . 
items
 ) 
	}

3391 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

3392 
fs
 = 
set
 ( )

3393 
items
 = 
self
 . 
items

3394 if 
reverse
 :

3395 
items
 . 
reverse
 ( )

3396 for 
s
 in 
items
 :

3397 
fs
 |= 
s
 . 
get_firstset
 ( 
reverse
 )

3398 if None not in 
fs
 :

3399 return 
fs

3400 
fs
 . 
discard
 ( None )

3402 return 
fs
 | 
set
 ( [ None ] ) 
	}

3404 def 
	$has_simple_start
 ( 
self
 ) :

3405 return 
bool
 ( 
self
 . 
items
 ) and 
self
 . 
items
 [ 0 ] . 
has_simple_start
 ( ) 
	}

3407 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3408 
seq
 = 
self
 . 
items

3409 if 
reverse
 :

3410 
seq
 = 
seq
 [ : : - 1 ]

3412 
code
 = [ ]

3413 for 
s
 in 
seq
 :

3414 
code
 . 
extend
 ( 
s
 . 
compile
 ( 
reverse
 , 
fuzzy
 ) )

3416 return 
code
 
	}

3418 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3419 for 
s
 in 
self
 . 
items
 :

3420 
s
 . 
dump
 ( 
indent
 , 
reverse
 ) 
	}

3422 @ 
	`staticmethod

3423 def 
	$_flush_characters
 ( 
info
 , 
characters
 , 
case_flags
 , 
items
 ) :

3424 if not 
characters
 :

3428 if 
case_flags
 & 
IGNORECASE
 :

3429 if not 
any
 ( 
is_cased_i
 ( 
info
 , 
c
 ) for 
c
 in 
characters
 ) :

3430 
case_flags
 = 
NOCASE

3432 if ( 
case_flags
 & 
FULLIGNORECASE
 ) == 
FULLIGNORECASE
 :

3433 
literals
 = 
Sequence
 . 
_fix_full_casefold
 ( 
characters
 )

3435 for 
item
 in 
literals
 :

3436 
chars
 = 
item
 . 
characters

3438 if 
len
 ( 
chars
 ) == 1 :

3439 
items
 . 
append
 ( 
Character
 ( 
chars
 [ 0 ] , 
case_flags
 = 
item
 . 
case_flags
 ) )

3441 
items
 . 
append
 ( 
String
 ( 
chars
 , 
case_flags
 = 
item
 . 
case_flags
 ) )

3443 if 
len
 ( 
characters
 ) == 1 :

3444 
items
 . 
append
 ( 
Character
 ( 
characters
 [ 0 ] , 
case_flags
 = 
case_flags
 ) )

3446 
items
 . 
append
 ( 
String
 ( 
characters
 , 
case_flags
 = 
case_flags
 ) )

3448 
characters
 [ : ] = [ ] 
	}

3450 @ 
	`staticmethod

3451 def 
	$_fix_full_casefold
 ( 
characters
 ) :

3454 
expanded
 = [ 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
c
 ) for 
c
 in

3455 
_regex
 . 
get_expand_on_folding
 ( ) ]

3456 
string
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , '' . 
join
 ( 
chr
 ( 
c
 )

3457 for 
c
 in 
characters
 ) ) . 
lower
 ( )

3458 
chunks
 = [ ]

3460 for 
e
 in 
expanded
 :

3461 
found
 = 
string
 . 
find
 ( 
e
 )

3463 while 
found
 >= 0 :

3464 
chunks
 . 
append
 ( ( 
found
 , 
found
 + 
len
 ( 
e
 ) ) )

3465 
found
 = 
string
 . 
find
 ( 
e
 , 
found
 + 1 )

3467 
pos
 = 0

3468 
literals
 = [ ]

3470 for 
start
 , 
end
 in 
Sequence
 . 
_merge_chunks
 ( 
chunks
 ) :

3471 if 
pos
 < 
start
 :

3472 
literals
 . 
append
 ( 
Literal
 ( 
characters
 [ 
pos
 : 
start
 ] ,

3473 
case_flags
 = 
IGNORECASE
 ) )

3475 
literals
 . 
append
 ( 
Literal
 ( 
characters
 [ 
start
 : 
end
 ] ,

3476 
case_flags
 = 
FULLIGNORECASE
 ) )

3477 
pos
 = 
end

3479 if 
pos
 < 
len
 ( 
characters
 ) :

3480 
literals
 . 
append
 ( 
Literal
 ( 
characters
 [ 
pos
 : ] , 
case_flags
 = 
IGNORECASE
 ) )

3482 return 
literals
 
	}

3484 @ 
	`staticmethod

3485 def 
	$_merge_chunks
 ( 
chunks
 ) :

3486 if 
len
 ( 
chunks
 ) < 2 :

3487 return 
chunks

3489 
chunks
 . 
sort
 ( )

3491 
start
 , 
end
 = 
chunks
 [ 0 ]

3492 
new_chunks
 = [ ]

3494 for 
s
 , 
e
 in 
chunks
 [ 1 : ] :

3495 if 
s
 <= 
end
 :

3496 
end
 = 
max
 ( 
end
 , 
e
 )

3498 
new_chunks
 . 
append
 ( ( 
start
 , 
end
 ) )

3499 
start
 , 
end
 = 
s
 , 
e

3501 
new_chunks
 . 
append
 ( ( 
start
 , 
end
 ) )

3503 return 
new_chunks
 
	}

3505 def 
	$is_empty
 ( 
self
 ) :

3506 return 
all
 ( 
i
 . 
is_empty
 ( ) for 
i
 in 
self
 . 
items
 ) 
	}

3508 def 
	$__eq__
 ( 
self
 , 
other
 ) :

3509 return 
type
 ( 
self
 ) is 
type
 ( 
other
 ) and 
self
 . 
items
 == 
other
 . 
items
 
	}

3511 def 
	$max_width
 ( 
self
 ) :

3512 return 
sum
 ( 
s
 . 
max_width
 ( ) for 
s
 in 
self
 . 
items
 ) 
	}

3514 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

3515 
seq
 = 
self
 . 
items

3516 if 
reverse
 :

3517 
seq
 = 
seq
 [ : : - 1 ]

3519 
offset
 = 0

3521 for 
s
 in 
seq
 :

3522 
ofs
 , 
req
 = 
s
 . 
get_required_string
 ( 
reverse
 )

3523 
offset
 += 
ofs

3524 if 
req
 :

3525 return 
offset
 , 
req

3527 return 
offset
 , None 
	}

3529 class 
	cSetBase
 ( 
RegexBase
 ) :

3530 def 
	$__init__
 ( 
self
 , 
info
 , 
items
 , 
positive
 = True , 
case_flags
 = 
NOCASE
 ,

3531 
zerowidth
 = False ) :

3532 
RegexBase
 . 
__init__
 ( 
self
 )

3533 
self
 . 
info
 = 
info

3534 
self
 . 
items
 = 
tuple
 ( 
items
 )

3535 
self
 . 
positive
 = 
bool
 ( 
positive
 )

3536 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3537 
self
 . 
zerowidth
 = 
bool
 ( 
zerowidth
 )

3539 
self
 . 
char_width
 = 1

3541 
self
 . 
_key
 = ( 
self
 . 
__class__
 , 
self
 . 
items
 , 
self
 . 
positive
 ,

3542 
self
 . 
case_flags
 , 
self
 . 
zerowidth
 ) 
	}

3544 def 
	$rebuild
 ( 
self
 , 
positive
 , 
case_flags
 , 
zerowidth
 ) :

3545 return 
type
 ( 
self
 ) ( 
self
 . 
info
 , 
self
 . 
items
 , 
positive
 , 
case_flags
 ,

3546 
zerowidth
 ) . 
optimise
 ( 
self
 . 
info
 , False ) 
	}

3548 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

3549 return 
set
 ( [ 
self
 ] ) 
	}

3551 def 
	$has_simple_start
 ( 
self
 ) :

3552 return True 
	}

3554 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3555 
flags
 = 0

3556 if 
self
 . 
positive
 :

3557 
flags
 |= 
POSITIVE_OP

3558 if 
self
 . 
zerowidth
 :

3559 
flags
 |= 
ZEROWIDTH_OP

3560 if 
fuzzy
 :

3561 
flags
 |= 
FUZZY_OP

3562 
code
 = [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 ) ]

3563 for 
m
 in 
self
 . 
items
 :

3564 
code
 . 
extend
 ( 
m
 . 
compile
 ( ) )

3566 
code
 . 
append
 ( ( 
OP
 . 
END
 , ) )

3568 return 
code
 
	}

3570 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3571 
print
 ( "{}{} {}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
_op_name
 ,

3572 
POS_TEXT
 [ 
self
 . 
positive
 ] , 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) )

3573 for 
i
 in 
self
 . 
items
 :

3574 
i
 . 
dump
 ( 
indent
 + 1 , 
reverse
 ) 
	}

3576 def 
	$_handle_case_folding
 ( 
self
 , 
info
 , 
in_set
 ) :

3578 if not 
self
 . 
positive
 or not ( 
self
 . 
case_flags
 & 
IGNORECASE
 ) or 
in_set
 :

3579 return 
self

3582 if ( not ( 
self
 . 
info
 . 
flags
 & 
UNICODE
 ) or ( 
self
 . 
case_flags
 &

3583 
FULLIGNORECASE
 ) != 
FULLIGNORECASE
 ) :

3584 return 
self

3587 
expanding_chars
 = 
_regex
 . 
get_expand_on_folding
 ( )

3590 
items
 = [ ]

3591 
seen
 = 
set
 ( )

3592 for 
ch
 in 
expanding_chars
 :

3593 if 
self
 . 
matches
 ( 
ord
 ( 
ch
 ) ) :

3594 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
ch
 )

3595 if 
folded
 not in 
seen
 :

3596 
items
 . 
append
 ( 
String
 ( [ 
ord
 ( 
c
 ) for 
c
 in 
folded
 ] ,

3597 
case_flags
 = 
self
 . 
case_flags
 ) )

3598 
seen
 . 
add
 ( 
folded
 )

3600 if not 
items
 :

3602 return 
self

3604 return 
Branch
 ( [ 
self
 ] + 
items
 ) 
	}

3606 def 
	$max_width
 ( 
self
 ) :

3608 if not 
self
 . 
positive
 or not ( 
self
 . 
case_flags
 & 
IGNORECASE
 ) :

3612 if ( not ( 
self
 . 
info
 . 
flags
 & 
UNICODE
 ) or ( 
self
 . 
case_flags
 &

3613 
FULLIGNORECASE
 ) != 
FULLIGNORECASE
 ) :

3617 
expanding_chars
 = 
_regex
 . 
get_expand_on_folding
 ( )

3620 
seen
 = 
set
 ( )

3621 for 
ch
 in 
expanding_chars
 :

3622 if 
self
 . 
matches
 ( 
ord
 ( 
ch
 ) ) :

3623 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
ch
 )

3624 
seen
 . 
add
 ( 
folded
 )

3626 if not 
seen
 :

3629 return 
max
 ( 
len
 ( 
folded
 ) for 
folded
 in 
seen
 ) 
	}

3631 class 
	cSetDiff
 ( 
SetBase
 ) :

3632 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
SET_DIFF
 , ( 
IGNORECASE
 , False ) :

3633 
OP
 . 
SET_DIFF_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
SET_DIFF
 , ( 
FULLIGNORECASE
 , False ) :

3634 
OP
 . 
SET_DIFF_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
SET_DIFF_REV
 , ( 
IGNORECASE
 , True ) :

3635 
OP
 . 
SET_DIFF_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
SET_DIFF_REV
 , ( 
FULLIGNORECASE
 ,

3636 True ) : 
OP
 . 
SET_DIFF_IGN_REV
 }

3637 
_op_name
 = "SET_DIFF"

3639 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3640 
items
 = 
self
 . 
items

3641 if 
len
 ( 
items
 ) > 2 :

3642 
items
 = [ 
items
 [ 0 ] , 
SetUnion
 ( 
info
 , 
items
 [ 1 : ] ) ]

3644 if 
len
 ( 
items
 ) == 1 :

3645 return 
items
 [ 0 ] . 
with_flags
 ( 
case_flags
 = 
self
 . 
case_flags
 ,

3646 
zerowidth
 = 
self
 . 
zerowidth
 ) . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 )

3648 
self
 . 
items
 = 
tuple
 ( 
m
 . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 = True ) for 
m
 in

3649 
items
 )

3651 return 
self
 . 
_handle_case_folding
 ( 
info
 , 
in_set
 ) 
	}

3653 def 
	$matches
 ( 
self
 , 
ch
 ) :

3654 
m
 = 
self
 . 
items
 [ 0 ] . 
matches
 ( 
ch
 ) and not 
self
 . 
items
 [ 1 ] . 
matches
 ( 
ch
 )

3655 return 
m
 == 
self
 . 
positive
 
	}

3657 class 
	cSetInter
 ( 
SetBase
 ) :

3658 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
SET_INTER
 , ( 
IGNORECASE
 , False ) :

3659 
OP
 . 
SET_INTER_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
SET_INTER
 , ( 
FULLIGNORECASE
 ,

3660 False ) : 
OP
 . 
SET_INTER_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
SET_INTER_REV
 , ( 
IGNORECASE
 ,

3661 True ) : 
OP
 . 
SET_INTER_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
SET_INTER_REV
 ,

3662 ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
SET_INTER_IGN_REV
 }

3663 
_op_name
 = "SET_INTER"

3665 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3666 
items
 = [ ]

3667 for 
m
 in 
self
 . 
items
 :

3668 
m
 = 
m
 . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 = True )

3669 if 
isinstance
 ( 
m
 , 
SetInter
 ) and 
m
 . 
positive
 :

3671 
items
 . 
extend
 ( 
m
 . 
items
 )

3673 
items
 . 
append
 ( 
m
 )

3675 if 
len
 ( 
items
 ) == 1 :

3676 return 
items
 [ 0 ] . 
with_flags
 ( 
case_flags
 = 
self
 . 
case_flags
 ,

3677 
zerowidth
 = 
self
 . 
zerowidth
 ) . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 )

3679 
self
 . 
items
 = 
tuple
 ( 
items
 )

3681 return 
self
 . 
_handle_case_folding
 ( 
info
 , 
in_set
 ) 
	}

3683 def 
	$matches
 ( 
self
 , 
ch
 ) :

3684 
m
 = 
all
 ( 
i
 . 
matches
 ( 
ch
 ) for 
i
 in 
self
 . 
items
 )

3685 return 
m
 == 
self
 . 
positive
 
	}

3687 class 
	cSetSymDiff
 ( 
SetBase
 ) :

3688 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
SET_SYM_DIFF
 , ( 
IGNORECASE
 , False ) :

3689 
OP
 . 
SET_SYM_DIFF_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
SET_SYM_DIFF
 , ( 
FULLIGNORECASE
 ,

3690 False ) : 
OP
 . 
SET_SYM_DIFF_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
SET_SYM_DIFF_REV
 ,

3691 ( 
IGNORECASE
 , True ) : 
OP
 . 
SET_SYM_DIFF_IGN_REV
 , ( 
FULLCASE
 , True ) :

3692 
OP
 . 
SET_SYM_DIFF_REV
 , ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
SET_SYM_DIFF_IGN_REV
 }

3693 
_op_name
 = "SET_SYM_DIFF"

3695 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3696 
items
 = [ ]

3697 for 
m
 in 
self
 . 
items
 :

3698 
m
 = 
m
 . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 = True )

3699 if 
isinstance
 ( 
m
 , 
SetSymDiff
 ) and 
m
 . 
positive
 :

3701 
items
 . 
extend
 ( 
m
 . 
items
 )

3703 
items
 . 
append
 ( 
m
 )

3705 if 
len
 ( 
items
 ) == 1 :

3706 return 
items
 [ 0 ] . 
with_flags
 ( 
case_flags
 = 
self
 . 
case_flags
 ,

3707 
zerowidth
 = 
self
 . 
zerowidth
 ) . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 )

3709 
self
 . 
items
 = 
tuple
 ( 
items
 )

3711 return 
self
 . 
_handle_case_folding
 ( 
info
 , 
in_set
 ) 
	}

3713 def 
	$matches
 ( 
self
 , 
ch
 ) :

3714 
m
 = False

3715 for 
i
 in 
self
 . 
items
 :

3716 
m
 = 
m
 != 
i
 . 
matches
 ( 
ch
 )

3718 return 
m
 == 
self
 . 
positive
 
	}

3720 class 
	cSetUnion
 ( 
SetBase
 ) :

3721 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
SET_UNION
 , ( 
IGNORECASE
 , False ) :

3722 
OP
 . 
SET_UNION_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
SET_UNION
 , ( 
FULLIGNORECASE
 ,

3723 False ) : 
OP
 . 
SET_UNION_IGN
 , ( 
NOCASE
 , True ) : 
OP
 . 
SET_UNION_REV
 , ( 
IGNORECASE
 ,

3724 True ) : 
OP
 . 
SET_UNION_IGN_REV
 , ( 
FULLCASE
 , True ) : 
OP
 . 
SET_UNION_REV
 ,

3725 ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
SET_UNION_IGN_REV
 }

3726 
_op_name
 = "SET_UNION"

3728 def 
	$optimise
 ( 
self
 , 
info
 , 
reverse
 , 
in_set
 = False ) :

3729 
items
 = [ ]

3730 for 
m
 in 
self
 . 
items
 :

3731 
m
 = 
m
 . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 = True )

3732 if 
isinstance
 ( 
m
 , 
SetUnion
 ) and 
m
 . 
positive
 :

3734 
items
 . 
extend
 ( 
m
 . 
items
 )

3736 
items
 . 
append
 ( 
m
 )

3738 if 
len
 ( 
items
 ) == 1 :

3739 
i
 = 
items
 [ 0 ]

3740 return 
i
 . 
with_flags
 ( 
positive
 = 
i
 . 
positive
 == 
self
 . 
positive
 ,

3741 
case_flags
 = 
self
 . 
case_flags
 ,

3742 
zerowidth
 = 
self
 . 
zerowidth
 ) . 
optimise
 ( 
info
 , 
reverse
 , 
in_set
 )

3744 
self
 . 
items
 = 
tuple
 ( 
items
 )

3746 return 
self
 . 
_handle_case_folding
 ( 
info
 , 
in_set
 ) 
	}

3748 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3749 
flags
 = 0

3750 if 
self
 . 
positive
 :

3751 
flags
 |= 
POSITIVE_OP

3752 if 
self
 . 
zerowidth
 :

3753 
flags
 |= 
ZEROWIDTH_OP

3754 if 
fuzzy
 :

3755 
flags
 |= 
FUZZY_OP

3757 
characters
 , 
others
 = 
defaultdict
 ( 
list
 ) , [ ]

3758 for 
m
 in 
self
 . 
items
 :

3759 if 
isinstance
 ( 
m
 , 
Character
 ) :

3760 
characters
 [ 
m
 . 
positive
 ] . 
append
 ( 
m
 . 
value
 )

3762 
others
 . 
append
 ( 
m
 )

3764 
code
 = [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 ) ]

3766 for 
positive
 , 
values
 in 
characters
 . 
items
 ( ) :

3767 
flags
 = 0

3768 if 
positive
 :

3769 
flags
 |= 
POSITIVE_OP

3770 if 
len
 ( 
values
 ) == 1 :

3771 
code
 . 
append
 ( ( 
OP
 . 
CHARACTER
 , 
flags
 , 
values
 [ 0 ] ) )

3773 
code
 . 
append
 ( ( 
OP
 . 
STRING
 , 
flags
 , 
len
 ( 
values
 ) ) + 
tuple
 ( 
values
 ) )

3775 for 
m
 in 
others
 :

3776 
code
 . 
extend
 ( 
m
 . 
compile
 ( ) )

3778 
code
 . 
append
 ( ( 
OP
 . 
END
 , ) )

3780 return 
code
 
	}

3782 def 
	$matches
 ( 
self
 , 
ch
 ) :

3783 
m
 = 
any
 ( 
i
 . 
matches
 ( 
ch
 ) for 
i
 in 
self
 . 
items
 )

3784 return 
m
 == 
self
 . 
positive
 
	}

3786 class 
	cSkip
 ( 
ZeroWidthBase
 ) :

3787 
_op_name
 = "SKIP"

3788 
_opcode
 = 
OP
 . 
SKIP

3790 class 
	cStartOfLine
 ( 
ZeroWidthBase
 ) :

3791 
_opcode
 = 
OP
 . 
START_OF_LINE

3792 
_op_name
 = "START_OF_LINE"

3794 class 
	cStartOfLineU
 ( 
StartOfLine
 ) :

3795 
_opcode
 = 
OP
 . 
START_OF_LINE_U

3796 
_op_name
 = "START_OF_LINE_U"

3798 class 
	cStartOfString
 ( 
ZeroWidthBase
 ) :

3799 
_opcode
 = 
OP
 . 
START_OF_STRING

3800 
_op_name
 = "START_OF_STRING"

3802 class 
	cStartOfWord
 ( 
ZeroWidthBase
 ) :

3803 
_opcode
 = 
OP
 . 
START_OF_WORD

3804 
_op_name
 = "START_OF_WORD"

3806 class 
	cString
 ( 
RegexBase
 ) :

3807 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
STRING
 , ( 
IGNORECASE
 , False ) : 
OP
 . 
STRING_IGN
 ,

3808 ( 
FULLCASE
 , False ) : 
OP
 . 
STRING
 , ( 
FULLIGNORECASE
 , False ) : 
OP
 . 
STRING_FLD
 ,

3809 ( 
NOCASE
 , True ) : 
OP
 . 
STRING_REV
 , ( 
IGNORECASE
 , True ) : 
OP
 . 
STRING_IGN_REV
 ,

3810 ( 
FULLCASE
 , True ) : 
OP
 . 
STRING_REV
 , ( 
FULLIGNORECASE
 , True ) :

3811 
OP
 . 
STRING_FLD_REV
 }

3813 def 
	$__init__
 ( 
self
 , 
characters
 , 
case_flags
 = 
NOCASE
 ) :

3814 
self
 . 
characters
 = 
tuple
 ( 
characters
 )

3815 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3817 if ( 
self
 . 
case_flags
 & 
FULLIGNORECASE
 ) == 
FULLIGNORECASE
 :

3818 
folded_characters
 = [ ]

3819 for 
char
 in 
self
 . 
characters
 :

3820 
folded
 = 
_regex
 . 
fold_case
 ( 
FULL_CASE_FOLDING
 , 
chr
 ( 
char
 ) )

3821 
folded_characters
 . 
extend
 ( 
ord
 ( 
c
 ) for 
c
 in 
folded
 )

3823 
folded_characters
 = 
self
 . 
characters

3825 
self
 . 
folded_characters
 = 
tuple
 ( 
folded_characters
 )

3826 
self
 . 
required
 = False

3828 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
characters
 , 
self
 . 
case_flags
 
	}

3830 def 
	$get_firstset
 ( 
self
 , 
reverse
 ) :

3831 if 
reverse
 :

3832 
pos
 = - 1

3834 
pos
 = 0

3835 return 
set
 ( [ 
Character
 ( 
self
 . 
characters
 [ 
pos
 ] ,

3836 
case_flags
 = 
self
 . 
case_flags
 ) ] ) 
	}

3838 def 
	$has_simple_start
 ( 
self
 ) :

3839 return True 
	}

3841 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3842 
flags
 = 0

3843 if 
fuzzy
 :

3844 
flags
 |= 
FUZZY_OP

3845 if 
self
 . 
required
 :

3846 
flags
 |= 
REQUIRED_OP

3847 return [ ( 
self
 . 
_opcode
 [ 
self
 . 
case_flags
 , 
reverse
 ] , 
flags
 ,

3848 
len
 ( 
self
 . 
folded_characters
 ) ) + 
self
 . 
folded_characters
 ] 
	}

3850 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3851 
display
 = 
ascii
 ( "" . 
join
 ( 
chr
 ( 
c
 ) for 
c
 in 
self
 . 
characters
 ) ) . 
lstrip
 ( "bu" )

3852 
print
 ( "{}STRING {}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
display
 ,

3853 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3855 def 
	$max_width
 ( 
self
 ) :

3856 return 
len
 ( 
self
 . 
folded_characters
 ) 
	}

3858 def 
	$get_required_string
 ( 
self
 , 
reverse
 ) :

3859 return 0 , 
self
 
	}

3861 class 
	cLiteral
 ( 
String
 ) :

3862 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3863 
literal
 = '' . 
join
 ( 
chr
 ( 
c
 ) for 
c
 in 
self
 . 
characters
 )

3864 
display
 = 
ascii
 ( 
literal
 ) . 
lstrip
 ( "bu" )

3865 
print
 ( "{}LITERAL MATCH {}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
display
 ,

3866 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3868 class 
	cStringSet
 ( 
RegexBase
 ) :

3869 
_opcode
 = { ( 
NOCASE
 , False ) : 
OP
 . 
STRING_SET
 , ( 
IGNORECASE
 , False ) :

3870 
OP
 . 
STRING_SET_IGN
 , ( 
FULLCASE
 , False ) : 
OP
 . 
STRING_SET
 , ( 
FULLIGNORECASE
 ,

3871 False ) : 
OP
 . 
STRING_SET_FLD
 , ( 
NOCASE
 , True ) : 
OP
 . 
STRING_SET_REV
 ,

3872 ( 
IGNORECASE
 , True ) : 
OP
 . 
STRING_SET_IGN_REV
 , ( 
FULLCASE
 , True ) :

3873 
OP
 . 
STRING_SET_REV
 , ( 
FULLIGNORECASE
 , True ) : 
OP
 . 
STRING_SET_FLD_REV
 }

3875 def 
	$__init__
 ( 
self
 , 
info
 , 
name
 , 
case_flags
 = 
NOCASE
 ) :

3876 
self
 . 
info
 = 
info

3877 
self
 . 
name
 = 
name

3878 
self
 . 
case_flags
 = 
CASE_FLAGS_COMBINATIONS
 [ 
case_flags
 ]

3880 
self
 . 
_key
 = 
self
 . 
__class__
 , 
self
 . 
name
 , 
self
 . 
case_flags

3882 
self
 . 
set_key
 = ( 
name
 , 
self
 . 
case_flags
 )

3883 if 
self
 . 
set_key
 not in 
info
 . 
named_lists_used
 :

3884 
info
 . 
named_lists_used
 [ 
self
 . 
set_key
 ] = 
len
 ( 
info
 . 
named_lists_used
 ) 
	}

3886 def 
	$_compile
 ( 
self
 , 
reverse
 , 
fuzzy
 ) :

3887 
index
 = 
self
 . 
info
 . 
named_lists_used
 [ 
self
 . 
set_key
 ]

3888 
items
 = 
self
 . 
info
 . 
kwargs
 [ 
self
 . 
name
 ]

3890 
case_flags
 = 
self
 . 
case_flags

3892 if not 
items
 :

3895 
encoding
 = 
self
 . 
info
 . 
flags
 & 
_ALL_ENCODINGS

3896 
fold_flags
 = 
encoding
 | 
case_flags

3898 if 
fuzzy
 :

3899 
choices
 = [ 
self
 . 
_folded
 ( 
fold_flags
 , 
i
 ) for 
i
 in 
items
 ]

3902 
choices
 . 
sort
 ( 
key
 = lambda 
s
 : ( - 
len
 ( 
s
 ) , 
s
 ) )

3904 
branches
 = [ ]

3905 for 
string
 in 
choices
 :

3906 
branches
 . 
append
 ( 
Sequence
 ( [ 
Character
 ( 
c
 , 
case_flags
 = 
case_flags
 )

3907 for 
c
 in 
string
 ] ) )

3909 if 
len
 ( 
branches
 ) > 1 :

3910 
branch
 = 
Branch
 ( 
branches
 )

3912 
branch
 = 
branches
 [ 0 ]

3913 
branch
 = 
branch
 . 
optimise
 ( 
self
 . 
info
 ,

3914 
reverse
 ) . 
pack_characters
 ( 
self
 . 
info
 )

3916 return 
branch
 . 
compile
 ( 
reverse
 , 
fuzzy
 )

3918 
min_len
 = 
min
 ( 
len
 ( 
i
 ) for 
i
 in 
items
 )

3919 
max_len
 = 
max
 ( 
len
 ( 
self
 . 
_folded
 ( 
fold_flags
 , 
i
 ) ) for 
i
 in 
items
 )

3920 return [ ( 
self
 . 
_opcode
 [ 
case_flags
 , 
reverse
 ] , 
index
 , 
min_len
 ,

3921 
max_len
 ) ] 
	}

3923 def 
	$dump
 ( 
self
 , 
indent
 , 
reverse
 ) :

3924 
print
 ( "{}STRING_SET {}{}" . 
format
 ( 
INDENT
 * 
indent
 , 
self
 . 
name
 ,

3925 
CASE_TEXT
 [ 
self
 . 
case_flags
 ] ) ) 
	}

3927 def 
	$_folded
 ( 
self
 , 
fold_flags
 , 
item
 ) :

3928 if 
isinstance
 ( 
item
 , 
str
 ) :

3929 return [ 
ord
 ( 
c
 ) for 
c
 in 
_regex
 . 
fold_case
 ( 
fold_flags
 , 
item
 ) ]

3931 return 
list
 ( 
item
 ) 
	}

3933 def 
	$_flatten
 ( 
self
 , 
s
 ) :

3935 if 
isinstance
 ( 
s
 , 
Branch
 ) :

3936 for 
b
 in 
s
 . 
branches
 :

3937 
self
 . 
_flatten
 ( 
b
 )

3938 elif 
isinstance
 ( 
s
 , 
Sequence
 ) and 
s
 . 
items
 :

3939 
seq
 = 
s
 . 
items

3941 while 
isinstance
 ( 
seq
 [ - 1 ] , 
Sequence
 ) :

3942 
seq
 [ - 1 : ] = 
seq
 [ - 1 ] . 
items

3944 
n
 = 0

3945 while 
n
 < 
len
 ( 
seq
 ) and 
isinstance
 ( 
seq
 [ 
n
 ] , 
Character
 ) :

3946 
n
 += 1

3948 if 
n
 > 1 :

3949 
seq
 [ : 
n
 ] = [ 
String
 ( [ 
c
 . 
value
 for 
c
 in 
seq
 [ : 
n
 ] ] ,

3950 
case_flags
 = 
self
 . 
case_flags
 ) ]

3952 
self
 . 
_flatten
 ( 
seq
 [ - 1 ] ) 
	}

3954 def 
	$max_width
 ( 
self
 ) :

3955 if not 
self
 . 
info
 . 
kwargs
 [ 
self
 . 
name
 ] :

3958 if 
self
 . 
case_flags
 & 
IGNORECASE
 :

3959 
fold_flags
 = ( 
self
 . 
info
 . 
flags
 & 
_ALL_ENCODINGS
 ) | 
self
 . 
case_flags

3960 return 
max
 ( 
len
 ( 
_regex
 . 
fold_case
 ( 
fold_flags
 , 
i
 ) ) for 
i
 in

3961 
self
 . 
info
 . 
kwargs
 [ 
self
 . 
name
 ] )

3963 return 
max
 ( 
len
 ( 
i
 ) for 
i
 in 
self
 . 
info
 . 
kwargs
 [ 
self
 . 
name
 ] ) 
	}

3965 class 
	cSource
 :

3967 def 
	$__init__
 ( 
self
 , 
string
 ) :

3968 if 
isinstance
 ( 
string
 , 
str
 ) :

3969 
self
 . 
string
 = 
string

3970 
self
 . 
char_type
 = 
chr

3972 
self
 . 
string
 = 
string
 . 
decode
 ( "latin-1" )

3973 
self
 . 
char_type
 = lambda 
c
 : 
bytes
 ( [ 
c
 ] )

3975 
self
 . 
pos
 = 0

3976 
self
 . 
ignore_space
 = False

3977 
self
 . 
sep
 = 
string
 [ : 0 ] 
	}

3979 def 
	$get
 ( 
self
 ) :

3980 
string
 = 
self
 . 
string

3981 
pos
 = 
self
 . 
pos

3984 if 
self
 . 
ignore_space
 :

3986 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

3988 
pos
 += 1

3989 elif 
string
 [ 
pos
 ] == "#" :

3991 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

3995 
ch
 = 
string
 [ 
pos
 ]

3996 
self
 . 
pos
 = 
pos
 + 1

3997 return 
ch

3998 except 
IndexError
 :

4000 
self
 . 
pos
 = 
pos

4001 return 
string
 [ : 0 ]

4002 except 
ValueError
 :

4004 
self
 . 
pos
 = 
len
 ( 
string
 )

4005 return 
string
 [ : 0 ] 
	}

4007 def 
	$get_many
 ( 
self
 , 
count
 = 1 ) :

4008 
string
 = 
self
 . 
string

4009 
pos
 = 
self
 . 
pos

4012 if 
self
 . 
ignore_space
 :

4013 
substring
 = [ ]

4015 while 
len
 ( 
substring
 ) < 
count
 :

4017 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

4019 
pos
 += 1

4020 elif 
string
 [ 
pos
 ] == "#" :

4022 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

4026 
substring
 . 
append
 ( 
string
 [ 
pos
 ] )

4027 
pos
 += 1

4029 
substring
 = "" . 
join
 ( 
substring
 )

4031 
substring
 = 
string
 [ 
pos
 : 
pos
 + 
count
 ]

4032 
pos
 += 
len
 ( 
substring
 )

4034 
self
 . 
pos
 = 
pos

4035 return 
substring

4036 except 
IndexError
 :

4038 
self
 . 
pos
 = 
len
 ( 
string
 )

4039 return "" . 
join
 ( 
substring
 )

4040 except 
ValueError
 :

4042 
self
 . 
pos
 = 
len
 ( 
string
 )

4043 return "" . 
join
 ( 
substring
 ) 
	}

4045 def 
	$get_while
 ( 
self
 , 
test_set
 , 
include
 = True ) :

4046 
string
 = 
self
 . 
string

4047 
pos
 = 
self
 . 
pos

4049 if 
self
 . 
ignore_space
 :

4051 
substring
 = [ ]

4054 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

4056 
pos
 += 1

4057 elif 
string
 [ 
pos
 ] == "#" :

4059 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

4060 elif ( 
string
 [ 
pos
 ] in 
test_set
 ) == 
include
 :

4061 
substring
 . 
append
 ( 
string
 [ 
pos
 ] )

4062 
pos
 += 1

4066 
self
 . 
pos
 = 
pos

4067 except 
IndexError
 :

4069 
self
 . 
pos
 = 
len
 ( 
string
 )

4070 except 
ValueError
 :

4072 
self
 . 
pos
 = 
len
 ( 
string
 )

4074 return "" . 
join
 ( 
substring
 )

4077 while ( 
string
 [ 
pos
 ] in 
test_set
 ) == 
include
 :

4078 
pos
 += 1

4080 
substring
 = 
string
 [ 
self
 . 
pos
 : 
pos
 ]

4082 
self
 . 
pos
 = 
pos

4084 return 
substring

4085 except 
IndexError
 :

4087 
substring
 = 
string
 [ 
self
 . 
pos
 : 
pos
 ]

4089 
self
 . 
pos
 = 
pos

4091 return 
substring
 
	}

4093 def 
	$skip_while
 ( 
self
 , 
test_set
 , 
include
 = True ) :

4094 
string
 = 
self
 . 
string

4095 
pos
 = 
self
 . 
pos

4098 if 
self
 . 
ignore_space
 :

4100 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

4102 
pos
 += 1

4103 elif 
string
 [ 
pos
 ] == "#" :

4105 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

4106 elif ( 
string
 [ 
pos
 ] in 
test_set
 ) == 
include
 :

4107 
pos
 += 1

4111 while ( 
string
 [ 
pos
 ] in 
test_set
 ) == 
include
 :

4112 
pos
 += 1

4114 
self
 . 
pos
 = 
pos

4115 except 
IndexError
 :

4117 
self
 . 
pos
 = 
len
 ( 
string
 )

4118 except 
ValueError
 :

4120 
self
 . 
pos
 = 
len
 ( 
string
 ) 
	}

4122 def 
	$match
 ( 
self
 , 
substring
 ) :

4123 
string
 = 
self
 . 
string

4124 
pos
 = 
self
 . 
pos

4126 if 
self
 . 
ignore_space
 :

4128 for 
c
 in 
substring
 :

4130 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

4132 
pos
 += 1

4133 elif 
string
 [ 
pos
 ] == "#" :

4135 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

4139 if 
string
 [ 
pos
 ] != 
c
 :

4142 
pos
 += 1

4144 
self
 . 
pos
 = 
pos

4147 except 
IndexError
 :

4150 except 
ValueError
 :

4154 if not 
string
 . 
startswith
 ( 
substring
 , 
pos
 ) :

4157 
self
 . 
pos
 = 
pos
 + 
len
 ( 
substring
 )

4159 return True 
	}

4161 def 
	$expect
 ( 
self
 , 
substring
 ) :

4162 if not 
self
 . 
match
 ( 
substring
 ) :

4163 raise 
error
 ( "missing {}" . 
format
 ( 
substring
 ) , 
self
 . 
string
 , 
self
 . 
pos
 ) 
	}

4165 def 
	$at_end
 ( 
self
 ) :

4166 
string
 = 
self
 . 
string

4167 
pos
 = 
self
 . 
pos

4170 if 
self
 . 
ignore_space
 :

4172 if 
string
 [ 
pos
 ] . 
isspace
 ( ) :

4173 
pos
 += 1

4174 elif 
string
 [ 
pos
 ] == "#" :

4175 
pos
 = 
string
 . 
index
 ( "\n" , 
pos
 )

4179 return 
pos
 >= 
len
 ( 
string
 )

4180 except 
IndexError
 :

4183 except 
ValueError
 :

4185 return True 
	}

4187 class 
	cInfo
 :

4190 def 
	$__init__
 ( 
self
 , 
flags
 = 0 , 
char_type
 = None , 
kwargs
 = { } ) :

4191 
flags
 |= 
DEFAULT_FLAGS
 [ ( 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION
 ]

4192 
self
 . 
flags
 = 
flags

4193 
self
 . 
global_flags
 = 
flags

4194 
self
 . 
inline_locale
 = False

4196 
self
 . 
kwargs
 = 
kwargs

4198 
self
 . 
group_count
 = 0

4199 
self
 . 
group_index
 = { }

4200 
self
 . 
group_name
 = { }

4201 
self
 . 
char_type
 = 
char_type

4202 
self
 . 
named_lists_used
 = { }

4203 
self
 . 
open_groups
 = [ ]

4204 
self
 . 
open_group_count
 = { }

4205 
self
 . 
defined_groups
 = { }

4206 
self
 . 
group_calls
 = [ ]

4207 
self
 . 
private_groups
 = { } 
	}

4209 def 
	$open_group
 ( 
self
 , 
name
 = None ) :

4210 
group
 = 
self
 . 
group_index
 . 
get
 ( 
name
 )

4211 if 
group
 is None :

4213 
self
 . 
group_count
 += 1

4214 if 
name
 is None or 
self
 . 
group_count
 not in 
self
 . 
group_name
 :

4217 
group
 = 
self
 . 
group_count

4218 if 
name
 :

4219 
self
 . 
group_index
 [ 
name
 ] = 
group

4220 
self
 . 
group_name
 [ 
group
 ] = 
name

4222 if 
group
 in 
self
 . 
open_groups
 :

4226 
group_alias
 = - ( 
len
 ( 
self
 . 
private_groups
 ) + 1 )

4227 
self
 . 
private_groups
 [ 
group_alias
 ] = 
group

4228 
group
 = 
group_alias

4230 
self
 . 
open_groups
 . 
append
 ( 
group
 )

4231 
self
 . 
open_group_count
 [ 
group
 ] = 
self
 . 
open_group_count
 . 
get
 ( 
group
 , 0 ) + 1

4233 return 
group
 
	}

4235 def 
	$close_group
 ( 
self
 ) :

4236 
self
 . 
open_groups
 . 
pop
 ( ) 
	}

4238 def 
	$is_open_group
 ( 
self
 , 
name
 ) :

4241 
version
 = ( 
self
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

4242 if 
version
 == 
VERSION1
 :

4245 if 
name
 . 
isdigit
 ( ) :

4246 
group
 = 
int
 ( 
name
 )

4248 
group
 = 
self
 . 
group_index
 . 
get
 ( 
name
 )

4250 return 
group
 in 
self
 . 
open_groups
 
	}

4252 def 
	$_check_group_features
 ( 
info
 , 
parsed
 ) :

4256 
call_refs
 = { }

4257 
additional_groups
 = [ ]

4258 for 
call
 , 
reverse
 , 
fuzzy
 in 
info
 . 
group_calls
 :

4260 
key
 = ( 
call
 . 
group
 , 
reverse
 , 
fuzzy
 )

4261 
ref
 = 
call_refs
 . 
get
 ( 
key
 )

4262 if 
ref
 is None :

4264 if 
call
 . 
group
 == 0 :

4266 
rev
 = 
bool
 ( 
info
 . 
flags
 & 
REVERSE
 )

4267 
fuz
 = 
isinstance
 ( 
parsed
 , 
Fuzzy
 )

4268 if ( 
rev
 , 
fuz
 ) != ( 
reverse
 , 
fuzzy
 ) :

4272 
additional_groups
 . 
append
 ( ( 
CallRef
 ( 
len
 ( 
call_refs
 ) , 
parsed
 ) ,

4273 
reverse
 , 
fuzzy
 ) )

4276 
def_info
 = 
info
 . 
defined_groups
 [ 
call
 . 
group
 ]

4277 
group
 = 
def_info
 [ 0 ]

4278 if 
def_info
 [ 1 : ] != ( 
reverse
 , 
fuzzy
 ) :

4281 
additional_groups
 . 
append
 ( ( 
group
 , 
reverse
 , 
fuzzy
 ) )

4283 
ref
 = 
len
 ( 
call_refs
 )

4284 
call_refs
 [ 
key
 ] = 
ref

4286 
call
 . 
call_ref
 = 
ref

4288 
info
 . 
call_refs
 = 
call_refs

4289 
info
 . 
additional_groups
 = 
additional_groups
 
	}

4291 def 
	$_get_required_string
 ( 
parsed
 , 
flags
 ) :

4294 
req_offset
 , 
required
 = 
parsed
 . 
get_required_string
 ( 
bool
 ( 
flags
 & 
REVERSE
 ) )

4295 if 
required
 :

4296 
required
 . 
required
 = True

4297 if 
req_offset
 >= 
UNLIMITED
 :

4298 
req_offset
 = - 1

4300 
req_flags
 = 
required
 . 
case_flags

4301 if not ( 
flags
 & 
UNICODE
 ) :

4302 
req_flags
 &= ~ 
UNICODE

4304 
req_chars
 = 
required
 . 
folded_characters

4306 
req_offset
 = 0

4307 
req_chars
 = ( )

4308 
req_flags
 = 0

4310 return 
req_offset
 , 
req_chars
 , 
req_flags
 
	}

4312 class 
	cScanner
 :

4313 def 
	$__init__
 ( 
self
 , 
lexicon
 , 
flags
 = 0 ) :

4314 
self
 . 
lexicon
 = 
lexicon

4317 
patterns
 = [ ]

4318 for 
phrase
 , 
action
 in 
lexicon
 :

4320 
source
 = 
Source
 ( 
phrase
 )

4321 
info
 = 
Info
 ( 
flags
 , 
source
 . 
char_type
 )

4322 
source
 . 
ignore_space
 = 
bool
 ( 
info
 . 
flags
 & 
VERBOSE
 )

4323 
parsed
 = 
_parse_pattern
 ( 
source
 , 
info
 )

4324 if not 
source
 . 
at_end
 ( ) :

4325 raise 
error
 ( "unbalanced parenthesis" , 
source
 . 
string
 ,

4326 
source
 . 
pos
 )

4329 
patterns
 . 
append
 ( 
parsed
 . 
remove_captures
 ( ) )

4332 
info
 = 
Info
 ( 
flags
 )

4333 
patterns
 = [ 
Group
 ( 
info
 , 
g
 + 1 , 
p
 ) for 
g
 , 
p
 in 
enumerate
 ( 
patterns
 ) ]

4334 
parsed
 = 
Branch
 ( 
patterns
 )

4337 
reverse
 = 
bool
 ( 
info
 . 
flags
 & 
REVERSE
 )

4338 
parsed
 = 
parsed
 . 
optimise
 ( 
info
 , 
reverse
 )

4339 
parsed
 = 
parsed
 . 
pack_characters
 ( 
info
 )

4342 
req_offset
 , 
req_chars
 , 
req_flags
 = 
_get_required_string
 ( 
parsed
 ,

4343 
info
 . 
flags
 )

4346 
_check_group_features
 ( 
info
 , 
parsed
 )

4350 if 
info
 . 
call_refs
 :

4351 raise 
error
 ( "recursive regex not supported by Scanner" ,

4352 
source
 . 
string
 , 
source
 . 
pos
 )

4354 
reverse
 = 
bool
 ( 
info
 . 
flags
 & 
REVERSE
 )

4357 
code
 = 
parsed
 . 
compile
 ( 
reverse
 ) + [ ( 
OP
 . 
SUCCESS
 , ) ]

4360 
code
 = 
_flatten_code
 ( 
code
 )

4362 if not 
parsed
 . 
has_simple_start
 ( ) :

4365 
fs_code
 = 
_compile_firstset
 ( 
info
 , 
parsed
 . 
get_firstset
 ( 
reverse
 ) )

4366 
fs_code
 = 
_flatten_code
 ( 
fs_code
 )

4367 
code
 = 
fs_code
 + 
code

4368 except 
_FirstSetError
 :

4372 
version
 = ( 
info
 . 
flags
 & 
_ALL_VERSIONS
 ) or 
DEFAULT_VERSION

4373 if 
version
 not in ( 0 , 
VERSION0
 , 
VERSION1
 ) :

4374 raise 
ValueError
 ( "VERSION0 and VERSION1 flags are mutually incompatible" )

4382 
self
 . 
scanner
 = 
_regex
 . 
compile
 ( None , ( 
flags
 & 
GLOBAL_FLAGS
 ) | 
version
 ,

4383 
code
 , { } , { } , { } , [ ] , 
req_offset
 , 
req_chars
 , 
req_flags
 ,

4384 
len
 ( 
patterns
 ) ) 
	}

4386 def 
	$scan
 ( 
self
 , 
string
 ) :

4387 
result
 = [ ]

4388 
append
 = 
result
 . 
append

4389 
match
 = 
self
 . 
scanner
 . 
scanner
 ( 
string
 ) . 
match

4390 
i
 = 0

4392 
m
 = 
match
 ( )

4393 if not 
m
 :

4395 
j
 = 
m
 . 
end
 ( )

4396 if 
i
 == 
j
 :

4398 
action
 = 
self
 . 
lexicon
 [ 
m
 . 
lastindex
 - 1 ] [ 1 ]

4399 if 
hasattr
 ( 
action
 , '__call__' ) :

4400 
self
 . 
match
 = 
m

4401 
action
 = 
action
 ( 
self
 , 
m
 . 
group
 ( ) )

4402 if 
action
 is not None :

4403 
append
 ( 
action
 )

4404 
i
 = 
j

4406 return 
result
 , 
string
 [ 
i
 : ] 
	}

4409 
PROPERTIES
 = 
_regex
 . 
get_properties
 ( )

4412 
PROPERTY_NAMES
 = { }

4413 for 
prop_name
 , ( 
prop_id
 , 
values
 ) in 
PROPERTIES
 . 
items
 ( ) :

4414 
name
 , 
prop_values
 = 
PROPERTY_NAMES
 . 
get
 ( 
prop_id
 , ( "" , { } ) )

4415 
name
 = 
max
 ( 
name
 , 
prop_name
 , 
key
 = 
len
 )

4416 
PROPERTY_NAMES
 [ 
prop_id
 ] = 
name
 , 
prop_values

4418 for 
val_name
 , 
val_id
 in 
values
 . 
items
 ( ) :

4419 
prop_values
 [ 
val_id
 ] = 
max
 ( 
prop_values
 . 
get
 ( 
val_id
 , "" ) , 
val_name
 ,

4420 
key
 = 
len
 )

4423 
CHARACTER_ESCAPES
 = { "a"

4434 
CHARSET_ESCAPES
 = { "d"

4435 : 
lookup_property
 ( None , "Digit" , True ) , "D"

4436 : 
lookup_property
 ( None , "Digit" , False ) , "s"

4437 : 
lookup_property
 ( None , "Space" , True ) , "S"

4438 : 
lookup_property
 ( None , "Space" , False ) , "w"

4439 : 
lookup_property
 ( None , "Word" , True ) , "W"

4440 : 
lookup_property
 ( None , "Word" , False ) ,

4444 
POSITION_ESCAPES
 = { "A"

4445 : 
StartOfString
 ( ) , "b"

4446 : 
Boundary
 ( ) , "B"

4447 : 
Boundary
 ( False ) , "K"

4448 : 
Keep
 ( ) , "m"

4449 : 
StartOfWord
 ( ) , "M"

4450 : 
EndOfWord
 ( ) , "Z"

4451 : 
EndOfString
 ( ) ,

4455 
WORD_POSITION_ESCAPES
 = 
dict
 ( 
POSITION_ESCAPES
 )

4456 
WORD_POSITION_ESCAPES
 . 
update
 ( { "b"

4457 : 
DefaultBoundary
 ( ) , "B"

4458 : 
DefaultBoundary
 ( False ) , "m"

4459 : 
DefaultStartOfWord
 ( ) , "M"

4460 : 
DefaultEndOfWord
 ( ) ,

4464 
VERBS
 = { "FAIL"

4465 : 
Failure
 ( ) , "F"

4466 : 
Failure
 ( ) , "PRUNE"

4467 : 
Prune
 ( ) , "SKIP"

4468 : 
Skip
 ( ) ,


	@./env/lib/python3.7/site-packages/regex/__init__.py

1 from . 
	~regex
 import *

2 from . import 
regex

3 
__all__
 = 
regex
 . 
__all__


	@./env/lib/python3.7/site-packages/setuptools/depends.py

1 import 
	~sys

2 import 
	~imp

3 import 
	~marshal

4 from 
	~distutils.version
 import 
StrictVersion

5 from 
	~imp
 import 
PKG_DIRECTORY
 , 
PY_COMPILED
 , 
PY_SOURCE
 , 
PY_FROZEN

7 from . 
	~py33compat
 import 
Bytecode

10 
__all__
 = [ 'Require'

15 class 
	cRequire
 :

18 def 
	$__init__
 ( 
self
 , 
name
 , 
requested_version
 , 
module
 , 
homepage
 = '' ,

19 
attribute
 = None , 
format
 = None ) :

21 if 
format
 is None and 
requested_version
 is not None :

22 
format
 = 
StrictVersion

24 if 
format
 is not None :

25 
requested_version
 = 
format
 ( 
requested_version
 )

26 if 
attribute
 is None :

27 
attribute
 = '__version__'

29 
self
 . 
__dict__
 . 
update
 ( 
locals
 ( ) )

30 del 
self
 . 
self
 
	}

32 def 
	$full_name
 ( 
self
 ) :

34 if 
self
 . 
requested_version
 is not None :

35 return '%s-%s' % ( 
self
 . 
name
 , 
self
 . 
requested_version
 )

36 return 
self
 . 
name
 
	}

38 def 
	$version_ok
 ( 
self
 , 
version
 ) :

40 return 
self
 . 
attribute
 is None or 
self
 . 
format
 is None or

41 
str
 ( 
version
 ) != "unknown" and 
version
 >= 
self
 . 
requested_version
 
	}

43 def 
	$get_version
 ( 
self
 , 
paths
 = None , 
default
 = "unknown" ) :

54 if 
self
 . 
attribute
 is None :

56 
f
 , 
p
 , 
i
 = 
find_module
 ( 
self
 . 
module
 , 
paths
 )

57 if 
f
 :

58 
f
 . 
close
 ( )

59 return 
default

60 except 
ImportError
 :

63 
v
 = 
get_module_constant
 ( 
self
 . 
module
 , 
self
 . 
attribute
 , 
default
 , 
paths
 )

65 if 
v
 is not None and 
v
 is not 
default
 and 
self
 . 
format
 is not None :

66 return 
self
 . 
format
 ( 
v
 )

68 return 
v
 
	}

70 def 
	$is_present
 ( 
self
 , 
paths
 = None ) :

72 return 
self
 . 
get_version
 ( 
paths
 ) is not None 
	}

74 def 
	$is_current
 ( 
self
 , 
paths
 = None ) :

76 
version
 = 
self
 . 
get_version
 ( 
paths
 )

77 if 
version
 is None :

79 return 
self
 . 
version_ok
 ( 
version
 ) 
	}

82 def 
	$find_module
 ( 
module
 , 
paths
 = None ) :

85 
parts
 = 
module
 . 
split
 ( '.' )

87 while 
parts
 :

88 
part
 = 
parts
 . 
pop
 ( 0 )

89 
f
 , 
path
 , ( 
suffix
 , 
mode
 , 
kind
 ) = 
info
 = 
imp
 . 
find_module
 ( 
part
 , 
paths
 )

91 if 
kind
 == 
PKG_DIRECTORY
 :

92 
parts
 = 
parts
 or [ '__init__' ]

93 
paths
 = [ 
path
 ]

95 elif 
parts
 :

96 raise 
ImportError
 ( "Can't find %r in %s" % ( 
parts
 , 
module
 ) )

98 return 
info
 
	}

101 def 
	$get_module_constant
 ( 
module
 , 
symbol
 , 
default
 = - 1 , 
paths
 = None ) :

109 
f
 , 
path
 , ( 
suffix
 , 
mode
 , 
kind
 ) = 
find_module
 ( 
module
 , 
paths
 )

110 except 
ImportError
 :

115 if 
kind
 == 
PY_COMPILED
 :

116 
f
 . 
read
 ( 8 )

117 
code
 = 
marshal
 . 
load
 ( 
f
 )

118 elif 
kind
 == 
PY_FROZEN
 :

119 
code
 = 
imp
 . 
get_frozen_object
 ( 
module
 )

120 elif 
kind
 == 
PY_SOURCE
 :

121 
code
 = 
compile
 ( 
f
 . 
read
 ( ) , 
path
 , 'exec' )

124 if 
module
 not in 
sys
 . 
modules
 :

125 
imp
 . 
load_module
 ( 
module
 , 
f
 , 
path
 , ( 
suffix
 , 
mode
 , 
kind
 ) )

126 return 
getattr
 ( 
sys
 . 
modules
 [ 
module
 ] , 
symbol
 , None )

129 if 
f
 :

130 
f
 . 
close
 ( )

132 return 
extract_constant
 ( 
code
 , 
symbol
 , 
default
 ) 
	}

135 def 
	$extract_constant
 ( 
code
 , 
symbol
 , 
default
 = - 1 ) :

147 if 
symbol
 not in 
code
 . 
co_names
 :

151 
name_idx
 = 
list
 ( 
code
 . 
co_names
 ) . 
index
 ( 
symbol
 )

153 
STORE_NAME
 = 90

154 
STORE_GLOBAL
 = 97

155 
LOAD_CONST
 = 100

157 
const
 = 
default

159 for 
byte_code
 in 
Bytecode
 ( 
code
 ) :

160 
op
 = 
byte_code
 . 
opcode

161 
arg
 = 
byte_code
 . 
arg

163 if 
op
 == 
LOAD_CONST
 :

164 
const
 = 
code
 . 
co_consts
 [ 
arg
 ]

165 elif 
arg
 == 
name_idx
 and ( 
op
 == 
STORE_NAME
 or 
op
 == 
STORE_GLOBAL
 ) :

166 return 
const

168 
const
 = 
default
 
	}

171 def 
	$_update_globals
 ( ) :

178 if not 
sys
 . 
platform
 . 
startswith
 ( 'java' ) and 
sys
 . 
platform
 != 'cli' :

180 
incompatible
 = 'extract_constant' , 'get_module_constant'

181 for 
name
 in 
incompatible
 :

182 del 
globals
 ( ) [ 
name
 ]

183 
__all__
 . 
remove
 ( 
name
 ) 
	}

186 
_update_globals
 ( )


	@./env/lib/python3.7/site-packages/setuptools/package_index.py

2 import 
	~sys

3 import 
	~os

4 import 
	~re

5 import 
	~shutil

6 import 
	~socket

7 import 
	~base64

8 import 
	~hashlib

9 import 
	~itertools

10 import 
	~warnings

11 from 
	~functools
 import 
wraps

13 from 
	~setuptools.extern
 import 
six

14 from 
	~setuptools.extern.six.moves
 import 
urllib
 , 
http_client
 , 
configparser
 , 
map

16 import 
	~setuptools

17 from 
	~pkg_resources
 import (

18 
CHECKOUT_DIST
 , 
Distribution
 , 
BINARY_DIST
 , 
normalize_path
 , 
SOURCE_DIST
 ,

19 
Environment
 , 
find_distributions
 , 
safe_name
 , 
safe_version
 ,

20 
to_filename
 , 
Requirement
 , 
DEVELOP_DIST
 , 
EGG_DIST
 ,

22 from 
	~setuptools
 import 
ssl_support

23 from 
	~distutils
 import 
log

24 from 
	~distutils.errors
 import 
DistutilsError

25 from 
	~fnmatch
 import 
translate

26 from 
	~setuptools.py27compat
 import 
get_all_headers

27 from 
	~setuptools.py33compat
 import 
unescape

28 from 
	~setuptools.wheel
 import 
Wheel

30 
__metaclass__
 = 
type

32 
EGG_FRAGMENT
 = 
re
 . 
compile
 ( r'^egg=([-A-Za-z0-9_.+!]+)$' )

33 
HREF
 = 
re
 . 
compile
 ( r"""href\s*=\s*['"]?([^'"> ]+)""" , 
re
 . 
I
 )

34 
PYPI_MD5
 = 
re
 . 
compile
 ( r'<a href="([^"#]+)">([^<]+)</a>\n\s+\(<a (?:title="MD5 hash"\n\s+)' r'href="[^?]+\?:action=show_md5&amp;digest=([0-9a-f]{32})">md5</a>\)'

38 
URL_SCHEME
 = 
re
 . 
compile
 ( '([-+.a-z0-9]{2,}):' , 
re
 . 
I
 ) . 
match

39 
EXTENSIONS
 = ".tar.gz .tar.bz2 .tar .zip .tgz" . 
split
 ( )

41 
__all__
 = [ 'PackageIndex'

46 
_SOCKET_TIMEOUT
 = 15

48 
_tmpl
 = "setuptools/{setuptools.__version__} Python-urllib/{py_major}"

49 
user_agent
 = 
_tmpl
 . 
format
 ( 
py_major
 = 
sys
 . 
version
 [ : 3 ] , 
setuptools
 = 
setuptools
 )

52 def 
	$parse_requirement_arg
 ( 
spec
 ) :

54 return 
Requirement
 . 
parse
 ( 
spec
 )

55 except 
ValueError
 :

56 raise 
DistutilsError
 ( "Not a URL, existing file, or requirement spec: %r"

57 % ( 
spec
 , )

58 ) 
	}

61 def 
	$parse_bdist_wininst
 ( 
name
 ) :

64 
lower
 = 
name
 . 
lower
 ( )

65 
base
 , 
py_ver
 , 
plat
 = None , None , None

67 if 
lower
 . 
endswith
 ( '.exe' ) :

68 if 
lower
 . 
endswith
 ( '.win32.exe' ) :

69 
base
 = 
name
 [ : - 10 ]

70 
plat
 = 'win32'

71 elif 
lower
 . 
startswith
 ( '.win32-py' , - 16 ) :

72 
py_ver
 = 
name
 [ - 7 : - 4 ]

73 
base
 = 
name
 [ : - 16 ]

74 
plat
 = 'win32'

75 elif 
lower
 . 
endswith
 ( '.win-amd64.exe' ) :

76 
base
 = 
name
 [ : - 14 ]

77 
plat
 = 'win-amd64'

78 elif 
lower
 . 
startswith
 ( '.win-amd64-py' , - 20 ) :

79 
py_ver
 = 
name
 [ - 7 : - 4 ]

80 
base
 = 
name
 [ : - 20 ]

81 
plat
 = 'win-amd64'

82 return 
base
 , 
py_ver
 , 
plat
 
	}

85 def 
	$egg_info_for_url
 ( 
url
 ) :

86 
parts
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 )

87 
scheme
 , 
server
 , 
path
 , 
parameters
 , 
query
 , 
fragment
 = 
parts

88 
base
 = 
urllib
 . 
parse
 . 
unquote
 ( 
path
 . 
split
 ( '/' ) [ - 1 ] )

89 if 
server
 == 'sourceforge.net' and 
base
 == 'download' :

90 
base
 = 
urllib
 . 
parse
 . 
unquote
 ( 
path
 . 
split
 ( '/' ) [ - 2 ] )

91 if '#' in 
base
 :

92 
base
 , 
fragment
 = 
base
 . 
split
 ( '#' , 1 )

93 return 
base
 , 
fragment
 
	}

96 def 
	$distros_for_url
 ( 
url
 , 
metadata
 = None ) :

98 
base
 , 
fragment
 = 
egg_info_for_url
 ( 
url
 )

99 for 
dist
 in 
distros_for_location
 ( 
url
 , 
base
 , 
metadata
 ) :

100 yield 
dist

101 if 
fragment
 :

102 
match
 = 
EGG_FRAGMENT
 . 
match
 ( 
fragment
 )

103 if 
match
 :

104 for 
dist
 in 
interpret_distro_name
 (

105 
url
 , 
match
 . 
group
 ( 1 ) , 
metadata
 , 
precedence
 = 
CHECKOUT_DIST

107 yield 
dist
 
	}

110 def 
	$distros_for_location
 ( 
location
 , 
basename
 , 
metadata
 = None ) :

112 if 
basename
 . 
endswith
 ( '.egg.zip' ) :

113 
basename
 = 
basename
 [ : - 4 ]

114 if 
basename
 . 
endswith
 ( '.egg' ) and '-' in 
basename
 :

116 return [ 
Distribution
 . 
from_location
 ( 
location
 , 
basename
 , 
metadata
 ) ]

117 if 
basename
 . 
endswith
 ( '.whl' ) and '-' in 
basename
 :

118 
wheel
 = 
Wheel
 ( 
basename
 )

119 if not 
wheel
 . 
is_compatible
 ( ) :

121 return [ 
Distribution
 (

122 
location
 = 
location
 ,

123 
project_name
 = 
wheel
 . 
project_name
 ,

124 
version
 = 
wheel
 . 
version
 ,

126 
precedence
 = 
EGG_DIST
 + 1 ,

128 if 
basename
 . 
endswith
 ( '.exe' ) :

129 
win_base
 , 
py_ver
 , 
platform
 = 
parse_bdist_wininst
 ( 
basename
 )

130 if 
win_base
 is not None :

131 return 
interpret_distro_name
 (

132 
location
 , 
win_base
 , 
metadata
 , 
py_ver
 , 
BINARY_DIST
 , 
platform

136 for 
ext
 in 
EXTENSIONS
 :

137 if 
basename
 . 
endswith
 ( 
ext
 ) :

138 
basename
 = 
basename
 [ : - 
len
 ( 
ext
 ) ]

139 return 
interpret_distro_name
 ( 
location
 , 
basename
 , 
metadata
 )

140 return [ ] 
	}

143 def 
	$distros_for_filename
 ( 
filename
 , 
metadata
 = None ) :

145 return 
distros_for_location
 (

146 
normalize_path
 ( 
filename
 ) , 
os
 . 
path
 . 
basename
 ( 
filename
 ) , 
metadata

147 ) 
	}

150 def 
	$interpret_distro_name
 (

151 
location
 , 
basename
 , 
metadata
 , 
py_version
 = None , 
precedence
 = 
SOURCE_DIST
 ,

152 
platform
 = None

172 
parts
 = 
basename
 . 
split
 ( '-' )

173 if not 
py_version
 and 
any
 ( 
re
 . 
match
 ( r'py\d\.\d$' , 
p
 ) for 
p
 in 
parts
 [ 2 : ] ) :

177 for 
p
 in 
range
 ( 1 , 
len
 ( 
parts
 ) + 1 ) :

178 yield 
Distribution
 (

179 
location
 , 
metadata
 , '-' . 
join
 ( 
parts
 [ : 
p
 ] ) , '-' . 
join
 ( 
parts
 [ 
p
 : ] ) ,

180 
py_version
 = 
py_version
 , 
precedence
 = 
precedence
 ,

181 
platform
 = 
platform

182 ) 
	}

186 def 
	$unique_everseen
 ( 
iterable
 , 
key
 = None ) :

190 
seen
 = 
set
 ( )

191 
seen_add
 = 
seen
 . 
add

192 if 
key
 is None :

193 for 
element
 in 
six
 . 
moves
 . 
filterfalse
 ( 
seen
 . 
__contains__
 , 
iterable
 ) :

194 
seen_add
 ( 
element
 )

195 yield 
element

197 for 
element
 in 
iterable
 :

198 
k
 = 
key
 ( 
element
 )

199 if 
k
 not in 
seen
 :

200 
seen_add
 ( 
k
 )

201 yield 
element
 
	}

204 def 
	$unique_values
 ( 
func
 ) :

210 @ 
	`wraps
 ( 
func
 )

211 def 
wrapper
 ( * 
args
 , ** 
kwargs
 ) :

212 return 
unique_everseen
 ( 
func
 ( * 
args
 , ** 
kwargs
 ) )

214 return 
wrapper
 
	}

217 
REL
 = 
re
 . 
compile
 ( r"""<([^>]*\srel\s*=\s*['"]?([^'">]+)[^>]*)>""" , 
re
 . 
I
 )

221 @ 
	`unique_values

222 def 
	$find_external_links
 ( 
url
 , 
page
 ) :

225 for 
match
 in 
REL
 . 
finditer
 ( 
page
 ) :

226 
tag
 , 
rel
 = 
match
 . 
groups
 ( )

227 
rels
 = 
set
 ( 
map
 ( 
str
 . 
strip
 , 
rel
 . 
lower
 ( ) . 
split
 ( ',' ) ) )

228 if 'homepage' in 
rels
 or 'download' in 
rels
 :

229 for 
match
 in 
HREF
 . 
finditer
 ( 
tag
 ) :

230 yield 
urllib
 . 
parse
 . 
urljoin
 ( 
url
 , 
htmldecode
 ( 
match
 . 
group
 ( 1 ) ) )

232 for 
tag
 in ( "<th>Home Page" , "<th>Download URL" ) :

233 
pos
 = 
page
 . 
find
 ( 
tag
 )

234 if 
pos
 != - 1 :

235 
match
 = 
HREF
 . 
search
 ( 
page
 , 
pos
 )

236 if 
match
 :

237 yield 
urllib
 . 
parse
 . 
urljoin
 ( 
url
 , 
htmldecode
 ( 
match
 . 
group
 ( 1 ) ) ) 
	}

240 class 
	cContentChecker
 :

245 def 
	$feed
 ( 
self
 , 
block
 ) :

249 return 
	}

251 def 
	$is_valid
 ( 
self
 ) :

255 return True 
	}

257 def 
	$report
 ( 
self
 , 
reporter
 , 
template
 ) :

262 return 
	}

265 class 
	cHashChecker
 ( 
ContentChecker
 ) :

266 
pattern
 = 
re
 . 
compile
 ( r'(?P<hash_name>sha1|sha224|sha384|sha256|sha512|md5)=' r'(?P<expected>[a-f0-9]+)'

271 def 
	$__init__
 ( 
self
 , 
hash_name
 , 
expected
 ) :

272 
self
 . 
hash_name
 = 
hash_name

273 
self
 . 
hash
 = 
hashlib
 . 
new
 ( 
hash_name
 )

274 
self
 . 
expected
 = 
expected
 
	}

276 @ 
classmethod

277 def 
	$from_url
 ( 
cls
 , 
url
 ) :

279 
fragment
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 ) [ - 1 ]

280 if not 
fragment
 :

281 return 
ContentChecker
 ( )

282 
match
 = 
cls
 . 
pattern
 . 
search
 ( 
fragment
 )

283 if not 
match
 :

284 return 
ContentChecker
 ( )

285 return 
cls
 ( ** 
match
 . 
groupdict
 ( ) ) 
	}

287 def 
	$feed
 ( 
self
 , 
block
 ) :

288 
self
 . 
hash
 . 
update
 ( 
block
 ) 
	}

290 def 
	$is_valid
 ( 
self
 ) :

291 return 
self
 . 
hash
 . 
hexdigest
 ( ) == 
self
 . 
expected
 
	}

293 def 
	$report
 ( 
self
 , 
reporter
 , 
template
 ) :

294 
msg
 = 
template
 % 
self
 . 
hash_name

295 return 
reporter
 ( 
msg
 ) 
	}

298 class 
	cPackageIndex
 ( 
Environment
 ) :

301 def 
	$__init__
 (

302 
self
 , 
index_url
 = "https://pypi.org/simple/" , 
hosts
 = ( '*' , ) ,

303 
ca_bundle
 = None , 
verify_ssl
 = True , * 
args
 , ** 
kw

305 
Environment
 . 
__init__
 ( 
self
 , * 
args
 , ** 
kw
 )

306 
self
 . 
index_url
 = 
index_url
 + "/" [ : not 
index_url
 . 
endswith
 ( '/' ) ]

307 
self
 . 
scanned_urls
 = { }

308 
self
 . 
fetched_urls
 = { }

309 
self
 . 
package_pages
 = { }

310 
self
 . 
allows
 = 
re
 . 
compile
 ( '|' . 
join
 ( 
map
 ( 
translate
 , 
hosts
 ) ) ) . 
match

311 
self
 . 
to_scan
 = [ ]

312 
use_ssl
 = (

313 
verify_ssl

314 and 
ssl_support
 . 
is_available

315 and ( 
ca_bundle
 or 
ssl_support
 . 
find_ca_bundle
 ( ) )

317 if 
use_ssl
 :

318 
self
 . 
opener
 = 
ssl_support
 . 
opener_for
 ( 
ca_bundle
 )

320 
self
 . 
opener
 = 
urllib
 . 
request
 . 
urlopen
 
	}

322 def 
	$process_url
 ( 
self
 , 
url
 , 
retrieve
 = False ) :

324 if 
url
 in 
self
 . 
scanned_urls
 and not 
retrieve
 :

326 
self
 . 
scanned_urls
 [ 
url
 ] = True

327 if not 
URL_SCHEME
 ( 
url
 ) :

328 
self
 . 
process_filename
 ( 
url
 )

331 
dists
 = 
list
 ( 
distros_for_url
 ( 
url
 ) )

332 if 
dists
 :

333 if not 
self
 . 
url_ok
 ( 
url
 ) :

335 
self
 . 
debug
 ( "Found link: %s" , 
url
 )

337 if 
dists
 or not 
retrieve
 or 
url
 in 
self
 . 
fetched_urls
 :

338 
list
 ( 
map
 ( 
self
 . 
add
 , 
dists
 ) )

341 if not 
self
 . 
url_ok
 ( 
url
 ) :

342 
self
 . 
fetched_urls
 [ 
url
 ] = True

345 
self
 . 
info
 ( "Reading %s" , 
url
 )

346 
self
 . 
fetched_urls
 [ 
url
 ] = True

347 
tmpl
 = "Download error on %s: %%s -- Some packages may not be found!"

348 
f
 = 
self
 . 
open_url
 ( 
url
 , 
tmpl
 % 
url
 )

349 if 
f
 is None :

351 
self
 . 
fetched_urls
 [ 
f
 . 
url
 ] = True

352 if 'html' not in 
f
 . 
headers
 . 
get
 ( 'content-type' , '' ) . 
lower
 ( ) :

353 
f
 . 
close
 ( )

356 
base
 = 
f
 . 
url

357 
page
 = 
f
 . 
read
 ( )

358 if not 
isinstance
 ( 
page
 , 
str
 ) :

360 if 
isinstance
 ( 
f
 , 
urllib
 . 
error
 . 
HTTPError
 ) :

362 
charset
 = 'latin-1'

364 
charset
 = 
f
 . 
headers
 . 
get_param
 ( 'charset' ) or 'latin-1'

365 
page
 = 
page
 . 
decode
 ( 
charset
 , "ignore" )

366 
f
 . 
close
 ( )

367 for 
match
 in 
HREF
 . 
finditer
 ( 
page
 ) :

368 
link
 = 
urllib
 . 
parse
 . 
urljoin
 ( 
base
 , 
htmldecode
 ( 
match
 . 
group
 ( 1 ) ) )

369 
self
 . 
process_url
 ( 
link
 )

370 if 
url
 . 
startswith
 ( 
self
 . 
index_url
 ) and 
getattr
 ( 
f
 , 'code' , None ) != 404 :

371 
page
 = 
self
 . 
process_index
 ( 
url
 , 
page
 ) 
	}

373 def 
	$process_filename
 ( 
self
 , 
fn
 , 
nested
 = False ) :

375 if not 
os
 . 
path
 . 
exists
 ( 
fn
 ) :

376 
self
 . 
warn
 ( "Not found: %s" , 
fn
 )

379 if 
os
 . 
path
 . 
isdir
 ( 
fn
 ) and not 
nested
 :

380 
path
 = 
os
 . 
path
 . 
realpath
 ( 
fn
 )

381 for 
item
 in 
os
 . 
listdir
 ( 
path
 ) :

382 
self
 . 
process_filename
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
item
 ) , True )

384 
dists
 = 
distros_for_filename
 ( 
fn
 )

385 if 
dists
 :

386 
self
 . 
debug
 ( "Found: %s" , 
fn
 )

387 
list
 ( 
map
 ( 
self
 . 
add
 , 
dists
 ) ) 
	}

389 def 
	$url_ok
 ( 
self
 , 
url
 , 
fatal
 = False ) :

390 
s
 = 
URL_SCHEME
 ( 
url
 )

391 
is_file
 = 
s
 and 
s
 . 
group
 ( 1 ) . 
lower
 ( ) == 'file'

392 if 
is_file
 or 
self
 . 
allows
 ( 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 ) [ 1 ] ) :

394 
msg
 = ( "\nNote: Bypassing %s (disallowed host; see " "http://bit.ly/2hrImnY for details).\n"

397 if 
fatal
 :

398 raise 
DistutilsError
 ( 
msg
 % 
url
 )

400 
self
 . 
warn
 ( 
msg
 , 
url
 ) 
	}

402 def 
	$scan_egg_links
 ( 
self
 , 
search_path
 ) :

403 
dirs
 = 
filter
 ( 
os
 . 
path
 . 
isdir
 , 
search_path
 )

404 
egg_links
 = (

405 ( 
path
 , 
entry
 )

406 for 
path
 in 
dirs

407 for 
entry
 in 
os
 . 
listdir
 ( 
path
 )

408 if 
entry
 . 
endswith
 ( '.egg-link' )

410 
list
 ( 
itertools
 . 
starmap
 ( 
self
 . 
scan_egg_link
 , 
egg_links
 ) ) 
	}

412 def 
	$scan_egg_link
 ( 
self
 , 
path
 , 
entry
 ) :

413 with 
open
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
entry
 ) ) as 
raw_lines
 :

415 
lines
 = 
list
 ( 
filter
 ( None , 
map
 ( 
str
 . 
strip
 , 
raw_lines
 ) ) )

417 if 
len
 ( 
lines
 ) != 2 :

421 
egg_path
 , 
setup_path
 = 
lines

423 for 
dist
 in 
find_distributions
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
egg_path
 ) ) :

424 
dist
 . 
location
 = 
os
 . 
path
 . 
join
 ( 
path
 , * 
lines
 )

425 
dist
 . 
precedence
 = 
SOURCE_DIST

426 
self
 . 
add
 ( 
dist
 ) 
	}

428 def 
	$process_index
 ( 
self
 , 
url
 , 
page
 ) :

431 def 
scan
 ( 
link
 ) :

433 if 
link
 . 
startswith
 ( 
self
 . 
index_url
 ) :

434 
parts
 = 
list
 ( 
map
 (

435 
urllib
 . 
parse
 . 
unquote
 , 
link
 [ 
len
 ( 
self
 . 
index_url
 ) : ] . 
split
 ( '/' )

437 if 
len
 ( 
parts
 ) == 2 and '#' not in 
parts
 [ 1 ] :

439 
pkg
 = 
safe_name
 ( 
parts
 [ 0 ] )

440 
ver
 = 
safe_version
 ( 
parts
 [ 1 ] )

441 
self
 . 
package_pages
 . 
setdefault
 ( 
pkg
 . 
lower
 ( ) , { } ) [ 
link
 ] = True

442 return 
to_filename
 ( 
pkg
 ) , 
to_filename
 ( 
ver
 )

446 for 
match
 in 
HREF
 . 
finditer
 ( 
page
 ) :

448 
scan
 ( 
urllib
 . 
parse
 . 
urljoin
 ( 
url
 , 
htmldecode
 ( 
match
 . 
group
 ( 1 ) ) ) )

449 except 
ValueError
 :

452 
pkg
 , 
ver
 = 
scan
 ( 
url
 )

453 if 
pkg
 :

455 for 
new_url
 in 
find_external_links
 ( 
url
 , 
page
 ) :

457 
base
 , 
frag
 = 
egg_info_for_url
 ( 
new_url
 )

458 if 
base
 . 
endswith
 ( '.py' ) and not 
frag
 :

459 if 
ver
 :

460 
new_url
 += '#egg=%s-%s' % ( 
pkg
 , 
ver
 )

462 
self
 . 
need_version_info
 ( 
url
 )

463 
self
 . 
scan_url
 ( 
new_url
 )

465 return 
PYPI_MD5
 . 
sub
 (

466 lambda 
m
 : '<a href="%s#md5=%s">%s</a>' % 
m
 . 
group
 ( 1 , 3 , 2 ) , 
page

469 return "" 
	}

471 def 
	$need_version_info
 ( 
self
 , 
url
 ) :

472 
self
 . 
scan_all
 ( "Page at %s links to .py file(s) without version info; an index " "scan is required."

474 , 
url

475 ) 
	}

477 def 
	$scan_all
 ( 
self
 , 
msg
 = None , * 
args
 ) :

478 if 
self
 . 
index_url
 not in 
self
 . 
fetched_urls
 :

479 if 
msg
 :

480 
self
 . 
warn
 ( 
msg
 , * 
args
 )

481 
self
 . 
info
 ( "Scanning index of all packages (this may take a while)"

484 
self
 . 
scan_url
 ( 
self
 . 
index_url
 ) 
	}

486 def 
	$find_packages
 ( 
self
 , 
requirement
 ) :

487 
self
 . 
scan_url
 ( 
self
 . 
index_url
 + 
requirement
 . 
unsafe_name
 + '/' )

489 if not 
self
 . 
package_pages
 . 
get
 ( 
requirement
 . 
key
 ) :

491 
self
 . 
scan_url
 ( 
self
 . 
index_url
 + 
requirement
 . 
project_name
 + '/' )

493 if not 
self
 . 
package_pages
 . 
get
 ( 
requirement
 . 
key
 ) :

495 
self
 . 
not_found_in_index
 ( 
requirement
 )

497 for 
url
 in 
list
 ( 
self
 . 
package_pages
 . 
get
 ( 
requirement
 . 
key
 , ( ) ) ) :

499 
self
 . 
scan_url
 ( 
url
 ) 
	}

501 def 
	$obtain
 ( 
self
 , 
requirement
 , 
installer
 = None ) :

502 
self
 . 
prescan
 ( )

503 
self
 . 
find_packages
 ( 
requirement
 )

504 for 
dist
 in 
self
 [ 
requirement
 . 
key
 ] :

505 if 
dist
 in 
requirement
 :

506 return 
dist

507 
self
 . 
debug
 ( "%s does not match %s" , 
requirement
 , 
dist
 )

508 return 
super
 ( 
PackageIndex
 , 
self
 ) . 
obtain
 ( 
requirement
 , 
installer
 ) 
	}

510 def 
	$check_hash
 ( 
self
 , 
checker
 , 
filename
 , 
tfp
 ) :

514 
checker
 . 
report
 (

515 
self
 . 
debug
 , "Validating %%s checksum for %s"

516 % 
filename
 )

517 if not 
checker
 . 
is_valid
 ( ) :

518 
tfp
 . 
close
 ( )

519 
os
 . 
unlink
 ( 
filename
 )

520 raise 
DistutilsError
 ( "%s validation failed for %s; " "possible download problem?"

523 % ( 
checker
 . 
hash
 . 
name
 , 
os
 . 
path
 . 
basename
 ( 
filename
 ) )

524 ) 
	}

526 def 
	$add_find_links
 ( 
self
 , 
urls
 ) :

528 for 
url
 in 
urls
 :

530 
self
 . 
to_scan
 is None

531 or not 
URL_SCHEME
 ( 
url
 )

532 or 
url
 . 
startswith
 ( 'file:' )

533 or 
list
 ( 
distros_for_url
 ( 
url
 ) )

536 
self
 . 
scan_url
 ( 
url
 )

539 
self
 . 
to_scan
 . 
append
 ( 
url
 ) 
	}

541 def 
	$prescan
 ( 
self
 ) :

543 if 
self
 . 
to_scan
 :

544 
list
 ( 
map
 ( 
self
 . 
scan_url
 , 
self
 . 
to_scan
 ) )

545 
self
 . 
to_scan
 = None 
	}

547 def 
	$not_found_in_index
 ( 
self
 , 
requirement
 ) :

548 if 
self
 [ 
requirement
 . 
key
 ] :

549 
meth
 , 
msg
 = 
self
 . 
info
 , "Couldn't retrieve index page for %r"

551 
meth
 , 
msg
 = (

552 
self
 . 
warn
 , "Couldn't find index page for %r (maybe misspelled?)"

554 
meth
 ( 
msg
 , 
requirement
 . 
unsafe_name
 )

555 
self
 . 
scan_all
 ( ) 
	}

557 def 
	$download
 ( 
self
 , 
spec
 , 
tmpdir
 ) :

575 if not 
isinstance
 ( 
spec
 , 
Requirement
 ) :

576 
scheme
 = 
URL_SCHEME
 ( 
spec
 )

577 if 
scheme
 :

579 
found
 = 
self
 . 
_download_url
 ( 
scheme
 . 
group
 ( 1 ) , 
spec
 , 
tmpdir
 )

580 
base
 , 
fragment
 = 
egg_info_for_url
 ( 
spec
 )

581 if 
base
 . 
endswith
 ( '.py' ) :

582 
found
 = 
self
 . 
gen_setup
 ( 
found
 , 
fragment
 , 
tmpdir
 )

583 return 
found

584 elif 
os
 . 
path
 . 
exists
 ( 
spec
 ) :

586 return 
spec

588 
spec
 = 
parse_requirement_arg
 ( 
spec
 )

589 return 
getattr
 ( 
self
 . 
fetch_distribution
 ( 
spec
 , 
tmpdir
 ) , 'location' , None ) 
	}

591 def 
	$fetch_distribution
 (

592 
self
 , 
requirement
 , 
tmpdir
 , 
force_scan
 = False , 
source
 = False ,

593 
develop_ok
 = False , 
local_index
 = None ) :

611 
self
 . 
info
 ( "Searching for %s" , 
requirement
 )

612 
skipped
 = { }

613 
dist
 = None

615 def 
find
 ( 
req
 , 
env
 = None ) :

616 if 
env
 is None :

617 
env
 = 
self

620 for 
dist
 in 
env
 [ 
req
 . 
key
 ] :

622 if 
dist
 . 
precedence
 == 
DEVELOP_DIST
 and not 
develop_ok
 :

623 if 
dist
 not in 
skipped
 :

624 
self
 . 
warn
 ( "Skipping development or system egg: %s"

625 , 
dist
 ,

627 
skipped
 [ 
dist
 ] = 1

630 
test
 = (

631 
dist
 in 
req

632 and ( 
dist
 . 
precedence
 <= 
SOURCE_DIST
 or not 
source
 )

634 if 
test
 :

635 
loc
 = 
self
 . 
download
 ( 
dist
 . 
location
 , 
tmpdir
 )

636 
dist
 . 
download_location
 = 
loc

637 if 
os
 . 
path
 . 
exists
 ( 
dist
 . 
download_location
 ) :

638 return 
dist

640 if 
force_scan
 :

641 
self
 . 
prescan
 ( )

642 
self
 . 
find_packages
 ( 
requirement
 )

643 
dist
 = 
find
 ( 
requirement
 )

645 if not 
dist
 and 
local_index
 is not None :

646 
dist
 = 
find
 ( 
requirement
 , 
local_index
 )

648 if 
dist
 is None :

649 if 
self
 . 
to_scan
 is not None :

650 
self
 . 
prescan
 ( )

651 
dist
 = 
find
 ( 
requirement
 )

653 if 
dist
 is None and not 
force_scan
 :

654 
self
 . 
find_packages
 ( 
requirement
 )

655 
dist
 = 
find
 ( 
requirement
 )

657 if 
dist
 is None :

658 
self
 . 
warn
 ( "No local packages or working download links found for %s%s"

660 ( 
source
 and "a source distribution of " or "" ) ,

661 
requirement
 ,

664 
self
 . 
info
 ( "Best match: %s" , 
dist
 )

665 return 
dist
 . 
clone
 ( 
location
 = 
dist
 . 
download_location
 ) 
	}

667 def 
	$fetch
 ( 
self
 , 
requirement
 , 
tmpdir
 , 
force_scan
 = False , 
source
 = False ) :

675 
dist
 = 
self
 . 
fetch_distribution
 ( 
requirement
 , 
tmpdir
 , 
force_scan
 , 
source
 )

676 if 
dist
 is not None :

677 return 
dist
 . 
location

678 return None 
	}

680 def 
	$gen_setup
 ( 
self
 , 
filename
 , 
fragment
 , 
tmpdir
 ) :

681 
match
 = 
EGG_FRAGMENT
 . 
match
 ( 
fragment
 )

682 
dists
 = 
match
 and [

683 
d
 for 
d
 in

684 
interpret_distro_name
 ( 
filename
 , 
match
 . 
group
 ( 1 ) , None ) if 
d
 . 
version

687 if 
len
 ( 
dists
 ) == 1 :

688 
basename
 = 
os
 . 
path
 . 
basename
 ( 
filename
 )

691 if 
os
 . 
path
 . 
dirname
 ( 
filename
 ) != 
tmpdir
 :

692 
dst
 = 
os
 . 
path
 . 
join
 ( 
tmpdir
 , 
basename
 )

693 from 
	~setuptools.command.easy_install
 import 
samefile

694 if not 
samefile
 ( 
filename
 , 
dst
 ) :

695 
shutil
 . 
copy2
 ( 
filename
 , 
dst
 )

696 
filename
 = 
dst

698 with 
open
 ( 
os
 . 
path
 . 
join
 ( 
tmpdir
 , 'setup.py' ) , 'w' ) as 
file
 :

699 
file
 . 
write
 ( "from setuptools import setup\n" "setup(name=%r, version=%r, py_modules=[%r])\n"

703 
dists
 [ 0 ] . 
project_name
 , 
dists
 [ 0 ] . 
version
 ,

704 
os
 . 
path
 . 
splitext
 ( 
basename
 ) [ 0 ]

707 return 
filename

709 elif 
match
 :

710 raise 
DistutilsError
 ( "Can't unambiguously interpret project/version identifier %r; " "any dashes in the name or version should be escaped using " "underscores. %r"

713 % ( 
fragment
 , 
dists
 )

716 raise 
DistutilsError
 ( "Can't process plain .py files without an '#egg=name-version'" " suffix to enable automatic setup script generation."

719 ) 
	}

721 
dl_blocksize
 = 8192

723 def 
	$_download_to
 ( 
self
 , 
url
 , 
filename
 ) :

724 
self
 . 
info
 ( "Downloading %s" , 
url
 )

726 
fp
 = None

728 
checker
 = 
HashChecker
 . 
from_url
 ( 
url
 )

729 
fp
 = 
self
 . 
open_url
 ( 
url
 )

730 if 
isinstance
 ( 
fp
 , 
urllib
 . 
error
 . 
HTTPError
 ) :

731 raise 
DistutilsError
 ( "Can't download %s: %s %s"

732 % ( 
url
 , 
fp
 . 
code
 , 
fp
 . 
msg
 )

734 
headers
 = 
fp
 . 
info
 ( )

735 
blocknum
 = 0

736 
bs
 = 
self
 . 
dl_blocksize

737 
size
 = - 1

738 if "content-length" in 
headers
 :

740 
sizes
 = 
get_all_headers
 ( 
headers
 , 'Content-Length' )

741 
size
 = 
max
 ( 
map
 ( 
int
 , 
sizes
 ) )

742 
self
 . 
reporthook
 ( 
url
 , 
filename
 , 
blocknum
 , 
bs
 , 
size
 )

743 with 
open
 ( 
filename
 , 'wb' ) as 
tfp
 :

745 
block
 = 
fp
 . 
read
 ( 
bs
 )

746 if 
block
 :

747 
checker
 . 
feed
 ( 
block
 )

748 
tfp
 . 
write
 ( 
block
 )

749 
blocknum
 += 1

750 
self
 . 
reporthook
 ( 
url
 , 
filename
 , 
blocknum
 , 
bs
 , 
size
 )

753 
self
 . 
check_hash
 ( 
checker
 , 
filename
 , 
tfp
 )

754 return 
headers

756 if 
fp
 :

757 
fp
 . 
close
 ( ) 
	}

759 def 
	$reporthook
 ( 
self
 , 
url
 , 
filename
 , 
blocknum
 , 
blksize
 , 
size
 ) :

760 pass 
	}

762 def 
	$open_url
 ( 
self
 , 
url
 , 
warning
 = None ) :

763 if 
url
 . 
startswith
 ( 'file:' ) :

764 return 
local_open
 ( 
url
 )

766 return 
open_with_auth
 ( 
url
 , 
self
 . 
opener
 )

767 except ( 
ValueError
 , 
http_client
 . 
InvalidURL
 ) as 
v
 :

768 
msg
 = ' ' . 
join
 ( [ 
str
 ( 
arg
 ) for 
arg
 in 
v
 . 
args
 ] )

769 if 
warning
 :

770 
self
 . 
warn
 ( 
warning
 , 
msg
 )

772 raise 
DistutilsError
 ( '%s %s' % ( 
url
 , 
msg
 ) )

773 except 
urllib
 . 
error
 . 
HTTPError
 as 
v
 :

774 return 
v

775 except 
urllib
 . 
error
 . 
URLError
 as 
v
 :

776 if 
warning
 :

777 
self
 . 
warn
 ( 
warning
 , 
v
 . 
reason
 )

779 raise 
DistutilsError
 ( "Download error for %s: %s"

780 % ( 
url
 , 
v
 . 
reason
 ) )

781 except 
http_client
 . 
BadStatusLine
 as 
v
 :

782 if 
warning
 :

783 
self
 . 
warn
 ( 
warning
 , 
v
 . 
line
 )

785 raise 
DistutilsError
 ( '%s returned a bad status line. The server might be ' 'down, %s'

788 ( 
url
 , 
v
 . 
line
 )

790 except ( 
http_client
 . 
HTTPException
 , 
socket
 . 
error
 ) as 
v
 :

791 if 
warning
 :

792 
self
 . 
warn
 ( 
warning
 , 
v
 )

794 raise 
DistutilsError
 ( "Download error for %s: %s"

795 % ( 
url
 , 
v
 ) ) 
	}

797 def 
	$_download_url
 ( 
self
 , 
scheme
 , 
url
 , 
tmpdir
 ) :

800 
name
 , 
fragment
 = 
egg_info_for_url
 ( 
url
 )

801 if 
name
 :

802 while '..' in 
name
 :

803 
name
 = 
name
 . 
replace
 ( '..' , '.' ) . 
replace
 ( '\\' , '_' )

805 
name
 = "__downloaded__"

807 if 
name
 . 
endswith
 ( '.egg.zip' ) :

808 
name
 = 
name
 [ : - 4 ]

810 
filename
 = 
os
 . 
path
 . 
join
 ( 
tmpdir
 , 
name
 )

814 if 
scheme
 == 'svn' or 
scheme
 . 
startswith
 ( 'svn+' ) :

815 return 
self
 . 
_download_svn
 ( 
url
 , 
filename
 )

816 elif 
scheme
 == 'git' or 
scheme
 . 
startswith
 ( 'git+' ) :

817 return 
self
 . 
_download_git
 ( 
url
 , 
filename
 )

818 elif 
scheme
 . 
startswith
 ( 'hg+' ) :

819 return 
self
 . 
_download_hg
 ( 
url
 , 
filename
 )

820 elif 
scheme
 == 'file' :

821 return 
urllib
 . 
request
 . 
url2pathname
 ( 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 ) [ 2 ] )

823 
self
 . 
url_ok
 ( 
url
 , True )

824 return 
self
 . 
_attempt_download
 ( 
url
 , 
filename
 ) 
	}

826 def 
	$scan_url
 ( 
self
 , 
url
 ) :

827 
self
 . 
process_url
 ( 
url
 , True ) 
	}

829 def 
	$_attempt_download
 ( 
self
 , 
url
 , 
filename
 ) :

830 
headers
 = 
self
 . 
_download_to
 ( 
url
 , 
filename
 )

831 if 'html' in 
headers
 . 
get
 ( 'content-type' , '' ) . 
lower
 ( ) :

832 return 
self
 . 
_download_html
 ( 
url
 , 
headers
 , 
filename
 )

834 return 
filename
 
	}

836 def 
	$_download_html
 ( 
self
 , 
url
 , 
headers
 , 
filename
 ) :

837 
file
 = 
open
 ( 
filename
 )

838 for 
line
 in 
file
 :

839 if 
line
 . 
strip
 ( ) :

841 if 
re
 . 
search
 ( r'<title>([^- ]+ - )?Revision \d+:' , 
line
 ) :

843 
file
 . 
close
 ( )

844 
os
 . 
unlink
 ( 
filename
 )

845 return 
self
 . 
_download_svn
 ( 
url
 , 
filename
 )

847 
file
 . 
close
 ( )

848 
os
 . 
unlink
 ( 
filename
 )

849 raise 
DistutilsError
 ( "Unexpected HTML page found at " + 
url
 ) 
	}

851 def 
	$_download_svn
 ( 
self
 , 
url
 , 
filename
 ) :

852 
warnings
 . 
warn
 ( "SVN download support is deprecated" , 
UserWarning
 )

853 
url
 = 
url
 . 
split
 ( '#' , 1 ) [ 0 ]

854 
creds
 = ''

855 if 
url
 . 
lower
 ( ) . 
startswith
 ( 'svn:' ) and '@' in 
url
 :

856 
scheme
 , 
netloc
 , 
path
 , 
p
 , 
q
 , 
f
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 )

857 if not 
netloc
 and 
path
 . 
startswith
 ( '//' ) and '/' in 
path
 [ 2 : ] :

858 
netloc
 , 
path
 = 
path
 [ 2 : ] . 
split
 ( '/' , 1 )

859 
auth
 , 
host
 = 
_splituser
 ( 
netloc
 )

860 if 
auth
 :

861 if ':' in 
auth
 :

862 
user
 , 
pw
 = 
auth
 . 
split
 ( ':' , 1 )

863 
creds
 = " --username=%s --password=%s" % ( 
user
 , 
pw
 )

865 
creds
 = " --username=" + 
auth

866 
netloc
 = 
host

867 
parts
 = 
scheme
 , 
netloc
 , 
url
 , 
p
 , 
q
 , 
f

868 
url
 = 
urllib
 . 
parse
 . 
urlunparse
 ( 
parts
 )

869 
self
 . 
info
 ( "Doing subversion checkout from %s to %s" , 
url
 , 
filename
 )

870 
os
 . 
system
 ( "svn checkout%s -q %s %s" % ( 
creds
 , 
url
 , 
filename
 ) )

871 return 
filename
 
	}

873 @ 
	`staticmethod

874 def 
	$_vcs_split_rev_from_url
 ( 
url
 , 
pop_prefix
 = False ) :

875 
scheme
 , 
netloc
 , 
path
 , 
query
 , 
frag
 = 
urllib
 . 
parse
 . 
urlsplit
 ( 
url
 )

877 
scheme
 = 
scheme
 . 
split
 ( '+' , 1 ) [ - 1 ]

880 
path
 = 
path
 . 
split
 ( '#' , 1 ) [ 0 ]

882 
rev
 = None

883 if '@' in 
path
 :

884 
path
 , 
rev
 = 
path
 . 
rsplit
 ( '@' , 1 )

887 
url
 = 
urllib
 . 
parse
 . 
urlunsplit
 ( ( 
scheme
 , 
netloc
 , 
path
 , 
query
 , '' ) )

889 return 
url
 , 
rev
 
	}

891 def 
	$_download_git
 ( 
self
 , 
url
 , 
filename
 ) :

892 
filename
 = 
filename
 . 
split
 ( '#' , 1 ) [ 0 ]

893 
url
 , 
rev
 = 
self
 . 
_vcs_split_rev_from_url
 ( 
url
 , 
pop_prefix
 = True )

895 
self
 . 
info
 ( "Doing git clone from %s to %s" , 
url
 , 
filename
 )

896 
os
 . 
system
 ( "git clone --quiet %s %s" % ( 
url
 , 
filename
 ) )

898 if 
rev
 is not None :

899 
self
 . 
info
 ( "Checking out %s" , 
rev
 )

900 
os
 . 
system
 ( "(cd %s && git checkout --quiet %s)" % (

901 
filename
 ,

902 
rev
 ,

905 return 
filename
 
	}

907 def 
	$_download_hg
 ( 
self
 , 
url
 , 
filename
 ) :

908 
filename
 = 
filename
 . 
split
 ( '#' , 1 ) [ 0 ]

909 
url
 , 
rev
 = 
self
 . 
_vcs_split_rev_from_url
 ( 
url
 , 
pop_prefix
 = True )

911 
self
 . 
info
 ( "Doing hg clone from %s to %s" , 
url
 , 
filename
 )

912 
os
 . 
system
 ( "hg clone --quiet %s %s" % ( 
url
 , 
filename
 ) )

914 if 
rev
 is not None :

915 
self
 . 
info
 ( "Updating to %s" , 
rev
 )

916 
os
 . 
system
 ( "(cd %s && hg up -C -r %s -q)" % (

917 
filename
 ,

918 
rev
 ,

921 return 
filename
 
	}

923 def 
	$debug
 ( 
self
 , 
msg
 , * 
args
 ) :

924 
log
 . 
debug
 ( 
msg
 , * 
args
 ) 
	}

926 def 
	$info
 ( 
self
 , 
msg
 , * 
args
 ) :

927 
log
 . 
info
 ( 
msg
 , * 
args
 ) 
	}

929 def 
	$warn
 ( 
self
 , 
msg
 , * 
args
 ) :

930 
log
 . 
warn
 ( 
msg
 , * 
args
 ) 
	}

935 
entity_sub
 = 
re
 . 
compile
 ( r'&(#(\d+|x[\da-fA-F]+)|[\w.:-]+);?' ) . 
sub

938 def 
	$decode_entity
 ( 
match
 ) :

939 
what
 = 
match
 . 
group
 ( 0 )

940 return 
unescape
 ( 
what
 ) 
	}

943 def 
	$htmldecode
 ( 
text
 ) :

952 return 
entity_sub
 ( 
decode_entity
 , 
text
 ) 
	}

955 def 
	$socket_timeout
 ( 
timeout
 = 15 ) :

956 def 
_socket_timeout
 ( 
func
 ) :

957 def 
_socket_timeout
 ( * 
args
 , ** 
kwargs
 ) :

958 
old_timeout
 = 
socket
 . 
getdefaulttimeout
 ( )

959 
socket
 . 
setdefaulttimeout
 ( 
timeout
 )

961 return 
func
 ( * 
args
 , ** 
kwargs
 )

963 
socket
 . 
setdefaulttimeout
 ( 
old_timeout
 )

965 return 
_socket_timeout

967 return 
_socket_timeout
 
	}

970 def 
	$_encode_auth
 ( 
auth
 ) :

982 
auth_s
 = 
urllib
 . 
parse
 . 
unquote
 ( 
auth
 )

984 
auth_bytes
 = 
auth_s
 . 
encode
 ( )

985 
encoded_bytes
 = 
base64
 . 
b64encode
 ( 
auth_bytes
 )

987 
encoded
 = 
encoded_bytes
 . 
decode
 ( )

989 return 
encoded
 . 
replace
 ( '\n' , '' ) 
	}

992 class 
	cCredential
 :

997 def 
	$__init__
 ( 
self
 , 
username
 , 
password
 ) :

998 
self
 . 
username
 = 
username

999 
self
 . 
password
 = 
password
 
	}

1001 def 
	$__iter__
 ( 
self
 ) :

1002 yield 
self
 . 
username

1003 yield 
self
 . 
password
 
	}

1005 def 
	$__str__
 ( 
self
 ) :

1006 return '%(username)s:%(password)s' % 
vars
 ( 
self
 ) 
	}

1009 class 
	cPyPIConfig
 ( 
configparser
 . 
RawConfigParser
 ) :

1010 def 
	$__init__
 ( 
self
 ) :

1014 
defaults
 = 
dict
 . 
fromkeys
 ( [ 'username' , 'password' , 'repository' ] , '' )

1015 
configparser
 . 
RawConfigParser
 . 
__init__
 ( 
self
 , 
defaults
 )

1017 
rc
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
expanduser
 ( '~' ) , '.pypirc' )

1018 if 
os
 . 
path
 . 
exists
 ( 
rc
 ) :

1019 
self
 . 
read
 ( 
rc
 ) 
	}

1021 @ 
property

1022 def 
	$creds_by_repository
 ( 
self
 ) :

1023 
sections_with_repositories
 = [

1024 
section
 for 
section
 in 
self
 . 
sections
 ( )

1025 if 
self
 . 
get
 ( 
section
 , 'repository' ) . 
strip
 ( )

1028 return 
dict
 ( 
map
 ( 
self
 . 
_get_repo_cred
 , 
sections_with_repositories
 ) ) 
	}

1030 def 
	$_get_repo_cred
 ( 
self
 , 
section
 ) :

1031 
repo
 = 
self
 . 
get
 ( 
section
 , 'repository' ) . 
strip
 ( )

1032 return 
repo
 , 
Credential
 (

1033 
self
 . 
get
 ( 
section
 , 'username' ) . 
strip
 ( ) ,

1034 
self
 . 
get
 ( 
section
 , 'password' ) . 
strip
 ( ) ,

1035 ) 
	}

1037 def 
	$find_credential
 ( 
self
 , 
url
 ) :

1042 for 
repository
 , 
cred
 in 
self
 . 
creds_by_repository
 . 
items
 ( ) :

1043 if 
url
 . 
startswith
 ( 
repository
 ) :

1044 return 
cred
 
	}

1047 def 
	$open_with_auth
 ( 
url
 , 
opener
 = 
urllib
 . 
request
 . 
urlopen
 ) :

1050 
parsed
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 )

1051 
scheme
 , 
netloc
 , 
path
 , 
params
 , 
query
 , 
frag
 = 
parsed

1055 if 
netloc
 . 
endswith
 ( ':' ) :

1056 raise 
http_client
 . 
InvalidURL
 ( "nonnumeric port: ''" )

1058 if 
scheme
 in ( 'http' , 'https' ) :

1059 
auth
 , 
address
 = 
_splituser
 ( 
netloc
 )

1061 
auth
 = None

1063 if not 
auth
 :

1064 
cred
 = 
PyPIConfig
 ( ) . 
find_credential
 ( 
url
 )

1065 if 
cred
 :

1066 
auth
 = 
str
 ( 
cred
 )

1067 
info
 = 
cred
 . 
username
 , 
url

1068 
log
 . 
info
 ( 'Authenticating as %s for %s (from .pypirc)' , * 
info
 )

1070 if 
auth
 :

1071 
auth
 = "Basic " + 
_encode_auth
 ( 
auth
 )

1072 
parts
 = 
scheme
 , 
address
 , 
path
 , 
params
 , 
query
 , 
frag

1073 
new_url
 = 
urllib
 . 
parse
 . 
urlunparse
 ( 
parts
 )

1074 
request
 = 
urllib
 . 
request
 . 
Request
 ( 
new_url
 )

1075 
request
 . 
add_header
 ( "Authorization" , 
auth
 )

1077 
request
 = 
urllib
 . 
request
 . 
Request
 ( 
url
 )

1079 
request
 . 
add_header
 ( 'User-Agent' , 
user_agent
 )

1080 
fp
 = 
opener
 ( 
request
 )

1082 if 
auth
 :

1085 
s2
 , 
h2
 , 
path2
 , 
param2
 , 
query2
 , 
frag2
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
fp
 . 
url
 )

1086 if 
s2
 == 
scheme
 and 
h2
 == 
address
 :

1087 
parts
 = 
s2
 , 
netloc
 , 
path2
 , 
param2
 , 
query2
 , 
frag2

1088 
fp
 . 
url
 = 
urllib
 . 
parse
 . 
urlunparse
 ( 
parts
 )

1090 return 
fp
 
	}

1094 def 
	$_splituser
 ( 
host
 ) :

1096 
user
 , 
delim
 , 
host
 = 
host
 . 
rpartition
 ( '@' )

1097 return ( 
user
 if 
delim
 else None ) , 
host
 
	}

1101 
open_with_auth
 = 
socket_timeout
 ( 
_SOCKET_TIMEOUT
 ) ( 
open_with_auth
 )

1104 def 
	$fix_sf_url
 ( 
url
 ) :

1105 return 
url
 
	}

1108 def 
	$local_open
 ( 
url
 ) :

1110 
scheme
 , 
server
 , 
path
 , 
param
 , 
query
 , 
frag
 = 
urllib
 . 
parse
 . 
urlparse
 ( 
url
 )

1111 
filename
 = 
urllib
 . 
request
 . 
url2pathname
 ( 
path
 )

1112 if 
os
 . 
path
 . 
isfile
 ( 
filename
 ) :

1113 return 
urllib
 . 
request
 . 
urlopen
 ( 
url
 )

1114 elif 
path
 . 
endswith
 ( '/' ) and 
os
 . 
path
 . 
isdir
 ( 
filename
 ) :

1115 
files
 = [ ]

1116 for 
f
 in 
os
 . 
listdir
 ( 
filename
 ) :

1117 
filepath
 = 
os
 . 
path
 . 
join
 ( 
filename
 , 
f
 )

1118 if 
f
 == 'index.html' :

1119 with 
open
 ( 
filepath
 , 'r' ) as 
fp
 :

1120 
body
 = 
fp
 . 
read
 ( )

1122 elif 
os
 . 
path
 . 
isdir
 ( 
filepath
 ) :

1123 
f
 += '/'

1124 
files
 . 
append
 ( '<a href="{name}">{name}</a>' . 
format
 ( 
name
 = 
f
 ) )

1126 
tmpl
 = ( "<html><head><title>{url}</title>" "</head><body>{files}</body></html>"

1129 
body
 = 
tmpl
 . 
format
 ( 
url
 = 
url
 , 
files
 = '\n' . 
join
 ( 
files
 ) )

1130 
status
 , 
message
 = 200 , "OK"

1132 
status
 , 
message
 , 
body
 = 404 , "Path not found" , "Not found"

1134 
headers
 = { 'content-type' : 'text/html' }

1135 
body_stream
 = 
six
 . 
StringIO
 ( 
body
 )

1136 return 
urllib
 . 
error
 . 
HTTPError
 ( 
url
 , 
status
 , 
message
 , 
headers
 , 
body_stream
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/ssl_support.py

1 import 
	~os

2 import 
	~socket

3 import 
	~atexit

4 import 
	~re

5 import 
	~functools

7 from 
	~setuptools.extern.six.moves
 import 
urllib
 , 
http_client
 , 
map
 , 
filter

9 from 
	~pkg_resources
 import 
ResolutionError
 , 
ExtractionError

12 import 
	~ssl

13 except 
ImportError
 :

14 
ssl
 = None

16 
__all__
 = [ 'VerifyingHTTPSHandler'

21 
cert_paths
 = """\n/etc/pki/tls/certs/ca-bundle.crt\n/etc/ssl/certs/ca-certificates.crt\n/usr/share/ssl/certs/ca-bundle.crt\n/usr/local/share/certs/ca-root.crt\n/etc/ssl/cert.pem\n/System/Library/OpenSSL/certs/cert.pem\n/usr/local/share/certs/ca-root-nss.crt\n/etc/ssl/ca-bundle.pem\n"""

30 . 
strip
 ( ) . 
split
 ( )

33 
HTTPSHandler
 = 
urllib
 . 
request
 . 
HTTPSHandler

34 
HTTPSConnection
 = 
http_client
 . 
HTTPSConnection

35 except 
AttributeError
 :

36 
HTTPSHandler
 = 
HTTPSConnection
 = 
object

38 
is_available
 = 
ssl
 is not None and 
object
 not in ( 
HTTPSHandler
 , 
HTTPSConnection
 )

42 from 
	~ssl
 import 
CertificateError
 , 
match_hostname

43 except 
ImportError
 :

45 from 
	~backports.ssl_match_hostname
 import 
CertificateError

46 from 
	~backports.ssl_match_hostname
 import 
match_hostname

47 except 
ImportError
 :

48 
CertificateError
 = None

49 
match_hostname
 = None

51 if not 
CertificateError
 :

53 class 
	cCertificateError
 ( 
ValueError
 ) :

57 if not 
match_hostname
 :

59 def 
	$_dnsname_match
 ( 
dn
 , 
hostname
 , 
max_wildcards
 = 1 ) :

64 
pats
 = [ ]

65 if not 
dn
 :

70 
parts
 = 
dn
 . 
split
 ( r'.' )

71 
leftmost
 = 
parts
 [ 0 ]

72 
remainder
 = 
parts
 [ 1 : ]

74 
wildcards
 = 
leftmost
 . 
count
 ( '*' )

75 if 
wildcards
 > 
max_wildcards
 :

80 raise 
CertificateError
 ( "too many wildcards in certificate DNS name: "

81 + 
repr
 ( 
dn
 ) )

84 if not 
wildcards
 :

85 return 
dn
 . 
lower
 ( ) == 
hostname
 . 
lower
 ( )

90 if 
leftmost
 == '*' :

93 
pats
 . 
append
 ( '[^.]+' )

94 elif 
leftmost
 . 
startswith
 ( 'xn--' ) or 
hostname
 . 
startswith
 ( 'xn--' ) :

99 
pats
 . 
append
 ( 
re
 . 
escape
 ( 
leftmost
 ) )

102 
pats
 . 
append
 ( 
re
 . 
escape
 ( 
leftmost
 ) . 
replace
 ( r'\*' , '[^.]*' ) )

105 for 
frag
 in 
remainder
 :

106 
pats
 . 
append
 ( 
re
 . 
escape
 ( 
frag
 ) )

108 
pat
 = 
re
 . 
compile
 ( r'\A' + r'\.' . 
join
 ( 
pats
 ) + r'\Z' , 
re
 . 
IGNORECASE
 )

109 return 
pat
 . 
match
 ( 
hostname
 ) 
	}

111 def 
	$match_hostname
 ( 
cert
 , 
hostname
 ) :

119 if not 
cert
 :

120 raise 
ValueError
 ( "empty or no certificate" )

121 
dnsnames
 = [ ]

122 
san
 = 
cert
 . 
get
 ( 'subjectAltName' , ( ) )

123 for 
key
 , 
value
 in 
san
 :

124 if 
key
 == 'DNS' :

125 if 
_dnsname_match
 ( 
value
 , 
hostname
 ) :

127 
dnsnames
 . 
append
 ( 
value
 )

128 if not 
dnsnames
 :

131 for 
sub
 in 
cert
 . 
get
 ( 'subject' , ( ) ) :

132 for 
key
 , 
value
 in 
sub
 :

135 if 
key
 == 'commonName' :

136 if 
_dnsname_match
 ( 
value
 , 
hostname
 ) :

138 
dnsnames
 . 
append
 ( 
value
 )

139 if 
len
 ( 
dnsnames
 ) > 1 :

140 raise 
CertificateError
 ( "hostname %r " "doesn't match either of %s"

142 % ( 
hostname
 , ', ' . 
join
 ( 
map
 ( 
repr
 , 
dnsnames
 ) ) ) )

143 elif 
len
 ( 
dnsnames
 ) == 1 :

144 raise 
CertificateError
 ( "hostname %r " "doesn't match %r"

146 % ( 
hostname
 , 
dnsnames
 [ 0 ] ) )

148 raise 
CertificateError
 ( "no appropriate commonName or " "subjectAltName fields were found"

149 ) 
	}

152 class 
	cVerifyingHTTPSHandler
 ( 
HTTPSHandler
 ) :

155 def 
	$__init__
 ( 
self
 , 
ca_bundle
 ) :

156 
self
 . 
ca_bundle
 = 
ca_bundle

157 
HTTPSHandler
 . 
__init__
 ( 
self
 ) 
	}

159 def 
	$https_open
 ( 
self
 , 
req
 ) :

160 return 
self
 . 
do_open
 (

161 lambda 
host
 , ** 
kw
 : 
VerifyingHTTPSConn
 ( 
host
 , 
self
 . 
ca_bundle
 , ** 
kw
 ) , 
req

162 ) 
	}

165 class 
	cVerifyingHTTPSConn
 ( 
HTTPSConnection
 ) :

168 def 
	$__init__
 ( 
self
 , 
host
 , 
ca_bundle
 , ** 
kw
 ) :

169 
HTTPSConnection
 . 
__init__
 ( 
self
 , 
host
 , ** 
kw
 )

170 
self
 . 
ca_bundle
 = 
ca_bundle
 
	}

172 def 
	$connect
 ( 
self
 ) :

173 
sock
 = 
socket
 . 
create_connection
 (

174 ( 
self
 . 
host
 , 
self
 . 
port
 ) , 
getattr
 ( 
self
 , 'source_address' , None )

178 if 
hasattr
 ( 
self
 , '_tunnel' ) and 
getattr
 ( 
self
 , '_tunnel_host' , None ) :

179 
self
 . 
sock
 = 
sock

180 
self
 . 
_tunnel
 ( )

185 
actual_host
 = 
self
 . 
_tunnel_host

187 
actual_host
 = 
self
 . 
host

189 if 
hasattr
 ( 
ssl
 , 'create_default_context' ) :

190 
ctx
 = 
ssl
 . 
create_default_context
 ( 
cafile
 = 
self
 . 
ca_bundle
 )

191 
self
 . 
sock
 = 
ctx
 . 
wrap_socket
 ( 
sock
 , 
server_hostname
 = 
actual_host
 )

194 
self
 . 
sock
 = 
ssl
 . 
wrap_socket
 (

195 
sock
 , 
cert_reqs
 = 
ssl
 . 
CERT_REQUIRED
 , 
ca_certs
 = 
self
 . 
ca_bundle

198 
match_hostname
 ( 
self
 . 
sock
 . 
getpeercert
 ( ) , 
actual_host
 )

199 except 
CertificateError
 :

200 
self
 . 
sock
 . 
shutdown
 ( 
socket
 . 
SHUT_RDWR
 )

201 
self
 . 
sock
 . 
close
 ( )

202 raise 
	}

205 def 
	$opener_for
 ( 
ca_bundle
 = None ) :

207 return 
urllib
 . 
request
 . 
build_opener
 (

208 
VerifyingHTTPSHandler
 ( 
ca_bundle
 or 
find_ca_bundle
 ( ) )

209 ) . 
open
 
	}

213 def 
	$once
 ( 
func
 ) :

214 @ 
functools
 . 
	`wraps
 ( 
func
 )

215 def 
wrapper
 ( * 
args
 , ** 
kwargs
 ) :

216 if not 
hasattr
 ( 
func
 , 'always_returns' ) :

217 
func
 . 
always_returns
 = 
func
 ( * 
args
 , ** 
kwargs
 )

218 return 
func
 . 
always_returns

219 return 
wrapper
 
	}

222 @ 
	`once

223 def 
	$get_win_certfile
 ( ) :

225 import 
	~wincertstore

226 except 
ImportError
 :

229 class 
	cCertFile
 ( 
wincertstore
 . 
CertFile
 ) :

230 def 
__init__
 ( 
self
 ) :

231 
super
 ( 
CertFile
 , 
self
 ) . 
__init__
 ( )

232 
atexit
 . 
register
 ( 
self
 . 
close
 )

234 def 
close
 ( 
self
 ) :

236 
super
 ( 
CertFile
 , 
self
 ) . 
close
 ( )

237 except 
OSError
 :

240 
_wincerts
 = 
CertFile
 ( )

241 
_wincerts
 . 
addstore
 ( 'CA' )

242 
_wincerts
 . 
addstore
 ( 'ROOT' )

243 return 
_wincerts
 . 
name
 
	}

246 def 
	$find_ca_bundle
 ( ) :

248 
extant_cert_paths
 = 
filter
 ( 
os
 . 
path
 . 
isfile
 , 
cert_paths
 )

250 
get_win_certfile
 ( )

251 or 
next
 ( 
extant_cert_paths
 , None )

252 or 
_certifi_where
 ( )

253 ) 
	}

256 def 
	$_certifi_where
 ( ) :

258 return 
__import__
 ( 'certifi' ) . 
where
 ( )

259 except ( 
ImportError
 , 
ResolutionError
 , 
ExtractionError
 ) :

260 pass 
	}


	@./env/lib/python3.7/site-packages/setuptools/lib2to3_ex.py

10 from 
	~distutils.util
 import 
Mixin2to3
 as 
_Mixin2to3

11 from 
	~distutils
 import 
log

12 from 
	~lib2to3.refactor
 import 
RefactoringTool
 , 
get_fixers_from_package

14 import 
	~setuptools

17 class 
	cDistutilsRefactoringTool
 ( 
RefactoringTool
 ) :

18 def 
	$log_error
 ( 
self
 , 
msg
 , * 
args
 , ** 
kw
 ) :

19 
log
 . 
error
 ( 
msg
 , * 
args
 ) 
	}

21 def 
	$log_message
 ( 
self
 , 
msg
 , * 
args
 ) :

22 
log
 . 
info
 ( 
msg
 , * 
args
 ) 
	}

24 def 
	$log_debug
 ( 
self
 , 
msg
 , * 
args
 ) :

25 
log
 . 
debug
 ( 
msg
 , * 
args
 ) 
	}

28 class 
	cMixin2to3
 ( 
_Mixin2to3
 ) :

29 def 
	$run_2to3
 ( 
self
 , 
files
 , 
doctests
 = False ) :

32 if 
self
 . 
distribution
 . 
use_2to3
 is not True :

34 if not 
files
 :

36 
log
 . 
info
 ( "Fixing " + " " . 
join
 ( 
files
 ) )

37 
self
 . 
__build_fixer_names
 ( )

38 
self
 . 
__exclude_fixers
 ( )

39 if 
doctests
 :

40 if 
setuptools
 . 
run_2to3_on_doctests
 :

41 
r
 = 
DistutilsRefactoringTool
 ( 
self
 . 
fixer_names
 )

42 
r
 . 
refactor
 ( 
files
 , 
write
 = True , 
doctests_only
 = True )

44 
_Mixin2to3
 . 
run_2to3
 ( 
self
 , 
files
 ) 
	}

46 def 
	$__build_fixer_names
 ( 
self
 ) :

47 if 
self
 . 
fixer_names
 :

49 
self
 . 
fixer_names
 = [ ]

50 for 
p
 in 
setuptools
 . 
lib2to3_fixer_packages
 :

51 
self
 . 
fixer_names
 . 
extend
 ( 
get_fixers_from_package
 ( 
p
 ) )

52 if 
self
 . 
distribution
 . 
use_2to3_fixers
 is not None :

53 for 
p
 in 
self
 . 
distribution
 . 
use_2to3_fixers
 :

54 
self
 . 
fixer_names
 . 
extend
 ( 
get_fixers_from_package
 ( 
p
 ) ) 
	}

56 def 
	$__exclude_fixers
 ( 
self
 ) :

57 
excluded_fixers
 = 
getattr
 ( 
self
 , 'exclude_fixers' , [ ] )

58 if 
self
 . 
distribution
 . 
use_2to3_exclude_fixers
 is not None :

59 
excluded_fixers
 . 
extend
 ( 
self
 . 
distribution
 . 
use_2to3_exclude_fixers
 )

60 for 
fixer_name
 in 
excluded_fixers
 :

61 if 
fixer_name
 in 
self
 . 
fixer_names
 :

62 
self
 . 
fixer_names
 . 
remove
 ( 
fixer_name
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/archive_util.py

3 import 
	~zipfile

4 import 
	~tarfile

5 import 
	~os

6 import 
	~shutil

7 import 
	~posixpath

8 import 
	~contextlib

9 from 
	~distutils.errors
 import 
DistutilsError

11 from 
	~pkg_resources
 import 
ensure_directory

13 
__all__
 = [ "unpack_archive"

19 class 
	cUnrecognizedFormat
 ( 
DistutilsError
 ) :

23 def 
	$default_filter
 ( 
src
 , 
dst
 ) :

25 return 
dst
 
	}

28 def 
	$unpack_archive
 ( 
filename
 , 
extract_dir
 , 
progress_filter
 = 
default_filter
 ,

29 
drivers
 = None ) :

50 for 
driver
 in 
drivers
 or 
extraction_drivers
 :

52 
driver
 ( 
filename
 , 
extract_dir
 , 
progress_filter
 )

53 except 
UnrecognizedFormat
 :

58 raise 
UnrecognizedFormat
 ( "Not a recognized archive type: %s"

59 % 
filename

60 ) 
	}

63 def 
	$unpack_directory
 ( 
filename
 , 
extract_dir
 , 
progress_filter
 = 
default_filter
 ) :

68 if not 
os
 . 
path
 . 
isdir
 ( 
filename
 ) :

69 raise 
UnrecognizedFormat
 ( "%s is not a directory" % 
filename
 )

71 
paths
 = {

72 
filename
 : ( '' , 
extract_dir
 ) ,

74 for 
base
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
filename
 ) :

75 
src
 , 
dst
 = 
paths
 [ 
base
 ]

76 for 
d
 in 
dirs
 :

77 
paths
 [ 
os
 . 
path
 . 
join
 ( 
base
 , 
d
 ) ] = 
src
 + 
d
 + '/' , 
os
 . 
path
 . 
join
 ( 
dst
 , 
d
 )

78 for 
f
 in 
files
 :

79 
target
 = 
os
 . 
path
 . 
join
 ( 
dst
 , 
f
 )

80 
target
 = 
progress_filter
 ( 
src
 + 
f
 , 
target
 )

81 if not 
target
 :

84 
ensure_directory
 ( 
target
 )

85 
f
 = 
os
 . 
path
 . 
join
 ( 
base
 , 
f
 )

86 
shutil
 . 
copyfile
 ( 
f
 , 
target
 )

87 
shutil
 . 
copystat
 ( 
f
 , 
target
 ) 
	}

90 def 
	$unpack_zipfile
 ( 
filename
 , 
extract_dir
 , 
progress_filter
 = 
default_filter
 ) :

98 if not 
zipfile
 . 
is_zipfile
 ( 
filename
 ) :

99 raise 
UnrecognizedFormat
 ( "%s is not a zip file" % ( 
filename
 , ) )

101 with 
zipfile
 . 
ZipFile
 ( 
filename
 ) as 
z
 :

102 for 
info
 in 
z
 . 
infolist
 ( ) :

103 
name
 = 
info
 . 
filename

106 if 
name
 . 
startswith
 ( '/' ) or '..' in 
name
 . 
split
 ( '/' ) :

109 
target
 = 
os
 . 
path
 . 
join
 ( 
extract_dir
 , * 
name
 . 
split
 ( '/' ) )

110 
target
 = 
progress_filter
 ( 
name
 , 
target
 )

111 if not 
target
 :

113 if 
name
 . 
endswith
 ( '/' ) :

115 
ensure_directory
 ( 
target
 )

118 
ensure_directory
 ( 
target
 )

119 
data
 = 
z
 . 
read
 ( 
info
 . 
filename
 )

120 with 
open
 ( 
target
 , 'wb' ) as 
f
 :

121 
f
 . 
write
 ( 
data
 )

122 
unix_attributes
 = 
info
 . 
external_attr
 >> 16

123 if 
unix_attributes
 :

124 
os
 . 
chmod
 ( 
target
 , 
unix_attributes
 ) 
	}

127 def 
	$unpack_tarfile
 ( 
filename
 , 
extract_dir
 , 
progress_filter
 = 
default_filter
 ) :

135 
tarobj
 = 
tarfile
 . 
open
 ( 
filename
 )

136 except 
tarfile
 . 
TarError
 :

137 raise 
UnrecognizedFormat
 ( "%s is not a compressed or uncompressed tar file"

138 % ( 
filename
 , )

140 with 
contextlib
 . 
closing
 ( 
tarobj
 ) :

142 
tarobj
 . 
chown
 = lambda * 
args
 : None

143 for 
member
 in 
tarobj
 :

144 
name
 = 
member
 . 
name

146 if not 
name
 . 
startswith
 ( '/' ) and '..' not in 
name
 . 
split
 ( '/' ) :

147 
prelim_dst
 = 
os
 . 
path
 . 
join
 ( 
extract_dir
 , * 
name
 . 
split
 ( '/' ) )

151 while 
member
 is not None and ( 
member
 . 
islnk
 ( ) or 
member
 . 
issym
 ( ) ) :

152 
linkpath
 = 
member
 . 
linkname

153 if 
member
 . 
issym
 ( ) :

154 
base
 = 
posixpath
 . 
dirname
 ( 
member
 . 
name
 )

155 
linkpath
 = 
posixpath
 . 
join
 ( 
base
 , 
linkpath
 )

156 
linkpath
 = 
posixpath
 . 
normpath
 ( 
linkpath
 )

157 
member
 = 
tarobj
 . 
_getmember
 ( 
linkpath
 )

159 if 
member
 is not None and ( 
member
 . 
isfile
 ( ) or 
member
 . 
isdir
 ( ) ) :

160 
final_dst
 = 
progress_filter
 ( 
name
 , 
prelim_dst
 )

161 if 
final_dst
 :

162 if 
final_dst
 . 
endswith
 ( 
os
 . 
sep
 ) :

163 
final_dst
 = 
final_dst
 [ : - 1 ]

166 
tarobj
 . 
_extract_member
 ( 
member
 , 
final_dst
 )

167 except 
tarfile
 . 
ExtractError
 :

170 return True 
	}

173 
extraction_drivers
 = 
unpack_directory
 , 
unpack_zipfile
 , 
unpack_tarfile


	@./env/lib/python3.7/site-packages/setuptools/site-patch.py

1 def 
	$__boot
 ( ) :

2 import 
	~sys

3 import 
	~os

4 
PYTHONPATH
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' )

5 if 
PYTHONPATH
 is None or ( 
sys
 . 
platform
 == 'win32' and not 
PYTHONPATH
 ) :

6 
PYTHONPATH
 = [ ]

8 
PYTHONPATH
 = 
PYTHONPATH
 . 
split
 ( 
os
 . 
pathsep
 )

10 
pic
 = 
getattr
 ( 
sys
 , 'path_importer_cache' , { } )

11 
stdpath
 = 
sys
 . 
path
 [ 
len
 ( 
PYTHONPATH
 ) : ]

12 
mydir
 = 
os
 . 
path
 . 
dirname
 ( 
__file__
 )

14 for 
item
 in 
stdpath
 :

15 if 
item
 == 
mydir
 or not 
item
 :

17 
importer
 = 
pic
 . 
get
 ( 
item
 )

18 if 
importer
 is not None :

19 
loader
 = 
importer
 . 
find_module
 ( 'site' )

20 if 
loader
 is not None :

22 
loader
 . 
load_module
 ( 'site' )

26 import 
	~imp

27 
stream
 , 
path
 , 
descr
 = 
imp
 . 
find_module
 ( 'site' , [ 
item
 ] )

28 except 
ImportError
 :

30 if 
stream
 is None :

34 
imp
 . 
load_module
 ( 'site' , 
stream
 , 
path
 , 
descr
 )

36 
stream
 . 
close
 ( )

39 raise 
ImportError
 ( "Couldn't find the real 'site' module" )

41 
known_paths
 = 
dict
 ( [ ( 
makepath
 ( 
item
 ) [ 1 ] , 1 ) for 
item
 in 
sys
 . 
path
 ] )

43 
oldpos
 = 
getattr
 ( 
sys
 , '__egginsert' , 0 )

44 
sys
 . 
__egginsert
 = 0

46 for 
item
 in 
PYTHONPATH
 :

47 
addsitedir
 ( 
item
 )

49 
sys
 . 
__egginsert
 += 
oldpos

51 
d
 , 
nd
 = 
makepath
 ( 
stdpath
 [ 0 ] )

52 
insert_at
 = None

53 
new_path
 = [ ]

55 for 
item
 in 
sys
 . 
path
 :

56 
p
 , 
np
 = 
makepath
 ( 
item
 )

58 if 
np
 == 
nd
 and 
insert_at
 is None :

60 
insert_at
 = 
len
 ( 
new_path
 )

62 if 
np
 in 
known_paths
 or 
insert_at
 is None :

63 
new_path
 . 
append
 ( 
item
 )

66 
new_path
 . 
insert
 ( 
insert_at
 , 
item
 )

67 
insert_at
 += 1

69 
sys
 . 
path
 [ : ] = 
new_path
 
	}

72 if 
__name__
 == 'site' :

73 
__boot
 ( )

74 del 
__boot


	@./env/lib/python3.7/site-packages/setuptools/dep_util.py

1 from 
	~distutils.dep_util
 import 
newer_group

6 def 
	$newer_pairwise_group
 ( 
sources_groups
 , 
targets
 ) :

12 if 
len
 ( 
sources_groups
 ) != 
len
 ( 
targets
 ) :

13 raise 
ValueError
 ( "'sources_group' and 'targets' must be the same length" )

16 
n_sources
 = [ ]

17 
n_targets
 = [ ]

18 for 
i
 in 
range
 ( 
len
 ( 
sources_groups
 ) ) :

19 if 
newer_group
 ( 
sources_groups
 [ 
i
 ] , 
targets
 [ 
i
 ] ) :

20 
n_sources
 . 
append
 ( 
sources_groups
 [ 
i
 ] )

21 
n_targets
 . 
append
 ( 
targets
 [ 
i
 ] )

23 return 
n_sources
 , 
n_targets
 
	}


	@./env/lib/python3.7/site-packages/setuptools/build_meta.py

29 import 
	~os

30 import 
	~sys

31 import 
	~tokenize

32 import 
	~shutil

33 import 
	~contextlib

35 import 
	~setuptools

36 import 
	~distutils

38 
__all__
 = [ 'get_requires_for_build_sdist' , 'get_requires_for_build_wheel'

46 class 
	cSetupRequirementsError
 ( 
BaseException
 ) :

47 def 
	$__init__
 ( 
self
 , 
specifiers
 ) :

48 
self
 . 
specifiers
 = 
specifiers
 
	}

51 class 
	cDistribution
 ( 
setuptools
 . 
dist
 . 
Distribution
 ) :

52 def 
	$fetch_build_eggs
 ( 
self
 , 
specifiers
 ) :

53 raise 
SetupRequirementsError
 ( 
specifiers
 ) 
	}

55 @ 
classmethod

56 @ 
contextlib
 . 
	`contextmanager

57 def 
	$patch
 ( 
cls
 ) :

63 
orig
 = 
distutils
 . 
core
 . 
Distribution

64 
distutils
 . 
core
 . 
Distribution
 = 
cls

68 
distutils
 . 
core
 . 
Distribution
 = 
orig
 
	}

71 def 
	$_to_str
 ( 
s
 ) :

77 if 
sys
 . 
version_info
 [ 0 ] == 2 and not 
isinstance
 ( 
s
 , 
str
 ) :

80 return 
s
 . 
encode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

81 return 
s
 
	}

84 def 
	$_get_immediate_subdirectories
 ( 
a_dir
 ) :

85 return [ 
name
 for 
name
 in 
os
 . 
listdir
 ( 
a_dir
 )

86 if 
os
 . 
path
 . 
isdir
 ( 
os
 . 
path
 . 
join
 ( 
a_dir
 , 
name
 ) ) ] 
	}

89 def 
	$_file_with_extension
 ( 
directory
 , 
extension
 ) :

90 
matching
 = (

91 
f
 for 
f
 in 
os
 . 
listdir
 ( 
directory
 )

92 if 
f
 . 
endswith
 ( 
extension
 )

94 
file
 , = 
matching

95 return 
file
 
	}

98 class 
	c_BuildMetaBackend
 ( 
object
 ) :

100 def 
	$_fix_config
 ( 
self
 , 
config_settings
 ) :

101 
config_settings
 = 
config_settings
 or { }

102 
config_settings
 . 
setdefault
 ( '--global-option' , [ ] )

103 return 
config_settings
 
	}

105 def 
	$_get_build_requires
 ( 
self
 , 
config_settings
 , 
requirements
 ) :

106 
config_settings
 = 
self
 . 
_fix_config
 ( 
config_settings
 )

108 
sys
 . 
argv
 = 
sys
 . 
argv
 [ : 1 ] + [ 'egg_info' ] +

109 
config_settings
 [ "--global-option" ]

111 with 
Distribution
 . 
patch
 ( ) :

112 
self
 . 
run_setup
 ( )

113 except 
SetupRequirementsError
 as 
e
 :

114 
requirements
 += 
e
 . 
specifiers

116 return 
requirements
 
	}

118 def 
	$run_setup
 ( 
self
 , 
setup_script
 = 'setup.py' ) :

121 
__file__
 = 
setup_script

122 
__name__
 = '__main__'

123 
f
 = 
getattr
 ( 
tokenize
 , 'open' , 
open
 ) ( 
__file__
 )

124 
code
 = 
f
 . 
read
 ( ) . 
replace
 ( '\\r\\n' , '\\n' )

125 
f
 . 
close
 ( )

126 
exec
 ( 
compile
 ( 
code
 , 
__file__
 , 'exec' ) , 
locals
 ( ) ) 
	}

128 def 
	$get_requires_for_build_wheel
 ( 
self
 , 
config_settings
 = None ) :

129 
config_settings
 = 
self
 . 
_fix_config
 ( 
config_settings
 )

130 return 
self
 . 
_get_build_requires
 ( 
config_settings
 , 
requirements
 = [ 'wheel' ] ) 
	}

132 def 
	$get_requires_for_build_sdist
 ( 
self
 , 
config_settings
 = None ) :

133 
config_settings
 = 
self
 . 
_fix_config
 ( 
config_settings
 )

134 return 
self
 . 
_get_build_requires
 ( 
config_settings
 , 
requirements
 = [ ] ) 
	}

136 def 
	$prepare_metadata_for_build_wheel
 ( 
self
 , 
metadata_directory
 ,

137 
config_settings
 = None ) :

138 
sys
 . 
argv
 = 
sys
 . 
argv
 [ : 1 ] + [ 'dist_info' , '--egg-base' ,

139 
_to_str
 ( 
metadata_directory
 ) ]

140 
self
 . 
run_setup
 ( )

142 
dist_info_directory
 = 
metadata_directory

144 
dist_infos
 = [ 
f
 for 
f
 in 
os
 . 
listdir
 ( 
dist_info_directory
 )

145 if 
f
 . 
endswith
 ( '.dist-info' ) ]

147 if ( 
len
 ( 
dist_infos
 ) == 0 and

148 
len
 ( 
_get_immediate_subdirectories
 ( 
dist_info_directory
 ) ) == 1 ) :

150 
dist_info_directory
 = 
os
 . 
path
 . 
join
 (

151 
dist_info_directory
 , 
os
 . 
listdir
 ( 
dist_info_directory
 ) [ 0 ] )

154 assert 
len
 ( 
dist_infos
 ) == 1

159 if 
dist_info_directory
 != 
metadata_directory
 :

160 
shutil
 . 
move
 (

161 
os
 . 
path
 . 
join
 ( 
dist_info_directory
 , 
dist_infos
 [ 0 ] ) ,

162 
metadata_directory
 )

163 
shutil
 . 
rmtree
 ( 
dist_info_directory
 , 
ignore_errors
 = True )

165 return 
dist_infos
 [ 0 ] 
	}

167 def 
	$build_wheel
 ( 
self
 , 
wheel_directory
 , 
config_settings
 = None ,

168 
metadata_directory
 = None ) :

169 
config_settings
 = 
self
 . 
_fix_config
 ( 
config_settings
 )

170 
wheel_directory
 = 
os
 . 
path
 . 
abspath
 ( 
wheel_directory
 )

171 
sys
 . 
argv
 = 
sys
 . 
argv
 [ : 1 ] + [ 'bdist_wheel' ] +

172 
config_settings
 [ "--global-option" ]

173 
self
 . 
run_setup
 ( )

174 if 
wheel_directory
 != 'dist' :

175 
shutil
 . 
rmtree
 ( 
wheel_directory
 )

176 
shutil
 . 
copytree
 ( 'dist' , 
wheel_directory
 )

178 return 
_file_with_extension
 ( 
wheel_directory
 , '.whl' ) 
	}

180 def 
	$build_sdist
 ( 
self
 , 
sdist_directory
 , 
config_settings
 = None ) :

181 
config_settings
 = 
self
 . 
_fix_config
 ( 
config_settings
 )

182 
sdist_directory
 = 
os
 . 
path
 . 
abspath
 ( 
sdist_directory
 )

183 
sys
 . 
argv
 = 
sys
 . 
argv
 [ : 1 ] + [ 'sdist' , '--formats' , 'gztar' ] +

184 
config_settings
 [ "--global-option" ] +

185 [ "--dist-dir" , 
sdist_directory
 ]

186 
self
 . 
run_setup
 ( )

188 return 
_file_with_extension
 ( 
sdist_directory
 , '.tar.gz' ) 
	}

191 class 
	c_BuildMetaLegacyBackend
 ( 
_BuildMetaBackend
 ) :

199 def 
	$run_setup
 ( 
self
 , 
setup_script
 = 'setup.py' ) :

203 
sys_path
 = 
list
 ( 
sys
 . 
path
 )

205 
script_dir
 = 
os
 . 
path
 . 
dirname
 ( 
os
 . 
path
 . 
abspath
 ( 
setup_script
 ) )

206 if 
script_dir
 not in 
sys
 . 
path
 :

207 
sys
 . 
path
 . 
insert
 ( 0 , 
script_dir
 )

210 
super
 ( 
_BuildMetaLegacyBackend
 ,

211 
self
 ) . 
run_setup
 ( 
setup_script
 = 
setup_script
 )

218 
sys
 . 
path
 [ : ] = 
sys_path
 
	}

221 
_BACKEND
 = 
_BuildMetaBackend
 ( )

223 
get_requires_for_build_wheel
 = 
_BACKEND
 . 
get_requires_for_build_wheel

224 
get_requires_for_build_sdist
 = 
_BACKEND
 . 
get_requires_for_build_sdist

225 
prepare_metadata_for_build_wheel
 = 
_BACKEND
 . 
prepare_metadata_for_build_wheel

226 
build_wheel
 = 
_BACKEND
 . 
build_wheel

227 
build_sdist
 = 
_BACKEND
 . 
build_sdist

231 
__legacy__
 = 
_BuildMetaLegacyBackend
 ( )


	@./env/lib/python3.7/site-packages/setuptools/monkey.py

5 import 
	~sys

6 import 
	~distutils.filelist

7 import 
	~platform

8 import 
	~types

9 import 
	~functools

10 from 
	~importlib
 import 
import_module

11 import 
	~inspect

13 from 
	~setuptools.extern
 import 
six

15 import 
	~setuptools

17 
__all__
 = [ ] """\nEverything is private. Contact the project team\nif you think you need this functionality.\n"""

24 def 
	$_get_mro
 ( 
cls
 ) :

33 if 
platform
 . 
python_implementation
 ( ) == "Jython" :

34 return ( 
cls
 , ) + 
cls
 . 
__bases__

35 return 
inspect
 . 
getmro
 ( 
cls
 ) 
	}

38 def 
	$get_unpatched
 ( 
item
 ) :

39 
lookup
 = (

40 
get_unpatched_class
 if 
isinstance
 ( 
item
 , 
six
 . 
class_types
 ) else

41 
get_unpatched_function
 if 
isinstance
 ( 
item
 , 
types
 . 
FunctionType
 ) else

42 lambda 
item
 : None

44 return 
lookup
 ( 
item
 ) 
	}

47 def 
	$get_unpatched_class
 ( 
cls
 ) :

53 
external_bases
 = (

54 
cls

55 for 
cls
 in 
_get_mro
 ( 
cls
 )

56 if not 
cls
 . 
__module__
 . 
startswith
 ( 'setuptools' )

58 
base
 = 
next
 ( 
external_bases
 )

59 if not 
base
 . 
__module__
 . 
startswith
 ( 'distutils' ) :

60 
msg
 = "distutils has already been patched by %r" % 
cls

61 raise 
AssertionError
 ( 
msg
 )

62 return 
base
 
	}

65 def 
	$patch_all
 ( ) :

67 
distutils
 . 
core
 . 
Command
 = 
setuptools
 . 
Command

69 
has_issue_12885
 = 
sys
 . 
version_info
 <= ( 3 , 5 , 3 )

71 if 
has_issue_12885
 :

73 
distutils
 . 
filelist
 . 
findall
 = 
setuptools
 . 
findall

75 
needs_warehouse
 = (

76 
sys
 . 
version_info
 < ( 2 , 7 , 13 )

78 ( 3 , 4 ) < 
sys
 . 
version_info
 < ( 3 , 4 , 6 )

80 ( 3 , 5 ) < 
sys
 . 
version_info
 <= ( 3 , 5 , 3 )

83 if 
needs_warehouse
 :

84 
warehouse
 = 'https://upload.pypi.org/legacy/'

85 
distutils
 . 
config
 . 
PyPIRCCommand
 . 
DEFAULT_REPOSITORY
 = 
warehouse

87 
_patch_distribution_metadata
 ( )

90 for 
module
 in 
distutils
 . 
dist
 , 
distutils
 . 
core
 , 
distutils
 . 
cmd
 :

91 
module
 . 
Distribution
 = 
setuptools
 . 
dist
 . 
Distribution

94 
distutils
 . 
core
 . 
Extension
 = 
setuptools
 . 
extension
 . 
Extension

95 
distutils
 . 
extension
 . 
Extension
 = 
setuptools
 . 
extension
 . 
Extension

96 if 'distutils.command.build_ext' in 
sys
 . 
modules
 :

97 
sys
 . 
modules
 [ 'distutils.command.build_ext' ] . 
Extension
 = (

98 
setuptools
 . 
extension
 . 
Extension

101 
patch_for_msvc_specialized_compiler
 ( ) 
	}

104 def 
	$_patch_distribution_metadata
 ( ) :

106 for 
attr
 in ( 'write_pkg_file' , 'read_pkg_file' , 'get_metadata_version' ) :

107 
new_val
 = 
getattr
 ( 
setuptools
 . 
dist
 , 
attr
 )

108 
setattr
 ( 
distutils
 . 
dist
 . 
DistributionMetadata
 , 
attr
 , 
new_val
 ) 
	}

111 def 
	$patch_func
 ( 
replacement
 , 
target_mod
 , 
func_name
 ) :

118 
original
 = 
getattr
 ( 
target_mod
 , 
func_name
 )

122 
vars
 ( 
replacement
 ) . 
setdefault
 ( 'unpatched' , 
original
 )

125 
setattr
 ( 
target_mod
 , 
func_name
 , 
replacement
 ) 
	}

128 def 
	$get_unpatched_function
 ( 
candidate
 ) :

129 return 
getattr
 ( 
candidate
 , 'unpatched' ) 
	}

132 def 
	$patch_for_msvc_specialized_compiler
 ( ) :

138 
msvc
 = 
import_module
 ( 'setuptools.msvc' )

140 if 
platform
 . 
system
 ( ) != 'Windows' :

144 def 
patch_params
 ( 
mod_name
 , 
func_name
 ) :

148 
repl_prefix
 = 'msvc9_' if 'msvc9' in 
mod_name
 else 'msvc14_'

149 
repl_name
 = 
repl_prefix
 + 
func_name
 . 
lstrip
 ( '_' )

150 
repl
 = 
getattr
 ( 
msvc
 , 
repl_name
 )

151 
mod
 = 
import_module
 ( 
mod_name
 )

152 if not 
hasattr
 ( 
mod
 , 
func_name
 ) :

153 raise 
ImportError
 ( 
func_name
 )

154 return 
repl
 , 
mod
 , 
func_name

157 
msvc9
 = 
functools
 . 
partial
 ( 
patch_params
 , 'distutils.msvc9compiler' )

160 
msvc14
 = 
functools
 . 
partial
 ( 
patch_params
 , 'distutils._msvccompiler' )

164 
patch_func
 ( * 
msvc9
 ( 'find_vcvarsall' ) )

165 
patch_func
 ( * 
msvc9
 ( 'query_vcvarsall' ) )

166 except 
ImportError
 :

171 
patch_func
 ( * 
msvc14
 ( '_get_vc_env' ) )

172 except 
ImportError
 :

177 
patch_func
 ( * 
msvc14
 ( 'gen_lib_options' ) )

178 except 
ImportError
 :

179 pass 
	}


	@./env/lib/python3.7/site-packages/setuptools/version.py

1 import 
	~pkg_resources

4 
__version__
 = 
pkg_resources
 . 
get_distribution
 ( 'setuptools' ) . 
version

5 except 
Exception
 :

6 
__version__
 = 'unknown'


	@./env/lib/python3.7/site-packages/setuptools/command/bdist_egg.py

5 from 
	~distutils.errors
 import 
DistutilsSetupError

6 from 
	~distutils.dir_util
 import 
remove_tree
 , 
mkpath

7 from 
	~distutils
 import 
log

8 from 
	~types
 import 
CodeType

9 import 
	~sys

10 import 
	~os

11 import 
	~re

12 import 
	~textwrap

13 import 
	~marshal

15 from 
	~setuptools.extern
 import 
six

17 from 
	~pkg_resources
 import 
get_build_platform
 , 
Distribution
 , 
ensure_directory

18 from 
	~pkg_resources
 import 
EntryPoint

19 from 
	~setuptools.extension
 import 
Library

20 from 
	~setuptools
 import 
Command

24 from 
	~sysconfig
 import 
get_path
 , 
get_python_version

26 def 
	$_get_purelib
 ( ) :

27 return 
get_path
 ( "purelib" ) 
	}

28 except 
ImportError
 :

29 from 
	~distutils.sysconfig
 import 
get_python_lib
 , 
get_python_version

31 def 
	$_get_purelib
 ( ) :

32 return 
get_python_lib
 ( False ) 
	}

35 def 
	$strip_module
 ( 
filename
 ) :

36 if '.' in 
filename
 :

37 
filename
 = 
os
 . 
path
 . 
splitext
 ( 
filename
 ) [ 0 ]

38 if 
filename
 . 
endswith
 ( 'module' ) :

39 
filename
 = 
filename
 [ : - 6 ]

40 return 
filename
 
	}

43 def 
	$sorted_walk
 ( 
dir
 ) :

47 for 
base
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
dir
 ) :

48 
dirs
 . 
sort
 ( )

49 
files
 . 
sort
 ( )

50 yield 
base
 , 
dirs
 , 
files
 
	}

53 def 
	$write_stub
 ( 
resource
 , 
pyfile
 ) :

54 
_stub_template
 = 
textwrap
 . 
dedent
 ( """\n        def __bootstrap__():\n            global __bootstrap__, __loader__, __file__\n            import sys, pkg_resources, imp\n            __file__ = pkg_resources.resource_filename(__name__, %r)\n            __loader__ = None; del __bootstrap__, __loader__\n            imp.load_dynamic(__name__,__file__)\n        __bootstrap__()\n        """

62 ) . 
lstrip
 ( )

63 with 
open
 ( 
pyfile
 , 'w' ) as 
f
 :

64 
f
 . 
write
 ( 
_stub_template
 % 
resource
 ) 
	}

67 class 
	cbdist_egg
 ( 
Command
 ) :

68 
description
 = "create an \"egg\" distribution"

70 
user_options
 = [

74 % 
get_build_platform
 ( ) ) ,

86 
boolean_options
 = [ 'keep-temp'

90 def 
	$initialize_options
 ( 
self
 ) :

91 
self
 . 
bdist_dir
 = None

92 
self
 . 
plat_name
 = None

93 
self
 . 
keep_temp
 = 0

94 
self
 . 
dist_dir
 = None

95 
self
 . 
skip_build
 = 0

96 
self
 . 
egg_output
 = None

97 
self
 . 
exclude_source_files
 = None 
	}

99 def 
	$finalize_options
 ( 
self
 ) :

100 
ei_cmd
 = 
self
 . 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

101 
self
 . 
egg_info
 = 
ei_cmd
 . 
egg_info

103 if 
self
 . 
bdist_dir
 is None :

104 
bdist_base
 = 
self
 . 
get_finalized_command
 ( 'bdist' ) . 
bdist_base

105 
self
 . 
bdist_dir
 = 
os
 . 
path
 . 
join
 ( 
bdist_base
 , 'egg' )

107 if 
self
 . 
plat_name
 is None :

108 
self
 . 
plat_name
 = 
get_build_platform
 ( )

110 
self
 . 
set_undefined_options
 ( 'bdist' , ( 'dist_dir' , 'dist_dir' ) )

112 if 
self
 . 
egg_output
 is None :

115 
basename
 = 
Distribution
 (

116 None , None , 
ei_cmd
 . 
egg_name
 , 
ei_cmd
 . 
egg_version
 ,

117 
get_python_version
 ( ) ,

118 
self
 . 
distribution
 . 
has_ext_modules
 ( ) and 
self
 . 
plat_name

119 ) . 
egg_name
 ( )

121 
self
 . 
egg_output
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
dist_dir
 , 
basename
 + '.egg' ) 
	}

123 def 
	$do_install_data
 ( 
self
 ) :

125 
self
 . 
get_finalized_command
 ( 'install' ) . 
install_lib
 = 
self
 . 
bdist_dir

127 
site_packages
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
realpath
 ( 
_get_purelib
 ( ) ) )

128 
old
 , 
self
 . 
distribution
 . 
data_files
 = 
self
 . 
distribution
 . 
data_files
 , [ ]

130 for 
item
 in 
old
 :

131 if 
isinstance
 ( 
item
 , 
tuple
 ) and 
len
 ( 
item
 ) == 2 :

132 if 
os
 . 
path
 . 
isabs
 ( 
item
 [ 0 ] ) :

133 
realpath
 = 
os
 . 
path
 . 
realpath
 ( 
item
 [ 0 ] )

134 
normalized
 = 
os
 . 
path
 . 
normcase
 ( 
realpath
 )

135 if 
normalized
 == 
site_packages
 or 
normalized
 . 
startswith
 (

136 
site_packages
 + 
os
 . 
sep

138 
item
 = 
realpath
 [ 
len
 ( 
site_packages
 ) + 1 : ] , 
item
 [ 1 ]

140 
self
 . 
distribution
 . 
data_files
 . 
append
 ( 
item
 )

143 
log
 . 
info
 ( "installing package data to %s" , 
self
 . 
bdist_dir
 )

144 
self
 . 
call_command
 ( 'install_data' , 
force
 = 0 , 
root
 = None )

146 
self
 . 
distribution
 . 
data_files
 = 
old
 
	}

148 def 
	$get_outputs
 ( 
self
 ) :

149 return [ 
self
 . 
egg_output
 ] 
	}

151 def 
	$call_command
 ( 
self
 , 
cmdname
 , ** 
kw
 ) :

153 for 
dirname
 in 
INSTALL_DIRECTORY_ATTRS
 :

154 
kw
 . 
setdefault
 ( 
dirname
 , 
self
 . 
bdist_dir
 )

155 
kw
 . 
setdefault
 ( 'skip_build' , 
self
 . 
skip_build
 )

156 
kw
 . 
setdefault
 ( 'dry_run' , 
self
 . 
dry_run
 )

157 
cmd
 = 
self
 . 
reinitialize_command
 ( 
cmdname
 , ** 
kw
 )

158 
self
 . 
run_command
 ( 
cmdname
 )

159 return 
cmd
 
	}

161 def 
	$run
 ( 
self
 ) :

163 
self
 . 
run_command
 ( "egg_info" )

166 
log
 . 
info
 ( "installing library code to %s" , 
self
 . 
bdist_dir
 )

167 
instcmd
 = 
self
 . 
get_finalized_command
 ( 'install' )

168 
old_root
 = 
instcmd
 . 
root

169 
instcmd
 . 
root
 = None

170 if 
self
 . 
distribution
 . 
has_c_libraries
 ( ) and not 
self
 . 
skip_build
 :

171 
self
 . 
run_command
 ( 'build_clib' )

172 
cmd
 = 
self
 . 
call_command
 ( 'install_lib' , 
warn_dir
 = 0 )

173 
instcmd
 . 
root
 = 
old_root

175 
all_outputs
 , 
ext_outputs
 = 
self
 . 
get_ext_outputs
 ( )

176 
self
 . 
stubs
 = [ ]

177 
to_compile
 = [ ]

178 for ( 
p
 , 
ext_name
 ) in 
enumerate
 ( 
ext_outputs
 ) :

179 
filename
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
ext_name
 )

180 
pyfile
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
bdist_dir
 , 
strip_module
 ( 
filename
 ) + '.py'

182 
self
 . 
stubs
 . 
append
 ( 
pyfile
 )

183 
log
 . 
info
 ( "creating stub loader for %s" , 
ext_name
 )

184 if not 
self
 . 
dry_run
 :

185 
write_stub
 ( 
os
 . 
path
 . 
basename
 ( 
ext_name
 ) , 
pyfile
 )

186 
to_compile
 . 
append
 ( 
pyfile
 )

187 
ext_outputs
 [ 
p
 ] = 
ext_name
 . 
replace
 ( 
os
 . 
sep
 , '/' )

189 if 
to_compile
 :

190 
cmd
 . 
byte_compile
 ( 
to_compile
 )

191 if 
self
 . 
distribution
 . 
data_files
 :

192 
self
 . 
do_install_data
 ( )

195 
archive_root
 = 
self
 . 
bdist_dir

196 
egg_info
 = 
os
 . 
path
 . 
join
 ( 
archive_root
 , 'EGG-INFO' )

197 
self
 . 
mkpath
 ( 
egg_info
 )

198 if 
self
 . 
distribution
 . 
scripts
 :

199 
script_dir
 = 
os
 . 
path
 . 
join
 ( 
egg_info
 , 'scripts' )

200 
log
 . 
info
 ( "installing scripts to %s" , 
script_dir
 )

201 
self
 . 
call_command
 ( 'install_scripts' , 
install_dir
 = 
script_dir
 ,

202 
no_ep
 = 1 )

204 
self
 . 
copy_metadata_to
 ( 
egg_info
 )

205 
native_libs
 = 
os
 . 
path
 . 
join
 ( 
egg_info
 , "native_libs.txt" )

206 if 
all_outputs
 :

207 
log
 . 
info
 ( "writing %s" , 
native_libs
 )

208 if not 
self
 . 
dry_run
 :

209 
ensure_directory
 ( 
native_libs
 )

210 
libs_file
 = 
open
 ( 
native_libs
 , 'wt' )

211 
libs_file
 . 
write
 ( '\n' . 
join
 ( 
all_outputs
 ) )

212 
libs_file
 . 
write
 ( '\n' )

213 
libs_file
 . 
close
 ( )

214 elif 
os
 . 
path
 . 
isfile
 ( 
native_libs
 ) :

215 
log
 . 
info
 ( "removing %s" , 
native_libs
 )

216 if not 
self
 . 
dry_run
 :

217 
os
 . 
unlink
 ( 
native_libs
 )

219 
write_safety_flag
 (

220 
os
 . 
path
 . 
join
 ( 
archive_root
 , 'EGG-INFO' ) , 
self
 . 
zip_safe
 ( )

223 if 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_info
 , 'depends.txt' ) ) :

224 
log
 . 
warn
 ( "WARNING: 'depends.txt' will not be used by setuptools 0.6!\n" "Use the install_requires/extras_require setup() args instead."

229 if 
self
 . 
exclude_source_files
 :

230 
self
 . 
zap_pyfiles
 ( )

233 
make_zipfile
 ( 
self
 . 
egg_output
 , 
archive_root
 , 
verbose
 = 
self
 . 
verbose
 ,

234 
dry_run
 = 
self
 . 
dry_run
 , 
mode
 = 
self
 . 
gen_header
 ( ) )

235 if not 
self
 . 
keep_temp
 :

236 
remove_tree
 ( 
self
 . 
bdist_dir
 , 
dry_run
 = 
self
 . 
dry_run
 )

239 
getattr
 ( 
self
 . 
distribution
 , 'dist_files' , [ ] ) . 
append
 (

240 ( 'bdist_egg' , 
get_python_version
 ( ) , 
self
 . 
egg_output
 ) ) 
	}

242 def 
	$zap_pyfiles
 ( 
self
 ) :

243 
log
 . 
info
 ( "Removing .py files from temporary directory" )

244 for 
base
 , 
dirs
 , 
files
 in 
walk_egg
 ( 
self
 . 
bdist_dir
 ) :

245 for 
name
 in 
files
 :

246 
path
 = 
os
 . 
path
 . 
join
 ( 
base
 , 
name
 )

248 if 
name
 . 
endswith
 ( '.py' ) :

249 
log
 . 
debug
 ( "Deleting %s" , 
path
 )

250 
os
 . 
unlink
 ( 
path
 )

252 if 
base
 . 
endswith
 ( '__pycache__' ) :

253 
path_old
 = 
path

255 
pattern
 = r'(?P<name>.+)\.(?P<magic>[^.]+)\.pyc'

256 
m
 = 
re
 . 
match
 ( 
pattern
 , 
name
 )

257 
path_new
 = 
os
 . 
path
 . 
join
 (

258 
base
 , 
os
 . 
pardir
 , 
m
 . 
group
 ( 'name' ) + '.pyc' )

259 
log
 . 
info
 ( "Renaming file from [%s] to [%s]"

261 % ( 
path_old
 , 
path_new
 ) )

263 
os
 . 
remove
 ( 
path_new
 )

264 except 
OSError
 :

266 
os
 . 
rename
 ( 
path_old
 , 
path_new
 ) 
	}

268 def 
	$zip_safe
 ( 
self
 ) :

269 
safe
 = 
getattr
 ( 
self
 . 
distribution
 , 'zip_safe' , None )

270 if 
safe
 is not None :

271 return 
safe

272 
log
 . 
warn
 ( "zip_safe flag not set; analyzing archive contents..." )

273 return 
analyze_egg
 ( 
self
 . 
bdist_dir
 , 
self
 . 
stubs
 ) 
	}

275 def 
	$gen_header
 ( 
self
 ) :

276 
epm
 = 
EntryPoint
 . 
parse_map
 ( 
self
 . 
distribution
 . 
entry_points
 or '' )

277 
ep
 = 
epm
 . 
get
 ( 'setuptools.installation' , { } ) . 
get
 ( 'eggsecutable' )

278 if 
ep
 is None :

281 if not 
ep
 . 
attrs
 or 
ep
 . 
extras
 :

282 raise 
DistutilsSetupError
 ( "eggsecutable entry point (%r) cannot have 'extras' " "or refer to a module"

284 % ( 
ep
 , )

287 
pyver
 = 
sys
 . 
version
 [ : 3 ]

288 
pkg
 = 
ep
 . 
module_name

289 
full
 = '.' . 
join
 ( 
ep
 . 
attrs
 )

290 
base
 = 
ep
 . 
attrs
 [ 0 ]

291 
basename
 = 
os
 . 
path
 . 
basename
 ( 
self
 . 
egg_output
 )

293 
header
 = ( "#!/bin/sh\n" 'if [ `basename $0` = "%(basename)s" ]\n' 'then exec python%(pyver)s -c "' "import sys, os; sys.path.insert(0, os.path.abspath('$0')); " "from %(pkg)s import %(base)s; sys.exit(%(full)s())" '" "$@"\n' 'else\n' '  echo $0 is not the correct name for this egg file.\n' '  echo Please rename it back to %(basename)s and try again.\n' '  exec false\n' 'fi\n'

305 ) % 
locals
 ( )

307 if not 
self
 . 
dry_run
 :

308 
mkpath
 ( 
os
 . 
path
 . 
dirname
 ( 
self
 . 
egg_output
 ) , 
dry_run
 = 
self
 . 
dry_run
 )

309 
f
 = 
open
 ( 
self
 . 
egg_output
 , 'w' )

310 
f
 . 
write
 ( 
header
 )

311 
f
 . 
close
 ( )

312 return 'a' 
	}

314 def 
	$copy_metadata_to
 ( 
self
 , 
target_dir
 ) :

318 
norm_egg_info
 = 
os
 . 
path
 . 
normpath
 ( 
self
 . 
egg_info
 )

319 
prefix
 = 
os
 . 
path
 . 
join
 ( 
norm_egg_info
 , '' )

320 for 
path
 in 
self
 . 
ei_cmd
 . 
filelist
 . 
files
 :

321 if 
path
 . 
startswith
 ( 
prefix
 ) :

322 
target
 = 
os
 . 
path
 . 
join
 ( 
target_dir
 , 
path
 [ 
len
 ( 
prefix
 ) : ] )

323 
ensure_directory
 ( 
target
 )

324 
self
 . 
copy_file
 ( 
path
 , 
target
 ) 
	}

326 def 
	$get_ext_outputs
 ( 
self
 ) :

329 
all_outputs
 = [ ]

330 
ext_outputs
 = [ ]

332 
paths
 = { 
self
 . 
bdist_dir
 : '' }

333 for 
base
 , 
dirs
 , 
files
 in 
sorted_walk
 ( 
self
 . 
bdist_dir
 ) :

334 for 
filename
 in 
files
 :

335 if 
os
 . 
path
 . 
splitext
 ( 
filename
 ) [ 1 ] . 
lower
 ( ) in 
NATIVE_EXTENSIONS
 :

336 
all_outputs
 . 
append
 ( 
paths
 [ 
base
 ] + 
filename
 )

337 for 
filename
 in 
dirs
 :

338 
paths
 [ 
os
 . 
path
 . 
join
 ( 
base
 , 
filename
 ) ] = ( 
paths
 [ 
base
 ] +

339 
filename
 + '/' )

341 if 
self
 . 
distribution
 . 
has_ext_modules
 ( ) :

342 
build_cmd
 = 
self
 . 
get_finalized_command
 ( 'build_ext' )

343 for 
ext
 in 
build_cmd
 . 
extensions
 :

344 if 
isinstance
 ( 
ext
 , 
Library
 ) :

346 
fullname
 = 
build_cmd
 . 
get_ext_fullname
 ( 
ext
 . 
name
 )

347 
filename
 = 
build_cmd
 . 
get_ext_filename
 ( 
fullname
 )

348 if not 
os
 . 
path
 . 
basename
 ( 
filename
 ) . 
startswith
 ( 'dl-' ) :

349 if 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
self
 . 
bdist_dir
 , 
filename
 ) ) :

350 
ext_outputs
 . 
append
 ( 
filename
 )

352 return 
all_outputs
 , 
ext_outputs
 
	}

355 
NATIVE_EXTENSIONS
 = 
dict
 . 
fromkeys
 ( '.dll .so .dylib .pyd' . 
split
 ( ) )

358 def 
	$walk_egg
 ( 
egg_dir
 ) :

360 
walker
 = 
sorted_walk
 ( 
egg_dir
 )

361 
base
 , 
dirs
 , 
files
 = 
next
 ( 
walker
 )

362 if 'EGG-INFO' in 
dirs
 :

363 
dirs
 . 
remove
 ( 'EGG-INFO' )

364 yield 
base
 , 
dirs
 , 
files

365 for 
bdf
 in 
walker
 :

366 yield 
bdf
 
	}

369 def 
	$analyze_egg
 ( 
egg_dir
 , 
stubs
 ) :

371 for 
flag
 , 
fn
 in 
safety_flags
 . 
items
 ( ) :

372 if 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
egg_dir
 , 'EGG-INFO' , 
fn
 ) ) :

373 return 
flag

374 if not 
can_scan
 ( ) :

376 
safe
 = True

377 for 
base
 , 
dirs
 , 
files
 in 
walk_egg
 ( 
egg_dir
 ) :

378 for 
name
 in 
files
 :

379 if 
name
 . 
endswith
 ( '.py' ) or 
name
 . 
endswith
 ( '.pyw' ) :

381 elif 
name
 . 
endswith
 ( '.pyc' ) or 
name
 . 
endswith
 ( '.pyo' ) :

383 
safe
 = 
scan_module
 ( 
egg_dir
 , 
base
 , 
name
 , 
stubs
 ) and 
safe

384 return 
safe
 
	}

387 def 
	$write_safety_flag
 ( 
egg_dir
 , 
safe
 ) :

389 for 
flag
 , 
fn
 in 
safety_flags
 . 
items
 ( ) :

390 
fn
 = 
os
 . 
path
 . 
join
 ( 
egg_dir
 , 
fn
 )

391 if 
os
 . 
path
 . 
exists
 ( 
fn
 ) :

392 if 
safe
 is None or 
bool
 ( 
safe
 ) != 
flag
 :

393 
os
 . 
unlink
 ( 
fn
 )

394 elif 
safe
 is not None and 
bool
 ( 
safe
 ) == 
flag
 :

395 
f
 = 
open
 ( 
fn
 , 'wt' )

396 
f
 . 
write
 ( '\n' )

397 
f
 . 
close
 ( ) 
	}

400 
safety_flags
 = {

406 def 
	$scan_module
 ( 
egg_dir
 , 
base
 , 
name
 , 
stubs
 ) :

409 
filename
 = 
os
 . 
path
 . 
join
 ( 
base
 , 
name
 )

410 if 
filename
 [ : - 1 ] in 
stubs
 :

412 
pkg
 = 
base
 [ 
len
 ( 
egg_dir
 ) + 1 : ] . 
replace
 ( 
os
 . 
sep
 , '.' )

413 
module
 = 
pkg
 + ( 
pkg
 and '.' or '' ) + 
os
 . 
path
 . 
splitext
 ( 
name
 ) [ 0 ]

414 if 
six
 . 
PY2
 :

415 
skip
 = 8

416 elif 
sys
 . 
version_info
 < ( 3 , 7 ) :

417 
skip
 = 12

419 
skip
 = 16

420 
f
 = 
open
 ( 
filename
 , 'rb' )

421 
f
 . 
read
 ( 
skip
 )

422 
code
 = 
marshal
 . 
load
 ( 
f
 )

423 
f
 . 
close
 ( )

424 
safe
 = True

425 
symbols
 = 
dict
 . 
fromkeys
 ( 
iter_symbols
 ( 
code
 ) )

426 for 
bad
 in [ '__file__' , '__path__' ] :

427 if 
bad
 in 
symbols
 :

428 
log
 . 
warn
 ( "%s: module references %s" , 
module
 , 
bad
 )

429 
safe
 = False

430 if 'inspect' in 
symbols
 :

431 for 
bad
 in [ 'getsource'

436 if 
bad
 in 
symbols
 :

437 
log
 . 
warn
 ( "%s: module MAY be using inspect.%s" , 
module
 , 
bad
 )

438 
safe
 = False

439 return 
safe
 
	}

442 def 
	$iter_symbols
 ( 
code
 ) :

444 for 
name
 in 
code
 . 
co_names
 :

445 yield 
name

446 for 
const
 in 
code
 . 
co_consts
 :

447 if 
isinstance
 ( 
const
 , 
six
 . 
string_types
 ) :

448 yield 
const

449 elif 
isinstance
 ( 
const
 , 
CodeType
 ) :

450 for 
name
 in 
iter_symbols
 ( 
const
 ) :

451 yield 
name
 
	}

454 def 
	$can_scan
 ( ) :

455 if not 
sys
 . 
platform
 . 
startswith
 ( 'java' ) and 
sys
 . 
platform
 != 'cli' :

458 
log
 . 
warn
 ( "Unable to analyze compiled code on this platform." )

459 
log
 . 
warn
 ( "Please ask the author to include a 'zip_safe'" " setting (either True or False) in the package's setup.py"

460 ) 
	}

466 
INSTALL_DIRECTORY_ATTRS
 = [ 'install_lib'

471 def 
	$make_zipfile
 ( 
zip_filename
 , 
base_dir
 , 
verbose
 = 0 , 
dry_run
 = 0 , 
compress
 = True ,

472 
mode
 = 'w' ) :

479 import 
	~zipfile

481 
mkpath
 ( 
os
 . 
path
 . 
dirname
 ( 
zip_filename
 ) , 
dry_run
 = 
dry_run
 )

482 
log
 . 
info
 ( "creating '%s' and adding '%s' to it" , 
zip_filename
 , 
base_dir
 )

484 def 
visit
 ( 
z
 , 
dirname
 , 
names
 ) :

485 for 
name
 in 
names
 :

486 
path
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
join
 ( 
dirname
 , 
name
 ) )

487 if 
os
 . 
path
 . 
isfile
 ( 
path
 ) :

488 
p
 = 
path
 [ 
len
 ( 
base_dir
 ) + 1 : ]

489 if not 
dry_run
 :

490 
z
 . 
write
 ( 
path
 , 
p
 )

491 
log
 . 
debug
 ( "adding '%s'" , 
p
 )

493 
compression
 = 
zipfile
 . 
ZIP_DEFLATED
 if 
compress
 else 
zipfile
 . 
ZIP_STORED

494 if not 
dry_run
 :

495 
z
 = 
zipfile
 . 
ZipFile
 ( 
zip_filename
 , 
mode
 , 
compression
 = 
compression
 )

496 for 
dirname
 , 
dirs
 , 
files
 in 
sorted_walk
 ( 
base_dir
 ) :

497 
visit
 ( 
z
 , 
dirname
 , 
files
 )

498 
z
 . 
close
 ( )

500 for 
dirname
 , 
dirs
 , 
files
 in 
sorted_walk
 ( 
base_dir
 ) :

501 
visit
 ( None , 
dirname
 , 
files
 )

502 return 
zip_filename
 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/py36compat.py

1 import 
	~os

2 from 
	~glob
 import 
glob

3 from 
	~distutils.util
 import 
convert_path

4 from 
	~distutils.command
 import 
sdist

6 from 
	~setuptools.extern.six.moves
 import 
filter

9 class 
	csdist_add_defaults
 :

18 def 
	$add_defaults
 ( 
self
 ) :

32 
self
 . 
_add_defaults_standards
 ( )

33 
self
 . 
_add_defaults_optional
 ( )

34 
self
 . 
_add_defaults_python
 ( )

35 
self
 . 
_add_defaults_data_files
 ( )

36 
self
 . 
_add_defaults_ext
 ( )

37 
self
 . 
_add_defaults_c_libs
 ( )

38 
self
 . 
_add_defaults_scripts
 ( ) 
	}

40 @ 
	`staticmethod

41 def 
	$_cs_path_exists
 ( 
fspath
 ) :

50 if not 
os
 . 
path
 . 
exists
 ( 
fspath
 ) :

53 
abspath
 = 
os
 . 
path
 . 
abspath
 ( 
fspath
 )

54 
directory
 , 
filename
 = 
os
 . 
path
 . 
split
 ( 
abspath
 )

55 return 
filename
 in 
os
 . 
listdir
 ( 
directory
 ) 
	}

57 def 
	$_add_defaults_standards
 ( 
self
 ) :

58 
standards
 = [ 
self
 . 
READMES
 , 
self
 . 
distribution
 . 
script_name
 ]

59 for 
fn
 in 
standards
 :

60 if 
isinstance
 ( 
fn
 , 
tuple
 ) :

61 
alts
 = 
fn

62 
got_it
 = False

63 for 
fn
 in 
alts
 :

64 if 
self
 . 
_cs_path_exists
 ( 
fn
 ) :

65 
got_it
 = True

66 
self
 . 
filelist
 . 
append
 ( 
fn
 )

69 if not 
got_it
 :

70 
self
 . 
warn
 ( "standard file not found: should have one of " + ', '

71 . 
join
 ( 
alts
 ) )

73 if 
self
 . 
_cs_path_exists
 ( 
fn
 ) :

74 
self
 . 
filelist
 . 
append
 ( 
fn
 )

76 
self
 . 
warn
 ( "standard file '%s' not found" % 
fn
 ) 
	}

78 def 
	$_add_defaults_optional
 ( 
self
 ) :

79 
optional
 = [ 'test/test*.py' , 'setup.cfg' ]

80 for 
pattern
 in 
optional
 :

81 
files
 = 
filter
 ( 
os
 . 
path
 . 
isfile
 , 
glob
 ( 
pattern
 ) )

82 
self
 . 
filelist
 . 
extend
 ( 
files
 ) 
	}

84 def 
	$_add_defaults_python
 ( 
self
 ) :

88 
build_py
 = 
self
 . 
get_finalized_command
 ( 'build_py' )

91 if 
self
 . 
distribution
 . 
has_pure_modules
 ( ) :

92 
self
 . 
filelist
 . 
extend
 ( 
build_py
 . 
get_source_files
 ( ) )

96 for 
pkg
 , 
src_dir
 , 
build_dir
 , 
filenames
 in 
build_py
 . 
data_files
 :

97 for 
filename
 in 
filenames
 :

98 
self
 . 
filelist
 . 
append
 ( 
os
 . 
path
 . 
join
 ( 
src_dir
 , 
filename
 ) ) 
	}

100 def 
	$_add_defaults_data_files
 ( 
self
 ) :

102 if 
self
 . 
distribution
 . 
has_data_files
 ( ) :

103 for 
item
 in 
self
 . 
distribution
 . 
data_files
 :

104 if 
isinstance
 ( 
item
 , 
str
 ) :

106 
item
 = 
convert_path
 ( 
item
 )

107 if 
os
 . 
path
 . 
isfile
 ( 
item
 ) :

108 
self
 . 
filelist
 . 
append
 ( 
item
 )

111 
dirname
 , 
filenames
 = 
item

112 for 
f
 in 
filenames
 :

113 
f
 = 
convert_path
 ( 
f
 )

114 if 
os
 . 
path
 . 
isfile
 ( 
f
 ) :

115 
self
 . 
filelist
 . 
append
 ( 
f
 ) 
	}

117 def 
	$_add_defaults_ext
 ( 
self
 ) :

118 if 
self
 . 
distribution
 . 
has_ext_modules
 ( ) :

119 
build_ext
 = 
self
 . 
get_finalized_command
 ( 'build_ext' )

120 
self
 . 
filelist
 . 
extend
 ( 
build_ext
 . 
get_source_files
 ( ) ) 
	}

122 def 
	$_add_defaults_c_libs
 ( 
self
 ) :

123 if 
self
 . 
distribution
 . 
has_c_libraries
 ( ) :

124 
build_clib
 = 
self
 . 
get_finalized_command
 ( 'build_clib' )

125 
self
 . 
filelist
 . 
extend
 ( 
build_clib
 . 
get_source_files
 ( ) ) 
	}

127 def 
	$_add_defaults_scripts
 ( 
self
 ) :

128 if 
self
 . 
distribution
 . 
has_scripts
 ( ) :

129 
build_scripts
 = 
self
 . 
get_finalized_command
 ( 'build_scripts' )

130 
self
 . 
filelist
 . 
extend
 ( 
build_scripts
 . 
get_source_files
 ( ) ) 
	}

133 if 
hasattr
 ( 
sdist
 . 
sdist
 , '_add_defaults_standards' ) :

135 class 
	csdist_add_defaults
 :


	@./env/lib/python3.7/site-packages/setuptools/command/build_clib.py

1 import 
	~distutils.command.build_clib
 as 
orig

2 from 
	~distutils.errors
 import 
DistutilsSetupError

3 from 
	~distutils
 import 
log

4 from 
	~setuptools.dep_util
 import 
newer_pairwise_group

7 class 
	cbuild_clib
 ( 
orig
 . 
build_clib
 ) :

23 def 
	$build_libraries
 ( 
self
 , 
libraries
 ) :

24 for ( 
lib_name
 , 
build_info
 ) in 
libraries
 :

25 
sources
 = 
build_info
 . 
get
 ( 'sources' )

26 if 
sources
 is None or not 
isinstance
 ( 
sources
 , ( 
list
 , 
tuple
 ) ) :

27 raise 
DistutilsSetupError
 ( "in 'libraries' option (library '%s'), " "'sources' must be present and must be " "a list of source filenames"

30 % 
lib_name
 )

31 
sources
 = 
list
 ( 
sources
 )

33 
log
 . 
info
 ( "building '%s' library" , 
lib_name
 )

38 
obj_deps
 = 
build_info
 . 
get
 ( 'obj_deps' , 
dict
 ( ) )

39 if not 
isinstance
 ( 
obj_deps
 , 
dict
 ) :

40 raise 
DistutilsSetupError
 ( "in 'libraries' option (library '%s'), " "'obj_deps' must be a dictionary of " "type 'source: list'"

43 % 
lib_name
 )

44 
dependencies
 = [ ]

48 
global_deps
 = 
obj_deps
 . 
get
 ( '' , 
list
 ( ) )

49 if not 
isinstance
 ( 
global_deps
 , ( 
list
 , 
tuple
 ) ) :

50 raise 
DistutilsSetupError
 ( "in 'libraries' option (library '%s'), " "'obj_deps' must be a dictionary of " "type 'source: list'"

53 % 
lib_name
 )

57 for 
source
 in 
sources
 :

58 
src_deps
 = [ 
source
 ]

59 
src_deps
 . 
extend
 ( 
global_deps
 )

60 
extra_deps
 = 
obj_deps
 . 
get
 ( 
source
 , 
list
 ( ) )

61 if not 
isinstance
 ( 
extra_deps
 , ( 
list
 , 
tuple
 ) ) :

62 raise 
DistutilsSetupError
 ( "in 'libraries' option (library '%s'), " "'obj_deps' must be a dictionary of " "type 'source: list'"

65 % 
lib_name
 )

66 
src_deps
 . 
extend
 ( 
extra_deps
 )

67 
dependencies
 . 
append
 ( 
src_deps
 )

69 
expected_objects
 = 
self
 . 
compiler
 . 
object_filenames
 (

70 
sources
 ,

71 
output_dir
 = 
self
 . 
build_temp

74 if 
newer_pairwise_group
 ( 
dependencies
 , 
expected_objects
 ) != ( [ ] , [ ] ) :

78 
macros
 = 
build_info
 . 
get
 ( 'macros' )

79 
include_dirs
 = 
build_info
 . 
get
 ( 'include_dirs' )

80 
cflags
 = 
build_info
 . 
get
 ( 'cflags' )

81 
objects
 = 
self
 . 
compiler
 . 
compile
 (

82 
sources
 ,

83 
output_dir
 = 
self
 . 
build_temp
 ,

84 
macros
 = 
macros
 ,

85 
include_dirs
 = 
include_dirs
 ,

86 
extra_postargs
 = 
cflags
 ,

87 
debug
 = 
self
 . 
debug

93 
self
 . 
compiler
 . 
create_static_lib
 (

94 
expected_objects
 ,

95 
lib_name
 ,

96 
output_dir
 = 
self
 . 
build_clib
 ,

97 
debug
 = 
self
 . 
debug

98 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/alias.py

1 from 
	~distutils.errors
 import 
DistutilsOptionError

3 from 
	~setuptools.extern.six.moves
 import 
map

5 from 
	~setuptools.command.setopt
 import 
edit_config
 , 
option_base
 , 
config_file

8 def 
	$shquote
 ( 
arg
 ) :

10 for 
c
 in '"' , "'" , "\\" , "#" :

11 if 
c
 in 
arg
 :

12 return 
repr
 ( 
arg
 )

13 if 
arg
 . 
split
 ( ) != [ 
arg
 ] :

14 return 
repr
 ( 
arg
 )

15 return 
arg
 
	}

18 class 
	calias
 ( 
option_base
 ) :

21 
description
 = "define a shortcut to invoke one or more commands"

22 
command_consumes_arguments
 = True

24 
user_options
 = [

26 ] + 
option_base
 . 
user_options

28 
boolean_options
 = 
option_base
 . 
boolean_options
 + [ 'remove' ]

30 def 
	$initialize_options
 ( 
self
 ) :

31 
option_base
 . 
initialize_options
 ( 
self
 )

32 
self
 . 
args
 = None

33 
self
 . 
remove
 = None 
	}

35 def 
	$finalize_options
 ( 
self
 ) :

36 
option_base
 . 
finalize_options
 ( 
self
 )

37 if 
self
 . 
remove
 and 
len
 ( 
self
 . 
args
 ) != 1 :

38 raise 
DistutilsOptionError
 ( "Must specify exactly one argument (the alias name) when " "using --remove"

41 ) 
	}

43 def 
	$run
 ( 
self
 ) :

44 
aliases
 = 
self
 . 
distribution
 . 
get_option_dict
 ( 'aliases' )

46 if not 
self
 . 
args
 :

47 
print
 ( "Command Aliases" )

48 
print
 ( "---------------" )

49 for 
alias
 in 
aliases
 :

50 
print
 ( "setup.py alias" , 
format_alias
 ( 
alias
 , 
aliases
 ) )

53 elif 
len
 ( 
self
 . 
args
 ) == 1 :

54 
alias
 , = 
self
 . 
args

55 if 
self
 . 
remove
 :

56 
command
 = None

57 elif 
alias
 in 
aliases
 :

58 
print
 ( "setup.py alias" , 
format_alias
 ( 
alias
 , 
aliases
 ) )

61 
print
 ( "No alias definition found for %r" % 
alias
 )

64 
alias
 = 
self
 . 
args
 [ 0 ]

65 
command
 = ' ' . 
join
 ( 
map
 ( 
shquote
 , 
self
 . 
args
 [ 1 : ] ) )

67 
edit_config
 ( 
self
 . 
filename
 , { 'aliases' : { 
alias
 : 
command
 } } , 
self
 . 
dry_run
 ) 
	}

70 def 
	$format_alias
 ( 
name
 , 
aliases
 ) :

71 
source
 , 
command
 = 
aliases
 [ 
name
 ]

72 if 
source
 == 
config_file
 ( 'global' ) :

73 
source
 = '--global-config '

74 elif 
source
 == 
config_file
 ( 'user' ) :

75 
source
 = '--user-config '

76 elif 
source
 == 
config_file
 ( 'local' ) :

77 
source
 = ''

79 
source
 = '--filename=%r' % 
source

80 return 
source
 + 
name
 + ' ' + 
command
 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/upload.py

1 import 
	~io

2 import 
	~os

3 import 
	~hashlib

4 import 
	~getpass

6 from 
	~base64
 import 
standard_b64encode

8 from 
	~distutils
 import 
log

9 from 
	~distutils.command
 import 
upload
 as 
orig

10 from 
	~distutils.spawn
 import 
spawn

12 from 
	~distutils.errors
 import 
DistutilsError

14 from 
	~setuptools.extern.six.moves.urllib.request
 import 
urlopen
 , 
Request

15 from 
	~setuptools.extern.six.moves.urllib.error
 import 
HTTPError

16 from 
	~setuptools.extern.six.moves.urllib.parse
 import 
urlparse

19 class 
	cupload
 ( 
orig
 . 
upload
 ) :

24 def 
	$run
 ( 
self
 ) :

26 
orig
 . 
upload
 . 
run
 ( 
self
 )

28 
self
 . 
announce
 ( "WARNING: Uploading via this command is deprecated, use twine " "to upload instead (https://pypi.org/p/twine/)"

31 
log
 . 
WARN

32 ) 
	}

34 def 
	$finalize_options
 ( 
self
 ) :

35 
orig
 . 
upload
 . 
finalize_options
 ( 
self
 )

36 
self
 . 
username
 = (

37 
self
 . 
username
 or

38 
getpass
 . 
getuser
 ( )

42 
self
 . 
password
 = (

43 
self
 . 
password
 or

44 
self
 . 
_load_password_from_keyring
 ( ) or

45 
self
 . 
_prompt_for_password
 ( )

46 ) 
	}

48 def 
	$upload_file
 ( 
self
 , 
command
 , 
pyversion
 , 
filename
 ) :

50 
schema
 , 
netloc
 , 
url
 , 
params
 , 
query
 , 
fragments
 =

51 
urlparse
 ( 
self
 . 
repository
 )

52 if 
params
 or 
query
 or 
fragments
 :

53 raise 
AssertionError
 ( "Incompatible url %s" % 
self
 . 
repository
 )

55 if 
schema
 not in ( 'http' , 'https' ) :

56 raise 
AssertionError
 ( "unsupported schema " + 
schema
 )

59 if 
self
 . 
sign
 :

60 
gpg_args
 = [ "gpg" , "--detach-sign" , "-a" , 
filename
 ]

61 if 
self
 . 
identity
 :

62 
gpg_args
 [ 2 : 2 ] = [ "--local-user" , 
self
 . 
identity
 ]

63 
spawn
 ( 
gpg_args
 ,

64 
dry_run
 = 
self
 . 
dry_run
 )

68 with 
open
 ( 
filename
 , 'rb' ) as 
f
 :

69 
content
 = 
f
 . 
read
 ( )

71 
meta
 = 
self
 . 
distribution
 . 
metadata

73 
data
 = { ':action'

79 : 
meta
 . 
get_name
 ( ) , 'version'

80 : 
meta
 . 
get_version
 ( ) , 'content'

83 : ( 
os
 . 
path
 . 
basename
 ( 
filename
 ) , 
content
 ) , 'filetype'

84 : 
command
 , 'pyversion'

85 : 
pyversion
 , 'md5_digest'

86 : 
hashlib
 . 
md5
 ( 
content
 ) . 
hexdigest
 ( ) , 'metadata_version'

89 : 
str
 ( 
meta
 . 
get_metadata_version
 ( ) ) , 'summary'

90 : 
meta
 . 
get_description
 ( ) , 'home_page'

91 : 
meta
 . 
get_url
 ( ) , 'author'

92 : 
meta
 . 
get_contact
 ( ) , 'author_email'

93 : 
meta
 . 
get_contact_email
 ( ) , 'license'

94 : 
meta
 . 
get_licence
 ( ) , 'description'

95 : 
meta
 . 
get_long_description
 ( ) , 'keywords'

96 : 
meta
 . 
get_keywords
 ( ) , 'platform'

97 : 
meta
 . 
get_platforms
 ( ) , 'classifiers'

98 : 
meta
 . 
get_classifiers
 ( ) , 'download_url'

99 : 
meta
 . 
get_download_url
 ( ) , 'provides'

101 : 
meta
 . 
get_provides
 ( ) , 'requires'

102 : 
meta
 . 
get_requires
 ( ) , 'obsoletes'

103 : 
meta
 . 
get_obsoletes
 ( ) ,

106 
data
 [ 'comment' ] = ''

108 if 
self
 . 
sign
 :

109 
data
 [ 'gpg_signature' ] = ( 
os
 . 
path
 . 
basename
 ( 
filename
 ) + ".asc" ,

110 
open
 ( 
filename
 + ".asc" , "rb" ) . 
read
 ( ) )

113 
user_pass
 = ( 
self
 . 
username
 + ":" + 
self
 . 
password
 ) . 
encode
 ( 'ascii' )

116 
auth
 = "Basic " + 
standard_b64encode
 ( 
user_pass
 ) . 
decode
 ( 'ascii' )

119 
boundary
 = '--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'

120 
sep_boundary
 = b'\r\n--' + 
boundary
 . 
encode
 ( 'ascii' )

121 
end_boundary
 = 
sep_boundary
 + b'--\r\n'

122 
body
 = 
io
 . 
BytesIO
 ( )

123 for 
key
 , 
value
 in 
data
 . 
items
 ( ) :

124 
title
 = '\r\nContent-Disposition: form-data; name="%s"' % 
key

126 if not 
isinstance
 ( 
value
 , 
list
 ) :

127 
value
 = [ 
value
 ]

128 for 
value
 in 
value
 :

129 if 
type
 ( 
value
 ) is 
tuple
 :

130 
title
 += '; filename="%s"' % 
value
 [ 0 ]

131 
value
 = 
value
 [ 1 ]

133 
value
 = 
str
 ( 
value
 ) . 
encode
 ( 'utf-8' )

134 
body
 . 
write
 ( 
sep_boundary
 )

135 
body
 . 
write
 ( 
title
 . 
encode
 ( 'utf-8' ) )

136 
body
 . 
write
 ( b"\r\n\r\n" )

137 
body
 . 
write
 ( 
value
 )

138 
body
 . 
write
 ( 
end_boundary
 )

139 
body
 = 
body
 . 
getvalue
 ( )

141 
msg
 = "Submitting %s to %s" % ( 
filename
 , 
self
 . 
repository
 )

142 
self
 . 
announce
 ( 
msg
 , 
log
 . 
INFO
 )

145 
headers
 = { 'Content-type'

146 : 'multipart/form-data; boundary=%s' % 
boundary
 , 'Content-length'

147 : 
str
 ( 
len
 ( 
body
 ) ) , 'Authorization'

148 : 
auth
 ,

151 
request
 = 
Request
 ( 
self
 . 
repository
 , 
data
 = 
body
 ,

152 
headers
 = 
headers
 )

155 
result
 = 
urlopen
 ( 
request
 )

156 
status
 = 
result
 . 
getcode
 ( )

157 
reason
 = 
result
 . 
msg

158 except 
HTTPError
 as 
e
 :

159 
status
 = 
e
 . 
code

160 
reason
 = 
e
 . 
msg

161 except 
OSError
 as 
e
 :

162 
self
 . 
announce
 ( 
str
 ( 
e
 ) , 
log
 . 
ERROR
 )

165 if 
status
 == 200 :

166 
self
 . 
announce
 ( 'Server response (%s): %s' % ( 
status
 , 
reason
 ) ,

167 
log
 . 
INFO
 )

168 if 
self
 . 
show_response
 :

169 
text
 = 
getattr
 ( 
self
 , '_read_pypi_response' ,

170 lambda 
x
 : None ) ( 
result
 )

171 if 
text
 is not None :

172 
msg
 = '\n' . 
join
 ( ( '-' * 75 , 
text
 , '-' * 75 ) )

173 
self
 . 
announce
 ( 
msg
 , 
log
 . 
INFO
 )

175 
msg
 = 'Upload failed (%s): %s' % ( 
status
 , 
reason
 )

176 
self
 . 
announce
 ( 
msg
 , 
log
 . 
ERROR
 )

177 raise 
DistutilsError
 ( 
msg
 ) 
	}

179 def 
	$_load_password_from_keyring
 ( 
self
 ) :

184 
keyring
 = 
__import__
 ( 'keyring' )

185 return 
keyring
 . 
get_password
 ( 
self
 . 
repository
 , 
self
 . 
username
 )

186 except 
Exception
 :

187 pass 
	}

189 def 
	$_prompt_for_password
 ( 
self
 ) :

194 return 
getpass
 . 
getpass
 ( )

195 except ( 
Exception
 , 
KeyboardInterrupt
 ) :

196 pass 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/bdist_rpm.py

1 import 
	~distutils.command.bdist_rpm
 as 
orig

4 class 
	cbdist_rpm
 ( 
orig
 . 
bdist_rpm
 ) :

15 def 
	$run
 ( 
self
 ) :

17 
self
 . 
run_command
 ( 'egg_info' )

19 
orig
 . 
bdist_rpm
 . 
run
 ( 
self
 ) 
	}

21 def 
	$_make_spec_file
 ( 
self
 ) :

22 
version
 = 
self
 . 
distribution
 . 
get_version
 ( )

23 
rpmversion
 = 
version
 . 
replace
 ( '-' , '_' )

24 
spec
 = 
orig
 . 
bdist_rpm
 . 
_make_spec_file
 ( 
self
 )

25 
line23
 = '%define version ' + 
version

26 
line24
 = '%define version ' + 
rpmversion

27 
spec
 = [

28 
line
 . 
replace
 ( "Source0: %{name}-%{version}.tar"

31 ) . 
replace
 ( "setup.py install "

34 ) . 
replace
 ( "%setup"

37 ) . 
replace
 ( 
line23
 , 
line24
 )

38 for 
line
 in 
spec

40 
insert_loc
 = 
spec
 . 
index
 ( 
line24
 ) + 1

41 
unmangled_version
 = "%define unmangled_version " + 
version

42 
spec
 . 
insert
 ( 
insert_loc
 , 
unmangled_version
 )

43 return 
spec
 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/easy_install.py

14 from 
	~glob
 import 
glob

15 from 
	~distutils.util
 import 
get_platform

16 from 
	~distutils.util
 import 
convert_path
 , 
subst_vars

17 from 
	~distutils.errors
 import (

18 
DistutilsArgError
 , 
DistutilsOptionError
 ,

19 
DistutilsError
 , 
DistutilsPlatformError
 ,

21 from 
	~distutils.command.install
 import 
INSTALL_SCHEMES
 , 
SCHEME_KEYS

22 from 
	~distutils
 import 
log
 , 
dir_util

23 from 
	~distutils.command.build_scripts
 import 
first_line_re

24 from 
	~distutils.spawn
 import 
find_executable

25 import 
	~sys

26 import 
	~os

27 import 
	~zipimport

28 import 
	~shutil

29 import 
	~tempfile

30 import 
	~zipfile

31 import 
	~re

32 import 
	~stat

33 import 
	~random

34 import 
	~textwrap

35 import 
	~warnings

36 import 
	~site

37 import 
	~struct

38 import 
	~contextlib

39 import 
	~subprocess

40 import 
	~shlex

41 import 
	~io

44 from 
	~sysconfig
 import 
get_config_vars
 , 
get_path

46 from 
	~setuptools
 import 
SetuptoolsDeprecationWarning

48 from 
	~setuptools.extern
 import 
six

49 from 
	~setuptools.extern.six.moves
 import 
configparser
 , 
map

51 from 
	~setuptools
 import 
Command

52 from 
	~setuptools.sandbox
 import 
run_setup

53 from 
	~setuptools.py27compat
 import 
rmtree_safe

54 from 
	~setuptools.command
 import 
setopt

55 from 
	~setuptools.archive_util
 import 
unpack_archive

56 from 
	~setuptools.package_index
 import (

57 
PackageIndex
 , 
parse_requirement_arg
 , 
URL_SCHEME
 ,

59 from 
	~setuptools.command
 import 
bdist_egg
 , 
egg_info

60 from 
	~setuptools.wheel
 import 
Wheel

61 from 
	~pkg_resources
 import (

62 
yield_lines
 , 
normalize_path
 , 
resource_string
 , 
ensure_directory
 ,

63 
get_distribution
 , 
find_distributions
 , 
Environment
 , 
Requirement
 ,

64 
Distribution
 , 
PathMetadata
 , 
EggMetadata
 , 
WorkingSet
 , 
DistributionNotFound
 ,

65 
VersionConflict
 , 
DEVELOP_DIST
 ,

67 import 
	~pkg_resources.py31compat

69 
__metaclass__
 = 
type

72 
warnings
 . 
filterwarnings
 ( "default" , 
category
 = 
pkg_resources
 . 
PEP440Warning
 )

74 
__all__
 = [ 'samefile'

80 def 
	$is_64bit
 ( ) :

81 return 
struct
 . 
calcsize
 ( "P" ) == 8 
	}

84 def 
	$samefile
 ( 
p1
 , 
p2
 ) :

91 
both_exist
 = 
os
 . 
path
 . 
exists
 ( 
p1
 ) and 
os
 . 
path
 . 
exists
 ( 
p2
 )

92 
use_samefile
 = 
hasattr
 ( 
os
 . 
path
 , 'samefile' ) and 
both_exist

93 if 
use_samefile
 :

94 return 
os
 . 
path
 . 
samefile
 ( 
p1
 , 
p2
 )

95 
norm_p1
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
normcase
 ( 
p1
 ) )

96 
norm_p2
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
normcase
 ( 
p2
 ) )

97 return 
norm_p1
 == 
norm_p2
 
	}

100 if 
six
 . 
PY2
 :

102 def 
	$_to_bytes
 ( 
s
 ) :

103 return 
s
 
	}

105 def 
	$isascii
 ( 
s
 ) :

107 
six
 . 
text_type
 ( 
s
 , 'ascii' )

109 except 
UnicodeError
 :

110 return False 
	}

113 def 
	$_to_bytes
 ( 
s
 ) :

114 return 
s
 . 
encode
 ( 'utf8' ) 
	}

116 def 
	$isascii
 ( 
s
 ) :

118 
s
 . 
encode
 ( 'ascii' )

120 except 
UnicodeError
 :

121 return False 
	}

124 
_one_liner
 = lambda 
text
 : 
textwrap
 . 
dedent
 ( 
text
 ) . 
strip
 ( ) . 
replace
 ( '\n' , '; ' )

127 class 
	ceasy_install
 ( 
Command
 ) :

129 
description
 = "Find/get/install Python packages"

130 
command_consumes_arguments
 = True

132 
user_options
 = [

163 
boolean_options
 = [ 'zip-ok'

169 if 
site
 . 
ENABLE_USER_SITE
 :

170 
help_msg
 = "install in user site-package '%s'" % 
site
 . 
USER_SITE

171 
user_options
 . 
append
 ( ( 'user' , None , 
help_msg
 ) )

172 
boolean_options
 . 
append
 ( 'user' )

174 
negative_opt
 = { 'always-unzip' : 'zip-ok' }

175 
create_index
 = 
PackageIndex

177 def 
	$initialize_options
 ( 
self
 ) :

180 
self
 . 
user
 = 0

181 
self
 . 
zip_ok
 = 
self
 . 
local_snapshots_ok
 = None

182 
self
 . 
install_dir
 = 
self
 . 
script_dir
 = 
self
 . 
exclude_scripts
 = None

183 
self
 . 
index_url
 = None

184 
self
 . 
find_links
 = None

185 
self
 . 
build_directory
 = None

186 
self
 . 
args
 = None

187 
self
 . 
optimize
 = 
self
 . 
record
 = None

188 
self
 . 
upgrade
 = 
self
 . 
always_copy
 = 
self
 . 
multi_version
 = None

189 
self
 . 
editable
 = 
self
 . 
no_deps
 = 
self
 . 
allow_hosts
 = None

190 
self
 . 
root
 = 
self
 . 
prefix
 = 
self
 . 
no_report
 = None

191 
self
 . 
version
 = None

192 
self
 . 
install_purelib
 = None

193 
self
 . 
install_platlib
 = None

194 
self
 . 
install_headers
 = None

195 
self
 . 
install_lib
 = None

196 
self
 . 
install_scripts
 = None

197 
self
 . 
install_data
 = None

198 
self
 . 
install_base
 = None

199 
self
 . 
install_platbase
 = None

200 if 
site
 . 
ENABLE_USER_SITE
 :

201 
self
 . 
install_userbase
 = 
site
 . 
USER_BASE

202 
self
 . 
install_usersite
 = 
site
 . 
USER_SITE

204 
self
 . 
install_userbase
 = None

205 
self
 . 
install_usersite
 = None

206 
self
 . 
no_find_links
 = None

209 
self
 . 
package_index
 = None

210 
self
 . 
pth_file
 = 
self
 . 
always_copy_from
 = None

211 
self
 . 
site_dirs
 = None

212 
self
 . 
installed_projects
 = { }

213 
self
 . 
sitepy_installed
 = False

215 
self
 . 
install_layout
 = None

216 
self
 . 
force_installation_into_system_dir
 = None

217 
self
 . 
multiarch
 = None

224 
self
 . 
_dry_run
 = None

225 
self
 . 
verbose
 = 
self
 . 
distribution
 . 
verbose

226 
self
 . 
distribution
 . 
_set_command_options
 (

227 
self
 , 
self
 . 
distribution
 . 
get_option_dict
 ( 'easy_install' )

228 ) 
	}

230 def 
	$delete_blockers
 ( 
self
 , 
blockers
 ) :

231 
extant_blockers
 = (

232 
filename
 for 
filename
 in 
blockers

233 if 
os
 . 
path
 . 
exists
 ( 
filename
 ) or 
os
 . 
path
 . 
islink
 ( 
filename
 )

235 
list
 ( 
map
 ( 
self
 . 
_delete_path
 , 
extant_blockers
 ) ) 
	}

237 def 
	$_delete_path
 ( 
self
 , 
path
 ) :

238 
log
 . 
info
 ( "Deleting %s" , 
path
 )

239 if 
self
 . 
dry_run
 :

242 
is_tree
 = 
os
 . 
path
 . 
isdir
 ( 
path
 ) and not 
os
 . 
path
 . 
islink
 ( 
path
 )

243 
remover
 = 
rmtree
 if 
is_tree
 else 
os
 . 
unlink

244 
remover
 ( 
path
 ) 
	}

246 @ 
	`staticmethod

247 def 
	$_render_version
 ( ) :

251 
ver
 = 
sys
 . 
version
 [ : 3 ]

252 
dist
 = 
get_distribution
 ( 'setuptools' )

253 
tmpl
 = 'setuptools {dist.version} from {dist.location} (Python {ver})'

254 
print
 ( 
tmpl
 . 
format
 ( ** 
locals
 ( ) ) )

255 raise 
SystemExit
 ( ) 
	}

257 def 
	$finalize_options
 ( 
self
 ) :

258 
self
 . 
version
 and 
self
 . 
_render_version
 ( )

260 
py_version
 = 
sys
 . 
version
 . 
split
 ( ) [ 0 ]

261 
prefix
 , 
exec_prefix
 = 
get_config_vars
 ( 'prefix' , 'exec_prefix' )

263 
self
 . 
config_vars
 = { 'dist_name'

264 : 
self
 . 
distribution
 . 
get_name
 ( ) , 'dist_version'

265 : 
self
 . 
distribution
 . 
get_version
 ( ) , 'dist_fullname'

266 : 
self
 . 
distribution
 . 
get_fullname
 ( ) , 'py_version'

267 : 
py_version
 , 'py_version_short'

268 : 
py_version
 [ 0 : 3 ] , 'py_version_nodot'

269 : 
py_version
 [ 0 ] + 
py_version
 [ 2 ] , 'sys_prefix'

270 : 
prefix
 , 'prefix'

271 : 
prefix
 , 'sys_exec_prefix'

272 : 
exec_prefix
 , 'exec_prefix'

273 : 
exec_prefix
 , 'abiflags'

275 : 
getattr
 ( 
sys
 , 'abiflags' , '' ) ,

278 if 
site
 . 
ENABLE_USER_SITE
 :

279 
self
 . 
config_vars
 [ 'userbase' ] = 
self
 . 
install_userbase

280 
self
 . 
config_vars
 [ 'usersite' ] = 
self
 . 
install_usersite

282 
self
 . 
_fix_install_dir_for_user_site
 ( )

284 
self
 . 
expand_basedirs
 ( )

285 
self
 . 
expand_dirs
 ( )

287 if 
self
 . 
install_layout
 :

288 if not 
self
 . 
install_layout
 . 
lower
 ( ) in [ 'deb' ] :

289 raise 
DistutilsOptionError
 ( "unknown value for --install-layout" )

290 
self
 . 
install_layout
 = 
self
 . 
install_layout
 . 
lower
 ( )

292 import 
	~sysconfig

293 if 
sys
 . 
version_info
 [ : 2 ] >= ( 3 , 3 ) :

294 
self
 . 
multiarch
 = 
sysconfig
 . 
get_config_var
 ( 'MULTIARCH' )

296 
self
 . 
_expand
 ( 'install_dir'

302 if 
self
 . 
script_dir
 is None :

303 
self
 . 
script_dir
 = 
self
 . 
install_dir

305 if 
self
 . 
no_find_links
 is None :

306 
self
 . 
no_find_links
 = False

311 
self
 . 
set_undefined_options
 ( 'install_lib'

315 
self
 . 
set_undefined_options
 ( 'install_scripts'

319 if 
self
 . 
user
 and 
self
 . 
install_purelib
 :

320 
self
 . 
install_dir
 = 
self
 . 
install_purelib

321 
self
 . 
script_dir
 = 
self
 . 
install_scripts

323 if 
self
 . 
prefix
 == '/usr' and not 
self
 . 
force_installation_into_system_dir
 :

324 raise 
DistutilsOptionError
 ( """installation into /usr\n\nTrying to install into the system managed parts of the file system. Please\nconsider to install to another location, or use the option\n--force-installation-into-system-dir to overwrite this warning.\n"""

332 
self
 . 
set_undefined_options
 ( 'install' , ( 'record' , 'record' ) )

335 
normpath
 = 
map
 ( 
normalize_path
 , 
sys
 . 
path
 )

336 
self
 . 
all_site_dirs
 = 
get_site_dirs
 ( )

337 if 
self
 . 
site_dirs
 is not None :

338 
site_dirs
 = [

339 
os
 . 
path
 . 
expanduser
 ( 
s
 . 
strip
 ( ) ) for 
s
 in

340 
self
 . 
site_dirs
 . 
split
 ( ',' )

342 for 
d
 in 
site_dirs
 :

343 if not 
os
 . 
path
 . 
isdir
 ( 
d
 ) :

344 
log
 . 
warn
 ( "%s (in --site-dirs) does not exist" , 
d
 )

345 elif 
normalize_path
 ( 
d
 ) not in 
normpath
 :

346 raise 
DistutilsOptionError
 (

347 
d
 + " (in --site-dirs) is not on sys.path"

350 
self
 . 
all_site_dirs
 . 
append
 ( 
normalize_path
 ( 
d
 ) )

351 if not 
self
 . 
editable
 :

352 
self
 . 
check_site_dir
 ( )

353 
self
 . 
index_url
 = 
self
 . 
index_url
 or "https://pypi.org/simple/"

354 
self
 . 
shadow_path
 = 
self
 . 
all_site_dirs
 [ : ]

355 for 
path_item
 in 
self
 . 
install_dir
 , 
normalize_path
 ( 
self
 . 
script_dir
 ) :

356 if 
path_item
 not in 
self
 . 
shadow_path
 :

357 
self
 . 
shadow_path
 . 
insert
 ( 0 , 
path_item
 )

359 if 
self
 . 
allow_hosts
 is not None :

360 
hosts
 = [ 
s
 . 
strip
 ( ) for 
s
 in 
self
 . 
allow_hosts
 . 
split
 ( ',' ) ]

362 
hosts
 = [ '*' ]

363 if 
self
 . 
package_index
 is None :

364 
self
 . 
package_index
 = 
self
 . 
create_index
 (

365 
self
 . 
index_url
 , 
search_path
 = 
self
 . 
shadow_path
 , 
hosts
 = 
hosts
 ,

367 
self
 . 
local_index
 = 
Environment
 ( 
self
 . 
shadow_path
 + 
sys
 . 
path
 )

369 if 
self
 . 
find_links
 is not None :

370 if 
isinstance
 ( 
self
 . 
find_links
 , 
six
 . 
string_types
 ) :

371 
self
 . 
find_links
 = 
self
 . 
find_links
 . 
split
 ( )

373 
self
 . 
find_links
 = [ ]

374 if 
self
 . 
local_snapshots_ok
 :

375 
self
 . 
package_index
 . 
scan_egg_links
 ( 
self
 . 
shadow_path
 + 
sys
 . 
path
 )

376 if not 
self
 . 
no_find_links
 :

377 
self
 . 
package_index
 . 
add_find_links
 ( 
self
 . 
find_links
 )

378 
self
 . 
set_undefined_options
 ( 'install_lib' , ( 'optimize' , 'optimize' ) )

379 if not 
isinstance
 ( 
self
 . 
optimize
 , 
int
 ) :

381 
self
 . 
optimize
 = 
int
 ( 
self
 . 
optimize
 )

382 if not ( 0 <= 
self
 . 
optimize
 <= 2 ) :

383 raise 
ValueError

384 except 
ValueError
 :

385 raise 
DistutilsOptionError
 ( "--optimize must be 0, 1, or 2" )

387 if 
self
 . 
editable
 and not 
self
 . 
build_directory
 :

388 raise 
DistutilsArgError
 ( "Must specify a build directory (-b) when using --editable"

391 if not 
self
 . 
args
 :

392 raise 
DistutilsArgError
 ( "No urls, filenames, or requirements specified (see --help)"

395 
self
 . 
outputs
 = [ ] 
	}

397 def 
	$_fix_install_dir_for_user_site
 ( 
self
 ) :

401 if not 
self
 . 
user
 or not 
site
 . 
ENABLE_USER_SITE
 :

404 
self
 . 
create_home_path
 ( )

405 if 
self
 . 
install_userbase
 is None :

406 
msg
 = "User base directory is not specified"

407 raise 
DistutilsPlatformError
 ( 
msg
 )

408 
self
 . 
install_base
 = 
self
 . 
install_platbase
 = 
self
 . 
install_userbase

409 
scheme_name
 = 
os
 . 
name
 . 
replace
 ( 'posix' , 'unix' ) + '_user'

410 
self
 . 
select_scheme
 ( 
scheme_name
 ) 
	}

412 def 
	$_expand_attrs
 ( 
self
 , 
attrs
 ) :

413 for 
attr
 in 
attrs
 :

414 
val
 = 
getattr
 ( 
self
 , 
attr
 )

415 if 
val
 is not None :

416 if 
os
 . 
name
 == 'posix' or 
os
 . 
name
 == 'nt' :

417 
val
 = 
os
 . 
path
 . 
expanduser
 ( 
val
 )

418 
val
 = 
subst_vars
 ( 
val
 , 
self
 . 
config_vars
 )

419 
setattr
 ( 
self
 , 
attr
 , 
val
 ) 
	}

421 def 
	$expand_basedirs
 ( 
self
 ) :

424 
self
 . 
_expand_attrs
 ( [ 'install_base' , 'install_platbase' , 'root' ] ) 
	}

426 def 
	$expand_dirs
 ( 
self
 ) :

428 
dirs
 = [ 'install_purelib'

436 
self
 . 
_expand_attrs
 ( 
dirs
 ) 
	}

438 def 
	$run
 ( 
self
 ) :

439 if 
self
 . 
verbose
 != 
self
 . 
distribution
 . 
verbose
 :

440 
log
 . 
set_verbosity
 ( 
self
 . 
verbose
 )

442 for 
spec
 in 
self
 . 
args
 :

443 
self
 . 
easy_install
 ( 
spec
 , not 
self
 . 
no_deps
 )

444 if 
self
 . 
record
 :

445 
outputs
 = 
list
 ( 
sorted
 ( 
self
 . 
outputs
 ) )

446 if 
self
 . 
root
 :

447 
root_len
 = 
len
 ( 
self
 . 
root
 )

448 for 
counter
 in 
range
 ( 
len
 ( 
outputs
 ) ) :

449 
outputs
 [ 
counter
 ] = 
outputs
 [ 
counter
 ] [ 
root_len
 : ]

450 from 
	~distutils
 import 
file_util

452 
self
 . 
execute
 (

453 
file_util
 . 
write_file
 , ( 
self
 . 
record
 , 
outputs
 ) , "writing list of installed files to '%s'"

455 
self
 . 
record

457 
self
 . 
warn_deprecated_options
 ( )

459 
log
 . 
set_verbosity
 ( 
self
 . 
distribution
 . 
verbose
 ) 
	}

461 def 
	$pseudo_tempname
 ( 
self
 ) :

467 
pid
 = 
os
 . 
getpid
 ( )

468 except 
Exception
 :

469 
pid
 = 
random
 . 
randint
 ( 0 , 
sys
 . 
maxsize
 )

470 return 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , "test-easy-install-%s" % 
pid
 ) 
	}

472 def 
	$warn_deprecated_options
 ( 
self
 ) :

473 pass 
	}

475 def 
	$check_site_dir
 ( 
self
 ) :

478 
instdir
 = 
normalize_path
 ( 
self
 . 
install_dir
 )

479 
pth_file
 = 
os
 . 
path
 . 
join
 ( 
instdir
 , 'easy-install.pth' )

482 
is_site_dir
 = 
instdir
 in 
self
 . 
all_site_dirs

484 if not 
is_site_dir
 and not 
self
 . 
multi_version
 :

486 
is_site_dir
 = 
self
 . 
check_pth_processing
 ( )

489 
testfile
 = 
self
 . 
pseudo_tempname
 ( ) + '.write-test'

490 
test_exists
 = 
os
 . 
path
 . 
exists
 ( 
testfile
 )

492 if 
test_exists
 :

493 
os
 . 
unlink
 ( 
testfile
 )

494 
open
 ( 
testfile
 , 'w' ) . 
close
 ( )

495 
os
 . 
unlink
 ( 
testfile
 )

496 except ( 
OSError
 , 
IOError
 ) :

497 
self
 . 
cant_write_to_target
 ( )

499 if not 
is_site_dir
 and not 
self
 . 
multi_version
 :

501 raise 
DistutilsError
 ( 
self
 . 
no_default_version_msg
 ( ) )

503 if 
is_site_dir
 :

504 if 
self
 . 
pth_file
 is None :

505 
self
 . 
pth_file
 = 
PthDistributions
 ( 
pth_file
 , 
self
 . 
all_site_dirs
 )

507 
self
 . 
pth_file
 = None

509 if 
instdir
 not in 
map
 ( 
normalize_path
 , 
_pythonpath
 ( ) ) :

511 
self
 . 
sitepy_installed
 = True

512 elif 
self
 . 
multi_version
 and not 
os
 . 
path
 . 
exists
 ( 
pth_file
 ) :

513 
self
 . 
sitepy_installed
 = True

514 
self
 . 
pth_file
 = None

515 
self
 . 
install_dir
 = 
instdir
 
	}

517 
__cant_write_msg
 = 
textwrap
 . 
dedent
 ( """\n        can't create or remove files in install directory\n\n        The following error occurred while trying to add or remove files in the\n        installation directory:\n\n            %s\n\n        The installation directory you specified (via --install-dir, --prefix, or\n        the distutils default setting) was:\n\n            %s\n        """

529 ) . 
lstrip
 ( )

531 
__not_exists_id
 = 
textwrap
 . 
dedent
 ( """\n        This directory does not currently exist.  Please create it and try again, or\n        choose a different installation directory (using the -d or --install-dir\n        option).\n        """

535 ) . 
lstrip
 ( )

537 
__access_msg
 = 
textwrap
 . 
dedent
 ( """\n        Perhaps your account does not have write access to this directory?  If the\n        installation directory is a system-owned directory, you may need to sign in\n        as the administrator or "root" account.  If you do not have administrative\n        access to this machine, you may wish to choose a different installation\n        directory, preferably one that is listed in your PYTHONPATH environment\n        variable.\n\n        For information on other options, you may wish to consult the\n        documentation at:\n\n          https://setuptools.readthedocs.io/en/latest/easy_install.html\n\n        Please make the appropriate changes for your system and try again.\n        """

551 ) . 
lstrip
 ( )

553 def 
	$cant_write_to_target
 ( 
self
 ) :

554 
msg
 = 
self
 . 
__cant_write_msg
 % ( 
sys
 . 
exc_info
 ( ) [ 1 ] , 
self
 . 
install_dir
 , )

556 if not 
os
 . 
path
 . 
exists
 ( 
self
 . 
install_dir
 ) :

557 
msg
 += '\n' + 
self
 . 
__not_exists_id

559 
msg
 += '\n' + 
self
 . 
__access_msg

560 raise 
DistutilsError
 ( 
msg
 ) 
	}

562 def 
	$check_pth_processing
 ( 
self
 ) :

564 
instdir
 = 
self
 . 
install_dir

565 
log
 . 
info
 ( "Checking .pth file support in %s" , 
instdir
 )

566 
pth_file
 = 
self
 . 
pseudo_tempname
 ( ) + ".pth"

567 
ok_file
 = 
pth_file
 + '.ok'

568 
ok_exists
 = 
os
 . 
path
 . 
exists
 ( 
ok_file
 )

569 
tmpl
 = 
_one_liner
 ( """\n            import os\n            f = open({ok_file!r}, 'w')\n            f.write('OK')\n            f.close()\n            """

576 if 
ok_exists
 :

577 
os
 . 
unlink
 ( 
ok_file
 )

578 
dirname
 = 
os
 . 
path
 . 
dirname
 ( 
ok_file
 )

579 
pkg_resources
 . 
py31compat
 . 
makedirs
 ( 
dirname
 , 
exist_ok
 = True )

580 
f
 = 
open
 ( 
pth_file
 , 'w' )

581 except ( 
OSError
 , 
IOError
 ) :

582 
self
 . 
cant_write_to_target
 ( )

585 
f
 . 
write
 ( 
tmpl
 . 
format
 ( ** 
locals
 ( ) ) )

586 
f
 . 
close
 ( )

587 
f
 = None

588 
executable
 = 
sys
 . 
executable

589 if 
os
 . 
name
 == 'nt' :

590 
dirname
 , 
basename
 = 
os
 . 
path
 . 
split
 ( 
executable
 )

591 
alt
 = 
os
 . 
path
 . 
join
 ( 
dirname
 , 'pythonw.exe' )

592 
use_alt
 = (

593 
basename
 . 
lower
 ( ) == 'python.exe' and

594 
os
 . 
path
 . 
exists
 ( 
alt
 )

596 if 
use_alt
 :

598 
executable
 = 
alt

600 from 
	~distutils.spawn
 import 
spawn

602 
spawn
 ( [ 
executable
 , '-E' , '-c' , 'pass' ] , 0 )

604 if 
os
 . 
path
 . 
exists
 ( 
ok_file
 ) :

605 
log
 . 
info
 ( "TEST PASSED: %s appears to support .pth files"

607 
instdir

611 if 
f
 :

612 
f
 . 
close
 ( )

613 if 
os
 . 
path
 . 
exists
 ( 
ok_file
 ) :

614 
os
 . 
unlink
 ( 
ok_file
 )

615 if 
os
 . 
path
 . 
exists
 ( 
pth_file
 ) :

616 
os
 . 
unlink
 ( 
pth_file
 )

617 if not 
self
 . 
multi_version
 :

618 
log
 . 
warn
 ( "TEST FAILED: %s does NOT support .pth files" , 
instdir
 )

619 return False 
	}

621 def 
	$install_egg_scripts
 ( 
self
 , 
dist
 ) :

623 if not 
self
 . 
exclude_scripts
 and 
dist
 . 
metadata_isdir
 ( 'scripts' ) :

624 for 
script_name
 in 
dist
 . 
metadata_listdir
 ( 'scripts' ) :

625 if 
dist
 . 
metadata_isdir
 ( 'scripts/' + 
script_name
 ) :

629 
self
 . 
install_script
 (

630 
dist
 , 
script_name
 ,

631 
dist
 . 
get_metadata
 ( 'scripts/' + 
script_name
 )

633 
self
 . 
install_wrapper_scripts
 ( 
dist
 ) 
	}

635 def 
	$add_output
 ( 
self
 , 
path
 ) :

636 if 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

637 for 
base
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
path
 ) :

638 for 
filename
 in 
files
 :

639 
self
 . 
outputs
 . 
append
 ( 
os
 . 
path
 . 
join
 ( 
base
 , 
filename
 ) )

641 
self
 . 
outputs
 . 
append
 ( 
path
 ) 
	}

643 def 
	$not_editable
 ( 
self
 , 
spec
 ) :

644 if 
self
 . 
editable
 :

645 raise 
DistutilsArgError
 ( "Invalid argument %r: you can't use filenames or URLs " "with --editable (except via the --find-links option)."

648 % ( 
spec
 , )

649 ) 
	}

651 def 
	$check_editable
 ( 
self
 , 
spec
 ) :

652 if not 
self
 . 
editable
 :

655 if 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
self
 . 
build_directory
 , 
spec
 . 
key
 ) ) :

656 raise 
DistutilsArgError
 ( "%r already exists in %s; can't do a checkout there"

658 ( 
spec
 . 
key
 , 
self
 . 
build_directory
 )

659 ) 
	}

661 @ 
contextlib
 . 
	`contextmanager

662 def 
	$_tmpdir
 ( 
self
 ) :

663 
tmpdir
 = 
tempfile
 . 
mkdtemp
 ( 
prefix
 = u"easy_install-" )

666 yield 
str
 ( 
tmpdir
 )

668 
os
 . 
path
 . 
exists
 ( 
tmpdir
 ) and 
rmtree
 ( 
rmtree_safe
 ( 
tmpdir
 ) ) 
	}

670 def 
	$easy_install
 ( 
self
 , 
spec
 , 
deps
 = False ) :

671 if not 
self
 . 
editable
 :

672 
self
 . 
install_site_py
 ( )

674 with 
self
 . 
_tmpdir
 ( ) as 
tmpdir
 :

675 if not 
isinstance
 ( 
spec
 , 
Requirement
 ) :

676 if 
URL_SCHEME
 ( 
spec
 ) :

678 
self
 . 
not_editable
 ( 
spec
 )

679 
dl
 = 
self
 . 
package_index
 . 
download
 ( 
spec
 , 
tmpdir
 )

680 return 
self
 . 
install_item
 ( None , 
dl
 , 
tmpdir
 , 
deps
 , True )

682 elif 
os
 . 
path
 . 
exists
 ( 
spec
 ) :

684 
self
 . 
not_editable
 ( 
spec
 )

685 return 
self
 . 
install_item
 ( None , 
spec
 , 
tmpdir
 , 
deps
 , True )

687 
spec
 = 
parse_requirement_arg
 ( 
spec
 )

689 
self
 . 
check_editable
 ( 
spec
 )

690 
dist
 = 
self
 . 
package_index
 . 
fetch_distribution
 (

691 
spec
 , 
tmpdir
 , 
self
 . 
upgrade
 , 
self
 . 
editable
 ,

692 not 
self
 . 
always_copy
 , 
self
 . 
local_index

694 if 
dist
 is None :

695 
msg
 = "Could not find suitable distribution for %r" % 
spec

696 if 
self
 . 
always_copy
 :

697 
msg
 += " (--always-copy skips system and development eggs)"

698 raise 
DistutilsError
 ( 
msg
 )

699 elif 
dist
 . 
precedence
 == 
DEVELOP_DIST
 :

701 
self
 . 
process_distribution
 ( 
spec
 , 
dist
 , 
deps
 , "Using" )

702 return 
dist

704 return 
self
 . 
install_item
 ( 
spec
 , 
dist
 . 
location
 , 
tmpdir
 , 
deps
 ) 
	}

706 def 
	$install_item
 ( 
self
 , 
spec
 , 
download
 , 
tmpdir
 , 
deps
 , 
install_needed
 = False ) :

709 
install_needed
 = 
install_needed
 or 
self
 . 
always_copy

710 
install_needed
 = 
install_needed
 or 
os
 . 
path
 . 
dirname
 ( 
download
 ) == 
tmpdir

711 
install_needed
 = 
install_needed
 or not 
download
 . 
endswith
 ( '.egg' )

712 
install_needed
 = 
install_needed
 or (

713 
self
 . 
always_copy_from
 is not None and

714 
os
 . 
path
 . 
dirname
 ( 
normalize_path
 ( 
download
 ) ) ==

715 
normalize_path
 ( 
self
 . 
always_copy_from
 )

718 if 
spec
 and not 
install_needed
 :

721 for 
dist
 in 
self
 . 
local_index
 [ 
spec
 . 
project_name
 ] :

722 if 
dist
 . 
location
 == 
download
 :

725 
install_needed
 = True

727 
log
 . 
info
 ( "Processing %s" , 
os
 . 
path
 . 
basename
 ( 
download
 ) )

729 if 
install_needed
 :

730 
dists
 = 
self
 . 
install_eggs
 ( 
spec
 , 
download
 , 
tmpdir
 )

731 for 
dist
 in 
dists
 :

732 
self
 . 
process_distribution
 ( 
spec
 , 
dist
 , 
deps
 )

734 
dists
 = [ 
self
 . 
egg_distribution
 ( 
download
 ) ]

735 
self
 . 
process_distribution
 ( 
spec
 , 
dists
 [ 0 ] , 
deps
 , "Using" )

737 if 
spec
 is not None :

738 for 
dist
 in 
dists
 :

739 if 
dist
 in 
spec
 :

740 return 
dist
 
	}

742 def 
	$select_scheme
 ( 
self
 , 
name
 ) :

745 
scheme
 = 
INSTALL_SCHEMES
 [ 
name
 ]

746 for 
key
 in 
SCHEME_KEYS
 :

747 
attrname
 = 'install_' + 
key

748 if 
getattr
 ( 
self
 , 
attrname
 ) is None :

749 
setattr
 ( 
self
 , 
attrname
 , 
scheme
 [ 
key
 ] ) 
	}

751 def 
	$process_distribution
 ( 
self
 , 
requirement
 , 
dist
 , 
deps
 = True , * 
info
 ) :

752 
self
 . 
update_pth
 ( 
dist
 )

753 
self
 . 
package_index
 . 
add
 ( 
dist
 )

754 if 
dist
 in 
self
 . 
local_index
 [ 
dist
 . 
key
 ] :

755 
self
 . 
local_index
 . 
remove
 ( 
dist
 )

756 
self
 . 
local_index
 . 
add
 ( 
dist
 )

757 
self
 . 
install_egg_scripts
 ( 
dist
 )

758 
self
 . 
installed_projects
 [ 
dist
 . 
key
 ] = 
dist

759 
log
 . 
info
 ( 
self
 . 
installation_report
 ( 
requirement
 , 
dist
 , * 
info
 ) )

760 if ( 
dist
 . 
has_metadata
 ( 'dependency_links.txt' ) and

761 not 
self
 . 
no_find_links
 ) :

762 
self
 . 
package_index
 . 
add_find_links
 (

763 
dist
 . 
get_metadata_lines
 ( 'dependency_links.txt' )

765 if not 
deps
 and not 
self
 . 
always_copy
 :

767 elif 
requirement
 is not None and 
dist
 . 
key
 != 
requirement
 . 
key
 :

768 
log
 . 
warn
 ( "Skipping dependencies for %s" , 
dist
 )

770 elif 
requirement
 is None or 
dist
 not in 
requirement
 :

772 
distreq
 = 
dist
 . 
as_requirement
 ( )

773 
requirement
 = 
Requirement
 ( 
str
 ( 
distreq
 ) )

774 
log
 . 
info
 ( "Processing dependencies for %s" , 
requirement
 )

776 
distros
 = 
WorkingSet
 ( [ ] ) . 
resolve
 (

777 [ 
requirement
 ] , 
self
 . 
local_index
 , 
self
 . 
easy_install

779 except 
DistributionNotFound
 as 
e
 :

780 raise 
DistutilsError
 ( 
str
 ( 
e
 ) )

781 except 
VersionConflict
 as 
e
 :

782 raise 
DistutilsError
 ( 
e
 . 
report
 ( ) )

783 if 
self
 . 
always_copy
 or 
self
 . 
always_copy_from
 :

785 for 
dist
 in 
distros
 :

786 if 
dist
 . 
key
 not in 
self
 . 
installed_projects
 :

787 
self
 . 
easy_install
 ( 
dist
 . 
as_requirement
 ( ) )

788 
log
 . 
info
 ( "Finished processing dependencies for %s" , 
requirement
 ) 
	}

790 def 
	$should_unzip
 ( 
self
 , 
dist
 ) :

791 if 
self
 . 
zip_ok
 is not None :

792 return not 
self
 . 
zip_ok

793 if 
dist
 . 
has_metadata
 ( 'not-zip-safe' ) :

795 if not 
dist
 . 
has_metadata
 ( 'zip-safe' ) :

797 return False 
	}

799 def 
	$maybe_move
 ( 
self
 , 
spec
 , 
dist_filename
 , 
setup_base
 ) :

800 
dst
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
build_directory
 , 
spec
 . 
key
 )

801 if 
os
 . 
path
 . 
exists
 ( 
dst
 ) :

802 
msg
 = ( "%r already exists in %s; build directory %s will not be kept"

805 
log
 . 
warn
 ( 
msg
 , 
spec
 . 
key
 , 
self
 . 
build_directory
 , 
setup_base
 )

806 return 
setup_base

807 if 
os
 . 
path
 . 
isdir
 ( 
dist_filename
 ) :

808 
setup_base
 = 
dist_filename

810 if 
os
 . 
path
 . 
dirname
 ( 
dist_filename
 ) == 
setup_base
 :

811 
os
 . 
unlink
 ( 
dist_filename
 )

812 
contents
 = 
os
 . 
listdir
 ( 
setup_base
 )

813 if 
len
 ( 
contents
 ) == 1 :

814 
dist_filename
 = 
os
 . 
path
 . 
join
 ( 
setup_base
 , 
contents
 [ 0 ] )

815 if 
os
 . 
path
 . 
isdir
 ( 
dist_filename
 ) :

817 
setup_base
 = 
dist_filename

818 
ensure_directory
 ( 
dst
 )

819 
shutil
 . 
move
 ( 
setup_base
 , 
dst
 )

820 return 
dst
 
	}

822 def 
	$install_wrapper_scripts
 ( 
self
 , 
dist
 ) :

823 if 
self
 . 
exclude_scripts
 :

825 for 
args
 in 
ScriptWriter
 . 
best
 ( ) . 
get_args
 ( 
dist
 ) :

826 
self
 . 
write_script
 ( * 
args
 ) 
	}

828 def 
	$install_script
 ( 
self
 , 
dist
 , 
script_name
 , 
script_text
 , 
dev_path
 = None ) :

830 
spec
 = 
str
 ( 
dist
 . 
as_requirement
 ( ) )

831 
is_script
 = 
is_python_script
 ( 
script_text
 , 
script_name
 )

833 if 
is_script
 :

834 
body
 = 
self
 . 
_load_template
 ( 
dev_path
 ) % 
locals
 ( )

835 
script_text
 = 
ScriptWriter
 . 
get_header
 ( 
script_text
 ) + 
body

836 
self
 . 
write_script
 ( 
script_name
 , 
_to_bytes
 ( 
script_text
 ) , 'b' ) 
	}

838 @ 
	`staticmethod

839 def 
	$_load_template
 ( 
dev_path
 ) :

846 
name
 = 'script.tmpl'

847 if 
dev_path
 :

848 
name
 = 
name
 . 
replace
 ( '.tmpl' , ' (dev).tmpl' )

850 
raw_bytes
 = 
resource_string
 ( 'setuptools' , 
name
 )

851 return 
raw_bytes
 . 
decode
 ( 'utf-8' ) 
	}

853 def 
	$write_script
 ( 
self
 , 
script_name
 , 
contents
 , 
mode
 = "t" , 
blockers
 = ( ) ) :

855 
self
 . 
delete_blockers
 (

856 [ 
os
 . 
path
 . 
join
 ( 
self
 . 
script_dir
 , 
x
 ) for 
x
 in 
blockers
 ]

858 
log
 . 
info
 ( "Installing %s script to %s" , 
script_name
 , 
self
 . 
script_dir
 )

859 
target
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
script_dir
 , 
script_name
 )

860 
self
 . 
add_output
 ( 
target
 )

862 if 
self
 . 
dry_run
 :

865 
mask
 = 
current_umask
 ( )

866 
ensure_directory
 ( 
target
 )

867 if 
os
 . 
path
 . 
exists
 ( 
target
 ) :

868 
os
 . 
unlink
 ( 
target
 )

869 with 
open
 ( 
target
 , "w" + 
mode
 ) as 
f
 :

870 
f
 . 
write
 ( 
contents
 )

871 
chmod
 ( 
target
 , 0o777 - 
mask
 ) 
	}

873 def 
	$install_eggs
 ( 
self
 , 
spec
 , 
dist_filename
 , 
tmpdir
 ) :

875 if 
dist_filename
 . 
lower
 ( ) . 
endswith
 ( '.egg' ) :

876 return [ 
self
 . 
install_egg
 ( 
dist_filename
 , 
tmpdir
 ) ]

877 elif 
dist_filename
 . 
lower
 ( ) . 
endswith
 ( '.exe' ) :

878 return [ 
self
 . 
install_exe
 ( 
dist_filename
 , 
tmpdir
 ) ]

879 elif 
dist_filename
 . 
lower
 ( ) . 
endswith
 ( '.whl' ) :

880 return [ 
self
 . 
install_wheel
 ( 
dist_filename
 , 
tmpdir
 ) ]

883 
setup_base
 = 
tmpdir

884 if 
os
 . 
path
 . 
isfile
 ( 
dist_filename
 ) and not 
dist_filename
 . 
endswith
 ( '.py' ) :

885 
unpack_archive
 ( 
dist_filename
 , 
tmpdir
 , 
self
 . 
unpack_progress
 )

886 elif 
os
 . 
path
 . 
isdir
 ( 
dist_filename
 ) :

887 
setup_base
 = 
os
 . 
path
 . 
abspath
 ( 
dist_filename
 )

889 if ( 
setup_base
 . 
startswith
 ( 
tmpdir
 )

890 and 
self
 . 
build_directory
 and 
spec
 is not None ) :

891 
setup_base
 = 
self
 . 
maybe_move
 ( 
spec
 , 
dist_filename
 , 
setup_base
 )

894 
setup_script
 = 
os
 . 
path
 . 
join
 ( 
setup_base
 , 'setup.py' )

896 if not 
os
 . 
path
 . 
exists
 ( 
setup_script
 ) :

897 
setups
 = 
glob
 ( 
os
 . 
path
 . 
join
 ( 
setup_base
 , '*' , 'setup.py' ) )

898 if not 
setups
 :

899 raise 
DistutilsError
 ( "Couldn't find a setup script in %s"

901 
os
 . 
path
 . 
abspath
 ( 
dist_filename
 )

903 if 
len
 ( 
setups
 ) > 1 :

904 raise 
DistutilsError
 ( "Multiple setup scripts in %s"

906 
os
 . 
path
 . 
abspath
 ( 
dist_filename
 )

908 
setup_script
 = 
setups
 [ 0 ]

911 if 
self
 . 
editable
 :

912 
log
 . 
info
 ( 
self
 . 
report_editable
 ( 
spec
 , 
setup_script
 ) )

915 return 
self
 . 
build_and_install
 ( 
setup_script
 , 
setup_base
 ) 
	}

917 def 
	$egg_distribution
 ( 
self
 , 
egg_path
 ) :

918 if 
os
 . 
path
 . 
isdir
 ( 
egg_path
 ) :

919 
metadata
 = 
PathMetadata
 ( 
egg_path
 , 
os
 . 
path
 . 
join
 ( 
egg_path
 , 'EGG-INFO'

922 
metadata
 = 
EggMetadata
 ( 
zipimport
 . 
zipimporter
 ( 
egg_path
 ) )

923 return 
Distribution
 . 
from_filename
 ( 
egg_path
 , 
metadata
 = 
metadata
 ) 
	}

925 def 
	$install_egg
 ( 
self
 , 
egg_path
 , 
tmpdir
 ) :

926 
destination
 = 
os
 . 
path
 . 
join
 (

927 
self
 . 
install_dir
 ,

928 
os
 . 
path
 . 
basename
 ( 
egg_path
 ) ,

930 
destination
 = 
os
 . 
path
 . 
abspath
 ( 
destination
 )

931 if not 
self
 . 
dry_run
 :

932 
ensure_directory
 ( 
destination
 )

934 
dist
 = 
self
 . 
egg_distribution
 ( 
egg_path
 )

935 if not 
samefile
 ( 
egg_path
 , 
destination
 ) :

936 if 
os
 . 
path
 . 
isdir
 ( 
destination
 ) and not 
os
 . 
path
 . 
islink
 ( 
destination
 ) :

937 
dir_util
 . 
remove_tree
 ( 
destination
 , 
dry_run
 = 
self
 . 
dry_run
 )

938 elif 
os
 . 
path
 . 
exists
 ( 
destination
 ) :

939 
self
 . 
execute
 (

940 
os
 . 
unlink
 ,

941 ( 
destination
 , ) , "Removing "

942 + 
destination
 ,

945 
new_dist_is_zipped
 = False

946 if 
os
 . 
path
 . 
isdir
 ( 
egg_path
 ) :

947 if 
egg_path
 . 
startswith
 ( 
tmpdir
 ) :

948 
f
 , 
m
 = 
shutil
 . 
move
 , "Moving"

950 
f
 , 
m
 = 
shutil
 . 
copytree
 , "Copying"

951 elif 
self
 . 
should_unzip
 ( 
dist
 ) :

952 
self
 . 
mkpath
 ( 
destination
 )

953 
f
 , 
m
 = 
self
 . 
unpack_and_compile
 , "Extracting"

955 
new_dist_is_zipped
 = True

956 if 
egg_path
 . 
startswith
 ( 
tmpdir
 ) :

957 
f
 , 
m
 = 
shutil
 . 
move
 , "Moving"

959 
f
 , 
m
 = 
shutil
 . 
copy2
 , "Copying"

960 
self
 . 
execute
 (

961 
f
 ,

962 ( 
egg_path
 , 
destination
 ) ,

963 ( 
m
 + " %s to %s" ) % (

964 
os
 . 
path
 . 
basename
 ( 
egg_path
 ) ,

965 
os
 . 
path
 . 
dirname
 ( 
destination
 )

968 
update_dist_caches
 (

969 
destination
 ,

970 
fix_zipimporter_caches
 = 
new_dist_is_zipped
 ,

972 except 
Exception
 :

973 
update_dist_caches
 ( 
destination
 , 
fix_zipimporter_caches
 = False )

976 
self
 . 
add_output
 ( 
destination
 )

977 return 
self
 . 
egg_distribution
 ( 
destination
 ) 
	}

979 def 
	$install_exe
 ( 
self
 , 
dist_filename
 , 
tmpdir
 ) :

981 
cfg
 = 
extract_wininst_cfg
 ( 
dist_filename
 )

982 if 
cfg
 is None :

983 raise 
DistutilsError
 ( "%s is not a valid distutils Windows .exe"

984 % 
dist_filename

987 
dist
 = 
Distribution
 (

989 
project_name
 = 
cfg
 . 
get
 ( 'metadata' , 'name' ) ,

990 
version
 = 
cfg
 . 
get
 ( 'metadata' , 'version' ) , 
platform
 = 
get_platform
 ( ) ,

994 
egg_path
 = 
os
 . 
path
 . 
join
 ( 
tmpdir
 , 
dist
 . 
egg_name
 ( ) + '.egg' )

995 
dist
 . 
location
 = 
egg_path

996 
egg_tmp
 = 
egg_path
 + '.tmp'

997 
_egg_info
 = 
os
 . 
path
 . 
join
 ( 
egg_tmp
 , 'EGG-INFO' )

998 
pkg_inf
 = 
os
 . 
path
 . 
join
 ( 
_egg_info
 , 'PKG-INFO' )

999 
ensure_directory
 ( 
pkg_inf
 )

1000 
dist
 . 
_provider
 = 
PathMetadata
 ( 
egg_tmp
 , 
_egg_info
 )

1001 
self
 . 
exe_to_egg
 ( 
dist_filename
 , 
egg_tmp
 )

1004 if not 
os
 . 
path
 . 
exists
 ( 
pkg_inf
 ) :

1005 
f
 = 
open
 ( 
pkg_inf
 , 'w' )

1006 
f
 . 
write
 ( 'Metadata-Version: 1.0\n' )

1007 for 
k
 , 
v
 in 
cfg
 . 
items
 ( 'metadata' ) :

1008 if 
k
 != 'target_version' :

1009 
f
 . 
write
 ( '%s: %s\n' % ( 
k
 . 
replace
 ( '_' , '-' ) . 
title
 ( ) , 
v
 ) )

1010 
f
 . 
close
 ( )

1011 
script_dir
 = 
os
 . 
path
 . 
join
 ( 
_egg_info
 , 'scripts' )

1013 
self
 . 
delete_blockers
 ( [

1014 
os
 . 
path
 . 
join
 ( 
script_dir
 , 
args
 [ 0 ] )

1015 for 
args
 in 
ScriptWriter
 . 
get_args
 ( 
dist
 )

1018 
bdist_egg
 . 
make_zipfile
 (

1019 
egg_path
 , 
egg_tmp
 , 
verbose
 = 
self
 . 
verbose
 , 
dry_run
 = 
self
 . 
dry_run
 ,

1022 return 
self
 . 
install_egg
 ( 
egg_path
 , 
tmpdir
 ) 
	}

1024 def 
	$exe_to_egg
 ( 
self
 , 
dist_filename
 , 
egg_tmp
 ) :

1027 
prefixes
 = 
get_exe_prefixes
 ( 
dist_filename
 )

1028 
to_compile
 = [ ]

1029 
native_libs
 = [ ]

1030 
top_level
 = { }

1032 def 
process
 ( 
src
 , 
dst
 ) :

1033 
s
 = 
src
 . 
lower
 ( )

1034 for 
old
 , 
new
 in 
prefixes
 :

1035 if 
s
 . 
startswith
 ( 
old
 ) :

1036 
src
 = 
new
 + 
src
 [ 
len
 ( 
old
 ) : ]

1037 
parts
 = 
src
 . 
split
 ( '/' )

1038 
dst
 = 
os
 . 
path
 . 
join
 ( 
egg_tmp
 , * 
parts
 )

1039 
dl
 = 
dst
 . 
lower
 ( )

1040 if 
dl
 . 
endswith
 ( '.pyd' ) or 
dl
 . 
endswith
 ( '.dll' ) :

1041 
parts
 [ - 1 ] = 
bdist_egg
 . 
strip_module
 ( 
parts
 [ - 1 ] )

1042 
top_level
 [ 
os
 . 
path
 . 
splitext
 ( 
parts
 [ 0 ] ) [ 0 ] ] = 1

1043 
native_libs
 . 
append
 ( 
src
 )

1044 elif 
dl
 . 
endswith
 ( '.py' ) and 
old
 != 'SCRIPTS/' :

1045 
top_level
 [ 
os
 . 
path
 . 
splitext
 ( 
parts
 [ 0 ] ) [ 0 ] ] = 1

1046 
to_compile
 . 
append
 ( 
dst
 )

1047 return 
dst

1048 if not 
src
 . 
endswith
 ( '.pth' ) :

1049 
log
 . 
warn
 ( "WARNING: can't process %s" , 
src
 )

1053 
unpack_archive
 ( 
dist_filename
 , 
egg_tmp
 , 
process
 )

1054 
stubs
 = [ ]

1055 for 
res
 in 
native_libs
 :

1056 if 
res
 . 
lower
 ( ) . 
endswith
 ( '.pyd' ) :

1057 
parts
 = 
res
 . 
split
 ( '/' )

1058 
resource
 = 
parts
 [ - 1 ]

1059 
parts
 [ - 1 ] = 
bdist_egg
 . 
strip_module
 ( 
parts
 [ - 1 ] ) + '.py'

1060 
pyfile
 = 
os
 . 
path
 . 
join
 ( 
egg_tmp
 , * 
parts
 )

1061 
to_compile
 . 
append
 ( 
pyfile
 )

1062 
stubs
 . 
append
 ( 
pyfile
 )

1063 
bdist_egg
 . 
write_stub
 ( 
resource
 , 
pyfile
 )

1064 
self
 . 
byte_compile
 ( 
to_compile
 )

1065 
bdist_egg
 . 
write_safety_flag
 (

1066 
os
 . 
path
 . 
join
 ( 
egg_tmp
 , 'EGG-INFO' ) ,

1067 
bdist_egg
 . 
analyze_egg
 ( 
egg_tmp
 , 
stubs
 ) )

1069 for 
name
 in 'top_level' , 'native_libs' :

1070 if 
locals
 ( ) [ 
name
 ] :

1071 
txt
 = 
os
 . 
path
 . 
join
 ( 
egg_tmp
 , 'EGG-INFO' , 
name
 + '.txt' )

1072 if not 
os
 . 
path
 . 
exists
 ( 
txt
 ) :

1073 
f
 = 
open
 ( 
txt
 , 'w' )

1074 
f
 . 
write
 ( '\n' . 
join
 ( 
locals
 ( ) [ 
name
 ] ) + '\n' )

1075 
f
 . 
close
 ( ) 
	}

1077 def 
	$install_wheel
 ( 
self
 , 
wheel_path
 , 
tmpdir
 ) :

1078 
wheel
 = 
Wheel
 ( 
wheel_path
 )

1079 assert 
wheel
 . 
is_compatible
 ( )

1080 
destination
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 
wheel
 . 
egg_name
 ( ) )

1081 
destination
 = 
os
 . 
path
 . 
abspath
 ( 
destination
 )

1082 if not 
self
 . 
dry_run
 :

1083 
ensure_directory
 ( 
destination
 )

1084 if 
os
 . 
path
 . 
isdir
 ( 
destination
 ) and not 
os
 . 
path
 . 
islink
 ( 
destination
 ) :

1085 
dir_util
 . 
remove_tree
 ( 
destination
 , 
dry_run
 = 
self
 . 
dry_run
 )

1086 elif 
os
 . 
path
 . 
exists
 ( 
destination
 ) :

1087 
self
 . 
execute
 (

1088 
os
 . 
unlink
 ,

1089 ( 
destination
 , ) , "Removing "

1090 + 
destination
 ,

1093 
self
 . 
execute
 (

1094 
wheel
 . 
install_as_egg
 ,

1095 ( 
destination
 , ) ,

1097 
os
 . 
path
 . 
basename
 ( 
wheel_path
 ) ,

1098 
os
 . 
path
 . 
dirname
 ( 
destination
 )

1102 
update_dist_caches
 ( 
destination
 , 
fix_zipimporter_caches
 = False )

1103 
self
 . 
add_output
 ( 
destination
 )

1104 return 
self
 . 
egg_distribution
 ( 
destination
 ) 
	}

1106 
__mv_warning
 = 
textwrap
 . 
dedent
 ( """\n        Because this distribution was installed --multi-version, before you can\n        import modules from this package in an application, you will need to\n        'import pkg_resources' and then use a 'require()' call similar to one of\n        these examples, in order to select the desired version:\n\n            pkg_resources.require("%(name)s")  # latest installed version\n            pkg_resources.require("%(name)s==%(version)s")  # this exact version\n            pkg_resources.require("%(name)s>=%(version)s")  # this version or higher\n        """

1115 ) . 
lstrip
 ( )

1117 
__id_warning
 = 
textwrap
 . 
dedent
 ( """\n        Note also that the installation directory must be on sys.path at runtime for\n        this to work.  (e.g. by being the application's script directory, by being on\n        PYTHONPATH, or by being added to sys.path by your code.)\n        """

1123 def 
	$installation_report
 ( 
self
 , 
req
 , 
dist
 , 
what
 = "Installed" ) :

1125 
msg
 = "\n%(what)s %(eggloc)s%(extras)s"

1126 if 
self
 . 
multi_version
 and not 
self
 . 
no_report
 :

1127 
msg
 += '\n' + 
self
 . 
__mv_warning

1128 if 
self
 . 
install_dir
 not in 
map
 ( 
normalize_path
 , 
sys
 . 
path
 ) :

1129 
msg
 += '\n' + 
self
 . 
__id_warning

1131 
eggloc
 = 
dist
 . 
location

1132 
name
 = 
dist
 . 
project_name

1133 
version
 = 
dist
 . 
version

1134 
extras
 = ''

1135 return 
msg
 % 
locals
 ( ) 
	}

1137 
__editable_msg
 = 
textwrap
 . 
dedent
 ( """\n        Extracted editable version of %(spec)s to %(dirname)s\n\n        If it uses setuptools in its setup script, you can activate it in\n        "development" mode by going to that directory and running::\n\n            %(python)s setup.py develop\n\n        See the setuptools documentation for the "develop" command for more info.\n        """

1146 ) . 
lstrip
 ( )

1148 def 
	$report_editable
 ( 
self
 , 
spec
 , 
setup_script
 ) :

1149 
dirname
 = 
os
 . 
path
 . 
dirname
 ( 
setup_script
 )

1150 
python
 = 
sys
 . 
executable

1151 return '\n' + 
self
 . 
__editable_msg
 % 
locals
 ( ) 
	}

1153 def 
	$run_setup
 ( 
self
 , 
setup_script
 , 
setup_base
 , 
args
 ) :

1154 
sys
 . 
modules
 . 
setdefault
 ( 'distutils.command.bdist_egg' , 
bdist_egg
 )

1155 
sys
 . 
modules
 . 
setdefault
 ( 'distutils.command.egg_info' , 
egg_info
 )

1157 
args
 = 
list
 ( 
args
 )

1158 if 
self
 . 
verbose
 > 2 :

1159 
v
 = 'v' * ( 
self
 . 
verbose
 - 1 )

1160 
args
 . 
insert
 ( 0 , '-' + 
v
 )

1161 elif 
self
 . 
verbose
 < 2 :

1162 
args
 . 
insert
 ( 0 , '-q' )

1163 if 
self
 . 
dry_run
 :

1164 
args
 . 
insert
 ( 0 , '-n' )

1165 
log
 . 
info
 ( "Running %s %s"

1166 , 
setup_script
 [ 
len
 ( 
setup_base
 ) + 1 : ] , ' ' . 
join
 ( 
args
 )

1169 
run_setup
 ( 
setup_script
 , 
args
 )

1170 except 
SystemExit
 as 
v
 :

1171 raise 
DistutilsError
 ( "Setup script exited with %s" % ( 
v
 . 
args
 [ 0 ] , ) ) 
	}

1173 def 
	$build_and_install
 ( 
self
 , 
setup_script
 , 
setup_base
 ) :

1174 
args
 = [ 'bdist_egg' , '--dist-dir' ]

1176 
dist_dir
 = 
tempfile
 . 
mkdtemp
 (

1177 
prefix
 = 'egg-dist-tmp-' , 
dir
 = 
os
 . 
path
 . 
dirname
 ( 
setup_script
 )

1180 
self
 . 
_set_fetcher_options
 ( 
os
 . 
path
 . 
dirname
 ( 
setup_script
 ) )

1181 
args
 . 
append
 ( 
dist_dir
 )

1183 
self
 . 
run_setup
 ( 
setup_script
 , 
setup_base
 , 
args
 )

1184 
all_eggs
 = 
Environment
 ( [ 
dist_dir
 ] )

1185 
eggs
 = [ ]

1186 for 
key
 in 
all_eggs
 :

1187 for 
dist
 in 
all_eggs
 [ 
key
 ] :

1188 
eggs
 . 
append
 ( 
self
 . 
install_egg
 ( 
dist
 . 
location
 , 
setup_base
 ) )

1189 if not 
eggs
 and not 
self
 . 
dry_run
 :

1190 
log
 . 
warn
 ( "No eggs found in %s (setup script problem?)" ,

1191 
dist_dir
 )

1192 return 
eggs

1194 
rmtree
 ( 
dist_dir
 )

1195 
log
 . 
set_verbosity
 ( 
self
 . 
verbose
 ) 
	}

1197 def 
	$_set_fetcher_options
 ( 
self
 , 
base
 ) :

1206 
ei_opts
 = 
self
 . 
distribution
 . 
get_option_dict
 ( 'easy_install' ) . 
copy
 ( )

1207 
fetch_directives
 = ( 'find_links'

1211 
fetch_options
 = { }

1212 for 
key
 , 
val
 in 
ei_opts
 . 
items
 ( ) :

1213 if 
key
 not in 
fetch_directives
 :

1215 
fetch_options
 [ 
key
 . 
replace
 ( '_' , '-' ) ] = 
val
 [ 1 ]

1217 
settings
 = 
dict
 ( 
easy_install
 = 
fetch_options
 )

1218 
cfg_filename
 = 
os
 . 
path
 . 
join
 ( 
base
 , 'setup.cfg' )

1219 
setopt
 . 
edit_config
 ( 
cfg_filename
 , 
settings
 ) 
	}

1221 def 
	$update_pth
 ( 
self
 , 
dist
 ) :

1222 if 
self
 . 
pth_file
 is None :

1225 for 
d
 in 
self
 . 
pth_file
 [ 
dist
 . 
key
 ] :

1226 if 
self
 . 
multi_version
 or 
d
 . 
location
 != 
dist
 . 
location
 :

1227 
log
 . 
info
 ( "Removing %s from easy-install.pth file" , 
d
 )

1228 
self
 . 
pth_file
 . 
remove
 ( 
d
 )

1229 if 
d
 . 
location
 in 
self
 . 
shadow_path
 :

1230 
self
 . 
shadow_path
 . 
remove
 ( 
d
 . 
location
 )

1232 if not 
self
 . 
multi_version
 :

1233 if 
dist
 . 
location
 in 
self
 . 
pth_file
 . 
paths
 :

1234 
log
 . 
info
 ( "%s is already the active version in easy-install.pth"

1236 
dist
 ,

1239 
log
 . 
info
 ( "Adding %s to easy-install.pth file" , 
dist
 )

1240 
self
 . 
pth_file
 . 
add
 ( 
dist
 )

1241 if 
dist
 . 
location
 not in 
self
 . 
shadow_path
 :

1242 
self
 . 
shadow_path
 . 
append
 ( 
dist
 . 
location
 )

1244 if not 
self
 . 
dry_run
 :

1246 
self
 . 
pth_file
 . 
save
 ( )

1248 if 
dist
 . 
key
 == 'setuptools' :

1251 
filename
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 'setuptools.pth' )

1252 if 
os
 . 
path
 . 
islink
 ( 
filename
 ) :

1253 
os
 . 
unlink
 ( 
filename
 )

1254 
f
 = 
open
 ( 
filename
 , 'wt' )

1255 
f
 . 
write
 ( 
self
 . 
pth_file
 . 
make_relative
 ( 
dist
 . 
location
 ) + '\n' )

1256 
f
 . 
close
 ( ) 
	}

1258 def 
	$unpack_progress
 ( 
self
 , 
src
 , 
dst
 ) :

1260 
log
 . 
debug
 ( "Unpacking %s to %s" , 
src
 , 
dst
 )

1261 return 
dst
 
	}

1263 def 
	$unpack_and_compile
 ( 
self
 , 
egg_path
 , 
destination
 ) :

1264 
to_compile
 = [ ]

1265 
to_chmod
 = [ ]

1267 def 
pf
 ( 
src
 , 
dst
 ) :

1268 if 
dst
 . 
endswith
 ( '.py' ) and not 
src
 . 
startswith
 ( 'EGG-INFO/' ) :

1269 
to_compile
 . 
append
 ( 
dst
 )

1270 elif 
dst
 . 
endswith
 ( '.dll' ) or 
dst
 . 
endswith
 ( '.so' ) :

1271 
to_chmod
 . 
append
 ( 
dst
 )

1272 
self
 . 
unpack_progress
 ( 
src
 , 
dst
 )

1273 return not 
self
 . 
dry_run
 and 
dst
 or None

1275 
unpack_archive
 ( 
egg_path
 , 
destination
 , 
pf
 )

1276 
self
 . 
byte_compile
 ( 
to_compile
 )

1277 if not 
self
 . 
dry_run
 :

1278 for 
f
 in 
to_chmod
 :

1279 
mode
 = ( ( 
os
 . 
stat
 ( 
f
 ) [ 
stat
 . 
ST_MODE
 ] ) | 0o555 ) & 0o7755

1280 
chmod
 ( 
f
 , 
mode
 ) 
	}

1282 def 
	$byte_compile
 ( 
self
 , 
to_compile
 ) :

1283 if 
sys
 . 
dont_write_bytecode
 :

1286 from 
	~distutils.util
 import 
byte_compile

1290 
log
 . 
set_verbosity
 ( 
self
 . 
verbose
 - 1 )

1292 
byte_compile
 ( 
to_compile
 , 
optimize
 = 0 , 
force
 = 1 , 
dry_run
 = 
self
 . 
dry_run
 )

1293 if 
self
 . 
optimize
 :

1294 
byte_compile
 (

1295 
to_compile
 , 
optimize
 = 
self
 . 
optimize
 , 
force
 = 1 ,

1296 
dry_run
 = 
self
 . 
dry_run
 ,

1299 
log
 . 
set_verbosity
 ( 
self
 . 
verbose
 ) 
	}

1301 
__no_default_msg
 = 
textwrap
 . 
dedent
 ( """\n        bad install directory or PYTHONPATH\n\n        You are attempting to install a package to a directory that is not\n        on PYTHONPATH and which Python does not read ".pth" files from.  The\n        installation directory you specified (via --install-dir, --prefix, or\n        the distutils default setting) was:\n\n            %s\n\n        and your PYTHONPATH environment variable currently contains:\n\n            %r\n\n        Here are some of your options for correcting the problem:\n\n        * You can choose a different installation directory, i.e., one that is\n          on PYTHONPATH or supports .pth files\n\n        * You can add the installation directory to the PYTHONPATH environment\n          variable.  (It must then also be on PYTHONPATH whenever you run\n          Python and want to use the package(s) you are installing.)\n\n        * You can set up the installation directory to support ".pth" files by\n          using one of the approaches described here:\n\n          https://setuptools.readthedocs.io/en/latest/easy_install.html#custom-installation-locations\n\n\n        Please make the appropriate changes for your system and try again."""

1330 ) . 
lstrip
 ( )

1332 def 
	$no_default_version_msg
 ( 
self
 ) :

1333 
template
 = 
self
 . 
__no_default_msg

1334 return 
template
 % ( 
self
 . 
install_dir
 , 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , '' ) ) 
	}

1336 def 
	$install_site_py
 ( 
self
 ) :

1339 if 
self
 . 
sitepy_installed
 :

1342 
sitepy
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , "site.py" )

1343 
source
 = 
resource_string
 ( "setuptools" , "site-patch.py" )

1344 
source
 = 
source
 . 
decode
 ( 'utf-8' )

1345 
current
 = ""

1347 if 
os
 . 
path
 . 
exists
 ( 
sitepy
 ) :

1348 
log
 . 
debug
 ( "Checking existing site.py in %s" , 
self
 . 
install_dir
 )

1349 with 
io
 . 
open
 ( 
sitepy
 ) as 
strm
 :

1350 
current
 = 
strm
 . 
read
 ( )

1352 if not 
current
 . 
startswith
 ( 'def __boot():' ) :

1353 raise 
DistutilsError
 ( "%s is not a setuptools-generated site.py; please" " remove it."

1355 % 
sitepy

1358 if 
current
 != 
source
 :

1359 
log
 . 
info
 ( "Creating %s" , 
sitepy
 )

1360 if not 
self
 . 
dry_run
 :

1361 
ensure_directory
 ( 
sitepy
 )

1362 with 
io
 . 
open
 ( 
sitepy
 , 'w' , 
encoding
 = 'utf-8' ) as 
strm
 :

1363 
strm
 . 
write
 ( 
source
 )

1364 
self
 . 
byte_compile
 ( [ 
sitepy
 ] )

1366 
self
 . 
sitepy_installed
 = True 
	}

1368 def 
	$create_home_path
 ( 
self
 ) :

1370 if not 
self
 . 
user
 :

1372 
home
 = 
convert_path
 ( 
os
 . 
path
 . 
expanduser
 ( "~" ) )

1373 for 
name
 , 
path
 in 
six
 . 
iteritems
 ( 
self
 . 
config_vars
 ) :

1374 if 
path
 . 
startswith
 ( 
home
 ) and not 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

1375 
self
 . 
debug_print
 ( "os.makedirs('%s', 0o700)" % 
path
 )

1376 
os
 . 
makedirs
 ( 
path
 , 0o700 ) 
	}

1378 if 
sys
 . 
version
 [ : 3 ] in ( '2.3' , '2.4' , '2.5' ) or 'real_prefix' in 
sys
 . 
__dict__
 :

1379 
sitedir_name
 = 'site-packages'

1381 
sitedir_name
 = 'dist-packages'

1383 
INSTALL_SCHEMES
 = 
dict
 (

1384 
posix
 = 
dict
 (

1385 
install_dir
 = '$base/lib/python$py_version_short/site-packages' ,

1386 
script_dir
 = '$base/bin' ,

1388 
unix_local
 = 
dict
 (

1389 
install_dir
 = '$base/local/lib/python$py_version_short/%s' % 
sitedir_name
 ,

1390 
script_dir
 = '$base/local/bin' ,

1392 
posix_local
 = 
dict
 (

1393 
install_dir
 = '$base/local/lib/python$py_version_short/%s' % 
sitedir_name
 ,

1394 
script_dir
 = '$base/local/bin' ,

1396 
deb_system
 = 
dict
 (

1397 
install_dir
 = '$base/lib/python3/%s' % 
sitedir_name
 ,

1398 
script_dir
 = '$base/bin' ,

1402 
DEFAULT_SCHEME
 = 
dict
 (

1403 
install_dir
 = '$base/Lib/site-packages' ,

1404 
script_dir
 = '$base/Scripts' ,

1407 def 
	$_expand
 ( 
self
 , * 
attrs
 ) :

1408 
config_vars
 = 
self
 . 
get_finalized_command
 ( 'install' ) . 
config_vars

1410 if 
self
 . 
prefix
 or 
self
 . 
install_layout
 :

1411 if 
self
 . 
install_layout
 and 
self
 . 
install_layout
 in [ 'deb' ] :

1412 
scheme_name
 = "deb_system"

1413 
self
 . 
prefix
 = '/usr'

1414 elif 
self
 . 
prefix
 or 'real_prefix' in 
sys
 . 
__dict__
 :

1415 
scheme_name
 = 
os
 . 
name

1417 
scheme_name
 = "posix_local"

1419 
config_vars
 = 
config_vars
 . 
copy
 ( )

1420 
config_vars
 [ 'base' ] = 
self
 . 
prefix

1421 
scheme
 = 
self
 . 
INSTALL_SCHEMES
 . 
get
 ( 
scheme_name
 , 
self
 . 
DEFAULT_SCHEME
 )

1422 for 
attr
 , 
val
 in 
scheme
 . 
items
 ( ) :

1423 if 
getattr
 ( 
self
 , 
attr
 , None ) is None :

1424 
setattr
 ( 
self
 , 
attr
 , 
val
 )

1426 from 
	~distutils.util
 import 
subst_vars

1428 for 
attr
 in 
attrs
 :

1429 
val
 = 
getattr
 ( 
self
 , 
attr
 )

1430 if 
val
 is not None :

1431 
val
 = 
subst_vars
 ( 
val
 , 
config_vars
 )

1432 if 
os
 . 
name
 == 'posix' :

1433 
val
 = 
os
 . 
path
 . 
expanduser
 ( 
val
 )

1434 
setattr
 ( 
self
 , 
attr
 , 
val
 ) 
	}

1437 def 
	$_pythonpath
 ( ) :

1438 
items
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , '' ) . 
split
 ( 
os
 . 
pathsep
 )

1439 return 
filter
 ( None , 
items
 ) 
	}

1442 def 
	$get_site_dirs
 ( ) :

1447 
sitedirs
 = [ ]

1450 
sitedirs
 . 
extend
 ( 
_pythonpath
 ( ) )

1452 
prefixes
 = [ 
sys
 . 
prefix
 ]

1453 if 
sys
 . 
exec_prefix
 != 
sys
 . 
prefix
 :

1454 
prefixes
 . 
append
 ( 
sys
 . 
exec_prefix
 )

1455 for 
prefix
 in 
prefixes
 :

1456 if 
prefix
 :

1457 if 
sys
 . 
platform
 in ( 'os2emx' , 'riscos' ) :

1458 
sitedirs
 . 
append
 ( 
os
 . 
path
 . 
join
 ( 
prefix
 , "Lib" , "site-packages" ) )

1459 elif 
os
 . 
sep
 == '/' :

1460 
sitedirs
 . 
extend
 ( [

1461 
os
 . 
path
 . 
join
 (

1462 
prefix
 , "local/lib"

1464 + 
sys
 . 
version
 [ : 3 ] , "dist-packages"

1467 
os
 . 
path
 . 
join
 (

1468 
prefix
 , "lib"

1470 + 
sys
 . 
version
 [ : 3 ] , "dist-packages"

1473 
os
 . 
path
 . 
join
 ( 
prefix
 , "lib" , "site-python" ) ,

1476 
sitedirs
 . 
extend
 ( [

1477 
prefix
 ,

1478 
os
 . 
path
 . 
join
 ( 
prefix
 , "lib" , "site-packages" ) ,

1480 if 
sys
 . 
platform
 == 'darwin' :

1484 if 'Python.framework' in 
prefix
 :

1485 
home
 = 
os
 . 
environ
 . 
get
 ( 'HOME' )

1486 if 
home
 :

1487 
home_sp
 = 
os
 . 
path
 . 
join
 (

1488 
home
 , 'Library'

1491 
sys
 . 
version
 [ : 3 ] , 'site-packages'

1494 
sitedirs
 . 
append
 ( 
home_sp
 )

1495 
lib_paths
 = 
get_path
 ( 'purelib' ) , 
get_path
 ( 'platlib' )

1496 for 
site_lib
 in 
lib_paths
 :

1497 if 
site_lib
 not in 
sitedirs
 :

1498 
sitedirs
 . 
append
 ( 
site_lib
 )

1500 if 
site
 . 
ENABLE_USER_SITE
 :

1501 
sitedirs
 . 
append
 ( 
site
 . 
USER_SITE
 )

1504 
sitedirs
 . 
extend
 ( 
site
 . 
getsitepackages
 ( ) )

1505 except 
AttributeError
 :

1508 
sitedirs
 = 
list
 ( 
map
 ( 
normalize_path
 , 
sitedirs
 ) )

1510 return 
sitedirs
 
	}

1513 def 
	$expand_paths
 ( 
inputs
 ) :

1516 
seen
 = { }

1518 for 
dirname
 in 
inputs
 :

1519 
dirname
 = 
normalize_path
 ( 
dirname
 )

1520 if 
dirname
 in 
seen
 :

1523 
seen
 [ 
dirname
 ] = 1

1524 if not 
os
 . 
path
 . 
isdir
 ( 
dirname
 ) :

1527 
files
 = 
os
 . 
listdir
 ( 
dirname
 )

1528 yield 
dirname
 , 
files

1530 for 
name
 in 
files
 :

1531 if not 
name
 . 
endswith
 ( '.pth' ) :

1534 if 
name
 in ( 'easy-install.pth' , 'setuptools.pth' ) :

1539 
f
 = 
open
 ( 
os
 . 
path
 . 
join
 ( 
dirname
 , 
name
 ) )

1540 
lines
 = 
list
 ( 
yield_lines
 ( 
f
 ) )

1541 
f
 . 
close
 ( )

1544 for 
line
 in 
lines
 :

1545 if not 
line
 . 
startswith
 ( "import" ) :

1546 
line
 = 
normalize_path
 ( 
line
 . 
rstrip
 ( ) )

1547 if 
line
 not in 
seen
 :

1548 
seen
 [ 
line
 ] = 1

1549 if not 
os
 . 
path
 . 
isdir
 ( 
line
 ) :

1551 yield 
line
 , 
os
 . 
listdir
 ( 
line
 ) 
	}

1554 def 
	$extract_wininst_cfg
 ( 
dist_filename
 ) :

1559 
f
 = 
open
 ( 
dist_filename
 , 'rb' )

1561 
endrec
 = 
zipfile
 . 
_EndRecData
 ( 
f
 )

1562 if 
endrec
 is None :

1565 
prepended
 = ( 
endrec
 [ 9 ] - 
endrec
 [ 5 ] ) - 
endrec
 [ 6 ]

1566 if 
prepended
 < 12 :

1568 
f
 . 
seek
 ( 
prepended
 - 12 )

1570 
tag
 , 
cfglen
 , 
bmlen
 = 
struct
 . 
unpack
 ( "<iii" , 
f
 . 
read
 ( 12 ) )

1571 if 
tag
 not in ( 0x1234567A , 0x1234567B ) :

1574 
f
 . 
seek
 ( 
prepended
 - ( 12 + 
cfglen
 ) )

1575 
init
 = { 'version' : '' , 'target_version' : '' }

1576 
cfg
 = 
configparser
 . 
RawConfigParser
 ( 
init
 )

1578 
part
 = 
f
 . 
read
 ( 
cfglen
 )

1580 
config
 = 
part
 . 
split
 ( b'\0' , 1 ) [ 0 ]

1583 
config
 = 
config
 . 
decode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

1584 
cfg
 . 
readfp
 ( 
six
 . 
StringIO
 ( 
config
 ) )

1585 except 
configparser
 . 
Error
 :

1587 if not 
cfg
 . 
has_section
 ( 'metadata' ) or not 
cfg
 . 
has_section
 ( 'Setup' ) :

1589 return 
cfg

1592 
f
 . 
close
 ( ) 
	}

1595 def 
	$get_exe_prefixes
 ( 
exe_filename
 ) :

1598 
prefixes
 = [

1605 
z
 = 
zipfile
 . 
ZipFile
 ( 
exe_filename
 )

1607 for 
info
 in 
z
 . 
infolist
 ( ) :

1608 
name
 = 
info
 . 
filename

1609 
parts
 = 
name
 . 
split
 ( '/' )

1610 if 
len
 ( 
parts
 ) == 3 and 
parts
 [ 2 ] == 'PKG-INFO' :

1611 if 
parts
 [ 1 ] . 
endswith
 ( '.egg-info' ) :

1612 
prefixes
 . 
insert
 ( 0 , ( '/' . 
join
 ( 
parts
 [ : 2 ] ) , 'EGG-INFO/' ) )

1614 if 
len
 ( 
parts
 ) != 2 or not 
name
 . 
endswith
 ( '.pth' ) :

1616 if 
name
 . 
endswith
 ( '-nspkg.pth' ) :

1618 if 
parts
 [ 0 ] . 
upper
 ( ) in ( 'PURELIB' , 'PLATLIB' ) :

1619 
contents
 = 
z
 . 
read
 ( 
name
 )

1620 if 
six
 . 
PY3
 :

1621 
contents
 = 
contents
 . 
decode
 ( )

1622 for 
pth
 in 
yield_lines
 ( 
contents
 ) :

1623 
pth
 = 
pth
 . 
strip
 ( ) . 
replace
 ( '\\' , '/' )

1624 if not 
pth
 . 
startswith
 ( 'import' ) :

1625 
prefixes
 . 
append
 ( ( ( '%s/%s/' % ( 
parts
 [ 0 ] , 
pth
 ) ) , '' ) )

1627 
z
 . 
close
 ( )

1628 
prefixes
 = [ ( 
x
 . 
lower
 ( ) , 
y
 ) for 
x
 , 
y
 in 
prefixes
 ]

1629 
prefixes
 . 
sort
 ( )

1630 
prefixes
 . 
reverse
 ( )

1631 return 
prefixes
 
	}

1634 class 
	cPthDistributions
 ( 
Environment
 ) :

1637 
dirty
 = False

1639 def 
	$__init__
 ( 
self
 , 
filename
 , 
sitedirs
 = ( ) ) :

1640 
self
 . 
filename
 = 
filename

1641 
self
 . 
sitedirs
 = 
list
 ( 
map
 ( 
normalize_path
 , 
sitedirs
 ) )

1642 
self
 . 
basedir
 = 
normalize_path
 ( 
os
 . 
path
 . 
dirname
 ( 
self
 . 
filename
 ) )

1643 
self
 . 
_load
 ( )

1644 
Environment
 . 
__init__
 ( 
self
 , [ ] , None , None )

1645 for 
path
 in 
yield_lines
 ( 
self
 . 
paths
 ) :

1646 
list
 ( 
map
 ( 
self
 . 
add
 , 
find_distributions
 ( 
path
 , True ) ) ) 
	}

1648 def 
	$_load
 ( 
self
 ) :

1649 
self
 . 
paths
 = [ ]

1650 
saw_import
 = False

1651 
seen
 = 
dict
 . 
fromkeys
 ( 
self
 . 
sitedirs
 )

1652 if 
os
 . 
path
 . 
isfile
 ( 
self
 . 
filename
 ) :

1653 
f
 = 
open
 ( 
self
 . 
filename
 , 'rt' )

1654 for 
line
 in 
f
 :

1655 if 
line
 . 
startswith
 ( 'import' ) :

1656 
saw_import
 = True

1658 
path
 = 
line
 . 
rstrip
 ( )

1659 
self
 . 
paths
 . 
append
 ( 
path
 )

1660 if not 
path
 . 
strip
 ( ) or 
path
 . 
strip
 ( ) . 
startswith
 ( '#' ) :

1664 
path
 = 
self
 . 
paths
 [ - 1 ] = 
normalize_path
 (

1665 
os
 . 
path
 . 
join
 ( 
self
 . 
basedir
 , 
path
 )

1667 if not 
os
 . 
path
 . 
exists
 ( 
path
 ) or 
path
 in 
seen
 :

1668 
self
 . 
paths
 . 
pop
 ( )

1669 
self
 . 
dirty
 = True

1671 
seen
 [ 
path
 ] = 1

1672 
f
 . 
close
 ( )

1674 if 
self
 . 
paths
 and not 
saw_import
 :

1675 
self
 . 
dirty
 = True

1676 while 
self
 . 
paths
 and not 
self
 . 
paths
 [ - 1 ] . 
strip
 ( ) :

1677 
self
 . 
paths
 . 
pop
 ( ) 
	}

1679 def 
	$save
 ( 
self
 ) :

1681 if not 
self
 . 
dirty
 :

1684 
rel_paths
 = 
list
 ( 
map
 ( 
self
 . 
make_relative
 , 
self
 . 
paths
 ) )

1685 if 
rel_paths
 :

1686 
log
 . 
debug
 ( "Saving %s" , 
self
 . 
filename
 )

1687 
lines
 = 
self
 . 
_wrap_lines
 ( 
rel_paths
 )

1688 
data
 = '\n' . 
join
 ( 
lines
 ) + '\n'

1690 if 
os
 . 
path
 . 
islink
 ( 
self
 . 
filename
 ) :

1691 
os
 . 
unlink
 ( 
self
 . 
filename
 )

1692 with 
open
 ( 
self
 . 
filename
 , 'wt' ) as 
f
 :

1693 
f
 . 
write
 ( 
data
 )

1695 elif 
os
 . 
path
 . 
exists
 ( 
self
 . 
filename
 ) :

1696 
log
 . 
debug
 ( "Deleting empty %s" , 
self
 . 
filename
 )

1697 
os
 . 
unlink
 ( 
self
 . 
filename
 )

1699 
self
 . 
dirty
 = False 
	}

1701 @ 
	`staticmethod

1702 def 
	$_wrap_lines
 ( 
lines
 ) :

1703 return 
lines
 
	}

1705 def 
	$add
 ( 
self
 , 
dist
 ) :

1707 
new_path
 = (

1708 
dist
 . 
location
 not in 
self
 . 
paths
 and (

1709 
dist
 . 
location
 not in 
self
 . 
sitedirs
 or

1711 
dist
 . 
location
 == 
os
 . 
getcwd
 ( )

1714 if 
new_path
 :

1715 
self
 . 
paths
 . 
append
 ( 
dist
 . 
location
 )

1716 
self
 . 
dirty
 = True

1717 
Environment
 . 
add
 ( 
self
 , 
dist
 ) 
	}

1719 def 
	$remove
 ( 
self
 , 
dist
 ) :

1721 while 
dist
 . 
location
 in 
self
 . 
paths
 :

1722 
self
 . 
paths
 . 
remove
 ( 
dist
 . 
location
 )

1723 
self
 . 
dirty
 = True

1724 
Environment
 . 
remove
 ( 
self
 , 
dist
 ) 
	}

1726 def 
	$make_relative
 ( 
self
 , 
path
 ) :

1727 
npath
 , 
last
 = 
os
 . 
path
 . 
split
 ( 
normalize_path
 ( 
path
 ) )

1728 
baselen
 = 
len
 ( 
self
 . 
basedir
 )

1729 
parts
 = [ 
last
 ]

1730 
sep
 = 
os
 . 
altsep
 == '/' and '/' or 
os
 . 
sep

1731 while 
len
 ( 
npath
 ) >= 
baselen
 :

1732 if 
npath
 == 
self
 . 
basedir
 :

1733 
parts
 . 
append
 ( 
os
 . 
curdir
 )

1734 
parts
 . 
reverse
 ( )

1735 return 
sep
 . 
join
 ( 
parts
 )

1736 
npath
 , 
last
 = 
os
 . 
path
 . 
split
 ( 
npath
 )

1737 
parts
 . 
append
 ( 
last
 )

1739 return 
path
 
	}

1742 class 
	cRewritePthDistributions
 ( 
PthDistributions
 ) :

1743 @ 
classmethod

1744 def 
	$_wrap_lines
 ( 
cls
 , 
lines
 ) :

1745 yield 
cls
 . 
prelude

1746 for 
line
 in 
lines
 :

1747 yield 
line

1748 yield 
cls
 . 
postlude
 
	}

1750 
prelude
 = 
_one_liner
 ( """\n        import sys\n        sys.__plen = len(sys.path)\n        """

1754 
postlude
 = 
_one_liner
 ( """\n        import sys\n        new = sys.path[sys.__plen:]\n        del sys.path[sys.__plen:]\n        p = getattr(sys, '__egginsert', 0)\n        sys.path[p:p] = new\n        sys.__egginsert = p + len(new)\n        """

1764 if 
os
 . 
environ
 . 
get
 ( 'SETUPTOOLS_SYS_PATH_TECHNIQUE' , 'raw' ) == 'rewrite' :

1765 
PthDistributions
 = 
RewritePthDistributions

1768 def 
	$_first_line_re
 ( ) :

1773 if 
isinstance
 ( 
first_line_re
 . 
pattern
 , 
str
 ) :

1774 return 
first_line_re

1777 return 
re
 . 
compile
 ( 
first_line_re
 . 
pattern
 . 
decode
 ( ) ) 
	}

1780 def 
	$auto_chmod
 ( 
func
 , 
arg
 , 
exc
 ) :

1781 if 
func
 in [ 
os
 . 
unlink
 , 
os
 . 
remove
 ] and 
os
 . 
name
 == 'nt' :

1782 
chmod
 ( 
arg
 , 
stat
 . 
S_IWRITE
 )

1783 return 
func
 ( 
arg
 )

1784 
et
 , 
ev
 , 
_
 = 
sys
 . 
exc_info
 ( )

1785 
six
 . 
reraise
 ( 
et
 , ( 
ev
 [ 0 ] , 
ev
 [ 1 ] + ( " %s %s" % ( 
func
 , 
arg
 ) ) ) ) 
	}

1788 def 
	$update_dist_caches
 ( 
dist_path
 , 
fix_zipimporter_caches
 ) :

1848 
normalized_path
 = 
normalize_path
 ( 
dist_path
 )

1849 
_uncache
 ( 
normalized_path
 , 
sys
 . 
path_importer_cache
 )

1850 if 
fix_zipimporter_caches
 :

1851 
_replace_zip_directory_cache_data
 ( 
normalized_path
 )

1867 
_remove_and_clear_zip_directory_cache_data
 ( 
normalized_path
 ) 
	}

1870 def 
	$_collect_zipimporter_cache_entries
 ( 
normalized_path
 , 
cache
 ) :

1880 
result
 = [ ]

1881 
prefix_len
 = 
len
 ( 
normalized_path
 )

1882 for 
p
 in 
cache
 :

1883 
np
 = 
normalize_path
 ( 
p
 )

1884 if ( 
np
 . 
startswith
 ( 
normalized_path
 ) and

1885 
np
 [ 
prefix_len
 : 
prefix_len
 + 1 ] in ( 
os
 . 
sep
 , '' ) ) :

1886 
result
 . 
append
 ( 
p
 )

1887 return 
result
 
	}

1890 def 
	$_update_zipimporter_cache
 ( 
normalized_path
 , 
cache
 , 
updater
 = None ) :

1905 for 
p
 in 
_collect_zipimporter_cache_entries
 ( 
normalized_path
 , 
cache
 ) :

1915 
old_entry
 = 
cache
 [ 
p
 ]

1916 del 
cache
 [ 
p
 ]

1917 
new_entry
 = 
updater
 and 
updater
 ( 
p
 , 
old_entry
 )

1918 if 
new_entry
 is not None :

1919 
cache
 [ 
p
 ] = 
new_entry
 
	}

1922 def 
	$_uncache
 ( 
normalized_path
 , 
cache
 ) :

1923 
_update_zipimporter_cache
 ( 
normalized_path
 , 
cache
 ) 
	}

1926 def 
	$_remove_and_clear_zip_directory_cache_data
 ( 
normalized_path
 ) :

1927 def 
clear_and_remove_cached_zip_archive_directory_data
 ( 
path
 , 
old_entry
 ) :

1928 
old_entry
 . 
clear
 ( )

1930 
_update_zipimporter_cache
 (

1931 
normalized_path
 , 
zipimport
 . 
_zip_directory_cache
 ,

1932 
updater
 = 
clear_and_remove_cached_zip_archive_directory_data
 ) 
	}

1943 if '__pypy__' in 
sys
 . 
builtin_module_names
 :

1944 
_replace_zip_directory_cache_data
 =

1945 
_remove_and_clear_zip_directory_cache_data

1948 def 
	$_replace_zip_directory_cache_data
 ( 
normalized_path
 ) :

1949 def 
replace_cached_zip_archive_directory_data
 ( 
path
 , 
old_entry
 ) :

1957 
old_entry
 . 
clear
 ( )

1958 
zipimport
 . 
zipimporter
 ( 
path
 )

1959 
old_entry
 . 
update
 ( 
zipimport
 . 
_zip_directory_cache
 [ 
path
 ] )

1960 return 
old_entry

1962 
_update_zipimporter_cache
 (

1963 
normalized_path
 , 
zipimport
 . 
_zip_directory_cache
 ,

1964 
updater
 = 
replace_cached_zip_archive_directory_data
 ) 
	}

1967 def 
	$is_python
 ( 
text
 , 
filename
 = '<string>' ) :

1970 
compile
 ( 
text
 , 
filename
 , 'exec' )

1971 except ( 
SyntaxError
 , 
TypeError
 ) :

1974 return True 
	}

1977 def 
	$is_sh
 ( 
executable
 ) :

1980 with 
io
 . 
open
 ( 
executable
 , 
encoding
 = 'latin-1' ) as 
fp
 :

1981 
magic
 = 
fp
 . 
read
 ( 2 )

1982 except ( 
OSError
 , 
IOError
 ) :

1983 return 
executable

1984 return 
magic
 == '#!' 
	}

1987 def 
	$nt_quote_arg
 ( 
arg
 ) :

1989 return 
subprocess
 . 
list2cmdline
 ( [ 
arg
 ] ) 
	}

1992 def 
	$is_python_script
 ( 
script_text
 , 
filename
 ) :

1995 if 
filename
 . 
endswith
 ( '.py' ) or 
filename
 . 
endswith
 ( '.pyw' ) :

1997 if 
is_python
 ( 
script_text
 , 
filename
 ) :

1999 if 
script_text
 . 
startswith
 ( '#!' ) :

2001 return 'python' in 
script_text
 . 
splitlines
 ( ) [ 0 ] . 
lower
 ( )

2003 return False 
	}

2007 from 
	~os
 import 
chmod
 as 
_chmod

2008 except 
ImportError
 :

2010 def 
	$_chmod
 ( * 
args
 ) :

2011 pass 
	}

2014 def 
	$chmod
 ( 
path
 , 
mode
 ) :

2015 
log
 . 
debug
 ( "changing mode of %s to %o" , 
path
 , 
mode
 )

2017 
_chmod
 ( 
path
 , 
mode
 )

2018 except 
os
 . 
error
 as 
e
 :

2019 
log
 . 
debug
 ( "chmod failed: %s" , 
e
 ) 
	}

2022 class 
	cCommandSpec
 ( 
list
 ) :

2028 
options
 = [ ]

2029 
split_args
 = 
dict
 ( )

2031 @ 
classmethod

2032 def 
	$best
 ( 
cls
 ) :

2036 return 
cls
 
	}

2038 @ 
classmethod

2039 def 
	$_sys_executable
 ( 
cls
 ) :

2040 
_default
 = 
os
 . 
path
 . 
normpath
 ( 
sys
 . 
executable
 )

2041 return 
os
 . 
environ
 . 
get
 ( '__PYVENV_LAUNCHER__' , 
_default
 ) 
	}

2043 @ 
classmethod

2044 def 
	$from_param
 ( 
cls
 , 
param
 ) :

2049 if 
isinstance
 ( 
param
 , 
cls
 ) :

2050 return 
param

2051 if 
isinstance
 ( 
param
 , 
list
 ) :

2052 return 
cls
 ( 
param
 )

2053 if 
param
 is None :

2054 return 
cls
 . 
from_environment
 ( )

2056 return 
cls
 . 
from_string
 ( 
param
 ) 
	}

2058 @ 
classmethod

2059 def 
	$from_environment
 ( 
cls
 ) :

2060 return 
cls
 ( [ 
cls
 . 
_sys_executable
 ( ) ] ) 
	}

2062 @ 
classmethod

2063 def 
	$from_string
 ( 
cls
 , 
string
 ) :

2068 
items
 = 
shlex
 . 
split
 ( 
string
 , ** 
cls
 . 
split_args
 )

2069 return 
cls
 ( 
items
 ) 
	}

2071 def 
	$install_options
 ( 
self
 , 
script_text
 ) :

2072 
self
 . 
options
 = 
shlex
 . 
split
 ( 
self
 . 
_extract_options
 ( 
script_text
 ) )

2073 
cmdline
 = 
subprocess
 . 
list2cmdline
 ( 
self
 )

2074 if not 
isascii
 ( 
cmdline
 ) :

2075 
self
 . 
options
 [ : 0 ] = [ '-x' ] 
	}

2077 @ 
	`staticmethod

2078 def 
	$_extract_options
 ( 
orig_script
 ) :

2082 
first
 = ( 
orig_script
 + '\n' ) . 
splitlines
 ( ) [ 0 ]

2083 
match
 = 
_first_line_re
 ( ) . 
match
 ( 
first
 )

2084 
options
 = 
match
 . 
group
 ( 1 ) or '' if 
match
 else ''

2085 return 
options
 . 
strip
 ( ) 
	}

2087 def 
	$as_header
 ( 
self
 ) :

2088 return 
self
 . 
_render
 ( 
self
 + 
list
 ( 
self
 . 
options
 ) ) 
	}

2090 @ 
	`staticmethod

2091 def 
	$_strip_quotes
 ( 
item
 ) :

2092 
_QUOTES
 = '"\''

2093 for 
q
 in 
_QUOTES
 :

2094 if 
item
 . 
startswith
 ( 
q
 ) and 
item
 . 
endswith
 ( 
q
 ) :

2095 return 
item
 [ 1 : - 1 ]

2096 return 
item
 
	}

2098 @ 
	`staticmethod

2099 def 
	$_render
 ( 
items
 ) :

2100 
cmdline
 = 
subprocess
 . 
list2cmdline
 (

2101 
CommandSpec
 . 
_strip_quotes
 ( 
item
 . 
strip
 ( ) ) for 
item
 in 
items
 )

2102 return '#!' + 
cmdline
 + '\n' 
	}

2106 
sys_executable
 = 
CommandSpec
 . 
_sys_executable
 ( )

2109 class 
	cWindowsCommandSpec
 ( 
CommandSpec
 ) :

2110 
split_args
 = 
dict
 ( 
posix
 = False )

2113 class 
	cScriptWriter
 :

2119 
template
 = 
textwrap
 . 
dedent
 ( r"""\n        # EASY-INSTALL-ENTRY-SCRIPT: %(spec)r,%(group)r,%(name)r\n        __requires__ = %(spec)r\n        import re\n        import sys\n        from pkg_resources import load_entry_point\n\n        if __name__ == '__main__':\n            sys.argv[0] = re.sub(r'(-script\.pyw?|\.exe)?$', '', sys.argv[0])\n            sys.exit(\n                load_entry_point(%(spec)r, %(group)r, %(name)r)()\n            )\n    """

2131 ) . 
lstrip
 ( )

2133 
command_spec_class
 = 
CommandSpec

2135 @ 
classmethod

2136 def 
	$get_script_args
 ( 
cls
 , 
dist
 , 
executable
 = None , 
wininst
 = False ) :

2138 
warnings
 . 
warn
 ( "Use get_args" , 
EasyInstallDeprecationWarning
 )

2139 
writer
 = ( 
WindowsScriptWriter
 if 
wininst
 else 
ScriptWriter
 ) . 
best
 ( )

2140 
header
 = 
cls
 . 
get_script_header
 ( "" , 
executable
 , 
wininst
 )

2141 return 
writer
 . 
get_args
 ( 
dist
 , 
header
 ) 
	}

2143 @ 
classmethod

2144 def 
	$get_script_header
 ( 
cls
 , 
script_text
 , 
executable
 = None , 
wininst
 = False ) :

2146 
warnings
 . 
warn
 ( "Use get_header" , 
EasyInstallDeprecationWarning
 , 
stacklevel
 = 2 )

2147 if 
wininst
 :

2148 
executable
 = "python.exe"

2149 return 
cls
 . 
get_header
 ( 
script_text
 , 
executable
 ) 
	}

2151 @ 
classmethod

2152 def 
	$get_args
 ( 
cls
 , 
dist
 , 
header
 = None ) :

2157 if 
header
 is None :

2158 
header
 = 
cls
 . 
get_header
 ( )

2159 
spec
 = 
str
 ( 
dist
 . 
as_requirement
 ( ) )

2160 for 
type_
 in 'console' , 'gui' :

2161 
group
 = 
type_
 + '_scripts'

2162 for 
name
 , 
ep
 in 
dist
 . 
get_entry_map
 ( 
group
 ) . 
items
 ( ) :

2163 
cls
 . 
_ensure_safe_name
 ( 
name
 )

2164 
script_text
 = 
cls
 . 
template
 % 
locals
 ( )

2165 
args
 = 
cls
 . 
_get_script_args
 ( 
type_
 , 
name
 , 
header
 , 
script_text
 )

2166 for 
res
 in 
args
 :

2167 yield 
res
 
	}

2169 @ 
	`staticmethod

2170 def 
	$_ensure_safe_name
 ( 
name
 ) :

2174 
has_path_sep
 = 
re
 . 
search
 ( r'[\\/]' , 
name
 )

2175 if 
has_path_sep
 :

2176 raise 
ValueError
 ( "Path separators not allowed in script names" ) 
	}

2178 @ 
classmethod

2179 def 
	$get_writer
 ( 
cls
 , 
force_windows
 ) :

2181 
warnings
 . 
warn
 ( "Use best" , 
EasyInstallDeprecationWarning
 )

2182 return 
WindowsScriptWriter
 . 
best
 ( ) if 
force_windows
 else 
cls
 . 
best
 ( ) 
	}

2184 @ 
classmethod

2185 def 
	$best
 ( 
cls
 ) :

2189 if 
sys
 . 
platform
 == 'win32' or ( 
os
 . 
name
 == 'java' and 
os
 . 
_name
 == 'nt' ) :

2190 return 
WindowsScriptWriter
 . 
best
 ( )

2192 return 
cls
 
	}

2194 @ 
classmethod

2195 def 
	$_get_script_args
 ( 
cls
 , 
type_
 , 
name
 , 
header
 , 
script_text
 ) :

2197 yield ( 
name
 , 
header
 + 
script_text
 ) 
	}

2199 @ 
classmethod

2200 def 
	$get_header
 ( 
cls
 , 
script_text
 = "" , 
executable
 = None ) :

2202 
cmd
 = 
cls
 . 
command_spec_class
 . 
best
 ( ) . 
from_param
 ( 
executable
 )

2203 
cmd
 . 
install_options
 ( 
script_text
 )

2204 return 
cmd
 . 
as_header
 ( ) 
	}

2207 class 
	cWindowsScriptWriter
 ( 
ScriptWriter
 ) :

2208 
command_spec_class
 = 
WindowsCommandSpec

2210 @ 
classmethod

2211 def 
	$get_writer
 ( 
cls
 ) :

2213 
warnings
 . 
warn
 ( "Use best" , 
EasyInstallDeprecationWarning
 )

2214 return 
cls
 . 
best
 ( ) 
	}

2216 @ 
classmethod

2217 def 
	$best
 ( 
cls
 ) :

2221 
writer_lookup
 = 
dict
 (

2222 
executable
 = 
WindowsExecutableLauncherWriter
 ,

2223 
natural
 = 
cls
 ,

2226 
launcher
 = 
os
 . 
environ
 . 
get
 ( 'SETUPTOOLS_LAUNCHER' , 'executable' )

2227 return 
writer_lookup
 [ 
launcher
 ] 
	}

2229 @ 
classmethod

2230 def 
	$_get_script_args
 ( 
cls
 , 
type_
 , 
name
 , 
header
 , 
script_text
 ) :

2232 
ext
 = 
dict
 ( 
console
 = '.pya' , 
gui
 = '.pyw' ) [ 
type_
 ]

2233 if 
ext
 not in 
os
 . 
environ
 [ 'PATHEXT' ] . 
lower
 ( ) . 
split
 ( ';' ) :

2234 
msg
 = ( "{ext} not listed in PATHEXT; scripts will not be " "recognized as executables."

2237 ) . 
format
 ( ** 
locals
 ( ) )

2238 
warnings
 . 
warn
 ( 
msg
 , 
UserWarning
 )

2239 
old
 = [ '.pya' , '.py' , '-script.py' , '.pyc' , '.pyo' , '.pyw' , '.exe' ]

2240 
old
 . 
remove
 ( 
ext
 )

2241 
header
 = 
cls
 . 
_adjust_header
 ( 
type_
 , 
header
 )

2242 
blockers
 = [ 
name
 + 
x
 for 
x
 in 
old
 ]

2243 yield 
name
 + 
ext
 , 
header
 + 
script_text
 , 't' , 
blockers
 
	}

2245 @ 
classmethod

2246 def 
	$_adjust_header
 ( 
cls
 , 
type_
 , 
orig_header
 ) :

2251 
pattern
 = 'pythonw.exe'

2252 
repl
 = 'python.exe'

2253 if 
type_
 == 'gui' :

2254 
pattern
 , 
repl
 = 
repl
 , 
pattern

2255 
pattern_ob
 = 
re
 . 
compile
 ( 
re
 . 
escape
 ( 
pattern
 ) , 
re
 . 
IGNORECASE
 )

2256 
new_header
 = 
pattern_ob
 . 
sub
 ( 
string
 = 
orig_header
 , 
repl
 = 
repl
 )

2257 return 
new_header
 if 
cls
 . 
_use_header
 ( 
new_header
 ) else 
orig_header
 
	}

2259 @ 
	`staticmethod

2260 def 
	$_use_header
 ( 
new_header
 ) :

2268 
clean_header
 = 
new_header
 [ 2 : - 1 ] . 
strip
 ( '"' )

2269 return 
sys
 . 
platform
 != 'win32' or 
find_executable
 ( 
clean_header
 ) 
	}

2272 class 
	cWindowsExecutableLauncherWriter
 ( 
WindowsScriptWriter
 ) :

2273 @ 
classmethod

2274 def 
	$_get_script_args
 ( 
cls
 , 
type_
 , 
name
 , 
header
 , 
script_text
 ) :

2278 if 
type_
 == 'gui' :

2279 
launcher_type
 = 'gui'

2280 
ext
 = '-script.pyw'

2281 
old
 = [ '.pyw' ]

2283 
launcher_type
 = 'cli'

2284 
ext
 = '-script.py'

2285 
old
 = [ '.py' , '.pyc' , '.pyo' ]

2286 
hdr
 = 
cls
 . 
_adjust_header
 ( 
type_
 , 
header
 )

2287 
blockers
 = [ 
name
 + 
x
 for 
x
 in 
old
 ]

2288 yield ( 
name
 + 
ext
 , 
hdr
 + 
script_text
 , 't' , 
blockers
 )

2290 
name
 + '.exe' , 
get_win_launcher
 ( 
launcher_type
 ) , 'b'

2293 if not 
is_64bit
 ( ) :

2299 
m_name
 = 
name
 + '.exe.manifest'

2300 yield ( 
m_name
 , 
load_launcher_manifest
 ( 
name
 ) , 't' ) 
	}

2304 
get_script_args
 = 
ScriptWriter
 . 
get_script_args

2305 
get_script_header
 = 
ScriptWriter
 . 
get_script_header

2308 def 
	$get_win_launcher
 ( 
type
 ) :

2316 
launcher_fn
 = '%s.exe' % 
type

2317 if 
is_64bit
 ( ) :

2318 
launcher_fn
 = 
launcher_fn
 . 
replace
 ( "." , "-64." )

2320 
launcher_fn
 = 
launcher_fn
 . 
replace
 ( "." , "-32." )

2321 return 
resource_string
 ( 'setuptools' , 
launcher_fn
 ) 
	}

2324 def 
	$load_launcher_manifest
 ( 
name
 ) :

2325 
manifest
 = 
pkg_resources
 . 
resource_string
 ( 
__name__
 , 'launcher manifest.xml' )

2326 if 
six
 . 
PY2
 :

2327 return 
manifest
 % 
vars
 ( )

2329 return 
manifest
 . 
decode
 ( 'utf-8' ) % 
vars
 ( ) 
	}

2332 def 
	$rmtree
 ( 
path
 , 
ignore_errors
 = False , 
onerror
 = 
auto_chmod
 ) :

2333 return 
shutil
 . 
rmtree
 ( 
path
 , 
ignore_errors
 , 
onerror
 ) 
	}

2336 def 
	$current_umask
 ( ) :

2337 
tmp
 = 
os
 . 
umask
 ( 0o022 )

2338 
os
 . 
umask
 ( 
tmp
 )

2339 return 
tmp
 
	}

2342 def 
	$bootstrap
 ( ) :

2344 import 
	~setuptools

2346 
argv0
 = 
os
 . 
path
 . 
dirname
 ( 
setuptools
 . 
__path__
 [ 0 ] )

2347 
sys
 . 
argv
 [ 0 ] = 
argv0

2348 
sys
 . 
argv
 . 
append
 ( 
argv0
 )

2349 
main
 ( ) 
	}

2352 def 
	$main
 ( 
argv
 = None , ** 
kw
 ) :

2353 from 
	~setuptools
 import 
setup

2354 from 
	~setuptools.dist
 import 
Distribution

2356 class 
	cDistributionWithoutHelpCommands
 ( 
Distribution
 ) :

2357 
common_usage
 = ""

2359 def 
_show_help
 ( 
self
 , * 
args
 , ** 
kw
 ) :

2360 with 
_patch_usage
 ( ) :

2361 
Distribution
 . 
_show_help
 ( 
self
 , * 
args
 , ** 
kw
 )

2363 if 
argv
 is None :

2364 
argv
 = 
sys
 . 
argv
 [ 1 : ]

2366 with 
_patch_usage
 ( ) :

2367 
setup
 (

2368 
script_args
 = [ '-q' , 'easy_install' , '-v' ] + 
argv
 ,

2369 
script_name
 = 
sys
 . 
argv
 [ 0 ] or 'easy_install' ,

2370 
distclass
 = 
DistributionWithoutHelpCommands
 ,

2371 ** 
kw

2372 ) 
	}

2375 @ 
contextlib
 . 
	`contextmanager

2376 def 
	$_patch_usage
 ( ) :

2377 import 
	~distutils.core

2378 
USAGE
 = 
textwrap
 . 
dedent
 ( """\n        usage: %(script)s [options] requirement_or_url ...\n           or: %(script)s --help\n        """

2381 ) . 
lstrip
 ( )

2383 def 
gen_usage
 ( 
script_name
 ) :

2384 return 
USAGE
 % 
dict
 (

2385 
script
 = 
os
 . 
path
 . 
basename
 ( 
script_name
 ) ,

2388 
saved
 = 
distutils
 . 
core
 . 
gen_usage

2389 
distutils
 . 
core
 . 
gen_usage
 = 
gen_usage

2393 
distutils
 . 
core
 . 
gen_usage
 = 
saved
 
	}

2395 class 
	cEasyInstallDeprecationWarning
 ( 
SetuptoolsDeprecationWarning
 ) :


	@./env/lib/python3.7/site-packages/setuptools/command/upload_docs.py

8 from 
	~base64
 import 
standard_b64encode

9 from 
	~distutils
 import 
log

10 from 
	~distutils.errors
 import 
DistutilsOptionError

11 import 
	~os

12 import 
	~socket

13 import 
	~zipfile

14 import 
	~tempfile

15 import 
	~shutil

16 import 
	~itertools

17 import 
	~functools

19 from 
	~setuptools.extern
 import 
six

20 from 
	~setuptools.extern.six.moves
 import 
http_client
 , 
urllib

22 from 
	~pkg_resources
 import 
iter_entry_points

23 from . 
	~upload
 import 
upload

26 def 
	$_encode
 ( 
s
 ) :

27 
errors
 = 'surrogateescape' if 
six
 . 
PY3
 else 'strict'

28 return 
s
 . 
encode
 ( 'utf-8' , 
errors
 ) 
	}

31 class 
	cupload_docs
 ( 
upload
 ) :

34 
DEFAULT_REPOSITORY
 = 'https://pypi.python.org/pypi/'

36 
description
 = 'Upload documentation to PyPI'

38 
user_options
 = [

40 % 
upload
 . 
DEFAULT_REPOSITORY
 ) ,

45 
boolean_options
 = 
upload
 . 
boolean_options

47 def 
	$has_sphinx
 ( 
self
 ) :

48 if 
self
 . 
upload_dir
 is None :

49 for 
ep
 in 
iter_entry_points
 ( 'distutils.commands' , 'build_sphinx' ) :

50 return True 
	}

52 
sub_commands
 = [ ( 'build_sphinx' , 
has_sphinx
 ) ]

54 def 
	$initialize_options
 ( 
self
 ) :

55 
upload
 . 
initialize_options
 ( 
self
 )

56 
self
 . 
upload_dir
 = None

57 
self
 . 
target_dir
 = None 
	}

59 def 
	$finalize_options
 ( 
self
 ) :

60 
upload
 . 
finalize_options
 ( 
self
 )

61 if 
self
 . 
upload_dir
 is None :

62 if 
self
 . 
has_sphinx
 ( ) :

63 
build_sphinx
 = 
self
 . 
get_finalized_command
 ( 'build_sphinx' )

64 
self
 . 
target_dir
 = 
build_sphinx
 . 
builder_target_dir

66 
build
 = 
self
 . 
get_finalized_command
 ( 'build' )

67 
self
 . 
target_dir
 = 
os
 . 
path
 . 
join
 ( 
build
 . 
build_base
 , 'docs' )

69 
self
 . 
ensure_dirname
 ( 'upload_dir' )

70 
self
 . 
target_dir
 = 
self
 . 
upload_dir

71 if 'pypi.python.org' in 
self
 . 
repository
 :

72 
log
 . 
warn
 ( "Upload_docs command is deprecated. Use RTD instead." )

73 
self
 . 
announce
 ( 'Using upload directory %s' % 
self
 . 
target_dir
 ) 
	}

75 def 
	$create_zipfile
 ( 
self
 , 
filename
 ) :

76 
zip_file
 = 
zipfile
 . 
ZipFile
 ( 
filename
 , "w" )

78 
self
 . 
mkpath
 ( 
self
 . 
target_dir
 )

79 for 
root
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
self
 . 
target_dir
 ) :

80 if 
root
 == 
self
 . 
target_dir
 and not 
files
 :

81 
tmpl
 = "no files found in upload directory '%s'"

82 raise 
DistutilsOptionError
 ( 
tmpl
 % 
self
 . 
target_dir
 )

83 for 
name
 in 
files
 :

84 
full
 = 
os
 . 
path
 . 
join
 ( 
root
 , 
name
 )

85 
relative
 = 
root
 [ 
len
 ( 
self
 . 
target_dir
 ) : ] . 
lstrip
 ( 
os
 . 
path
 . 
sep
 )

86 
dest
 = 
os
 . 
path
 . 
join
 ( 
relative
 , 
name
 )

87 
zip_file
 . 
write
 ( 
full
 , 
dest
 )

89 
zip_file
 . 
close
 ( ) 
	}

91 def 
	$run
 ( 
self
 ) :

93 for 
cmd_name
 in 
self
 . 
get_sub_commands
 ( ) :

94 
self
 . 
run_command
 ( 
cmd_name
 )

96 
tmp_dir
 = 
tempfile
 . 
mkdtemp
 ( )

97 
name
 = 
self
 . 
distribution
 . 
metadata
 . 
get_name
 ( )

98 
zip_file
 = 
os
 . 
path
 . 
join
 ( 
tmp_dir
 , "%s.zip" % 
name
 )

100 
self
 . 
create_zipfile
 ( 
zip_file
 )

101 
self
 . 
upload_file
 ( 
zip_file
 )

103 
shutil
 . 
rmtree
 ( 
tmp_dir
 ) 
	}

105 @ 
	`staticmethod

106 def 
	$_build_part
 ( 
item
 , 
sep_boundary
 ) :

107 
key
 , 
values
 = 
item

108 
title
 = '\nContent-Disposition: form-data; name="%s"' % 
key

110 if not 
isinstance
 ( 
values
 , 
list
 ) :

111 
values
 = [ 
values
 ]

112 for 
value
 in 
values
 :

113 if 
isinstance
 ( 
value
 , 
tuple
 ) :

114 
title
 += '; filename="%s"' % 
value
 [ 0 ]

115 
value
 = 
value
 [ 1 ]

117 
value
 = 
_encode
 ( 
value
 )

118 yield 
sep_boundary

119 yield 
_encode
 ( 
title
 )

121 yield 
value

122 if 
value
 and 
value
 [ - 1 : ] == b'\r' :

123 yield b'\n' 
	}

125 @ 
classmethod

126 def 
	$_build_multipart
 ( 
cls
 , 
data
 ) :

130 
boundary
 = b'--------------GHSKFJDLGDS7543FJKLFHRE75642756743254'

131 
sep_boundary
 = b'\n--' + 
boundary

132 
end_boundary
 = 
sep_boundary
 + b'--'

133 
end_items
 = 
end_boundary
 , b"\n" ,

134 
builder
 = 
functools
 . 
partial
 (

135 
cls
 . 
_build_part
 ,

136 
sep_boundary
 = 
sep_boundary
 ,

138 
part_groups
 = 
map
 ( 
builder
 , 
data
 . 
items
 ( ) )

139 
parts
 = 
itertools
 . 
chain
 . 
from_iterable
 ( 
part_groups
 )

140 
body_items
 = 
itertools
 . 
chain
 ( 
parts
 , 
end_items
 )

141 
content_type
 = 'multipart/form-data; boundary=%s' % 
boundary
 . 
decode
 ( 'ascii' )

142 return b'' . 
join
 ( 
body_items
 ) , 
content_type
 
	}

144 def 
	$upload_file
 ( 
self
 , 
filename
 ) :

145 with 
open
 ( 
filename
 , 'rb' ) as 
f
 :

146 
content
 = 
f
 . 
read
 ( )

147 
meta
 = 
self
 . 
distribution
 . 
metadata

148 
data
 = { ':action'

150 : 
meta
 . 
get_name
 ( ) , 'content'

151 : ( 
os
 . 
path
 . 
basename
 ( 
filename
 ) , 
content
 ) ,

154 
credentials
 = 
_encode
 ( 
self
 . 
username
 + ':' + 
self
 . 
password
 )

155 
credentials
 = 
standard_b64encode
 ( 
credentials
 )

156 if 
six
 . 
PY3
 :

157 
credentials
 = 
credentials
 . 
decode
 ( 'ascii' )

158 
auth
 = "Basic " + 
credentials

160 
body
 , 
ct
 = 
self
 . 
_build_multipart
 ( 
data
 )

162 
msg
 = "Submitting documentation to %s" % ( 
self
 . 
repository
 )

163 
self
 . 
announce
 ( 
msg
 , 
log
 . 
INFO
 )

168 
schema
 , 
netloc
 , 
url
 , 
params
 , 
query
 , 
fragments
 =

169 
urllib
 . 
parse
 . 
urlparse
 ( 
self
 . 
repository
 )

170 assert not 
params
 and not 
query
 and not 
fragments

171 if 
schema
 == 'http' :

172 
conn
 = 
http_client
 . 
HTTPConnection
 ( 
netloc
 )

173 elif 
schema
 == 'https' :

174 
conn
 = 
http_client
 . 
HTTPSConnection
 ( 
netloc
 )

176 raise 
AssertionError
 ( "unsupported schema " + 
schema
 )

178 
data
 = ''

180 
conn
 . 
connect
 ( )

181 
conn
 . 
putrequest
 ( "POST" , 
url
 )

182 
content_type
 = 
ct

183 
conn
 . 
putheader
 ( 'Content-type' , 
content_type
 )

184 
conn
 . 
putheader
 ( 'Content-length' , 
str
 ( 
len
 ( 
body
 ) ) )

185 
conn
 . 
putheader
 ( 'Authorization' , 
auth
 )

186 
conn
 . 
endheaders
 ( )

187 
conn
 . 
send
 ( 
body
 )

188 except 
socket
 . 
error
 as 
e
 :

189 
self
 . 
announce
 ( 
str
 ( 
e
 ) , 
log
 . 
ERROR
 )

192 
r
 = 
conn
 . 
getresponse
 ( )

193 if 
r
 . 
status
 == 200 :

194 
msg
 = 'Server response (%s): %s' % ( 
r
 . 
status
 , 
r
 . 
reason
 )

195 
self
 . 
announce
 ( 
msg
 , 
log
 . 
INFO
 )

196 elif 
r
 . 
status
 == 301 :

197 
location
 = 
r
 . 
getheader
 ( 'Location' )

198 if 
location
 is None :

199 
location
 = 'https://pythonhosted.org/%s/' % 
meta
 . 
get_name
 ( )

200 
msg
 = 'Upload successful. Visit %s' % 
location

201 
self
 . 
announce
 ( 
msg
 , 
log
 . 
INFO
 )

203 
msg
 = 'Upload failed (%s): %s' % ( 
r
 . 
status
 , 
r
 . 
reason
 )

204 
self
 . 
announce
 ( 
msg
 , 
log
 . 
ERROR
 )

205 if 
self
 . 
show_response
 :

206 
print
 ( '-' * 75 , 
r
 . 
read
 ( ) , '-' * 75 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/build_py.py

1 from 
	~glob
 import 
glob

2 from 
	~distutils.util
 import 
convert_path

3 import 
	~distutils.command.build_py
 as 
orig

4 import 
	~os

5 import 
	~fnmatch

6 import 
	~textwrap

7 import 
	~io

8 import 
	~distutils.errors

9 import 
	~itertools

11 from 
	~setuptools.extern
 import 
six

12 from 
	~setuptools.extern.six.moves
 import 
map
 , 
filter
 , 
filterfalse

15 from 
	~setuptools.lib2to3_ex
 import 
Mixin2to3

16 except 
ImportError
 :

18 class 
	cMixin2to3
 :

19 def 
	$run_2to3
 ( 
self
 , 
files
 , 
doctests
 = True ) :

20 "do nothing" 
	}

23 class 
	cbuild_py
 ( 
orig
 . 
build_py
 , 
Mixin2to3
 ) :

33 def 
	$finalize_options
 ( 
self
 ) :

34 
orig
 . 
build_py
 . 
finalize_options
 ( 
self
 )

35 
self
 . 
package_data
 = 
self
 . 
distribution
 . 
package_data

36 
self
 . 
exclude_package_data
 = ( 
self
 . 
distribution
 . 
exclude_package_data
 or

38 if 'data_files' in 
self
 . 
__dict__
 :

39 del 
self
 . 
__dict__
 [ 'data_files' ]

40 
self
 . 
__updated_files
 = [ ]

41 
self
 . 
__doctests_2to3
 = [ ] 
	}

43 def 
	$run
 ( 
self
 ) :

45 if not 
self
 . 
py_modules
 and not 
self
 . 
packages
 :

48 if 
self
 . 
py_modules
 :

49 
self
 . 
build_modules
 ( )

51 if 
self
 . 
packages
 :

52 
self
 . 
build_packages
 ( )

53 
self
 . 
build_package_data
 ( )

55 
self
 . 
run_2to3
 ( 
self
 . 
__updated_files
 , False )

56 
self
 . 
run_2to3
 ( 
self
 . 
__updated_files
 , True )

57 
self
 . 
run_2to3
 ( 
self
 . 
__doctests_2to3
 , True )

61 
self
 . 
byte_compile
 ( 
orig
 . 
build_py
 . 
get_outputs
 ( 
self
 , 
include_bytecode
 = 0 ) ) 
	}

63 def 
	$__getattr__
 ( 
self
 , 
attr
 ) :

65 if 
attr
 == 'data_files' :

66 
self
 . 
data_files
 = 
self
 . 
_get_data_files
 ( )

67 return 
self
 . 
data_files

68 return 
orig
 . 
build_py
 . 
__getattr__
 ( 
self
 , 
attr
 ) 
	}

70 def 
	$build_module
 ( 
self
 , 
module
 , 
module_file
 , 
package
 ) :

71 if 
six
 . 
PY2
 and 
isinstance
 ( 
package
 , 
six
 . 
string_types
 ) :

73 
package
 = 
package
 . 
split
 ( '.' )

74 
outfile
 , 
copied
 = 
orig
 . 
build_py
 . 
build_module
 ( 
self
 , 
module
 , 
module_file
 ,

75 
package
 )

76 if 
copied
 :

77 
self
 . 
__updated_files
 . 
append
 ( 
outfile
 )

78 return 
outfile
 , 
copied
 
	}

80 def 
	$_get_data_files
 ( 
self
 ) :

82 
self
 . 
analyze_manifest
 ( )

83 return 
list
 ( 
map
 ( 
self
 . 
_get_pkg_data_files
 , 
self
 . 
packages
 or ( ) ) ) 
	}

85 def 
	$_get_pkg_data_files
 ( 
self
 , 
package
 ) :

87 
src_dir
 = 
self
 . 
get_package_dir
 ( 
package
 )

90 
build_dir
 = 
os
 . 
path
 . 
join
 ( * ( [ 
self
 . 
build_lib
 ] + 
package
 . 
split
 ( '.' ) ) )

93 
filenames
 = [

94 
os
 . 
path
 . 
relpath
 ( 
file
 , 
src_dir
 )

95 for 
file
 in 
self
 . 
find_data_files
 ( 
package
 , 
src_dir
 )

97 return 
package
 , 
src_dir
 , 
build_dir
 , 
filenames
 
	}

99 def 
	$find_data_files
 ( 
self
 , 
package
 , 
src_dir
 ) :

101 
patterns
 = 
self
 . 
_get_platform_patterns
 (

102 
self
 . 
package_data
 ,

103 
package
 ,

104 
src_dir
 ,

106 
globs_expanded
 = 
map
 ( 
glob
 , 
patterns
 )

108 
globs_matches
 = 
itertools
 . 
chain
 . 
from_iterable
 ( 
globs_expanded
 )

109 
glob_files
 = 
filter
 ( 
os
 . 
path
 . 
isfile
 , 
globs_matches
 )

110 
files
 = 
itertools
 . 
chain
 (

111 
self
 . 
manifest_files
 . 
get
 ( 
package
 , [ ] ) ,

112 
glob_files
 ,

114 return 
self
 . 
exclude_data_files
 ( 
package
 , 
src_dir
 , 
files
 ) 
	}

116 def 
	$build_package_data
 ( 
self
 ) :

118 for 
package
 , 
src_dir
 , 
build_dir
 , 
filenames
 in 
self
 . 
data_files
 :

119 for 
filename
 in 
filenames
 :

120 
target
 = 
os
 . 
path
 . 
join
 ( 
build_dir
 , 
filename
 )

121 
self
 . 
mkpath
 ( 
os
 . 
path
 . 
dirname
 ( 
target
 ) )

122 
srcfile
 = 
os
 . 
path
 . 
join
 ( 
src_dir
 , 
filename
 )

123 
outf
 , 
copied
 = 
self
 . 
copy_file
 ( 
srcfile
 , 
target
 )

124 
srcfile
 = 
os
 . 
path
 . 
abspath
 ( 
srcfile
 )

125 if ( 
copied
 and

126 
srcfile
 in 
self
 . 
distribution
 . 
convert_2to3_doctests
 ) :

127 
self
 . 
__doctests_2to3
 . 
append
 ( 
outf
 ) 
	}

129 def 
	$analyze_manifest
 ( 
self
 ) :

130 
self
 . 
manifest_files
 = 
mf
 = { }

131 if not 
self
 . 
distribution
 . 
include_package_data
 :

133 
src_dirs
 = { }

134 for 
package
 in 
self
 . 
packages
 or ( ) :

136 
src_dirs
 [ 
assert_relative
 ( 
self
 . 
get_package_dir
 ( 
package
 ) ) ] = 
package

138 
self
 . 
run_command
 ( 'egg_info' )

139 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( 'egg_info' )

140 for 
path
 in 
ei_cmd
 . 
filelist
 . 
files
 :

141 
d
 , 
f
 = 
os
 . 
path
 . 
split
 ( 
assert_relative
 ( 
path
 ) )

142 
prev
 = None

143 
oldf
 = 
f

144 while 
d
 and 
d
 != 
prev
 and 
d
 not in 
src_dirs
 :

145 
prev
 = 
d

146 
d
 , 
df
 = 
os
 . 
path
 . 
split
 ( 
d
 )

147 
f
 = 
os
 . 
path
 . 
join
 ( 
df
 , 
f
 )

148 if 
d
 in 
src_dirs
 :

149 if 
path
 . 
endswith
 ( '.py' ) and 
f
 == 
oldf
 :

151 
mf
 . 
setdefault
 ( 
src_dirs
 [ 
d
 ] , [ ] ) . 
append
 ( 
path
 ) 
	}

153 def 
	$get_data_files
 ( 
self
 ) :

154 pass 
	}

156 def 
	$check_package
 ( 
self
 , 
package
 , 
package_dir
 ) :

159 return 
self
 . 
packages_checked
 [ 
package
 ]

160 except 
KeyError
 :

163 
init_py
 = 
orig
 . 
build_py
 . 
check_package
 ( 
self
 , 
package
 , 
package_dir
 )

164 
self
 . 
packages_checked
 [ 
package
 ] = 
init_py

166 if not 
init_py
 or not 
self
 . 
distribution
 . 
namespace_packages
 :

167 return 
init_py

169 for 
pkg
 in 
self
 . 
distribution
 . 
namespace_packages
 :

170 if 
pkg
 == 
package
 or 
pkg
 . 
startswith
 ( 
package
 + '.' ) :

173 return 
init_py

175 with 
io
 . 
open
 ( 
init_py
 , 'rb' ) as 
f
 :

176 
contents
 = 
f
 . 
read
 ( )

177 if b'declare_namespace' not in 
contents
 :

178 raise 
distutils
 . 
errors
 . 
DistutilsError
 ( "Namespace package problem: %s is a namespace package, but " "its\n__init__.py does not call declare_namespace()! Please " 'fix it.\n(See the setuptools manual under ' '"Namespace Packages" for details.)\n"'

182 % ( 
package
 , )

184 return 
init_py
 
	}

186 def 
	$initialize_options
 ( 
self
 ) :

187 
self
 . 
packages_checked
 = { }

188 
orig
 . 
build_py
 . 
initialize_options
 ( 
self
 ) 
	}

190 def 
	$get_package_dir
 ( 
self
 , 
package
 ) :

191 
res
 = 
orig
 . 
build_py
 . 
get_package_dir
 ( 
self
 , 
package
 )

192 if 
self
 . 
distribution
 . 
src_root
 is not None :

193 return 
os
 . 
path
 . 
join
 ( 
self
 . 
distribution
 . 
src_root
 , 
res
 )

194 return 
res
 
	}

196 def 
	$exclude_data_files
 ( 
self
 , 
package
 , 
src_dir
 , 
files
 ) :

198 
files
 = 
list
 ( 
files
 )

199 
patterns
 = 
self
 . 
_get_platform_patterns
 (

200 
self
 . 
exclude_package_data
 ,

201 
package
 ,

202 
src_dir
 ,

204 
match_groups
 = (

205 
fnmatch
 . 
filter
 ( 
files
 , 
pattern
 )

206 for 
pattern
 in 
patterns

209 
matches
 = 
itertools
 . 
chain
 . 
from_iterable
 ( 
match_groups
 )

210 
bad
 = 
set
 ( 
matches
 )

211 
keepers
 = (

212 
fn

213 for 
fn
 in 
files

214 if 
fn
 not in 
bad

217 return 
list
 ( 
_unique_everseen
 ( 
keepers
 ) ) 
	}

219 @ 
	`staticmethod

220 def 
	$_get_platform_patterns
 ( 
spec
 , 
package
 , 
src_dir
 ) :

227 
raw_patterns
 = 
itertools
 . 
chain
 (

228 
spec
 . 
get
 ( '' , [ ] ) ,

229 
spec
 . 
get
 ( 
package
 , [ ] ) ,

233 
os
 . 
path
 . 
join
 ( 
src_dir
 , 
convert_path
 ( 
pattern
 ) )

234 for 
pattern
 in 
raw_patterns

235 ) 
	}

239 def 
	$_unique_everseen
 ( 
iterable
 , 
key
 = None ) :

243 
seen
 = 
set
 ( )

244 
seen_add
 = 
seen
 . 
add

245 if 
key
 is None :

246 for 
element
 in 
filterfalse
 ( 
seen
 . 
__contains__
 , 
iterable
 ) :

247 
seen_add
 ( 
element
 )

248 yield 
element

250 for 
element
 in 
iterable
 :

251 
k
 = 
key
 ( 
element
 )

252 if 
k
 not in 
seen
 :

253 
seen_add
 ( 
k
 )

254 yield 
element
 
	}

257 def 
	$assert_relative
 ( 
path
 ) :

258 if not 
os
 . 
path
 . 
isabs
 ( 
path
 ) :

259 return 
path

260 from 
	~distutils.errors
 import 
DistutilsSetupError

262 
msg
 = 
textwrap
 . 
dedent
 ( """\n        Error: setup script specifies an absolute path:\n\n            %s\n\n        setup() arguments must *always* be /-separated paths relative to the\n        setup.py directory, *never* absolute paths.\n        """

269 ) . 
lstrip
 ( ) % 
path

270 raise 
DistutilsSetupError
 ( 
msg
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/dist_info.py

6 import 
	~os

8 from 
	~distutils.core
 import 
Command

9 from 
	~distutils
 import 
log

12 class 
	cdist_info
 ( 
Command
 ) :

14 
description
 = 'create a .dist-info directory'

16 
user_options
 = [

21 def 
	$initialize_options
 ( 
self
 ) :

22 
self
 . 
egg_base
 = None 
	}

24 def 
	$finalize_options
 ( 
self
 ) :

25 pass 
	}

27 def 
	$run
 ( 
self
 ) :

28 
egg_info
 = 
self
 . 
get_finalized_command
 ( 'egg_info' )

29 
egg_info
 . 
egg_base
 = 
self
 . 
egg_base

30 
egg_info
 . 
finalize_options
 ( )

31 
egg_info
 . 
run
 ( )

32 
dist_info_dir
 = 
egg_info
 . 
egg_info
 [ : - 
len
 ( '.egg-info' ) ] + '.dist-info'

33 
log
 . 
info
 ( "creating '{}'" . 
format
 ( 
os
 . 
path
 . 
abspath
 ( 
dist_info_dir
 ) ) )

35 
bdist_wheel
 = 
self
 . 
get_finalized_command
 ( 'bdist_wheel' )

36 
bdist_wheel
 . 
egg2dist
 ( 
egg_info
 . 
egg_info
 , 
dist_info_dir
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/sdist.py

1 from 
	~distutils
 import 
log

2 import 
	~distutils.command.sdist
 as 
orig

3 import 
	~os

4 import 
	~sys

5 import 
	~io

6 import 
	~contextlib

8 from 
	~setuptools.extern
 import 
six

10 from . 
	~py36compat
 import 
sdist_add_defaults

12 import 
	~pkg_resources

14 
_default_revctrl
 = 
list

17 def 
	$walk_revctrl
 ( 
dirname
 = '' ) :

19 for 
ep
 in 
pkg_resources
 . 
iter_entry_points
 ( 'setuptools.file_finders' ) :

20 for 
item
 in 
ep
 . 
load
 ( ) ( 
dirname
 ) :

21 yield 
item
 
	}

24 class 
	csdist
 ( 
sdist_add_defaults
 , 
orig
 . 
sdist
 ) :

27 
user_options
 = [

38 
negative_opt
 = { }

40 
README_EXTENSIONS
 = [ '' , '.rst' , '.txt' , '.md' ]

41 
READMES
 = 
tuple
 ( 'README{0}' . 
format
 ( 
ext
 ) for 
ext
 in 
README_EXTENSIONS
 )

43 def 
	$run
 ( 
self
 ) :

44 
self
 . 
run_command
 ( 'egg_info' )

45 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( 'egg_info' )

46 
self
 . 
filelist
 = 
ei_cmd
 . 
filelist

47 
self
 . 
filelist
 . 
append
 ( 
os
 . 
path
 . 
join
 ( 
ei_cmd
 . 
egg_info
 , 'SOURCES.txt' ) )

48 
self
 . 
check_readme
 ( )

51 for 
cmd_name
 in 
self
 . 
get_sub_commands
 ( ) :

52 
self
 . 
run_command
 ( 
cmd_name
 )

54 
self
 . 
make_distribution
 ( )

56 
dist_files
 = 
getattr
 ( 
self
 . 
distribution
 , 'dist_files' , [ ] )

57 for 
file
 in 
self
 . 
archive_files
 :

58 
data
 = ( 'sdist' , '' , 
file
 )

59 if 
data
 not in 
dist_files
 :

60 
dist_files
 . 
append
 ( 
data
 ) 
	}

62 def 
	$initialize_options
 ( 
self
 ) :

63 
orig
 . 
sdist
 . 
initialize_options
 ( 
self
 )

65 
self
 . 
_default_to_gztar
 ( ) 
	}

67 def 
	$_default_to_gztar
 ( 
self
 ) :

69 if 
sys
 . 
version_info
 >= ( 3 , 6 , 0 , 'beta' , 1 ) :

71 
self
 . 
formats
 = [ 'gztar' ] 
	}

73 def 
	$make_distribution
 ( 
self
 ) :

77 with 
self
 . 
_remove_os_link
 ( ) :

78 
orig
 . 
sdist
 . 
make_distribution
 ( 
self
 ) 
	}

80 @ 
	`staticmethod

81 @ 
contextlib
 . 
	`contextmanager

82 def 
	$_remove_os_link
 ( ) :

87 class 
	cNoValue
 :

90 
orig_val
 = 
getattr
 ( 
os
 , 'link' , 
NoValue
 )

92 del 
os
 . 
link

93 except 
Exception
 :

98 if 
orig_val
 is not 
NoValue
 :

99 
setattr
 ( 
os
 , 'link' , 
orig_val
 ) 
	}

101 def 
	$__read_template_hack
 ( 
self
 ) :

107 
orig
 . 
sdist
 . 
read_template
 ( 
self
 )

108 except 
Exception
 :

109 
_
 , 
_
 , 
tb
 = 
sys
 . 
exc_info
 ( )

110 
tb
 . 
tb_next
 . 
tb_frame
 . 
f_locals
 [ 'template' ] . 
close
 ( )

111 raise 
	}

116 
has_leaky_handle
 = (

117 
sys
 . 
version_info
 < ( 2 , 7 , 2 )

118 or ( 3 , 0 ) <= 
sys
 . 
version_info
 < ( 3 , 1 , 4 )

119 or ( 3 , 2 ) <= 
sys
 . 
version_info
 < ( 3 , 2 , 1 )

121 if 
has_leaky_handle
 :

122 
read_template
 = 
__read_template_hack

124 def 
	$_add_defaults_python
 ( 
self
 ) :

126 if 
self
 . 
distribution
 . 
has_pure_modules
 ( ) :

127 
build_py
 = 
self
 . 
get_finalized_command
 ( 'build_py' )

128 
self
 . 
filelist
 . 
extend
 ( 
build_py
 . 
get_source_files
 ( ) )

133 if not 
self
 . 
distribution
 . 
include_package_data
 :

134 for 
_
 , 
src_dir
 , 
_
 , 
filenames
 in 
build_py
 . 
data_files
 :

135 
self
 . 
filelist
 . 
extend
 ( [ 
os
 . 
path
 . 
join
 ( 
src_dir
 , 
filename
 )

136 for 
filename
 in 
filenames
 ] ) 
	}

138 def 
	$_add_defaults_data_files
 ( 
self
 ) :

140 if 
six
 . 
PY2
 :

141 
sdist_add_defaults
 . 
_add_defaults_data_files
 ( 
self
 )

143 
super
 ( ) . 
_add_defaults_data_files
 ( )

144 except 
TypeError
 :

145 
log
 . 
warn
 ( "data_files contains unexpected objects" ) 
	}

147 def 
	$check_readme
 ( 
self
 ) :

148 for 
f
 in 
self
 . 
READMES
 :

149 if 
os
 . 
path
 . 
exists
 ( 
f
 ) :

152 
self
 . 
warn
 ( "standard file not found: should have one of "

154 . 
join
 ( 
self
 . 
READMES
 )

155 ) 
	}

157 def 
	$make_release_tree
 ( 
self
 , 
base_dir
 , 
files
 ) :

158 
orig
 . 
sdist
 . 
make_release_tree
 ( 
self
 , 
base_dir
 , 
files
 )

161 
dest
 = 
os
 . 
path
 . 
join
 ( 
base_dir
 , 'setup.cfg' )

162 if 
hasattr
 ( 
os
 , 'link' ) and 
os
 . 
path
 . 
exists
 ( 
dest
 ) :

165 
os
 . 
unlink
 ( 
dest
 )

166 
self
 . 
copy_file
 ( 'setup.cfg' , 
dest
 )

168 
self
 . 
get_finalized_command
 ( 'egg_info' ) . 
save_version_info
 ( 
dest
 ) 
	}

170 def 
	$_manifest_is_not_generated
 ( 
self
 ) :

172 if not 
os
 . 
path
 . 
isfile
 ( 
self
 . 
manifest
 ) :

175 with 
io
 . 
open
 ( 
self
 . 
manifest
 , 'rb' ) as 
fp
 :

176 
first_line
 = 
fp
 . 
readline
 ( )

177 return ( 
first_line
 != '# file GENERATED by distutils, do NOT edit\n'

178 . 
encode
 ( ) ) 
	}

180 def 
	$read_manifest
 ( 
self
 ) :

185 
log
 . 
info
 ( "reading manifest file '%s'" , 
self
 . 
manifest
 )

186 
manifest
 = 
open
 ( 
self
 . 
manifest
 , 'rb' )

187 for 
line
 in 
manifest
 :

189 if 
six
 . 
PY3
 :

191 
line
 = 
line
 . 
decode
 ( 'UTF-8' )

192 except 
UnicodeDecodeError
 :

193 
log
 . 
warn
 ( "%r not UTF-8 decodable -- skipping" % 
line
 )

196 
line
 = 
line
 . 
strip
 ( )

197 if 
line
 . 
startswith
 ( '#' ) or not 
line
 :

199 
self
 . 
filelist
 . 
append
 ( 
line
 )

200 
manifest
 . 
close
 ( ) 
	}

202 def 
	$check_license
 ( 
self
 ) :

207 
opts
 = 
self
 . 
distribution
 . 
get_option_dict
 ( 'metadata' )

210 
_
 , 
license_file
 = 
opts
 . 
get
 ( 'license_file' , ( None , None ) )

212 if 
license_file
 is None :

213 
log
 . 
debug
 ( "'license_file' option was not specified" )

216 if not 
os
 . 
path
 . 
exists
 ( 
license_file
 ) :

217 
log
 . 
warn
 ( "warning: Failed to find the configured license file '%s'" ,

218 
license_file
 )

221 
self
 . 
filelist
 . 
append
 ( 
license_file
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/install_scripts.py

1 from 
	~distutils
 import 
log

2 import 
	~distutils.command.install_scripts
 as 
orig

3 import 
	~os

4 import 
	~sys

6 from 
	~pkg_resources
 import 
Distribution
 , 
PathMetadata
 , 
ensure_directory

9 class 
	cinstall_scripts
 ( 
orig
 . 
install_scripts
 ) :

12 def 
	$initialize_options
 ( 
self
 ) :

13 
orig
 . 
install_scripts
 . 
initialize_options
 ( 
self
 )

14 
self
 . 
no_ep
 = False 
	}

16 def 
	$run
 ( 
self
 ) :

17 import 
	~setuptools.command.easy_install
 as 
ei

19 
self
 . 
run_command
 ( "egg_info" )

20 if 
self
 . 
distribution
 . 
scripts
 :

21 
orig
 . 
install_scripts
 . 
run
 ( 
self
 )

23 
self
 . 
outfiles
 = [ ]

24 if 
self
 . 
no_ep
 :

28 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

29 
dist
 = 
Distribution
 (

30 
ei_cmd
 . 
egg_base
 , 
PathMetadata
 ( 
ei_cmd
 . 
egg_base
 , 
ei_cmd
 . 
egg_info
 ) ,

31 
ei_cmd
 . 
egg_name
 , 
ei_cmd
 . 
egg_version
 ,

33 
bs_cmd
 = 
self
 . 
get_finalized_command
 ( 'build_scripts' )

34 
exec_param
 = 
getattr
 ( 
bs_cmd
 , 'executable' , None )

35 
bw_cmd
 = 
self
 . 
get_finalized_command
 ( "bdist_wininst" )

36 
is_wininst
 = 
getattr
 ( 
bw_cmd
 , '_is_running' , False )

37 
writer
 = 
ei
 . 
ScriptWriter

38 if 
is_wininst
 :

39 
exec_param
 = "python.exe"

40 
writer
 = 
ei
 . 
WindowsScriptWriter

41 if 
exec_param
 == 
sys
 . 
executable
 :

44 
exec_param
 = [ 
exec_param
 ]

46 
writer
 = 
writer
 . 
best
 ( )

47 
cmd
 = 
writer
 . 
command_spec_class
 . 
best
 ( ) . 
from_param
 ( 
exec_param
 )

48 for 
args
 in 
writer
 . 
get_args
 ( 
dist
 , 
cmd
 . 
as_header
 ( ) ) :

49 
self
 . 
write_script
 ( * 
args
 ) 
	}

51 def 
	$write_script
 ( 
self
 , 
script_name
 , 
contents
 , 
mode
 = "t" , * 
ignored
 ) :

53 from 
	~setuptools.command.easy_install
 import 
chmod
 , 
current_umask

55 
log
 . 
info
 ( "Installing %s script to %s" , 
script_name
 , 
self
 . 
install_dir
 )

56 
target
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 
script_name
 )

57 
self
 . 
outfiles
 . 
append
 ( 
target
 )

59 
mask
 = 
current_umask
 ( )

60 if not 
self
 . 
dry_run
 :

61 
ensure_directory
 ( 
target
 )

62 
f
 = 
open
 ( 
target
 , "w" + 
mode
 )

63 
f
 . 
write
 ( 
contents
 )

64 
f
 . 
close
 ( )

65 
chmod
 ( 
target
 , 0o777 - 
mask
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/saveopts.py

1 from 
	~setuptools.command.setopt
 import 
edit_config
 , 
option_base

4 class 
	csaveopts
 ( 
option_base
 ) :

7 
description
 = "save supplied options to setup.cfg or other config file"

9 def 
	$run
 ( 
self
 ) :

10 
dist
 = 
self
 . 
distribution

11 
settings
 = { }

13 for 
cmd
 in 
dist
 . 
command_options
 :

15 if 
cmd
 == 'saveopts' :

18 for 
opt
 , ( 
src
 , 
val
 ) in 
dist
 . 
get_option_dict
 ( 
cmd
 ) . 
items
 ( ) :

19 if 
src
 == "command line" :

20 
settings
 . 
setdefault
 ( 
cmd
 , { } ) [ 
opt
 ] = 
val

22 
edit_config
 ( 
self
 . 
filename
 , 
settings
 , 
self
 . 
dry_run
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/install.py

1 from 
	~distutils.errors
 import 
DistutilsArgError

2 import 
	~inspect

3 import 
	~glob

4 import 
	~warnings

5 import 
	~platform

6 import 
	~distutils.command.install
 as 
orig

8 import 
	~setuptools

12 
_install
 = 
orig
 . 
install

15 class 
	cinstall
 ( 
orig
 . 
install
 ) :

18 
user_options
 = 
orig
 . 
install
 . 
user_options
 + [

23 
boolean_options
 = 
orig
 . 
install
 . 
boolean_options
 + [ 'old-and-unmanageable'

26 
new_commands
 = [

27 ( 'install_egg_info' , lambda 
self
 : True ) ,

28 ( 'install_scripts' , lambda 
self
 : True ) ,

30 
_nc
 = 
dict
 ( 
new_commands
 )

32 def 
	$initialize_options
 ( 
self
 ) :

33 
orig
 . 
install
 . 
initialize_options
 ( 
self
 )

34 
self
 . 
old_and_unmanageable
 = None

35 
self
 . 
single_version_externally_managed
 = None 
	}

37 def 
	$finalize_options
 ( 
self
 ) :

38 
orig
 . 
install
 . 
finalize_options
 ( 
self
 )

39 if 
self
 . 
root
 :

40 
self
 . 
single_version_externally_managed
 = True

41 elif 
self
 . 
single_version_externally_managed
 :

42 if not 
self
 . 
root
 and not 
self
 . 
record
 :

43 raise 
DistutilsArgError
 ( "You must specify --record or --root when building system" " packages"

46 ) 
	}

48 def 
	$handle_extra_path
 ( 
self
 ) :

49 if 
self
 . 
root
 or 
self
 . 
single_version_externally_managed
 :

51 return 
orig
 . 
install
 . 
handle_extra_path
 ( 
self
 )

55 
self
 . 
path_file
 = None

56 
self
 . 
extra_dirs
 = '' 
	}

58 def 
	$run
 ( 
self
 ) :

60 if 
self
 . 
old_and_unmanageable
 or 
self
 . 
single_version_externally_managed
 :

61 return 
orig
 . 
install
 . 
run
 ( 
self
 )

63 if not 
self
 . 
_called_from_setup
 ( 
inspect
 . 
currentframe
 ( ) ) :

65 
orig
 . 
install
 . 
run
 ( 
self
 )

67 
self
 . 
do_egg_install
 ( ) 
	}

69 @ 
	`staticmethod

70 def 
	$_called_from_setup
 ( 
run_frame
 ) :

80 if 
run_frame
 is None :

81 
msg
 = "Call stack not available. bdist_* commands may fail."

82 
warnings
 . 
warn
 ( 
msg
 )

83 if 
platform
 . 
python_implementation
 ( ) == 'IronPython' :

84 
msg
 = "For best results, pass -X:Frames to enable call stack."

85 
warnings
 . 
warn
 ( 
msg
 )

87 
res
 = 
inspect
 . 
getouterframes
 ( 
run_frame
 ) [ 2 ]

88 
caller
 , = 
res
 [ : 1 ]

89 
info
 = 
inspect
 . 
getframeinfo
 ( 
caller
 )

90 
caller_module
 = 
caller
 . 
f_globals
 . 
get
 ( '__name__' , '' )

92 
caller_module
 == 'distutils.dist'

93 and 
info
 . 
function
 == 'run_commands'

94 ) 
	}

96 def 
	$do_egg_install
 ( 
self
 ) :

98 
easy_install
 = 
self
 . 
distribution
 . 
get_command_class
 ( 'easy_install' )

100 
cmd
 = 
easy_install
 (

101 
self
 . 
distribution
 , 
args
 = "x" , 
root
 = 
self
 . 
root
 , 
record
 = 
self
 . 
record
 ,

103 
cmd
 . 
ensure_finalized
 ( )

104 
cmd
 . 
always_copy_from
 = '.'

107 
cmd
 . 
package_index
 . 
scan
 ( 
glob
 . 
glob
 ( '*.egg' ) )

109 
self
 . 
run_command
 ( 'bdist_egg' )

110 
args
 = [ 
self
 . 
distribution
 . 
get_command_obj
 ( 'bdist_egg' ) . 
egg_output
 ]

112 if 
setuptools
 . 
bootstrap_install_from
 :

114 
args
 . 
insert
 ( 0 , 
setuptools
 . 
bootstrap_install_from
 )

116 
cmd
 . 
args
 = 
args

117 
cmd
 . 
run
 ( )

118 
setuptools
 . 
bootstrap_install_from
 = None 
	}

122 
install
 . 
sub_commands
 = (

123 [ 
cmd
 for 
cmd
 in 
orig
 . 
install
 . 
sub_commands
 if 
cmd
 [ 0 ] not in 
install
 . 
_nc
 ] +

124 
install
 . 
new_commands


	@./env/lib/python3.7/site-packages/setuptools/command/bdist_wininst.py

1 import 
	~distutils.command.bdist_wininst
 as 
orig

4 class 
	cbdist_wininst
 ( 
orig
 . 
bdist_wininst
 ) :

5 def 
	$reinitialize_command
 ( 
self
 , 
command
 , 
reinit_subcommands
 = 0 ) :

10 
cmd
 = 
self
 . 
distribution
 . 
reinitialize_command
 (

11 
command
 , 
reinit_subcommands
 )

12 if 
command
 in ( 'install' , 'install_lib' ) :

13 
cmd
 . 
install_lib
 = None

14 return 
cmd
 
	}

16 def 
	$run
 ( 
self
 ) :

17 
self
 . 
_is_running
 = True

19 
orig
 . 
bdist_wininst
 . 
run
 ( 
self
 )

21 
self
 . 
_is_running
 = False 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/register.py

1 from 
	~distutils
 import 
log

2 import 
	~distutils.command.register
 as 
orig

5 class 
	cregister
 ( 
orig
 . 
register
 ) :

6 
__doc__
 = 
orig
 . 
register
 . 
__doc__

8 def 
	$run
 ( 
self
 ) :

11 
self
 . 
run_command
 ( 'egg_info' )

12 
orig
 . 
register
 . 
run
 ( 
self
 )

14 
self
 . 
announce
 ( "WARNING: Registering is deprecated, use twine to " "upload instead (https://pypi.org/p/twine/)"

17 
log
 . 
WARN

18 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/__init__.py

1 
__all__
 = [ 'alias'

9 from 
	~distutils.command.bdist
 import 
bdist

10 import 
	~sys

12 from 
	~setuptools.command
 import 
install_scripts

14 if 'egg' not in 
bdist
 . 
format_commands
 :

15 
bdist
 . 
format_command
 [ 'egg' ] = ( 'bdist_egg' , "Python .egg file" )

16 
bdist
 . 
format_commands
 . 
append
 ( 'egg' )

18 del 
bdist
 , 
sys


	@./env/lib/python3.7/site-packages/setuptools/command/develop.py

1 from 
	~distutils.util
 import 
convert_path

2 from 
	~distutils
 import 
log

3 from 
	~distutils.errors
 import 
DistutilsError
 , 
DistutilsOptionError

4 import 
	~os

5 import 
	~glob

6 import 
	~io

8 from 
	~setuptools.extern
 import 
six

10 import 
	~pkg_resources

11 from 
	~setuptools.command.easy_install
 import 
easy_install

12 from 
	~setuptools
 import 
namespaces

13 import 
	~setuptools

15 
__metaclass__
 = 
type

18 class 
	cdevelop
 ( 
namespaces
 . 
DevelopInstaller
 , 
easy_install
 ) :

21 
description
 = "install package in 'development mode'"

23 
user_options
 = 
easy_install
 . 
user_options
 + [

28 
boolean_options
 = 
easy_install
 . 
boolean_options
 + [ 'uninstall' ]

30 
command_consumes_arguments
 = False

32 def 
	$run
 ( 
self
 ) :

33 if 
self
 . 
uninstall
 :

34 
self
 . 
multi_version
 = True

35 
self
 . 
uninstall_link
 ( )

36 
self
 . 
uninstall_namespaces
 ( )

38 
self
 . 
install_for_development
 ( )

39 
self
 . 
warn_deprecated_options
 ( ) 
	}

41 def 
	$initialize_options
 ( 
self
 ) :

42 
self
 . 
uninstall
 = None

43 
self
 . 
egg_path
 = None

44 
easy_install
 . 
initialize_options
 ( 
self
 )

45 
self
 . 
setup_path
 = None

46 
self
 . 
always_copy_from
 = '.' 
	}

48 def 
	$finalize_options
 ( 
self
 ) :

49 
ei
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

50 if 
ei
 . 
broken_egg_info
 :

51 
template
 = "Please rename %r to %r before using 'develop'"

52 
args
 = 
ei
 . 
egg_info
 , 
ei
 . 
broken_egg_info

53 raise 
DistutilsError
 ( 
template
 % 
args
 )

54 
self
 . 
args
 = [ 
ei
 . 
egg_name
 ]

56 
easy_install
 . 
finalize_options
 ( 
self
 )

57 
self
 . 
expand_basedirs
 ( )

58 
self
 . 
expand_dirs
 ( )

60 
self
 . 
package_index
 . 
scan
 ( 
glob
 . 
glob
 ( '*.egg' ) )

62 
egg_link_fn
 = 
ei
 . 
egg_name
 + '.egg-link'

63 
self
 . 
egg_link
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 
egg_link_fn
 )

64 
self
 . 
egg_base
 = 
ei
 . 
egg_base

65 if 
self
 . 
egg_path
 is None :

66 
self
 . 
egg_path
 = 
os
 . 
path
 . 
abspath
 ( 
ei
 . 
egg_base
 )

68 
target
 = 
pkg_resources
 . 
normalize_path
 ( 
self
 . 
egg_base
 )

69 
egg_path
 = 
pkg_resources
 . 
normalize_path
 (

70 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 
self
 . 
egg_path
 ) )

71 if 
egg_path
 != 
target
 :

72 raise 
DistutilsOptionError
 ( "--egg-path must be a relative path from the install" " directory to "

74 + 
target

78 
self
 . 
dist
 = 
pkg_resources
 . 
Distribution
 (

79 
target
 ,

80 
pkg_resources
 . 
PathMetadata
 ( 
target
 , 
os
 . 
path
 . 
abspath
 ( 
ei
 . 
egg_info
 ) ) ,

81 
project_name
 = 
ei
 . 
egg_name

84 
self
 . 
setup_path
 = 
self
 . 
_resolve_setup_path
 (

85 
self
 . 
egg_base
 ,

86 
self
 . 
install_dir
 ,

87 
self
 . 
egg_path
 ,

88 ) 
	}

90 @ 
	`staticmethod

91 def 
	$_resolve_setup_path
 ( 
egg_base
 , 
install_dir
 , 
egg_path
 ) :

97 
path_to_setup
 = 
egg_base
 . 
replace
 ( 
os
 . 
sep
 , '/' ) . 
rstrip
 ( '/' )

98 if 
path_to_setup
 != 
os
 . 
curdir
 :

99 
path_to_setup
 = '../' * ( 
path_to_setup
 . 
count
 ( '/' ) + 1 )

100 
resolved
 = 
pkg_resources
 . 
normalize_path
 (

101 
os
 . 
path
 . 
join
 ( 
install_dir
 , 
egg_path
 , 
path_to_setup
 )

103 if 
resolved
 != 
pkg_resources
 . 
normalize_path
 ( 
os
 . 
curdir
 ) :

104 raise 
DistutilsOptionError
 ( "Can't get a consistent path to setup script from" " installation directory"

106 , 
resolved
 ,

107 
pkg_resources
 . 
normalize_path
 ( 
os
 . 
curdir
 ) )

108 return 
path_to_setup
 
	}

110 def 
	$install_for_development
 ( 
self
 ) :

111 if 
six
 . 
PY3
 and 
getattr
 ( 
self
 . 
distribution
 , 'use_2to3' , False ) :

115 
self
 . 
reinitialize_command
 ( 'build_py' , 
inplace
 = 0 )

116 
self
 . 
run_command
 ( 'build_py' )

117 
bpy_cmd
 = 
self
 . 
get_finalized_command
 ( "build_py" )

118 
build_path
 = 
pkg_resources
 . 
normalize_path
 ( 
bpy_cmd
 . 
build_lib
 )

121 
self
 . 
reinitialize_command
 ( 'egg_info' , 
egg_base
 = 
build_path
 )

122 
self
 . 
run_command
 ( 'egg_info' )

124 
self
 . 
reinitialize_command
 ( 'build_ext' , 
inplace
 = 0 )

125 
self
 . 
run_command
 ( 'build_ext' )

128 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

129 
self
 . 
egg_path
 = 
build_path

130 
self
 . 
dist
 . 
location
 = 
build_path

132 
self
 . 
dist
 . 
_provider
 = 
pkg_resources
 . 
PathMetadata
 (

133 
build_path
 , 
ei_cmd
 . 
egg_info
 )

136 
self
 . 
run_command
 ( 'egg_info' )

139 
self
 . 
reinitialize_command
 ( 'build_ext' , 
inplace
 = 1 )

140 
self
 . 
run_command
 ( 'build_ext' )

142 
self
 . 
install_site_py
 ( )

143 if 
setuptools
 . 
bootstrap_install_from
 :

144 
self
 . 
easy_install
 ( 
setuptools
 . 
bootstrap_install_from
 )

145 
setuptools
 . 
bootstrap_install_from
 = None

147 
self
 . 
install_namespaces
 ( )

150 
log
 . 
info
 ( "Creating %s (link to %s)" , 
self
 . 
egg_link
 , 
self
 . 
egg_base
 )

151 if not 
self
 . 
dry_run
 :

152 with 
open
 ( 
self
 . 
egg_link
 , "w" ) as 
f
 :

153 
f
 . 
write
 ( 
self
 . 
egg_path
 + "\n" + 
self
 . 
setup_path
 )

156 
self
 . 
process_distribution
 ( None , 
self
 . 
dist
 , not 
self
 . 
no_deps
 ) 
	}

158 def 
	$uninstall_link
 ( 
self
 ) :

159 if 
os
 . 
path
 . 
exists
 ( 
self
 . 
egg_link
 ) :

160 
log
 . 
info
 ( "Removing %s (link to %s)" , 
self
 . 
egg_link
 , 
self
 . 
egg_base
 )

161 
egg_link_file
 = 
open
 ( 
self
 . 
egg_link
 )

162 
contents
 = [ 
line
 . 
rstrip
 ( ) for 
line
 in 
egg_link_file
 ]

163 
egg_link_file
 . 
close
 ( )

164 if 
contents
 not in ( [ 
self
 . 
egg_path
 ] ,

165 [ 
self
 . 
egg_path
 , 
self
 . 
setup_path
 ] ) :

166 
log
 . 
warn
 ( "Link points to %s: uninstall aborted" , 
contents
 )

168 if not 
self
 . 
dry_run
 :

169 
os
 . 
unlink
 ( 
self
 . 
egg_link
 )

170 if not 
self
 . 
dry_run
 :

171 
self
 . 
update_pth
 ( 
self
 . 
dist
 )

172 if 
self
 . 
distribution
 . 
scripts
 :

174 
log
 . 
warn
 ( "Note: you must uninstall or replace scripts manually!" ) 
	}

176 def 
	$install_egg_scripts
 ( 
self
 , 
dist
 ) :

177 if 
dist
 is not 
self
 . 
dist
 :

179 return 
easy_install
 . 
install_egg_scripts
 ( 
self
 , 
dist
 )

184 
self
 . 
install_wrapper_scripts
 ( 
dist
 )

187 for 
script_name
 in 
self
 . 
distribution
 . 
scripts
 or [ ] :

188 
script_path
 = 
os
 . 
path
 . 
abspath
 ( 
convert_path
 ( 
script_name
 ) )

189 
script_name
 = 
os
 . 
path
 . 
basename
 ( 
script_path
 )

190 with 
io
 . 
open
 ( 
script_path
 ) as 
strm
 :

191 
script_text
 = 
strm
 . 
read
 ( )

192 
self
 . 
install_script
 ( 
dist
 , 
script_name
 , 
script_text
 , 
script_path
 ) 
	}

194 def 
	$install_wrapper_scripts
 ( 
self
 , 
dist
 ) :

195 
dist
 = 
VersionlessRequirement
 ( 
dist
 )

196 return 
easy_install
 . 
install_wrapper_scripts
 ( 
self
 , 
dist
 ) 
	}

199 class 
	cVersionlessRequirement
 :

214 def 
	$__init__
 ( 
self
 , 
dist
 ) :

215 
self
 . 
__dist
 = 
dist
 
	}

217 def 
	$__getattr__
 ( 
self
 , 
name
 ) :

218 return 
getattr
 ( 
self
 . 
__dist
 , 
name
 ) 
	}

220 def 
	$as_requirement
 ( 
self
 ) :

221 return 
self
 . 
project_name
 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/test.py

1 import 
	~os

2 import 
	~operator

3 import 
	~sys

4 import 
	~contextlib

5 import 
	~itertools

6 import 
	~unittest

7 from 
	~distutils.errors
 import 
DistutilsError
 , 
DistutilsOptionError

8 from 
	~distutils
 import 
log

9 from 
	~unittest
 import 
TestLoader

11 from 
	~setuptools.extern
 import 
six

12 from 
	~setuptools.extern.six.moves
 import 
map
 , 
filter

14 from 
	~pkg_resources
 import ( 
resource_listdir
 , 
resource_exists
 , 
normalize_path
 ,

15 
working_set
 , 
_namespace_packages
 , 
evaluate_marker
 ,

16 
add_activation_listener
 , 
require
 , 
EntryPoint
 )

17 from 
	~setuptools
 import 
Command

19 
__metaclass__
 = 
type

22 class 
	cScanningLoader
 ( 
TestLoader
 ) :

24 def 
	$__init__
 ( 
self
 ) :

25 
TestLoader
 . 
__init__
 ( 
self
 )

26 
self
 . 
_visited
 = 
set
 ( ) 
	}

28 def 
	$loadTestsFromModule
 ( 
self
 , 
module
 , 
pattern
 = None ) :

35 if 
module
 in 
self
 . 
_visited
 :

37 
self
 . 
_visited
 . 
add
 ( 
module
 )

39 
tests
 = [ ]

40 
tests
 . 
append
 ( 
TestLoader
 . 
loadTestsFromModule
 ( 
self
 , 
module
 ) )

42 if 
hasattr
 ( 
module
 , "additional_tests" ) :

43 
tests
 . 
append
 ( 
module
 . 
additional_tests
 ( ) )

45 if 
hasattr
 ( 
module
 , '__path__' ) :

46 for 
file
 in 
resource_listdir
 ( 
module
 . 
__name__
 , '' ) :

47 if 
file
 . 
endswith
 ( '.py' ) and 
file
 != '__init__.py' :

48 
submodule
 = 
module
 . 
__name__
 + '.' + 
file
 [ : - 3 ]

50 if 
resource_exists
 ( 
module
 . 
__name__
 , 
file
 + '/__init__.py' ) :

51 
submodule
 = 
module
 . 
__name__
 + '.' + 
file

54 
tests
 . 
append
 ( 
self
 . 
loadTestsFromName
 ( 
submodule
 ) )

56 if 
len
 ( 
tests
 ) != 1 :

57 return 
self
 . 
suiteClass
 ( 
tests
 )

59 return 
tests
 [ 0 ] 
	}

63 class 
	cNonDataProperty
 :

64 def 
	$__init__
 ( 
self
 , 
fget
 ) :

65 
self
 . 
fget
 = 
fget
 
	}

67 def 
	$__get__
 ( 
self
 , 
obj
 , 
objtype
 = None ) :

68 if 
obj
 is None :

69 return 
self

70 return 
self
 . 
fget
 ( 
obj
 ) 
	}

73 class 
	ctest
 ( 
Command
 ) :

76 
description
 = "run unit tests after in-place build"

78 
user_options
 = [

85 def 
	$initialize_options
 ( 
self
 ) :

86 
self
 . 
test_suite
 = None

87 
self
 . 
test_module
 = None

88 
self
 . 
test_loader
 = None

89 
self
 . 
test_runner
 = None 
	}

91 def 
	$finalize_options
 ( 
self
 ) :

93 if 
self
 . 
test_suite
 and 
self
 . 
test_module
 :

94 
msg
 = "You may specify a module or a suite, but not both"

95 raise 
DistutilsOptionError
 ( 
msg
 )

97 if 
self
 . 
test_suite
 is None :

98 if 
self
 . 
test_module
 is None :

99 
self
 . 
test_suite
 = 
self
 . 
distribution
 . 
test_suite

101 
self
 . 
test_suite
 = 
self
 . 
test_module
 + ".test_suite"

103 if 
self
 . 
test_loader
 is None :

104 
self
 . 
test_loader
 = 
getattr
 ( 
self
 . 
distribution
 , 'test_loader' , None )

105 if 
self
 . 
test_loader
 is None :

106 
self
 . 
test_loader
 = "setuptools.command.test:ScanningLoader"

107 if 
self
 . 
test_runner
 is None :

108 
self
 . 
test_runner
 = 
getattr
 ( 
self
 . 
distribution
 , 'test_runner' , None ) 
	}

110 @ 
	`NonDataProperty

111 def 
	$test_args
 ( 
self
 ) :

112 return 
list
 ( 
self
 . 
_test_args
 ( ) ) 
	}

114 def 
	$_test_args
 ( 
self
 ) :

115 if not 
self
 . 
test_suite
 and 
sys
 . 
version_info
 >= ( 2 , 7 ) :

117 if 
self
 . 
verbose
 :

119 if 
self
 . 
test_suite
 :

120 yield 
self
 . 
test_suite
 
	}

122 def 
	$with_project_on_sys_path
 ( 
self
 , 
func
 ) :

126 with 
self
 . 
project_on_sys_path
 ( ) :

127 
func
 ( ) 
	}

129 @ 
contextlib
 . 
	`contextmanager

130 def 
	$project_on_sys_path
 ( 
self
 , 
include_dists
 = [ ] ) :

131 
with_2to3
 = 
six
 . 
PY3
 and 
getattr
 ( 
self
 . 
distribution
 , 'use_2to3' , False )

133 if 
with_2to3
 :

137 
self
 . 
reinitialize_command
 ( 'build_py' , 
inplace
 = 0 )

138 
self
 . 
run_command
 ( 'build_py' )

139 
bpy_cmd
 = 
self
 . 
get_finalized_command
 ( "build_py" )

140 
build_path
 = 
normalize_path
 ( 
bpy_cmd
 . 
build_lib
 )

143 
self
 . 
reinitialize_command
 ( 'egg_info' , 
egg_base
 = 
build_path
 )

144 
self
 . 
run_command
 ( 'egg_info' )

146 
self
 . 
reinitialize_command
 ( 'build_ext' , 
inplace
 = 0 )

147 
self
 . 
run_command
 ( 'build_ext' )

150 
self
 . 
run_command
 ( 'egg_info' )

153 
self
 . 
reinitialize_command
 ( 'build_ext' , 
inplace
 = 1 )

154 
self
 . 
run_command
 ( 'build_ext' )

156 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

158 
old_path
 = 
sys
 . 
path
 [ : ]

159 
old_modules
 = 
sys
 . 
modules
 . 
copy
 ( )

162 
project_path
 = 
normalize_path
 ( 
ei_cmd
 . 
egg_base
 )

163 
sys
 . 
path
 . 
insert
 ( 0 , 
project_path
 )

164 
working_set
 . 
__init__
 ( )

165 
add_activation_listener
 ( lambda 
dist
 : 
dist
 . 
activate
 ( ) )

166 
require
 ( '%s==%s' % ( 
ei_cmd
 . 
egg_name
 , 
ei_cmd
 . 
egg_version
 ) )

167 with 
self
 . 
paths_on_pythonpath
 ( [ 
project_path
 ] ) :

170 
sys
 . 
path
 [ : ] = 
old_path

171 
sys
 . 
modules
 . 
clear
 ( )

172 
sys
 . 
modules
 . 
update
 ( 
old_modules
 )

173 
working_set
 . 
__init__
 ( ) 
	}

175 @ 
	`staticmethod

176 @ 
contextlib
 . 
	`contextmanager

177 def 
	$paths_on_pythonpath
 ( 
paths
 ) :

185 
nothing
 = 
object
 ( )

186 
orig_pythonpath
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , 
nothing
 )

187 
current_pythonpath
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , '' )

189 
prefix
 = 
os
 . 
pathsep
 . 
join
 ( 
paths
 )

190 
to_join
 = 
filter
 ( None , [ 
prefix
 , 
current_pythonpath
 ] )

191 
new_path
 = 
os
 . 
pathsep
 . 
join
 ( 
to_join
 )

192 if 
new_path
 :

193 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
new_path

196 if 
orig_pythonpath
 is 
nothing
 :

197 
os
 . 
environ
 . 
pop
 ( 'PYTHONPATH' , None )

199 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
orig_pythonpath
 
	}

201 @ 
	`staticmethod

202 def 
	$install_dists
 ( 
dist
 ) :

207 
ir_d
 = 
dist
 . 
fetch_build_eggs
 ( 
dist
 . 
install_requires
 )

208 
tr_d
 = 
dist
 . 
fetch_build_eggs
 ( 
dist
 . 
tests_require
 or [ ] )

209 
er_d
 = 
dist
 . 
fetch_build_eggs
 (

210 
v
 for 
k
 , 
v
 in 
dist
 . 
extras_require
 . 
items
 ( )

211 if 
k
 . 
startswith
 ( ':' ) and 
evaluate_marker
 ( 
k
 [ 1 : ] )

213 return 
itertools
 . 
chain
 ( 
ir_d
 , 
tr_d
 , 
er_d
 ) 
	}

215 def 
	$run
 ( 
self
 ) :

216 
installed_dists
 = 
self
 . 
install_dists
 ( 
self
 . 
distribution
 )

218 
cmd
 = ' ' . 
join
 ( 
self
 . 
_argv
 )

219 if 
self
 . 
dry_run
 :

220 
self
 . 
announce
 ( 'skipping "%s" (dry run)' % 
cmd
 )

223 
self
 . 
announce
 ( 'running "%s"' % 
cmd
 )

225 
paths
 = 
map
 ( 
operator
 . 
attrgetter
 ( 'location' ) , 
installed_dists
 )

226 with 
self
 . 
paths_on_pythonpath
 ( 
paths
 ) :

227 with 
self
 . 
project_on_sys_path
 ( ) :

228 
self
 . 
run_tests
 ( ) 
	}

230 def 
	$run_tests
 ( 
self
 ) :

234 if 
six
 . 
PY3
 and 
getattr
 ( 
self
 . 
distribution
 , 'use_2to3' , False ) :

235 
module
 = 
self
 . 
test_suite
 . 
split
 ( '.' ) [ 0 ]

236 if 
module
 in 
_namespace_packages
 :

237 
del_modules
 = [ ]

238 if 
module
 in 
sys
 . 
modules
 :

239 
del_modules
 . 
append
 ( 
module
 )

240 
module
 += '.'

241 for 
name
 in 
sys
 . 
modules
 :

242 if 
name
 . 
startswith
 ( 
module
 ) :

243 
del_modules
 . 
append
 ( 
name
 )

244 
list
 ( 
map
 ( 
sys
 . 
modules
 . 
__delitem__
 , 
del_modules
 ) )

246 
test
 = 
unittest
 . 
main
 (

247 None , None , 
self
 . 
_argv
 ,

248 
testLoader
 = 
self
 . 
_resolve_as_ep
 ( 
self
 . 
test_loader
 ) ,

249 
testRunner
 = 
self
 . 
_resolve_as_ep
 ( 
self
 . 
test_runner
 ) ,

250 
exit
 = False ,

252 if not 
test
 . 
result
 . 
wasSuccessful
 ( ) :

253 
msg
 = 'Test failed: %s' % 
test
 . 
result

254 
self
 . 
announce
 ( 
msg
 , 
log
 . 
ERROR
 )

255 raise 
DistutilsError
 ( 
msg
 ) 
	}

257 @ 
property

258 def 
	$_argv
 ( 
self
 ) :

259 return [ 'unittest' ] + 
self
 . 
test_args
 
	}

261 @ 
	`staticmethod

262 def 
	$_resolve_as_ep
 ( 
val
 ) :

267 if 
val
 is None :

269 
parsed
 = 
EntryPoint
 . 
parse
 ( "x=" + 
val
 )

270 return 
parsed
 . 
resolve
 ( ) ( ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/install_lib.py

1 import 
	~os

2 import 
	~sys

3 import 
	~imp

4 from 
	~itertools
 import 
product
 , 
starmap

5 import 
	~distutils.command.install_lib
 as 
orig

8 class 
	cinstall_lib
 ( 
orig
 . 
install_lib
 ) :

11 def 
	$initialize_options
 ( 
self
 ) :

12 
orig
 . 
install_lib
 . 
initialize_options
 ( 
self
 )

13 
self
 . 
multiarch
 = None

14 
self
 . 
install_layout
 = None 
	}

16 def 
	$finalize_options
 ( 
self
 ) :

17 
orig
 . 
install_lib
 . 
finalize_options
 ( 
self
 )

18 
self
 . 
set_undefined_options
 ( 'install' , ( 'install_layout' , 'install_layout' ) )

19 if 
self
 . 
install_layout
 == 'deb' and 
sys
 . 
version_info
 [ : 2 ] >= ( 3 , 3 ) :

20 import 
	~sysconfig

21 
self
 . 
multiarch
 = 
sysconfig
 . 
get_config_var
 ( 'MULTIARCH' ) 
	}

23 def 
	$run
 ( 
self
 ) :

24 
self
 . 
build
 ( )

25 
outfiles
 = 
self
 . 
install
 ( )

26 if 
outfiles
 is not None :

28 
self
 . 
byte_compile
 ( 
outfiles
 ) 
	}

30 def 
	$get_exclusions
 ( 
self
 ) :

35 
all_packages
 = (

36 
pkg

37 for 
ns_pkg
 in 
self
 . 
_get_SVEM_NSPs
 ( )

38 for 
pkg
 in 
self
 . 
_all_packages
 ( 
ns_pkg
 )

41 
excl_specs
 = 
product
 ( 
all_packages
 , 
self
 . 
_gen_exclusion_paths
 ( ) )

42 return 
set
 ( 
starmap
 ( 
self
 . 
_exclude_pkg_path
 , 
excl_specs
 ) ) 
	}

44 def 
	$_exclude_pkg_path
 ( 
self
 , 
pkg
 , 
exclusion_path
 ) :

49 
parts
 = 
pkg
 . 
split
 ( '.' ) + [ 
exclusion_path
 ]

50 return 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , * 
parts
 ) 
	}

52 @ 
	`staticmethod

53 def 
	$_all_packages
 ( 
pkg_name
 ) :

58 while 
pkg_name
 :

59 yield 
pkg_name

60 
pkg_name
 , 
sep
 , 
child
 = 
pkg_name
 . 
rpartition
 ( '.' ) 
	}

62 def 
	$_get_SVEM_NSPs
 ( 
self
 ) :

70 if not 
self
 . 
distribution
 . 
namespace_packages
 :

73 
install_cmd
 = 
self
 . 
get_finalized_command
 ( 'install' )

74 
svem
 = 
install_cmd
 . 
single_version_externally_managed

76 return 
self
 . 
distribution
 . 
namespace_packages
 if 
svem
 else [ ] 
	}

78 @ 
	`staticmethod

79 def 
	$_gen_exclusion_paths
 ( ) :

90 if not 
hasattr
 ( 
imp
 , 'get_tag' ) :

93 
base
 = 
os
 . 
path
 . 
join
 ( '__pycache__' , '__init__.' + 
imp
 . 
get_tag
 ( ) )

94 yield 
base
 + '.pyc'

95 yield 
base
 + '.pyo'

96 yield 
base
 + '.opt-1.pyc'

97 yield 
base
 + '.opt-2.pyc' 
	}

99 def 
	$copy_tree
 (

100 
self
 , 
infile
 , 
outfile
 ,

101 
preserve_mode
 = 1 , 
preserve_times
 = 1 , 
preserve_symlinks
 = 0 , 
level
 = 1

103 assert 
preserve_mode
 and 
preserve_times
 and not 
preserve_symlinks

104 
exclude
 = 
self
 . 
get_exclusions
 ( )

106 if not 
exclude
 :

107 import 
	~distutils.dir_util

108 
distutils
 . 
dir_util
 . 
_multiarch
 = 
self
 . 
multiarch

109 return 
orig
 . 
install_lib
 . 
copy_tree
 ( 
self
 , 
infile
 , 
outfile
 )

113 from 
	~setuptools.archive_util
 import 
unpack_directory

114 from 
	~distutils
 import 
log

116 
outfiles
 = [ ]

118 if 
self
 . 
multiarch
 :

119 import 
	~sysconfig

120 
ext_suffix
 = 
sysconfig
 . 
get_config_var
 ( 'EXT_SUFFIX' )

121 if 
ext_suffix
 . 
endswith
 ( 
self
 . 
multiarch
 + 
ext_suffix
 [ - 3 : ] ) :

122 
new_suffix
 = None

124 
new_suffix
 = "%s-%s%s" % ( 
ext_suffix
 [ : - 3 ] , 
self
 . 
multiarch
 , 
ext_suffix
 [ - 3 : ] )

126 def 
pf
 ( 
src
 , 
dst
 ) :

127 if 
dst
 in 
exclude
 :

128 
log
 . 
warn
 ( "Skipping installation of %s (namespace package)" ,

129 
dst
 )

132 if 
self
 . 
multiarch
 and 
new_suffix
 and 
dst
 . 
endswith
 ( 
ext_suffix
 ) and not 
dst
 . 
endswith
 ( 
new_suffix
 ) :

133 
dst
 = 
dst
 . 
replace
 ( 
ext_suffix
 , 
new_suffix
 )

134 
log
 . 
info
 ( "renaming extension to %s" , 
os
 . 
path
 . 
basename
 ( 
dst
 ) )

136 
log
 . 
info
 ( "copying %s -> %s" , 
src
 , 
os
 . 
path
 . 
dirname
 ( 
dst
 ) )

137 
outfiles
 . 
append
 ( 
dst
 )

138 return 
dst

140 
unpack_directory
 ( 
infile
 , 
outfile
 , 
pf
 )

141 return 
outfiles
 
	}

143 def 
	$get_outputs
 ( 
self
 ) :

144 
outputs
 = 
orig
 . 
install_lib
 . 
get_outputs
 ( 
self
 )

145 
exclude
 = 
self
 . 
get_exclusions
 ( )

146 if 
exclude
 :

147 return [ 
f
 for 
f
 in 
outputs
 if 
f
 not in 
exclude
 ]

148 return 
outputs
 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/build_ext.py

1 import 
	~os

2 import 
	~sys

3 import 
	~itertools

4 import 
	~imp

5 from 
	~distutils.command.build_ext
 import 
build_ext
 as 
_du_build_ext

6 from 
	~distutils.file_util
 import 
copy_file

7 from 
	~distutils.ccompiler
 import 
new_compiler

8 from 
	~distutils.sysconfig
 import 
customize_compiler
 , 
get_config_var

9 from 
	~distutils.errors
 import 
DistutilsError

10 from 
	~distutils
 import 
log

12 from 
	~setuptools.extension
 import 
Library

13 from 
	~setuptools.extern
 import 
six

17 from 
	~Cython.Distutils.build_ext
 import 
build_ext
 as 
_build_ext

20 
__import__
 ( 'Cython.Compiler.Main' )

21 except 
ImportError
 :

22 
_build_ext
 = 
_du_build_ext

25 
get_config_var
 ( "LDSHARED" )

26 from 
	~distutils.sysconfig
 import 
_config_vars
 as 
_CONFIG_VARS

29 def 
	$_customize_compiler_for_shlib
 ( 
compiler
 ) :

30 if 
sys
 . 
platform
 == "darwin" :

34 
tmp
 = 
_CONFIG_VARS
 . 
copy
 ( )

37 
_CONFIG_VARS
 [ 'LDSHARED' ] = ( "gcc -Wl,-x -dynamiclib -undefined dynamic_lookup"

39 
_CONFIG_VARS
 [ 'CCSHARED' ] = " -dynamiclib"

40 
_CONFIG_VARS
 [ 'SO' ] = ".dylib"

41 
customize_compiler
 ( 
compiler
 )

43 
_CONFIG_VARS
 . 
clear
 ( )

44 
_CONFIG_VARS
 . 
update
 ( 
tmp
 )

46 
customize_compiler
 ( 
compiler
 ) 
	}

49 
have_rtld
 = False

50 
use_stubs
 = False

51 
libtype
 = 'shared'

53 if 
sys
 . 
platform
 == "darwin" :

54 
use_stubs
 = True

55 elif 
os
 . 
name
 != 'nt' :

57 import 
	~dl

58 
use_stubs
 = 
have_rtld
 = 
hasattr
 ( 
dl
 , 'RTLD_NOW' )

59 except 
ImportError
 :

62 
if_dl
 = lambda 
s
 : 
s
 if 
have_rtld
 else ''

65 def 
	$get_abi3_suffix
 ( ) :

67 for 
suffix
 , 
_
 , 
_
 in ( 
s
 for 
s
 in 
imp
 . 
get_suffixes
 ( ) if 
s
 [ 2 ] == 
imp
 . 
C_EXTENSION
 ) :

68 if '.abi3' in 
suffix
 :

69 return 
suffix

70 elif 
suffix
 == '.pyd' :

71 return 
suffix
 
	}

74 class 
	cbuild_ext
 ( 
_build_ext
 ) :

75 def 
	$run
 ( 
self
 ) :

77 
old_inplace
 , 
self
 . 
inplace
 = 
self
 . 
inplace
 , 0

78 
_build_ext
 . 
run
 ( 
self
 )

79 
self
 . 
inplace
 = 
old_inplace

80 if 
old_inplace
 :

81 
self
 . 
copy_extensions_to_source
 ( ) 
	}

83 def 
	$copy_extensions_to_source
 ( 
self
 ) :

84 
build_py
 = 
self
 . 
get_finalized_command
 ( 'build_py' )

85 for 
ext
 in 
self
 . 
extensions
 :

86 
fullname
 = 
self
 . 
get_ext_fullname
 ( 
ext
 . 
name
 )

87 
filename
 = 
self
 . 
get_ext_filename
 ( 
fullname
 )

88 
modpath
 = 
fullname
 . 
split
 ( '.' )

89 
package
 = '.' . 
join
 ( 
modpath
 [ : - 1 ] )

90 
package_dir
 = 
build_py
 . 
get_package_dir
 ( 
package
 )

91 
dest_filename
 = 
os
 . 
path
 . 
join
 ( 
package_dir
 ,

92 
os
 . 
path
 . 
basename
 ( 
filename
 ) )

93 
src_filename
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
build_lib
 , 
filename
 )

98 
copy_file
 (

99 
src_filename
 , 
dest_filename
 , 
verbose
 = 
self
 . 
verbose
 ,

100 
dry_run
 = 
self
 . 
dry_run

102 if 
ext
 . 
_needs_stub
 :

103 
self
 . 
write_stub
 ( 
package_dir
 or 
os
 . 
curdir
 , 
ext
 , True ) 
	}

105 def 
	$get_ext_filename
 ( 
self
 , 
fullname
 ) :

106 
filename
 = 
_build_ext
 . 
get_ext_filename
 ( 
self
 , 
fullname
 )

107 if 
fullname
 in 
self
 . 
ext_map
 :

108 
ext
 = 
self
 . 
ext_map
 [ 
fullname
 ]

109 
use_abi3
 = (

110 
six
 . 
PY3

111 and 
getattr
 ( 
ext
 , 'py_limited_api' )

112 and 
get_abi3_suffix
 ( )

114 if 
use_abi3
 :

115 
so_ext
 = 
get_config_var
 ( 'EXT_SUFFIX' )

116 
filename
 = 
filename
 [ : - 
len
 ( 
so_ext
 ) ]

117 
filename
 = 
filename
 + 
get_abi3_suffix
 ( )

118 if 
isinstance
 ( 
ext
 , 
Library
 ) :

119 
fn
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
filename
 )

120 return 
self
 . 
shlib_compiler
 . 
library_filename
 ( 
fn
 , 
libtype
 )

121 elif 
use_stubs
 and 
ext
 . 
_links_to_dynamic
 :

122 
d
 , 
fn
 = 
os
 . 
path
 . 
split
 ( 
filename
 )

123 return 
os
 . 
path
 . 
join
 ( 
d
 , 'dl-' + 
fn
 )

124 return 
filename
 
	}

126 def 
	$initialize_options
 ( 
self
 ) :

127 
_build_ext
 . 
initialize_options
 ( 
self
 )

128 
self
 . 
shlib_compiler
 = None

129 
self
 . 
shlibs
 = [ ]

130 
self
 . 
ext_map
 = { } 
	}

132 def 
	$finalize_options
 ( 
self
 ) :

133 
_build_ext
 . 
finalize_options
 ( 
self
 )

134 
self
 . 
extensions
 = 
self
 . 
extensions
 or [ ]

135 
self
 . 
check_extensions_list
 ( 
self
 . 
extensions
 )

136 
self
 . 
shlibs
 = [ 
ext
 for 
ext
 in 
self
 . 
extensions

137 if 
isinstance
 ( 
ext
 , 
Library
 ) ]

138 if 
self
 . 
shlibs
 :

139 
self
 . 
setup_shlib_compiler
 ( )

140 for 
ext
 in 
self
 . 
extensions
 :

141 
ext
 . 
_full_name
 = 
self
 . 
get_ext_fullname
 ( 
ext
 . 
name
 )

142 for 
ext
 in 
self
 . 
extensions
 :

143 
fullname
 = 
ext
 . 
_full_name

144 
self
 . 
ext_map
 [ 
fullname
 ] = 
ext

148 
self
 . 
ext_map
 [ 
fullname
 . 
split
 ( '.' ) [ - 1 ] ] = 
ext

150 
ltd
 = 
self
 . 
shlibs
 and 
self
 . 
links_to_dynamic
 ( 
ext
 ) or False

151 
ns
 = 
ltd
 and 
use_stubs
 and not 
isinstance
 ( 
ext
 , 
Library
 )

152 
ext
 . 
_links_to_dynamic
 = 
ltd

153 
ext
 . 
_needs_stub
 = 
ns

154 
filename
 = 
ext
 . 
_file_name
 = 
self
 . 
get_ext_filename
 ( 
fullname
 )

155 
libdir
 = 
os
 . 
path
 . 
dirname
 ( 
os
 . 
path
 . 
join
 ( 
self
 . 
build_lib
 , 
filename
 ) )

156 if 
ltd
 and 
libdir
 not in 
ext
 . 
library_dirs
 :

157 
ext
 . 
library_dirs
 . 
append
 ( 
libdir
 )

158 if 
ltd
 and 
use_stubs
 and 
os
 . 
curdir
 not in 
ext
 . 
runtime_library_dirs
 :

159 
ext
 . 
runtime_library_dirs
 . 
append
 ( 
os
 . 
curdir
 ) 
	}

161 def 
	$setup_shlib_compiler
 ( 
self
 ) :

162 
compiler
 = 
self
 . 
shlib_compiler
 = 
new_compiler
 (

163 
compiler
 = 
self
 . 
compiler
 , 
dry_run
 = 
self
 . 
dry_run
 , 
force
 = 
self
 . 
force

165 
_customize_compiler_for_shlib
 ( 
compiler
 )

167 if 
self
 . 
include_dirs
 is not None :

168 
compiler
 . 
set_include_dirs
 ( 
self
 . 
include_dirs
 )

169 if 
self
 . 
define
 is not None :

171 for ( 
name
 , 
value
 ) in 
self
 . 
define
 :

172 
compiler
 . 
define_macro
 ( 
name
 , 
value
 )

173 if 
self
 . 
undef
 is not None :

174 for 
macro
 in 
self
 . 
undef
 :

175 
compiler
 . 
undefine_macro
 ( 
macro
 )

176 if 
self
 . 
libraries
 is not None :

177 
compiler
 . 
set_libraries
 ( 
self
 . 
libraries
 )

178 if 
self
 . 
library_dirs
 is not None :

179 
compiler
 . 
set_library_dirs
 ( 
self
 . 
library_dirs
 )

180 if 
self
 . 
rpath
 is not None :

181 
compiler
 . 
set_runtime_library_dirs
 ( 
self
 . 
rpath
 )

182 if 
self
 . 
link_objects
 is not None :

183 
compiler
 . 
set_link_objects
 ( 
self
 . 
link_objects
 )

186 
compiler
 . 
link_shared_object
 = 
link_shared_object
 . 
__get__
 ( 
compiler
 ) 
	}

188 def 
	$get_export_symbols
 ( 
self
 , 
ext
 ) :

189 if 
isinstance
 ( 
ext
 , 
Library
 ) :

190 return 
ext
 . 
export_symbols

191 return 
_build_ext
 . 
get_export_symbols
 ( 
self
 , 
ext
 ) 
	}

193 def 
	$build_extension
 ( 
self
 , 
ext
 ) :

194 
ext
 . 
_convert_pyx_sources_to_lang
 ( )

195 
_compiler
 = 
self
 . 
compiler

197 if 
isinstance
 ( 
ext
 , 
Library
 ) :

198 
self
 . 
compiler
 = 
self
 . 
shlib_compiler

199 
_build_ext
 . 
build_extension
 ( 
self
 , 
ext
 )

200 if 
ext
 . 
_needs_stub
 :

201 
cmd
 = 
self
 . 
get_finalized_command
 ( 'build_py' ) . 
build_lib

202 
self
 . 
write_stub
 ( 
cmd
 , 
ext
 )

204 
self
 . 
compiler
 = 
_compiler
 
	}

206 def 
	$links_to_dynamic
 ( 
self
 , 
ext
 ) :

211 
libnames
 = 
dict
 . 
fromkeys
 ( [ 
lib
 . 
_full_name
 for 
lib
 in 
self
 . 
shlibs
 ] )

212 
pkg
 = '.' . 
join
 ( 
ext
 . 
_full_name
 . 
split
 ( '.' ) [ : - 1 ] + [ '' ] )

213 return 
any
 ( 
pkg
 + 
libname
 in 
libnames
 for 
libname
 in 
ext
 . 
libraries
 ) 
	}

215 def 
	$get_outputs
 ( 
self
 ) :

216 return 
_build_ext
 . 
get_outputs
 ( 
self
 ) + 
self
 . 
__get_stubs_outputs
 ( ) 
	}

218 def 
	$__get_stubs_outputs
 ( 
self
 ) :

220 
ns_ext_bases
 = (

221 
os
 . 
path
 . 
join
 ( 
self
 . 
build_lib
 , * 
ext
 . 
_full_name
 . 
split
 ( '.' ) )

222 for 
ext
 in 
self
 . 
extensions

223 if 
ext
 . 
_needs_stub

226 
pairs
 = 
itertools
 . 
product
 ( 
ns_ext_bases
 , 
self
 . 
__get_output_extensions
 ( ) )

227 return 
list
 ( 
base
 + 
fnext
 for 
base
 , 
fnext
 in 
pairs
 ) 
	}

229 def 
	$__get_output_extensions
 ( 
self
 ) :

232 if 
self
 . 
get_finalized_command
 ( 'build_py' ) . 
optimize
 :

233 yield '.pyo' 
	}

235 def 
	$write_stub
 ( 
self
 , 
output_dir
 , 
ext
 , 
compile
 = False ) :

236 
log
 . 
info
 ( "writing stub loader for %s to %s" , 
ext
 . 
_full_name
 ,

237 
output_dir
 )

238 
stub_file
 = ( 
os
 . 
path
 . 
join
 ( 
output_dir
 , * 
ext
 . 
_full_name
 . 
split
 ( '.' ) ) + '.py'

240 if 
compile
 and 
os
 . 
path
 . 
exists
 ( 
stub_file
 ) :

241 raise 
DistutilsError
 ( 
stub_file
 + " already exists! Please delete." )

242 if not 
self
 . 
dry_run
 :

243 
f
 = 
open
 ( 
stub_file
 , 'w' )

244 
f
 . 
write
 ( '\n'

245 . 
join
 ( [ "def __bootstrap__():"

248 + 
if_dl
 ( ", dl" ) , "   __file__ = pkg_resources.resource_filename" "(__name__,%r)"

251 % 
os
 . 
path
 . 
basename
 ( 
ext
 . 
_file_name
 ) , "   del __bootstrap__"

255 
if_dl
 ( "   old_flags = sys.getdlopenflags()" ) , "   old_dir = os.getcwd()"

259 
if_dl
 ( "     sys.setdlopenflags(dl.RTLD_NOW)" ) , "     imp.load_dynamic(__name__,__file__)"

262 
if_dl
 ( "     sys.setdlopenflags(old_flags)" ) , "     os.chdir(old_dir)"

268 
f
 . 
close
 ( )

269 if 
compile
 :

270 from 
	~distutils.util
 import 
byte_compile

272 
byte_compile
 ( [ 
stub_file
 ] , 
optimize
 = 0 ,

273 
force
 = True , 
dry_run
 = 
self
 . 
dry_run
 )

274 
optimize
 = 
self
 . 
get_finalized_command
 ( 'install_lib' ) . 
optimize

275 if 
optimize
 > 0 :

276 
byte_compile
 ( [ 
stub_file
 ] , 
optimize
 = 
optimize
 ,

277 
force
 = True , 
dry_run
 = 
self
 . 
dry_run
 )

278 if 
os
 . 
path
 . 
exists
 ( 
stub_file
 ) and not 
self
 . 
dry_run
 :

279 
os
 . 
unlink
 ( 
stub_file
 ) 
	}

282 if 
use_stubs
 or 
os
 . 
name
 == 'nt' :

285 def 
	$link_shared_object
 (

286 
self
 , 
objects
 , 
output_libname
 , 
output_dir
 = None , 
libraries
 = None ,

287 
library_dirs
 = None , 
runtime_library_dirs
 = None , 
export_symbols
 = None ,

288 
debug
 = 0 , 
extra_preargs
 = None , 
extra_postargs
 = None , 
build_temp
 = None ,

289 
target_lang
 = None ) :

290 
self
 . 
link
 (

291 
self
 . 
SHARED_LIBRARY
 , 
objects
 , 
output_libname
 ,

292 
output_dir
 , 
libraries
 , 
library_dirs
 , 
runtime_library_dirs
 ,

293 
export_symbols
 , 
debug
 , 
extra_preargs
 , 
extra_postargs
 ,

294 
build_temp
 , 
target_lang

295 ) 
	}

298 
libtype
 = 'static'

300 def 
	$link_shared_object
 (

301 
self
 , 
objects
 , 
output_libname
 , 
output_dir
 = None , 
libraries
 = None ,

302 
library_dirs
 = None , 
runtime_library_dirs
 = None , 
export_symbols
 = None ,

303 
debug
 = 0 , 
extra_preargs
 = None , 
extra_postargs
 = None , 
build_temp
 = None ,

304 
target_lang
 = None ) :

311 assert 
output_dir
 is None

312 
output_dir
 , 
filename
 = 
os
 . 
path
 . 
split
 ( 
output_libname
 )

313 
basename
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
filename
 )

314 if 
self
 . 
library_filename
 ( "x" ) . 
startswith
 ( 'lib' ) :

317 
basename
 = 
basename
 [ 3 : ]

319 
self
 . 
create_static_lib
 (

320 
objects
 , 
basename
 , 
output_dir
 , 
debug
 , 
target_lang

321 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/install_egg_info.py

1 from 
	~distutils
 import 
log
 , 
dir_util

2 import 
	~os
 , 
	~sys

4 from 
	~setuptools
 import 
Command

5 from 
	~setuptools
 import 
namespaces

6 from 
	~setuptools.archive_util
 import 
unpack_archive

7 import 
	~pkg_resources

10 class 
	cinstall_egg_info
 ( 
namespaces
 . 
Installer
 , 
Command
 ) :

13 
description
 = "Install an .egg-info directory for the package"

15 
user_options
 = [

19 def 
	$initialize_options
 ( 
self
 ) :

20 
self
 . 
install_dir
 = None

21 
self
 . 
install_layout
 = None

22 
self
 . 
prefix_option
 = None 
	}

24 def 
	$finalize_options
 ( 
self
 ) :

25 
self
 . 
set_undefined_options
 ( 'install_lib' ,

27 
self
 . 
set_undefined_options
 ( 'install' , ( 'install_layout' , 'install_layout' ) )

28 if 
sys
 . 
hexversion
 > 0x2060000 :

29 
self
 . 
set_undefined_options
 ( 'install' , ( 'prefix_option' , 'prefix_option' ) )

30 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( "egg_info" )

31 
basename
 = 
pkg_resources
 . 
Distribution
 (

32 None , None , 
ei_cmd
 . 
egg_name
 , 
ei_cmd
 . 
egg_version

33 ) . 
egg_name
 ( ) + '.egg-info'

35 if 
self
 . 
install_layout
 :

36 if not 
self
 . 
install_layout
 . 
lower
 ( ) in [ 'deb' ] :

37 raise 
DistutilsOptionError
 ( "unknown value for --install-layout" )

38 
self
 . 
install_layout
 = 
self
 . 
install_layout
 . 
lower
 ( )

39 
basename
 = 
basename
 . 
replace
 ( '-py%s' % 
pkg_resources
 . 
PY_MAJOR
 , '' )

40 elif 
self
 . 
prefix_option
 or 'real_prefix' in 
sys
 . 
__dict__
 :

44 
basename
 = 
basename
 . 
replace
 ( '-py%s' % 
pkg_resources
 . 
PY_MAJOR
 , '' )

46 
self
 . 
source
 = 
ei_cmd
 . 
egg_info

47 
self
 . 
target
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
install_dir
 , 
basename
 )

48 
self
 . 
outputs
 = [ ] 
	}

50 def 
	$run
 ( 
self
 ) :

51 
self
 . 
run_command
 ( 'egg_info' )

52 if 
os
 . 
path
 . 
isdir
 ( 
self
 . 
target
 ) and not 
os
 . 
path
 . 
islink
 ( 
self
 . 
target
 ) :

53 
dir_util
 . 
remove_tree
 ( 
self
 . 
target
 , 
dry_run
 = 
self
 . 
dry_run
 )

54 elif 
os
 . 
path
 . 
exists
 ( 
self
 . 
target
 ) :

55 
self
 . 
execute
 ( 
os
 . 
unlink
 , ( 
self
 . 
target
 , ) , "Removing " + 
self
 . 
target
 )

56 if not 
self
 . 
dry_run
 :

57 
pkg_resources
 . 
ensure_directory
 ( 
self
 . 
target
 )

58 
self
 . 
execute
 (

59 
self
 . 
copytree
 , ( ) , "Copying %s to %s" % ( 
self
 . 
source
 , 
self
 . 
target
 )

61 
self
 . 
install_namespaces
 ( ) 
	}

63 def 
	$get_outputs
 ( 
self
 ) :

64 return 
self
 . 
outputs
 
	}

66 def 
	$copytree
 ( 
self
 ) :

68 def 
skimmer
 ( 
src
 , 
dst
 ) :

72 for 
skip
 in '.svn/' , 'CVS/' :

73 if 
src
 . 
startswith
 ( 
skip
 ) or '/' + 
skip
 in 
src
 :

75 if 
self
 . 
install_layout
 and 
self
 . 
install_layout
 in [ 'deb' ] and 
src
 . 
startswith
 ( 'SOURCES.txt' ) :

76 
log
 . 
info
 ( "Skipping SOURCES.txt" )

78 
self
 . 
outputs
 . 
append
 ( 
dst
 )

79 
log
 . 
debug
 ( "Copying %s to %s" , 
src
 , 
dst
 )

80 return 
dst

82 
unpack_archive
 ( 
self
 . 
source
 , 
self
 . 
target
 , 
skimmer
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/egg_info.py

5 from 
	~distutils.filelist
 import 
FileList
 as 
_FileList

6 from 
	~distutils.errors
 import 
DistutilsInternalError

7 from 
	~distutils.util
 import 
convert_path

8 from 
	~distutils
 import 
log

9 import 
	~distutils.errors

10 import 
	~distutils.filelist

11 import 
	~os

12 import 
	~re

13 import 
	~sys

14 import 
	~io

15 import 
	~warnings

16 import 
	~time

17 import 
	~collections

19 from 
	~setuptools.extern
 import 
six

20 from 
	~setuptools.extern.six.moves
 import 
map

22 from 
	~setuptools
 import 
Command

23 from 
	~setuptools.command.sdist
 import 
sdist

24 from 
	~setuptools.command.sdist
 import 
walk_revctrl

25 from 
	~setuptools.command.setopt
 import 
edit_config

26 from 
	~setuptools.command
 import 
bdist_egg

27 from 
	~pkg_resources
 import (

28 
parse_requirements
 , 
safe_name
 , 
parse_version
 ,

29 
safe_version
 , 
yield_lines
 , 
EntryPoint
 , 
iter_entry_points
 , 
to_filename
 )

30 import 
	~setuptools.unicode_utils
 as 
unicode_utils

31 from 
	~setuptools.glob
 import 
glob

33 from 
	~setuptools.extern
 import 
packaging

34 from 
	~setuptools
 import 
SetuptoolsDeprecationWarning

36 def 
	$translate_pattern
 ( 
glob
 ) :

43 
pat
 = ''

46 
chunks
 = 
glob
 . 
split
 ( 
os
 . 
path
 . 
sep
 )

48 
sep
 = 
re
 . 
escape
 ( 
os
 . 
sep
 )

49 
valid_char
 = '[^%s]' % ( 
sep
 , )

51 for 
c
 , 
chunk
 in 
enumerate
 ( 
chunks
 ) :

52 
last_chunk
 = 
c
 == 
len
 ( 
chunks
 ) - 1

55 if 
chunk
 == '**' :

56 if 
last_chunk
 :

58 
pat
 += '.*'

61 
pat
 += '(?:%s+%s)*' % ( 
valid_char
 , 
sep
 )

65 
i
 = 0

66 
chunk_len
 = 
len
 ( 
chunk
 )

67 while 
i
 < 
chunk_len
 :

68 
char
 = 
chunk
 [ 
i
 ]

69 if 
char
 == '*' :

71 
pat
 += 
valid_char
 + '*'

72 elif 
char
 == '?' :

74 
pat
 += 
valid_char

75 elif 
char
 == '[' :

77 
inner_i
 = 
i
 + 1

79 if 
inner_i
 < 
chunk_len
 and 
chunk
 [ 
inner_i
 ] == '!' :

80 
inner_i
 = 
inner_i
 + 1

81 if 
inner_i
 < 
chunk_len
 and 
chunk
 [ 
inner_i
 ] == ']' :

82 
inner_i
 = 
inner_i
 + 1

85 while 
inner_i
 < 
chunk_len
 and 
chunk
 [ 
inner_i
 ] != ']' :

86 
inner_i
 = 
inner_i
 + 1

88 if 
inner_i
 >= 
chunk_len
 :

91 
pat
 += 
re
 . 
escape
 ( 
char
 )

94 
inner
 = 
chunk
 [ 
i
 + 1 : 
inner_i
 ]

95 
char_class
 = ''

98 if 
inner
 [ 0 ] == '!' :

99 
char_class
 = '^'

100 
inner
 = 
inner
 [ 1 : ]

102 
char_class
 += 
re
 . 
escape
 ( 
inner
 )

103 
pat
 += '[%s]' % ( 
char_class
 , )

106 
i
 = 
inner_i

108 
pat
 += 
re
 . 
escape
 ( 
char
 )

109 
i
 += 1

112 if not 
last_chunk
 :

113 
pat
 += 
sep

115 
pat
 += r'\Z'

116 return 
re
 . 
compile
 ( 
pat
 , 
flags
 = 
re
 . 
MULTILINE
 | 
re
 . 
DOTALL
 ) 
	}

119 class 
	cInfoCommon
 :

120 
tag_build
 = None

121 
tag_date
 = None

123 @ 
property

124 def 
	$name
 ( 
self
 ) :

125 return 
safe_name
 ( 
self
 . 
distribution
 . 
get_name
 ( ) ) 
	}

127 def 
	$tagged_version
 ( 
self
 ) :

128 
version
 = 
self
 . 
distribution
 . 
get_version
 ( )

131 if 
self
 . 
vtags
 and 
version
 . 
endswith
 ( 
self
 . 
vtags
 ) :

132 return 
safe_version
 ( 
version
 )

133 return 
safe_version
 ( 
version
 + 
self
 . 
vtags
 ) 
	}

135 def 
	$tags
 ( 
self
 ) :

136 
version
 = ''

137 if 
self
 . 
tag_build
 :

138 
version
 += 
self
 . 
tag_build

139 if 
self
 . 
tag_date
 :

140 
version
 += 
time
 . 
strftime
 ( "-%Y%m%d" )

141 return 
version
 
	}

142 
vtags
 = 
property
 ( 
tags
 )

145 class 
	cegg_info
 ( 
InfoCommon
 , 
Command
 ) :

146 
description
 = "create a distribution's .egg-info directory"

148 
user_options
 = [

156 
boolean_options
 = [ 'tag-date' ]

157 
negative_opt
 = { 'no-date'

161 def 
	$initialize_options
 ( 
self
 ) :

162 
self
 . 
egg_base
 = None

163 
self
 . 
egg_name
 = None

164 
self
 . 
egg_info
 = None

165 
self
 . 
egg_version
 = None

166 
self
 . 
broken_egg_info
 = False 
	}

171 @ 
property

172 def 
	$tag_svn_revision
 ( 
self
 ) :

173 pass 
	}

175 @ 
tag_svn_revision
 . 
	`setter

176 def 
	$tag_svn_revision
 ( 
self
 , 
value
 ) :

177 pass 
	}

180 def 
	$save_version_info
 ( 
self
 , 
filename
 ) :

186 
egg_info
 = 
collections
 . 
OrderedDict
 ( )

189 
egg_info
 [ 'tag_build' ] = 
self
 . 
tags
 ( )

190 
egg_info
 [ 'tag_date' ] = 0

191 
edit_config
 ( 
filename
 , 
dict
 ( 
egg_info
 = 
egg_info
 ) ) 
	}

193 def 
	$finalize_options
 ( 
self
 ) :

198 
self
 . 
egg_name
 = 
self
 . 
name

199 
self
 . 
egg_version
 = 
self
 . 
tagged_version
 ( )

200 
parsed_version
 = 
parse_version
 ( 
self
 . 
egg_version
 )

203 
is_version
 = 
isinstance
 ( 
parsed_version
 , 
packaging
 . 
version
 . 
Version
 )

204 
spec
 = ( "%s==%s"

205 if 
is_version
 else "%s===%s"

207 
list
 (

208 
parse_requirements
 ( 
spec
 % ( 
self
 . 
egg_name
 , 
self
 . 
egg_version
 ) )

210 except 
ValueError
 :

211 raise 
distutils
 . 
errors
 . 
DistutilsOptionError
 ( "Invalid distribution name or version syntax: %s-%s"

213 ( 
self
 . 
egg_name
 , 
self
 . 
egg_version
 )

216 if 
self
 . 
egg_base
 is None :

217 
dirs
 = 
self
 . 
distribution
 . 
package_dir

218 
self
 . 
egg_base
 = ( 
dirs
 or { } ) . 
get
 ( '' , 
os
 . 
curdir
 )

220 
self
 . 
ensure_dirname
 ( 'egg_base' )

221 
self
 . 
egg_info
 = 
to_filename
 ( 
self
 . 
egg_name
 ) + '.egg-info'

222 if 
self
 . 
egg_base
 != 
os
 . 
curdir
 :

223 
self
 . 
egg_info
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_base
 , 
self
 . 
egg_info
 )

224 if '-' in 
self
 . 
egg_name
 :

225 
self
 . 
check_broken_egg_info
 ( )

230 
self
 . 
distribution
 . 
metadata
 . 
version
 = 
self
 . 
egg_version

236 
pd
 = 
self
 . 
distribution
 . 
_patched_dist

237 if 
pd
 is not None and 
pd
 . 
key
 == 
self
 . 
egg_name
 . 
lower
 ( ) :

238 
pd
 . 
_version
 = 
self
 . 
egg_version

239 
pd
 . 
_parsed_version
 = 
parse_version
 ( 
self
 . 
egg_version
 )

240 
self
 . 
distribution
 . 
_patched_dist
 = None 
	}

242 def 
	$write_or_delete_file
 ( 
self
 , 
what
 , 
filename
 , 
data
 , 
force
 = False ) :

251 if 
data
 :

252 
self
 . 
write_file
 ( 
what
 , 
filename
 , 
data
 )

253 elif 
os
 . 
path
 . 
exists
 ( 
filename
 ) :

254 if 
data
 is None and not 
force
 :

255 
log
 . 
warn
 ( "%s not set in setup(), but %s exists"

256 , 
what
 , 
filename

260 
self
 . 
delete_file
 ( 
filename
 ) 
	}

262 def 
	$write_file
 ( 
self
 , 
what
 , 
filename
 , 
data
 ) :

268 
log
 . 
info
 ( "writing %s to %s" , 
what
 , 
filename
 )

269 if 
six
 . 
PY3
 :

270 
data
 = 
data
 . 
encode
 ( "utf-8" )

271 if not 
self
 . 
dry_run
 :

272 
f
 = 
open
 ( 
filename
 , 'wb' )

273 
f
 . 
write
 ( 
data
 )

274 
f
 . 
close
 ( ) 
	}

276 def 
	$delete_file
 ( 
self
 , 
filename
 ) :

278 
log
 . 
info
 ( "deleting %s" , 
filename
 )

279 if not 
self
 . 
dry_run
 :

280 
os
 . 
unlink
 ( 
filename
 ) 
	}

282 def 
	$run
 ( 
self
 ) :

283 
self
 . 
mkpath
 ( 
self
 . 
egg_info
 )

284 
os
 . 
utime
 ( 
self
 . 
egg_info
 , None )

285 
installer
 = 
self
 . 
distribution
 . 
fetch_build_egg

286 for 
ep
 in 
iter_entry_points
 ( 'egg_info.writers' ) :

287 
ep
 . 
require
 ( 
installer
 = 
installer
 )

288 
writer
 = 
ep
 . 
resolve
 ( )

289 
writer
 ( 
self
 , 
ep
 . 
name
 , 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_info
 , 
ep
 . 
name
 ) )

292 
nl
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_info
 , "native_libs.txt" )

293 if 
os
 . 
path
 . 
exists
 ( 
nl
 ) :

294 
self
 . 
delete_file
 ( 
nl
 )

296 
self
 . 
find_sources
 ( ) 
	}

298 def 
	$find_sources
 ( 
self
 ) :

300 
manifest_filename
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_info
 , "SOURCES.txt" )

301 
mm
 = 
manifest_maker
 ( 
self
 . 
distribution
 )

302 
mm
 . 
manifest
 = 
manifest_filename

303 
mm
 . 
run
 ( )

304 
self
 . 
filelist
 = 
mm
 . 
filelist
 
	}

306 def 
	$check_broken_egg_info
 ( 
self
 ) :

307 
bei
 = 
self
 . 
egg_name
 + '.egg-info'

308 if 
self
 . 
egg_base
 != 
os
 . 
curdir
 :

309 
bei
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
egg_base
 , 
bei
 )

310 if 
os
 . 
path
 . 
exists
 ( 
bei
 ) :

311 
log
 . 
warn
 ( "-"

316 
bei
 , 
self
 . 
egg_info

318 
self
 . 
broken_egg_info
 = 
self
 . 
egg_info

319 
self
 . 
egg_info
 = 
bei
 
	}

322 class 
	cFileList
 ( 
_FileList
 ) :

325 def 
	$process_template_line
 ( 
self
 , 
line
 ) :

331 ( 
action
 , 
patterns
 , 
dir
 , 
dir_pattern
 ) = 
self
 . 
_parse_template_line
 ( 
line
 )

336 if 
action
 == 'include' :

337 
self
 . 
debug_print
 ( "include " + ' ' . 
join
 ( 
patterns
 ) )

338 for 
pattern
 in 
patterns
 :

339 if not 
self
 . 
include
 ( 
pattern
 ) :

340 
log
 . 
warn
 ( "warning: no files found matching '%s'" , 
pattern
 )

342 elif 
action
 == 'exclude' :

343 
self
 . 
debug_print
 ( "exclude " + ' ' . 
join
 ( 
patterns
 ) )

344 for 
pattern
 in 
patterns
 :

345 if not 
self
 . 
exclude
 ( 
pattern
 ) :

346 
log
 . 
warn
 ( ( "warning: no previously-included files " "found matching '%s'"

347 ) , 
pattern
 )

349 elif 
action
 == 'global-include' :

350 
self
 . 
debug_print
 ( "global-include " + ' ' . 
join
 ( 
patterns
 ) )

351 for 
pattern
 in 
patterns
 :

352 if not 
self
 . 
global_include
 ( 
pattern
 ) :

353 
log
 . 
warn
 ( ( "warning: no files found matching '%s' " "anywhere in distribution"

354 ) , 
pattern
 )

356 elif 
action
 == 'global-exclude' :

357 
self
 . 
debug_print
 ( "global-exclude " + ' ' . 
join
 ( 
patterns
 ) )

358 for 
pattern
 in 
patterns
 :

359 if not 
self
 . 
global_exclude
 ( 
pattern
 ) :

360 
log
 . 
warn
 ( ( "warning: no previously-included files matching " "'%s' found anywhere in distribution"

362 
pattern
 )

364 elif 
action
 == 'recursive-include' :

365 
self
 . 
debug_print
 ( "recursive-include %s %s" %

366 ( 
dir
 , ' ' . 
join
 ( 
patterns
 ) ) )

367 for 
pattern
 in 
patterns
 :

368 if not 
self
 . 
recursive_include
 ( 
dir
 , 
pattern
 ) :

369 
log
 . 
warn
 ( ( "warning: no files found matching '%s' " "under directory '%s'"

371 
pattern
 , 
dir
 )

373 elif 
action
 == 'recursive-exclude' :

374 
self
 . 
debug_print
 ( "recursive-exclude %s %s" %

375 ( 
dir
 , ' ' . 
join
 ( 
patterns
 ) ) )

376 for 
pattern
 in 
patterns
 :

377 if not 
self
 . 
recursive_exclude
 ( 
dir
 , 
pattern
 ) :

378 
log
 . 
warn
 ( ( "warning: no previously-included files matching " "'%s' found under directory '%s'"

380 
pattern
 , 
dir
 )

382 elif 
action
 == 'graft' :

383 
self
 . 
debug_print
 ( "graft " + 
dir_pattern
 )

384 if not 
self
 . 
graft
 ( 
dir_pattern
 ) :

385 
log
 . 
warn
 ( "warning: no directories found matching '%s'" ,

386 
dir_pattern
 )

388 elif 
action
 == 'prune' :

389 
self
 . 
debug_print
 ( "prune " + 
dir_pattern
 )

390 if not 
self
 . 
prune
 ( 
dir_pattern
 ) :

391 
log
 . 
warn
 ( ( "no previously-included directories found " "matching '%s'"

392 ) , 
dir_pattern
 )

395 raise 
DistutilsInternalError
 ( "this cannot happen: invalid action '%s'"

396 % 
action
 ) 
	}

398 def 
	$_remove_files
 ( 
self
 , 
predicate
 ) :

403 
found
 = False

404 for 
i
 in 
range
 ( 
len
 ( 
self
 . 
files
 ) - 1 , - 1 , - 1 ) :

405 if 
predicate
 ( 
self
 . 
files
 [ 
i
 ] ) :

406 
self
 . 
debug_print
 ( " removing " + 
self
 . 
files
 [ 
i
 ] )

407 del 
self
 . 
files
 [ 
i
 ]

408 
found
 = True

409 return 
found
 
	}

411 def 
	$include
 ( 
self
 , 
pattern
 ) :

413 
found
 = [ 
f
 for 
f
 in 
glob
 ( 
pattern
 ) if not 
os
 . 
path
 . 
isdir
 ( 
f
 ) ]

414 
self
 . 
extend
 ( 
found
 )

415 return 
bool
 ( 
found
 ) 
	}

417 def 
	$exclude
 ( 
self
 , 
pattern
 ) :

419 
match
 = 
translate_pattern
 ( 
pattern
 )

420 return 
self
 . 
_remove_files
 ( 
match
 . 
match
 ) 
	}

422 def 
	$recursive_include
 ( 
self
 , 
dir
 , 
pattern
 ) :

426 
full_pattern
 = 
os
 . 
path
 . 
join
 ( 
dir
 , '**' , 
pattern
 )

427 
found
 = [ 
f
 for 
f
 in 
glob
 ( 
full_pattern
 , 
recursive
 = True )

428 if not 
os
 . 
path
 . 
isdir
 ( 
f
 ) ]

429 
self
 . 
extend
 ( 
found
 )

430 return 
bool
 ( 
found
 ) 
	}

432 def 
	$recursive_exclude
 ( 
self
 , 
dir
 , 
pattern
 ) :

436 
match
 = 
translate_pattern
 ( 
os
 . 
path
 . 
join
 ( 
dir
 , '**' , 
pattern
 ) )

437 return 
self
 . 
_remove_files
 ( 
match
 . 
match
 ) 
	}

439 def 
	$graft
 ( 
self
 , 
dir
 ) :

441 
found
 = [

442 
item

443 for 
match_dir
 in 
glob
 ( 
dir
 )

444 for 
item
 in 
distutils
 . 
filelist
 . 
findall
 ( 
match_dir
 )

446 
self
 . 
extend
 ( 
found
 )

447 return 
bool
 ( 
found
 ) 
	}

449 def 
	$prune
 ( 
self
 , 
dir
 ) :

451 
match
 = 
translate_pattern
 ( 
os
 . 
path
 . 
join
 ( 
dir
 , '**' ) )

452 return 
self
 . 
_remove_files
 ( 
match
 . 
match
 ) 
	}

454 def 
	$global_include
 ( 
self
 , 
pattern
 ) :

459 if 
self
 . 
allfiles
 is None :

460 
self
 . 
findall
 ( )

461 
match
 = 
translate_pattern
 ( 
os
 . 
path
 . 
join
 ( '**' , 
pattern
 ) )

462 
found
 = [ 
f
 for 
f
 in 
self
 . 
allfiles
 if 
match
 . 
match
 ( 
f
 ) ]

463 
self
 . 
extend
 ( 
found
 )

464 return 
bool
 ( 
found
 ) 
	}

466 def 
	$global_exclude
 ( 
self
 , 
pattern
 ) :

470 
match
 = 
translate_pattern
 ( 
os
 . 
path
 . 
join
 ( '**' , 
pattern
 ) )

471 return 
self
 . 
_remove_files
 ( 
match
 . 
match
 ) 
	}

473 def 
	$append
 ( 
self
 , 
item
 ) :

474 if 
item
 . 
endswith
 ( '\r' ) :

475 
item
 = 
item
 [ : - 1 ]

476 
path
 = 
convert_path
 ( 
item
 )

478 if 
self
 . 
_safe_path
 ( 
path
 ) :

479 
self
 . 
files
 . 
append
 ( 
path
 ) 
	}

481 def 
	$extend
 ( 
self
 , 
paths
 ) :

482 
self
 . 
files
 . 
extend
 ( 
filter
 ( 
self
 . 
_safe_path
 , 
paths
 ) ) 
	}

484 def 
	$_repair
 ( 
self
 ) :

492 
self
 . 
files
 = 
list
 ( 
filter
 ( 
self
 . 
_safe_path
 , 
self
 . 
files
 ) ) 
	}

494 def 
	$_safe_path
 ( 
self
 , 
path
 ) :

495 
enc_warn
 = "'%s' not %s encodable -- skipping"

498 
u_path
 = 
unicode_utils
 . 
filesys_decode
 ( 
path
 )

499 if 
u_path
 is None :

500 
log
 . 
warn
 ( "'%s' in unexpected encoding -- skipping" % 
path
 )

504 
utf8_path
 = 
unicode_utils
 . 
try_encode
 ( 
u_path
 , "utf-8" )

505 if 
utf8_path
 is None :

506 
log
 . 
warn
 ( 
enc_warn
 , 
path
 , 'utf-8' )

511 if 
os
 . 
path
 . 
exists
 ( 
u_path
 ) or 
os
 . 
path
 . 
exists
 ( 
utf8_path
 ) :

514 except 
UnicodeEncodeError
 :

515 
log
 . 
warn
 ( 
enc_warn
 , 
path
 , 
sys
 . 
getfilesystemencoding
 ( ) ) 
	}

518 class 
	cmanifest_maker
 ( 
sdist
 ) :

519 
template
 = "MANIFEST.in"

521 def 
	$initialize_options
 ( 
self
 ) :

522 
self
 . 
use_defaults
 = 1

523 
self
 . 
prune
 = 1

524 
self
 . 
manifest_only
 = 1

525 
self
 . 
force_manifest
 = 1 
	}

527 def 
	$finalize_options
 ( 
self
 ) :

528 pass 
	}

530 def 
	$run
 ( 
self
 ) :

531 
self
 . 
filelist
 = 
FileList
 ( )

532 if not 
os
 . 
path
 . 
exists
 ( 
self
 . 
manifest
 ) :

533 
self
 . 
write_manifest
 ( )

534 
self
 . 
add_defaults
 ( )

535 if 
os
 . 
path
 . 
exists
 ( 
self
 . 
template
 ) :

536 
self
 . 
read_template
 ( )

537 
self
 . 
prune_file_list
 ( )

538 
self
 . 
filelist
 . 
sort
 ( )

539 
self
 . 
filelist
 . 
remove_duplicates
 ( )

540 
self
 . 
write_manifest
 ( ) 
	}

542 def 
	$_manifest_normalize
 ( 
self
 , 
path
 ) :

543 
path
 = 
unicode_utils
 . 
filesys_decode
 ( 
path
 )

544 return 
path
 . 
replace
 ( 
os
 . 
sep
 , '/' ) 
	}

546 def 
	$write_manifest
 ( 
self
 ) :

551 
self
 . 
filelist
 . 
_repair
 ( )

554 
files
 = [ 
self
 . 
_manifest_normalize
 ( 
f
 ) for 
f
 in 
self
 . 
filelist
 . 
files
 ]

555 
msg
 = "writing manifest file '%s'" % 
self
 . 
manifest

556 
self
 . 
execute
 ( 
write_file
 , ( 
self
 . 
manifest
 , 
files
 ) , 
msg
 ) 
	}

558 def 
	$warn
 ( 
self
 , 
msg
 ) :

559 if not 
self
 . 
_should_suppress_warning
 ( 
msg
 ) :

560 
sdist
 . 
warn
 ( 
self
 , 
msg
 ) 
	}

562 @ 
	`staticmethod

563 def 
	$_should_suppress_warning
 ( 
msg
 ) :

567 return 
re
 . 
match
 ( r"standard file .*not found" , 
msg
 ) 
	}

569 def 
	$add_defaults
 ( 
self
 ) :

570 
sdist
 . 
add_defaults
 ( 
self
 )

571 
self
 . 
check_license
 ( )

572 
self
 . 
filelist
 . 
append
 ( 
self
 . 
template
 )

573 
self
 . 
filelist
 . 
append
 ( 
self
 . 
manifest
 )

574 
rcfiles
 = 
list
 ( 
walk_revctrl
 ( ) )

575 if 
rcfiles
 :

576 
self
 . 
filelist
 . 
extend
 ( 
rcfiles
 )

577 elif 
os
 . 
path
 . 
exists
 ( 
self
 . 
manifest
 ) :

578 
self
 . 
read_manifest
 ( )

580 if 
os
 . 
path
 . 
exists
 ( "setup.py" ) :

583 
self
 . 
filelist
 . 
append
 ( "setup.py" )

585 
ei_cmd
 = 
self
 . 
get_finalized_command
 ( 'egg_info' )

586 
self
 . 
filelist
 . 
graft
 ( 
ei_cmd
 . 
egg_info
 ) 
	}

588 def 
	$prune_file_list
 ( 
self
 ) :

589 
build
 = 
self
 . 
get_finalized_command
 ( 'build' )

590 
base_dir
 = 
self
 . 
distribution
 . 
get_fullname
 ( )

591 
self
 . 
filelist
 . 
prune
 ( 
build
 . 
build_base
 )

592 
self
 . 
filelist
 . 
prune
 ( 
base_dir
 )

593 
sep
 = 
re
 . 
escape
 ( 
os
 . 
sep
 )

594 
self
 . 
filelist
 . 
exclude_pattern
 ( r'(^|' + 
sep
 + r')(RCS|CVS|\.svn)' + 
sep
 ,

595 
is_regex
 = 1 ) 
	}

598 def 
	$write_file
 ( 
filename
 , 
contents
 ) :

602 
contents
 = "\n" . 
join
 ( 
contents
 )

605 
contents
 = 
contents
 . 
encode
 ( "utf-8" )

607 with 
open
 ( 
filename
 , "wb" ) as 
f
 :

608 
f
 . 
write
 ( 
contents
 ) 
	}

611 def 
	$write_pkg_info
 ( 
cmd
 , 
basename
 , 
filename
 ) :

612 
log
 . 
info
 ( "writing %s" , 
filename
 )

613 if not 
cmd
 . 
dry_run
 :

614 
metadata
 = 
cmd
 . 
distribution
 . 
metadata

615 
metadata
 . 
version
 , 
oldver
 = 
cmd
 . 
egg_version
 , 
metadata
 . 
version

616 
metadata
 . 
name
 , 
oldname
 = 
cmd
 . 
egg_name
 , 
metadata
 . 
name

621 
metadata
 . 
write_pkg_info
 ( 
cmd
 . 
egg_info
 )

623 
metadata
 . 
name
 , 
metadata
 . 
version
 = 
oldname
 , 
oldver

625 
safe
 = 
getattr
 ( 
cmd
 . 
distribution
 , 'zip_safe' , None )

627 
bdist_egg
 . 
write_safety_flag
 ( 
cmd
 . 
egg_info
 , 
safe
 ) 
	}

630 def 
	$warn_depends_obsolete
 ( 
cmd
 , 
basename
 , 
filename
 ) :

631 if 
os
 . 
path
 . 
exists
 ( 
filename
 ) :

632 
log
 . 
warn
 ( "WARNING: 'depends.txt' is not used by setuptools 0.6!\n" "Use the install_requires/extras_require setup() args instead."

635 ) 
	}

638 def 
	$_write_requirements
 ( 
stream
 , 
reqs
 ) :

639 
lines
 = 
yield_lines
 ( 
reqs
 or ( ) )

640 
append_cr
 = lambda 
line
 : 
line
 + '\n'

641 
lines
 = 
map
 ( 
append_cr
 , 
sorted
 ( 
lines
 ) )

642 
stream
 . 
writelines
 ( 
lines
 ) 
	}

645 def 
	$write_requirements
 ( 
cmd
 , 
basename
 , 
filename
 ) :

646 
dist
 = 
cmd
 . 
distribution

647 
data
 = 
six
 . 
StringIO
 ( )

648 
_write_requirements
 ( 
data
 , 
dist
 . 
install_requires
 )

649 
extras_require
 = 
dist
 . 
extras_require
 or { }

650 for 
extra
 in 
sorted
 ( 
extras_require
 ) :

651 
data
 . 
write
 ( '\n[{extra}]\n' . 
format
 ( ** 
vars
 ( ) ) )

652 
_write_requirements
 ( 
data
 , 
extras_require
 [ 
extra
 ] )

653 
cmd
 . 
write_or_delete_file
 ( "requirements" , 
filename
 , 
data
 . 
getvalue
 ( ) ) 
	}

656 def 
	$write_setup_requirements
 ( 
cmd
 , 
basename
 , 
filename
 ) :

657 
data
 = 
io
 . 
StringIO
 ( )

658 
_write_requirements
 ( 
data
 , 
cmd
 . 
distribution
 . 
setup_requires
 )

659 
cmd
 . 
write_or_delete_file
 ( "setup-requirements" , 
filename
 , 
data
 . 
getvalue
 ( ) ) 
	}

662 def 
	$write_toplevel_names
 ( 
cmd
 , 
basename
 , 
filename
 ) :

663 
pkgs
 = 
dict
 . 
fromkeys
 (

665 
k
 . 
split
 ( '.' , 1 ) [ 0 ]

666 for 
k
 in 
cmd
 . 
distribution
 . 
iter_distribution_names
 ( )

669 
cmd
 . 
write_file
 ( "top-level names" , 
filename
 , '\n' . 
join
 ( 
sorted
 ( 
pkgs
 ) ) + '\n' ) 
	}

672 def 
	$overwrite_arg
 ( 
cmd
 , 
basename
 , 
filename
 ) :

673 
write_arg
 ( 
cmd
 , 
basename
 , 
filename
 , True ) 
	}

676 def 
	$write_arg
 ( 
cmd
 , 
basename
 , 
filename
 , 
force
 = False ) :

677 
argname
 = 
os
 . 
path
 . 
splitext
 ( 
basename
 ) [ 0 ]

678 
value
 = 
getattr
 ( 
cmd
 . 
distribution
 , 
argname
 , None )

679 if 
value
 is not None :

680 
value
 = '\n' . 
join
 ( 
value
 ) + '\n'

681 
cmd
 . 
write_or_delete_file
 ( 
argname
 , 
filename
 , 
value
 , 
force
 ) 
	}

684 def 
	$write_entries
 ( 
cmd
 , 
basename
 , 
filename
 ) :

685 
ep
 = 
cmd
 . 
distribution
 . 
entry_points

687 if 
isinstance
 ( 
ep
 , 
six
 . 
string_types
 ) or 
ep
 is None :

688 
data
 = 
ep

689 elif 
ep
 is not None :

690 
data
 = [ ]

691 for 
section
 , 
contents
 in 
sorted
 ( 
ep
 . 
items
 ( ) ) :

692 if not 
isinstance
 ( 
contents
 , 
six
 . 
string_types
 ) :

693 
contents
 = 
EntryPoint
 . 
parse_group
 ( 
section
 , 
contents
 )

694 
contents
 = '\n' . 
join
 ( 
sorted
 ( 
map
 ( 
str
 , 
contents
 . 
values
 ( ) ) ) )

695 
data
 . 
append
 ( '[%s]\n%s\n\n' % ( 
section
 , 
contents
 ) )

696 
data
 = '' . 
join
 ( 
data
 )

698 
cmd
 . 
write_or_delete_file
 ( 'entry points' , 
filename
 , 
data
 , True ) 
	}

701 def 
	$get_pkg_info_revision
 ( ) :

706 
warnings
 . 
warn
 ( "get_pkg_info_revision is deprecated." , 
EggInfoDeprecationWarning
 )

707 if 
os
 . 
path
 . 
exists
 ( 'PKG-INFO' ) :

708 with 
io
 . 
open
 ( 'PKG-INFO' ) as 
f
 :

709 for 
line
 in 
f
 :

710 
match
 = 
re
 . 
match
 ( r"Version:.*-r(\d+)\s*$" , 
line
 )

711 if 
match
 :

712 return 
int
 ( 
match
 . 
group
 ( 1 ) )

713 return 0 
	}

716 class 
	cEggInfoDeprecationWarning
 ( 
SetuptoolsDeprecationWarning
 ) :


	@./env/lib/python3.7/site-packages/setuptools/command/setopt.py

1 from 
	~distutils.util
 import 
convert_path

2 from 
	~distutils
 import 
log

3 from 
	~distutils.errors
 import 
DistutilsOptionError

4 import 
	~distutils

5 import 
	~os

7 from 
	~setuptools.extern.six.moves
 import 
configparser

9 from 
	~setuptools
 import 
Command

11 
__all__
 = [ 'config_file' , 'edit_config' , 'option_base' , 'setopt' ]

14 def 
	$config_file
 ( 
kind
 = "local" ) :

19 if 
kind
 == 'local' :

21 if 
kind
 == 'global' :

22 return 
os
 . 
path
 . 
join
 (

23 
os
 . 
path
 . 
dirname
 ( 
distutils
 . 
__file__
 ) , 'distutils.cfg'

25 if 
kind
 == 'user' :

26 
dot
 = 
os
 . 
name
 == 'posix' and '.' or ''

27 return 
os
 . 
path
 . 
expanduser
 ( 
convert_path
 ( "~/%spydistutils.cfg" % 
dot
 ) )

28 raise 
ValueError
 ( "config_file() type must be 'local', 'global', or 'user'"

29 , 
kind

30 ) 
	}

33 def 
	$edit_config
 ( 
filename
 , 
settings
 , 
dry_run
 = False ) :

41 
log
 . 
debug
 ( "Reading configuration from %s" , 
filename
 )

42 
opts
 = 
configparser
 . 
RawConfigParser
 ( )

43 
opts
 . 
read
 ( [ 
filename
 ] )

44 for 
section
 , 
options
 in 
settings
 . 
items
 ( ) :

45 if 
options
 is None :

46 
log
 . 
info
 ( "Deleting section [%s] from %s" , 
section
 , 
filename
 )

47 
opts
 . 
remove_section
 ( 
section
 )

49 if not 
opts
 . 
has_section
 ( 
section
 ) :

50 
log
 . 
debug
 ( "Adding new section [%s] to %s" , 
section
 , 
filename
 )

51 
opts
 . 
add_section
 ( 
section
 )

52 for 
option
 , 
value
 in 
options
 . 
items
 ( ) :

53 if 
value
 is None :

54 
log
 . 
debug
 ( "Deleting %s.%s from %s"

56 
section
 , 
option
 , 
filename

58 
opts
 . 
remove_option
 ( 
section
 , 
option
 )

59 if not 
opts
 . 
options
 ( 
section
 ) :

60 
log
 . 
info
 ( "Deleting empty [%s] section from %s" ,

61 
section
 , 
filename
 )

62 
opts
 . 
remove_section
 ( 
section
 )

64 
log
 . 
debug
 ( "Setting %s.%s to %r in %s"

66 
section
 , 
option
 , 
value
 , 
filename

68 
opts
 . 
set
 ( 
section
 , 
option
 , 
value
 )

70 
log
 . 
info
 ( "Writing %s" , 
filename
 )

71 if not 
dry_run
 :

72 with 
open
 ( 
filename
 , 'w' ) as 
f
 :

73 
opts
 . 
write
 ( 
f
 ) 
	}

76 class 
	coption_base
 ( 
Command
 ) :

79 
user_options
 = [

88 
boolean_options
 = [ 'global-config'

92 def 
	$initialize_options
 ( 
self
 ) :

93 
self
 . 
global_config
 = None

94 
self
 . 
user_config
 = None

95 
self
 . 
filename
 = None 
	}

97 def 
	$finalize_options
 ( 
self
 ) :

98 
filenames
 = [ ]

99 if 
self
 . 
global_config
 :

100 
filenames
 . 
append
 ( 
config_file
 ( 'global' ) )

101 if 
self
 . 
user_config
 :

102 
filenames
 . 
append
 ( 
config_file
 ( 'user' ) )

103 if 
self
 . 
filename
 is not None :

104 
filenames
 . 
append
 ( 
self
 . 
filename
 )

105 if not 
filenames
 :

106 
filenames
 . 
append
 ( 
config_file
 ( 'local' ) )

107 if 
len
 ( 
filenames
 ) > 1 :

108 raise 
DistutilsOptionError
 ( "Must specify only one configuration file option"

110 
filenames

112 
self
 . 
filename
 , = 
filenames
 
	}

115 class 
	csetopt
 ( 
option_base
 ) :

118 
description
 = "set an option in setup.cfg or another config file"

120 
user_options
 = [

125 ] + 
option_base
 . 
user_options

127 
boolean_options
 = 
option_base
 . 
boolean_options
 + [ 'remove' ]

129 def 
	$initialize_options
 ( 
self
 ) :

130 
option_base
 . 
initialize_options
 ( 
self
 )

131 
self
 . 
command
 = None

132 
self
 . 
option
 = None

133 
self
 . 
set_value
 = None

134 
self
 . 
remove
 = None 
	}

136 def 
	$finalize_options
 ( 
self
 ) :

137 
option_base
 . 
finalize_options
 ( 
self
 )

138 if 
self
 . 
command
 is None or 
self
 . 
option
 is None :

139 raise 
DistutilsOptionError
 ( "Must specify --command *and* --option" )

140 if 
self
 . 
set_value
 is None and not 
self
 . 
remove
 :

141 raise 
DistutilsOptionError
 ( "Must specify --set-value or --remove" ) 
	}

143 def 
	$run
 ( 
self
 ) :

144 
edit_config
 (

145 
self
 . 
filename
 , {

146 
self
 . 
command
 : { 
self
 . 
option
 . 
replace
 ( '-' , '_' ) : 
self
 . 
set_value
 }

148 
self
 . 
dry_run

149 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/command/rotate.py

1 from 
	~distutils.util
 import 
convert_path

2 from 
	~distutils
 import 
log

3 from 
	~distutils.errors
 import 
DistutilsOptionError

4 import 
	~os

5 import 
	~shutil

7 from 
	~setuptools.extern
 import 
six

9 from 
	~setuptools
 import 
Command

12 class 
	crotate
 ( 
Command
 ) :

15 
description
 = "delete older distributions, keeping N newest files"

16 
user_options
 = [

22 
boolean_options
 = [ ]

24 def 
	$initialize_options
 ( 
self
 ) :

25 
self
 . 
match
 = None

26 
self
 . 
dist_dir
 = None

27 
self
 . 
keep
 = None 
	}

29 def 
	$finalize_options
 ( 
self
 ) :

30 if 
self
 . 
match
 is None :

31 raise 
DistutilsOptionError
 ( "Must specify one or more (comma-separated) match patterns " "(e.g. '.zip' or '.egg')"

35 if 
self
 . 
keep
 is None :

36 raise 
DistutilsOptionError
 ( "Must specify number of files to keep" )

38 
self
 . 
keep
 = 
int
 ( 
self
 . 
keep
 )

39 except 
ValueError
 :

40 raise 
DistutilsOptionError
 ( "--keep must be an integer" )

41 if 
isinstance
 ( 
self
 . 
match
 , 
six
 . 
string_types
 ) :

42 
self
 . 
match
 = [

43 
convert_path
 ( 
p
 . 
strip
 ( ) ) for 
p
 in 
self
 . 
match
 . 
split
 ( ',' )

45 
self
 . 
set_undefined_options
 ( 'bdist' , ( 'dist_dir' , 'dist_dir' ) ) 
	}

47 def 
	$run
 ( 
self
 ) :

48 
self
 . 
run_command
 ( "egg_info" )

49 from 
	~glob
 import 
glob

51 for 
pattern
 in 
self
 . 
match
 :

52 
pattern
 = 
self
 . 
distribution
 . 
get_name
 ( ) + '*' + 
pattern

53 
files
 = 
glob
 ( 
os
 . 
path
 . 
join
 ( 
self
 . 
dist_dir
 , 
pattern
 ) )

54 
files
 = [ ( 
os
 . 
path
 . 
getmtime
 ( 
f
 ) , 
f
 ) for 
f
 in 
files
 ]

55 
files
 . 
sort
 ( )

56 
files
 . 
reverse
 ( )

58 
log
 . 
info
 ( "%d file(s) matching %s" , 
len
 ( 
files
 ) , 
pattern
 )

59 
files
 = 
files
 [ 
self
 . 
keep
 : ]

60 for ( 
t
 , 
f
 ) in 
files
 :

61 
log
 . 
info
 ( "Deleting %s" , 
f
 )

62 if not 
self
 . 
dry_run
 :

63 if 
os
 . 
path
 . 
isdir
 ( 
f
 ) :

64 
shutil
 . 
rmtree
 ( 
f
 )

66 
os
 . 
unlink
 ( 
f
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/py31compat.py

1 
__all__
 = [ ]

3 
__metaclass__
 = 
type

8 from 
	~tempfile
 import 
TemporaryDirectory

9 except 
ImportError
 :

10 import 
	~shutil

11 import 
	~tempfile

13 class 
	cTemporaryDirectory
 :

20 def 
	$__init__
 ( 
self
 ) :

21 
self
 . 
name
 = None

22 
self
 . 
name
 = 
tempfile
 . 
mkdtemp
 ( ) 
	}

24 def 
	$__enter__
 ( 
self
 ) :

25 return 
self
 . 
name
 
	}

27 def 
	$__exit__
 ( 
self
 , 
exctype
 , 
excvalue
 , 
exctrace
 ) :

29 
shutil
 . 
rmtree
 ( 
self
 . 
name
 , True )

30 except 
OSError
 :

32 
self
 . 
name
 = None 
	}


	@./env/lib/python3.7/site-packages/setuptools/unicode_utils.py

1 import 
	~unicodedata

2 import 
	~sys

3 import 
	~re

5 from 
	~setuptools.extern
 import 
six

9 def 
	$decompose
 ( 
path
 ) :

10 if 
isinstance
 ( 
path
 , 
six
 . 
text_type
 ) :

11 return 
unicodedata
 . 
normalize
 ( 'NFD' , 
path
 )

13 
path
 = 
path
 . 
decode
 ( 'utf-8' )

14 
path
 = 
unicodedata
 . 
normalize
 ( 'NFD' , 
path
 )

15 
path
 = 
path
 . 
encode
 ( 'utf-8' )

16 except 
UnicodeError
 :

18 return 
path
 
	}

21 def 
	$filesys_decode
 ( 
path
 ) :

27 if 
isinstance
 ( 
path
 , 
six
 . 
text_type
 ) :

28 return 
path

30 
fs_enc
 = 
sys
 . 
getfilesystemencoding
 ( ) or 'utf-8'

31 
candidates
 = 
fs_enc
 , 'utf-8'

33 for 
enc
 in 
candidates
 :

35 return 
path
 . 
decode
 ( 
enc
 )

36 except 
UnicodeDecodeError
 :

37 continue 
	}

40 def 
	$try_encode
 ( 
string
 , 
enc
 ) :

43 return 
string
 . 
encode
 ( 
enc
 )

44 except 
UnicodeEncodeError
 :

45 return None 
	}

48 
CODING_RE
 = 
re
 . 
compile
 ( br'^[ \t\f]*#.*?coding[:=][ \t]*([-\w.]+)' )

51 def 
	$detect_encoding
 ( 
fp
 ) :

52 
first_line
 = 
fp
 . 
readline
 ( )

53 
fp
 . 
seek
 ( 0 )

54 
m
 = 
CODING_RE
 . 
match
 ( 
first_line
 )

55 if 
m
 is None :

57 return 
m
 . 
group
 ( 1 ) . 
decode
 ( 'ascii' ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/glibc.py

3 from 
	~__future__
 import 
absolute_import

5 import 
	~ctypes

6 import 
	~re

7 import 
	~warnings

10 def 
	$glibc_version_string
 ( ) :

17 
process_namespace
 = 
ctypes
 . 
CDLL
 ( None )

19 
gnu_get_libc_version
 = 
process_namespace
 . 
gnu_get_libc_version

20 except 
AttributeError
 :

26 
gnu_get_libc_version
 . 
restype
 = 
ctypes
 . 
c_char_p

27 
version_str
 = 
gnu_get_libc_version
 ( )

29 if not 
isinstance
 ( 
version_str
 , 
str
 ) :

30 
version_str
 = 
version_str
 . 
decode
 ( "ascii" )

32 return 
version_str
 
	}

36 def 
	$check_glibc_version
 ( 
version_str
 , 
required_major
 , 
minimum_minor
 ) :

43 
m
 = 
re
 . 
match
 ( r"(?P<major>[0-9]+)\.(?P<minor>[0-9]+)" , 
version_str
 )

44 if not 
m
 :

45 
warnings
 . 
warn
 ( "Expected glibc version with 2 components major.minor," " got: %s"

46 % 
version_str
 , 
RuntimeWarning
 )

48 return ( 
int
 ( 
m
 . 
group
 ( "major" ) ) == 
required_major
 and

49 
int
 ( 
m
 . 
group
 ( "minor" ) ) >= 
minimum_minor
 ) 
	}

52 def 
	$have_compatible_glibc
 ( 
required_major
 , 
minimum_minor
 ) :

53 
version_str
 = 
glibc_version_string
 ( )

54 if 
version_str
 is None :

56 return 
check_glibc_version
 ( 
version_str
 , 
required_major
 , 
minimum_minor
 ) 
	}

76 def 
	$libc_ver
 ( ) :

82 
glibc_version
 = 
glibc_version_string
 ( )

83 if 
glibc_version
 is None :

86 return ( "glibc" , 
glibc_version
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/wheel.py

3 from 
	~distutils.util
 import 
get_platform

4 import 
	~email

5 import 
	~itertools

6 import 
	~os

7 import 
	~posixpath

8 import 
	~re

9 import 
	~zipfile

11 import 
	~pkg_resources

12 import 
	~setuptools

13 from 
	~pkg_resources
 import 
parse_version

14 from 
	~setuptools.extern.packaging.utils
 import 
canonicalize_name

15 from 
	~setuptools.extern.six
 import 
PY3

16 from 
	~setuptools
 import 
pep425tags

17 from 
	~setuptools.command.egg_info
 import 
write_requirements

20 
__metaclass__
 = 
type

23 
WHEEL_NAME
 = 
re
 . 
compile
 ( r"""^(?P<project_name>.+?)-(?P<version>\d.*?)\n    ((-(?P<build>\d.*?))?-(?P<py_version>.+?)-(?P<abi>.+?)-(?P<platform>.+?)\n    )\.whl$"""

27 
re
 . 
VERBOSE
 ) . 
match

29 
NAMESPACE_PACKAGE_INIT
 = '''\\ntry:\n    __import__('pkg_resources').declare_namespace(__name__)\nexcept ImportError:\n    __path__ = __import__('pkgutil').extend_path(__path__, __name__)\n'''

37 def 
	$unpack
 ( 
src_dir
 , 
dst_dir
 ) :

39 for 
dirpath
 , 
dirnames
 , 
filenames
 in 
os
 . 
walk
 ( 
src_dir
 ) :

40 
subdir
 = 
os
 . 
path
 . 
relpath
 ( 
dirpath
 , 
src_dir
 )

41 for 
f
 in 
filenames
 :

42 
src
 = 
os
 . 
path
 . 
join
 ( 
dirpath
 , 
f
 )

43 
dst
 = 
os
 . 
path
 . 
join
 ( 
dst_dir
 , 
subdir
 , 
f
 )

44 
os
 . 
renames
 ( 
src
 , 
dst
 )

45 for 
n
 , 
d
 in 
reversed
 ( 
list
 ( 
enumerate
 ( 
dirnames
 ) ) ) :

46 
src
 = 
os
 . 
path
 . 
join
 ( 
dirpath
 , 
d
 )

47 
dst
 = 
os
 . 
path
 . 
join
 ( 
dst_dir
 , 
subdir
 , 
d
 )

48 if not 
os
 . 
path
 . 
exists
 ( 
dst
 ) :

51 
os
 . 
renames
 ( 
src
 , 
dst
 )

52 del 
dirnames
 [ 
n
 ]

54 for 
dirpath
 , 
dirnames
 , 
filenames
 in 
os
 . 
walk
 ( 
src_dir
 , 
topdown
 = True ) :

55 assert not 
filenames

56 
os
 . 
rmdir
 ( 
dirpath
 ) 
	}

59 class 
	cWheel
 :

61 def 
	$__init__
 ( 
self
 , 
filename
 ) :

62 
match
 = 
WHEEL_NAME
 ( 
os
 . 
path
 . 
basename
 ( 
filename
 ) )

63 if 
match
 is None :

64 raise 
ValueError
 ( 'invalid wheel name: %r' % 
filename
 )

65 
self
 . 
filename
 = 
filename

66 for 
k
 , 
v
 in 
match
 . 
groupdict
 ( ) . 
items
 ( ) :

67 
setattr
 ( 
self
 , 
k
 , 
v
 ) 
	}

69 def 
	$tags
 ( 
self
 ) :

71 return 
itertools
 . 
product
 (

72 
self
 . 
py_version
 . 
split
 ( '.' ) ,

73 
self
 . 
abi
 . 
split
 ( '.' ) ,

74 
self
 . 
platform
 . 
split
 ( '.' ) ,

75 ) 
	}

77 def 
	$is_compatible
 ( 
self
 ) :

79 
supported_tags
 = 
pep425tags
 . 
get_supported
 ( )

80 return 
next
 ( ( True for 
t
 in 
self
 . 
tags
 ( ) if 
t
 in 
supported_tags
 ) , False ) 
	}

82 def 
	$egg_name
 ( 
self
 ) :

83 return 
pkg_resources
 . 
Distribution
 (

84 
project_name
 = 
self
 . 
project_name
 , 
version
 = 
self
 . 
version
 ,

85 
platform
 = ( None if 
self
 . 
platform
 == 'any' else 
get_platform
 ( ) ) ,

86 ) . 
egg_name
 ( ) + '.egg' 
	}

88 def 
	$get_dist_info
 ( 
self
 , 
zf
 ) :

90 for 
member
 in 
zf
 . 
namelist
 ( ) :

91 
dirname
 = 
posixpath
 . 
dirname
 ( 
member
 )

92 if ( 
dirname
 . 
endswith
 ( '.dist-info' ) and

93 
canonicalize_name
 ( 
dirname
 ) . 
startswith
 (

94 
canonicalize_name
 ( 
self
 . 
project_name
 ) ) ) :

95 return 
dirname

96 raise 
ValueError
 ( "unsupported wheel format. .dist-info not found" ) 
	}

98 def 
	$install_as_egg
 ( 
self
 , 
destination_eggdir
 ) :

100 with 
zipfile
 . 
ZipFile
 ( 
self
 . 
filename
 ) as 
zf
 :

101 
self
 . 
_install_as_egg
 ( 
destination_eggdir
 , 
zf
 ) 
	}

103 def 
	$_install_as_egg
 ( 
self
 , 
destination_eggdir
 , 
zf
 ) :

104 
dist_basename
 = '%s-%s' % ( 
self
 . 
project_name
 , 
self
 . 
version
 )

105 
dist_info
 = 
self
 . 
get_dist_info
 ( 
zf
 )

106 
dist_data
 = '%s.data' % 
dist_basename

107 
egg_info
 = 
os
 . 
path
 . 
join
 ( 
destination_eggdir
 , 'EGG-INFO' )

109 
self
 . 
_convert_metadata
 ( 
zf
 , 
destination_eggdir
 , 
dist_info
 , 
egg_info
 )

110 
self
 . 
_move_data_entries
 ( 
destination_eggdir
 , 
dist_data
 )

111 
self
 . 
_fix_namespace_packages
 ( 
egg_info
 , 
destination_eggdir
 ) 
	}

113 @ 
	`staticmethod

114 def 
	$_convert_metadata
 ( 
zf
 , 
destination_eggdir
 , 
dist_info
 , 
egg_info
 ) :

115 def 
get_metadata
 ( 
name
 ) :

116 with 
zf
 . 
open
 ( 
posixpath
 . 
join
 ( 
dist_info
 , 
name
 ) ) as 
fp
 :

117 
value
 = 
fp
 . 
read
 ( ) . 
decode
 ( 'utf-8' ) if 
PY3
 else 
fp
 . 
read
 ( )

118 return 
email
 . 
parser
 . 
Parser
 ( ) . 
parsestr
 ( 
value
 )

120 
wheel_metadata
 = 
get_metadata
 ( 'WHEEL' )

122 
wheel_version
 = 
parse_version
 ( 
wheel_metadata
 . 
get
 ( 'Wheel-Version' ) )

123 
wheel_v1
 = (

124 
parse_version
 ( '1.0' ) <= 
wheel_version
 < 
parse_version
 ( '2.0dev0' )

126 if not 
wheel_v1
 :

127 raise 
ValueError
 ( 'unsupported wheel format version: %s'

128 % 
wheel_version
 )

130 
os
 . 
mkdir
 ( 
destination_eggdir
 )

131 
zf
 . 
extractall
 ( 
destination_eggdir
 )

133 
dist_info
 = 
os
 . 
path
 . 
join
 ( 
destination_eggdir
 , 
dist_info
 )

134 
dist
 = 
pkg_resources
 . 
Distribution
 . 
from_location
 (

135 
destination_eggdir
 , 
dist_info
 ,

136 
metadata
 = 
pkg_resources
 . 
PathMetadata
 ( 
destination_eggdir
 , 
dist_info
 ) ,

142 def 
raw_req
 ( 
req
 ) :

143 
req
 . 
marker
 = None

144 return 
str
 ( 
req
 )

145 
install_requires
 = 
list
 ( 
sorted
 ( 
map
 ( 
raw_req
 , 
dist
 . 
requires
 ( ) ) ) )

146 
extras_require
 = {

147 
extra
 : 
sorted
 (

148 
req

149 for 
req
 in 
map
 ( 
raw_req
 , 
dist
 . 
requires
 ( ( 
extra
 , ) ) )

150 if 
req
 not in 
install_requires

152 for 
extra
 in 
dist
 . 
extras

154 
os
 . 
rename
 ( 
dist_info
 , 
egg_info
 )

155 
os
 . 
rename
 (

156 
os
 . 
path
 . 
join
 ( 
egg_info
 , 'METADATA' ) ,

157 
os
 . 
path
 . 
join
 ( 
egg_info
 , 'PKG-INFO' ) ,

159 
setup_dist
 = 
setuptools
 . 
Distribution
 (

160 
attrs
 = 
dict
 (

161 
install_requires
 = 
install_requires
 ,

162 
extras_require
 = 
extras_require
 ,

165 
write_requirements
 (

166 
setup_dist
 . 
get_command_obj
 ( 'egg_info' ) ,

168 
os
 . 
path
 . 
join
 ( 
egg_info
 , 'requires.txt' ) ,

169 ) 
	}

171 @ 
	`staticmethod

172 def 
	$_move_data_entries
 ( 
destination_eggdir
 , 
dist_data
 ) :

174 
dist_data
 = 
os
 . 
path
 . 
join
 ( 
destination_eggdir
 , 
dist_data
 )

175 
dist_data_scripts
 = 
os
 . 
path
 . 
join
 ( 
dist_data
 , 'scripts' )

176 if 
os
 . 
path
 . 
exists
 ( 
dist_data_scripts
 ) :

177 
egg_info_scripts
 = 
os
 . 
path
 . 
join
 (

178 
destination_eggdir
 , 'EGG-INFO' , 'scripts' )

179 
os
 . 
mkdir
 ( 
egg_info_scripts
 )

180 for 
entry
 in 
os
 . 
listdir
 ( 
dist_data_scripts
 ) :

183 if 
entry
 . 
endswith
 ( '.pyc' ) :

184 
os
 . 
unlink
 ( 
os
 . 
path
 . 
join
 ( 
dist_data_scripts
 , 
entry
 ) )

186 
os
 . 
rename
 (

187 
os
 . 
path
 . 
join
 ( 
dist_data_scripts
 , 
entry
 ) ,

188 
os
 . 
path
 . 
join
 ( 
egg_info_scripts
 , 
entry
 ) ,

190 
os
 . 
rmdir
 ( 
dist_data_scripts
 )

191 for 
subdir
 in 
filter
 ( 
os
 . 
path
 . 
exists
 , (

192 
os
 . 
path
 . 
join
 ( 
dist_data
 , 
d
 )

193 for 
d
 in ( 'data' , 'headers' , 'purelib' , 'platlib' )

195 
unpack
 ( 
subdir
 , 
destination_eggdir
 )

196 if 
os
 . 
path
 . 
exists
 ( 
dist_data
 ) :

197 
os
 . 
rmdir
 ( 
dist_data
 ) 
	}

199 @ 
	`staticmethod

200 def 
	$_fix_namespace_packages
 ( 
egg_info
 , 
destination_eggdir
 ) :

201 
namespace_packages
 = 
os
 . 
path
 . 
join
 (

202 
egg_info
 , 'namespace_packages.txt' )

203 if 
os
 . 
path
 . 
exists
 ( 
namespace_packages
 ) :

204 with 
open
 ( 
namespace_packages
 ) as 
fp
 :

205 
namespace_packages
 = 
fp
 . 
read
 ( ) . 
split
 ( )

206 for 
mod
 in 
namespace_packages
 :

207 
mod_dir
 = 
os
 . 
path
 . 
join
 ( 
destination_eggdir
 , * 
mod
 . 
split
 ( '.' ) )

208 
mod_init
 = 
os
 . 
path
 . 
join
 ( 
mod_dir
 , '__init__.py' )

209 if 
os
 . 
path
 . 
exists
 ( 
mod_dir
 ) and not 
os
 . 
path
 . 
exists
 ( 
mod_init
 ) :

210 with 
open
 ( 
mod_init
 , 'w' ) as 
fp
 :

211 
fp
 . 
write
 ( 
NAMESPACE_PACKAGE_INIT
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/glob.py

9 import 
	~os

10 import 
	~re

11 import 
	~fnmatch

13 
__all__
 = [ "glob" , "iglob" , "escape" ]

16 def 
	$glob
 ( 
pathname
 , 
recursive
 = False ) :

27 return 
list
 ( 
iglob
 ( 
pathname
 , 
recursive
 = 
recursive
 ) ) 
	}

30 def 
	$iglob
 ( 
pathname
 , 
recursive
 = False ) :

41 
it
 = 
_iglob
 ( 
pathname
 , 
recursive
 )

42 if 
recursive
 and 
_isrecursive
 ( 
pathname
 ) :

43 
s
 = 
next
 ( 
it
 )

44 assert not 
s

45 return 
it
 
	}

48 def 
	$_iglob
 ( 
pathname
 , 
recursive
 ) :

49 
dirname
 , 
basename
 = 
os
 . 
path
 . 
split
 ( 
pathname
 )

50 if not 
has_magic
 ( 
pathname
 ) :

51 if 
basename
 :

52 if 
os
 . 
path
 . 
lexists
 ( 
pathname
 ) :

53 yield 
pathname

56 if 
os
 . 
path
 . 
isdir
 ( 
dirname
 ) :

57 yield 
pathname

59 if not 
dirname
 :

60 if 
recursive
 and 
_isrecursive
 ( 
basename
 ) :

61 for 
x
 in 
glob2
 ( 
dirname
 , 
basename
 ) :

62 yield 
x

64 for 
x
 in 
glob1
 ( 
dirname
 , 
basename
 ) :

65 yield 
x

70 if 
dirname
 != 
pathname
 and 
has_magic
 ( 
dirname
 ) :

71 
dirs
 = 
_iglob
 ( 
dirname
 , 
recursive
 )

73 
dirs
 = [ 
dirname
 ]

74 if 
has_magic
 ( 
basename
 ) :

75 if 
recursive
 and 
_isrecursive
 ( 
basename
 ) :

76 
glob_in_dir
 = 
glob2

78 
glob_in_dir
 = 
glob1

80 
glob_in_dir
 = 
glob0

81 for 
dirname
 in 
dirs
 :

82 for 
name
 in 
glob_in_dir
 ( 
dirname
 , 
basename
 ) :

83 yield 
os
 . 
path
 . 
join
 ( 
dirname
 , 
name
 ) 
	}

91 def 
	$glob1
 ( 
dirname
 , 
pattern
 ) :

92 if not 
dirname
 :

93 if 
isinstance
 ( 
pattern
 , 
bytes
 ) :

94 
dirname
 = 
os
 . 
curdir
 . 
encode
 ( 'ASCII' )

96 
dirname
 = 
os
 . 
curdir

98 
names
 = 
os
 . 
listdir
 ( 
dirname
 )

99 except 
OSError
 :

101 return 
fnmatch
 . 
filter
 ( 
names
 , 
pattern
 ) 
	}

104 def 
	$glob0
 ( 
dirname
 , 
basename
 ) :

105 if not 
basename
 :

108 if 
os
 . 
path
 . 
isdir
 ( 
dirname
 ) :

109 return [ 
basename
 ]

111 if 
os
 . 
path
 . 
lexists
 ( 
os
 . 
path
 . 
join
 ( 
dirname
 , 
basename
 ) ) :

112 return [ 
basename
 ]

113 return [ ] 
	}

120 def 
	$glob2
 ( 
dirname
 , 
pattern
 ) :

121 assert 
_isrecursive
 ( 
pattern
 )

122 yield 
pattern
 [ : 0 ]

123 for 
x
 in 
_rlistdir
 ( 
dirname
 ) :

124 yield 
x
 
	}

128 def 
	$_rlistdir
 ( 
dirname
 ) :

129 if not 
dirname
 :

130 if 
isinstance
 ( 
dirname
 , 
bytes
 ) :

131 
dirname
 = 
os
 . 
curdir
 . 
encode
 ( 'ASCII' )

133 
dirname
 = 
os
 . 
curdir

135 
names
 = 
os
 . 
listdir
 ( 
dirname
 )

136 except 
os
 . 
error
 :

138 for 
x
 in 
names
 :

139 yield 
x

140 
path
 = 
os
 . 
path
 . 
join
 ( 
dirname
 , 
x
 ) if 
dirname
 else 
x

141 for 
y
 in 
_rlistdir
 ( 
path
 ) :

142 yield 
os
 . 
path
 . 
join
 ( 
x
 , 
y
 ) 
	}

145 
magic_check
 = 
re
 . 
compile
 ( '([*?[])' )

146 
magic_check_bytes
 = 
re
 . 
compile
 ( b'([*?[])' )

149 def 
	$has_magic
 ( 
s
 ) :

150 if 
isinstance
 ( 
s
 , 
bytes
 ) :

151 
match
 = 
magic_check_bytes
 . 
search
 ( 
s
 )

153 
match
 = 
magic_check
 . 
search
 ( 
s
 )

154 return 
match
 is not None 
	}

157 def 
	$_isrecursive
 ( 
pattern
 ) :

158 if 
isinstance
 ( 
pattern
 , 
bytes
 ) :

159 return 
pattern
 == b'**'

161 return 
pattern
 == '**' 
	}

164 def 
	$escape
 ( 
pathname
 ) :

169 
drive
 , 
pathname
 = 
os
 . 
path
 . 
splitdrive
 ( 
pathname
 )

170 if 
isinstance
 ( 
pathname
 , 
bytes
 ) :

171 
pathname
 = 
magic_check_bytes
 . 
sub
 ( br'[\1]' , 
pathname
 )

173 
pathname
 = 
magic_check
 . 
sub
 ( r'[\1]' , 
pathname
 )

174 return 
drive
 + 
pathname
 
	}


	@./env/lib/python3.7/site-packages/setuptools/_deprecation_warning.py

1 class 
	cSetuptoolsDeprecationWarning
 ( 
Warning
 ) :


	@./env/lib/python3.7/site-packages/setuptools/windows_support.py

1 import 
	~platform

2 import 
	~ctypes

5 def 
	$windows_only
 ( 
func
 ) :

6 if 
platform
 . 
system
 ( ) != 'Windows' :

7 return lambda * 
args
 , ** 
kwargs
 : None

8 return 
func
 
	}

11 @ 
	`windows_only

12 def 
	$hide_file
 ( 
path
 ) :

20 
__import__
 ( 'ctypes.wintypes' )

21 
SetFileAttributes
 = 
ctypes
 . 
windll
 . 
kernel32
 . 
SetFileAttributesW

22 
SetFileAttributes
 . 
argtypes
 = 
ctypes
 . 
wintypes
 . 
LPWSTR
 , 
ctypes
 . 
wintypes
 . 
DWORD

23 
SetFileAttributes
 . 
restype
 = 
ctypes
 . 
wintypes
 . 
BOOL

25 
FILE_ATTRIBUTE_HIDDEN
 = 0x02

27 
ret
 = 
SetFileAttributes
 ( 
path
 , 
FILE_ATTRIBUTE_HIDDEN
 )

28 if not 
ret
 :

29 raise 
ctypes
 . 
WinError
 ( ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/msvc.py

20 import 
	~os

21 import 
	~sys

22 import 
	~platform

23 import 
	~itertools

24 import 
	~distutils.errors

25 from 
	~setuptools.extern.packaging.version
 import 
LegacyVersion

27 from 
	~setuptools.extern.six.moves
 import 
filterfalse

29 from . 
	~monkey
 import 
get_unpatched

31 if 
platform
 . 
system
 ( ) == 'Windows' :

32 from 
	~setuptools.extern.six.moves
 import 
winreg

33 
safe_env
 = 
os
 . 
environ

40 class 
	cwinreg
 :

41 
HKEY_USERS
 = None

42 
HKEY_CURRENT_USER
 = None

43 
HKEY_LOCAL_MACHINE
 = None

44 
HKEY_CLASSES_ROOT
 = None

46 
safe_env
 = 
dict
 ( )

48 
_msvc9_suppress_errors
 = (

50 
ImportError
 ,

54 
distutils
 . 
errors
 . 
DistutilsPlatformError
 ,

58 from 
	~distutils.msvc9compiler
 import 
Reg

59 except 
_msvc9_suppress_errors
 :

63 def 
	$msvc9_find_vcvarsall
 ( 
version
 ) :

85 
VC_BASE
 = r'Software\%sMicrosoft\DevDiv\VCForPython\%0.1f'

86 
key
 = 
VC_BASE
 % ( '' , 
version
 )

89 
productdir
 = 
Reg
 . 
get_value
 ( 
key
 , "installdir" )

90 except 
KeyError
 :

93 
key
 = 
VC_BASE
 % ( 'Wow6432Node\\' , 
version
 )

94 
productdir
 = 
Reg
 . 
get_value
 ( 
key
 , "installdir" )

95 except 
KeyError
 :

96 
productdir
 = None

98 if 
productdir
 :

99 
vcvarsall
 = 
os
 . 
path
 . 
os
 . 
path
 . 
join
 ( 
productdir
 , "vcvarsall.bat" )

100 if 
os
 . 
path
 . 
isfile
 ( 
vcvarsall
 ) :

101 return 
vcvarsall

103 return 
get_unpatched
 ( 
msvc9_find_vcvarsall
 ) ( 
version
 ) 
	}

106 def 
	$msvc9_query_vcvarsall
 ( 
ver
 , 
arch
 = 'x86' , * 
args
 , ** 
kwargs
 ) :

136 
orig
 = 
get_unpatched
 ( 
msvc9_query_vcvarsall
 )

137 return 
orig
 ( 
ver
 , 
arch
 , * 
args
 , ** 
kwargs
 )

138 except 
distutils
 . 
errors
 . 
DistutilsPlatformError
 :

141 except 
ValueError
 :

147 return 
EnvironmentInfo
 ( 
arch
 , 
ver
 ) . 
return_env
 ( )

148 except 
distutils
 . 
errors
 . 
DistutilsPlatformError
 as 
exc
 :

149 
_augment_exception
 ( 
exc
 , 
ver
 , 
arch
 )

150 raise 
	}

153 def 
	$msvc14_get_vc_env
 ( 
plat_spec
 ) :

178 return 
get_unpatched
 ( 
msvc14_get_vc_env
 ) ( 
plat_spec
 )

179 except 
distutils
 . 
errors
 . 
DistutilsPlatformError
 :

185 return 
EnvironmentInfo
 ( 
plat_spec
 , 
vc_min_ver
 = 14.0 ) . 
return_env
 ( )

186 except 
distutils
 . 
errors
 . 
DistutilsPlatformError
 as 
exc
 :

187 
_augment_exception
 ( 
exc
 , 14.0 )

188 raise 
	}

191 def 
	$msvc14_gen_lib_options
 ( * 
args
 , ** 
kwargs
 ) :

197 if "numpy.distutils" in 
sys
 . 
modules
 :

198 import 
	~numpy
 as 
np

199 if 
LegacyVersion
 ( 
np
 . 
__version__
 ) < 
LegacyVersion
 ( '1.11.2' ) :

200 return 
np
 . 
distutils
 . 
ccompiler
 . 
gen_lib_options
 ( * 
args
 , ** 
kwargs
 )

201 return 
get_unpatched
 ( 
msvc14_gen_lib_options
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

204 def 
	$_augment_exception
 ( 
exc
 , 
version
 , 
arch
 = '' ) :

210 
message
 = 
exc
 . 
args
 [ 0 ]

212 if "vcvarsall" in 
message
 . 
lower
 ( ) or "visual c" in 
message
 . 
lower
 ( ) :

214 
tmpl
 = 'Microsoft Visual C++ {version:0.1f} is required.'

215 
message
 = 
tmpl
 . 
format
 ( ** 
locals
 ( ) )

216 
msdownload
 = 'www.microsoft.com/download/details.aspx?id=%d'

217 if 
version
 == 9.0 :

218 if 
arch
 . 
lower
 ( ) . 
find
 ( 'ia64' ) > - 1 :

221 
message
 += ' Get it with "Microsoft Windows SDK 7.0": '

222 
message
 += 
msdownload
 % 3138

227 
message
 += ' Get it from http://aka.ms/vcpython27'

228 elif 
version
 == 10.0 :

230 
message
 += ' Get it with "Microsoft Windows SDK 7.1": '

231 
message
 += 
msdownload
 % 8279

232 elif 
version
 >= 14.0 :

234 
message
 += ( ' Get it with "Microsoft Visual C++ Build Tools": ' r'https://visualstudio.microsoft.com/downloads/'

237 
exc
 . 
args
 = ( 
message
 , ) 
	}

240 class 
	cPlatformInfo
 :

249 
current_cpu
 = 
safe_env
 . 
get
 ( 'processor_architecture' , '' ) . 
lower
 ( )

251 def 
	$__init__
 ( 
self
 , 
arch
 ) :

252 
self
 . 
arch
 = 
arch
 . 
lower
 ( ) . 
replace
 ( 'x64' , 'amd64' ) 
	}

254 @ 
property

255 def 
	$target_cpu
 ( 
self
 ) :

256 return 
self
 . 
arch
 [ 
self
 . 
arch
 . 
find
 ( '_' ) + 1 : ] 
	}

258 def 
	$target_is_x86
 ( 
self
 ) :

259 return 
self
 . 
target_cpu
 == 'x86' 
	}

261 def 
	$current_is_x86
 ( 
self
 ) :

262 return 
self
 . 
current_cpu
 == 'x86' 
	}

264 def 
	$current_dir
 ( 
self
 , 
hidex86
 = False , 
x64
 = False ) :

281 if ( 
self
 . 
current_cpu
 == 'x86' and 
hidex86
 ) else r'\x64'

282 if ( 
self
 . 
current_cpu
 == 'amd64' and 
x64
 ) else r'\%s'

283 % 
self
 . 
current_cpu

284 ) 
	}

286 def 
	$target_dir
 ( 
self
 , 
hidex86
 = False , 
x64
 = False ) :

303 if ( 
self
 . 
target_cpu
 == 'x86' and 
hidex86
 ) else r'\x64'

304 if ( 
self
 . 
target_cpu
 == 'amd64' and 
x64
 ) else r'\%s'

305 % 
self
 . 
target_cpu

306 ) 
	}

308 def 
	$cross_dir
 ( 
self
 , 
forcex86
 = False ) :

324 
current
 = 'x86' if 
forcex86
 else 
self
 . 
current_cpu

326 if 
self
 . 
target_cpu
 == 
current
 else

327 
self
 . 
target_dir
 ( ) . 
replace
 ( '\\' , '\\%s_' % 
current
 )

328 ) 
	}

331 class 
	cRegistryInfo
 :

340 
HKEYS
 = ( 
winreg
 . 
HKEY_USERS
 ,

341 
winreg
 . 
HKEY_CURRENT_USER
 ,

342 
winreg
 . 
HKEY_LOCAL_MACHINE
 ,

343 
winreg
 . 
HKEY_CLASSES_ROOT
 )

345 def 
	$__init__
 ( 
self
 , 
platform_info
 ) :

346 
self
 . 
pi
 = 
platform_info
 
	}

348 @ 
property

349 def 
	$visualstudio
 ( 
self
 ) :

353 return 'VisualStudio' 
	}

355 @ 
property

356 def 
	$sxs
 ( 
self
 ) :

360 return 
os
 . 
path
 . 
join
 ( 
self
 . 
visualstudio
 , 'SxS' ) 
	}

362 @ 
property

363 def 
	$vc
 ( 
self
 ) :

367 return 
os
 . 
path
 . 
join
 ( 
self
 . 
sxs
 , 'VC7' ) 
	}

369 @ 
property

370 def 
	$vs
 ( 
self
 ) :

374 return 
os
 . 
path
 . 
join
 ( 
self
 . 
sxs
 , 'VS7' ) 
	}

376 @ 
property

377 def 
	$vc_for_python
 ( 
self
 ) :

381 return r'DevDiv\VCForPython' 
	}

383 @ 
property

384 def 
	$microsoft_sdk
 ( 
self
 ) :

388 return 'Microsoft SDKs' 
	}

390 @ 
property

391 def 
	$windows_sdk
 ( 
self
 ) :

395 return 
os
 . 
path
 . 
join
 ( 
self
 . 
microsoft_sdk
 , 'Windows' ) 
	}

397 @ 
property

398 def 
	$netfx_sdk
 ( 
self
 ) :

402 return 
os
 . 
path
 . 
join
 ( 
self
 . 
microsoft_sdk
 , 'NETFXSDK' ) 
	}

404 @ 
property

405 def 
	$windows_kits_roots
 ( 
self
 ) :

409 return r'Windows Kits\Installed Roots' 
	}

411 def 
	$microsoft
 ( 
self
 , 
key
 , 
x86
 = False ) :

426 
node64
 = '' if 
self
 . 
pi
 . 
current_is_x86
 ( ) or 
x86
 else 'Wow6432Node'

427 return 
os
 . 
path
 . 
join
 ( 'Software' , 
node64
 , 'Microsoft' , 
key
 ) 
	}

429 def 
	$lookup
 ( 
self
 , 
key
 , 
name
 ) :

444 
KEY_READ
 = 
winreg
 . 
KEY_READ

445 
openkey
 = 
winreg
 . 
OpenKey

446 
ms
 = 
self
 . 
microsoft

447 for 
hkey
 in 
self
 . 
HKEYS
 :

449 
bkey
 = 
openkey
 ( 
hkey
 , 
ms
 ( 
key
 ) , 0 , 
KEY_READ
 )

450 except ( 
OSError
 , 
IOError
 ) :

451 if not 
self
 . 
pi
 . 
current_is_x86
 ( ) :

453 
bkey
 = 
openkey
 ( 
hkey
 , 
ms
 ( 
key
 , True ) , 0 , 
KEY_READ
 )

454 except ( 
OSError
 , 
IOError
 ) :

459 return 
winreg
 . 
QueryValueEx
 ( 
bkey
 , 
name
 ) [ 0 ]

460 except ( 
OSError
 , 
IOError
 ) :

461 pass 
	}

464 class 
	cSystemInfo
 :

478 
WinDir
 = 
safe_env
 . 
get
 ( 'WinDir' , '' )

479 
ProgramFiles
 = 
safe_env
 . 
get
 ( 'ProgramFiles' , '' )

480 
ProgramFilesx86
 = 
safe_env
 . 
get
 ( 'ProgramFiles(x86)' , 
ProgramFiles
 )

482 def 
	$__init__
 ( 
self
 , 
registry_info
 , 
vc_ver
 = None ) :

483 
self
 . 
ri
 = 
registry_info

484 
self
 . 
pi
 = 
self
 . 
ri
 . 
pi

485 
self
 . 
vc_ver
 = 
vc_ver
 or 
self
 . 
_find_latest_available_vc_ver
 ( ) 
	}

487 def 
	$_find_latest_available_vc_ver
 ( 
self
 ) :

489 return 
self
 . 
find_available_vc_vers
 ( ) [ - 1 ]

490 except 
IndexError
 :

491 
err
 = 'No Microsoft Visual C++ version found'

492 raise 
distutils
 . 
errors
 . 
DistutilsPlatformError
 ( 
err
 ) 
	}

494 def 
	$find_available_vc_vers
 ( 
self
 ) :

498 
ms
 = 
self
 . 
ri
 . 
microsoft

499 
vckeys
 = ( 
self
 . 
ri
 . 
vc
 , 
self
 . 
ri
 . 
vc_for_python
 , 
self
 . 
ri
 . 
vs
 )

500 
vc_vers
 = [ ]

501 for 
hkey
 in 
self
 . 
ri
 . 
HKEYS
 :

502 for 
key
 in 
vckeys
 :

504 
bkey
 = 
winreg
 . 
OpenKey
 ( 
hkey
 , 
ms
 ( 
key
 ) , 0 , 
winreg
 . 
KEY_READ
 )

505 except ( 
OSError
 , 
IOError
 ) :

507 
subkeys
 , 
values
 , 
_
 = 
winreg
 . 
QueryInfoKey
 ( 
bkey
 )

508 for 
i
 in 
range
 ( 
values
 ) :

510 
ver
 = 
float
 ( 
winreg
 . 
EnumValue
 ( 
bkey
 , 
i
 ) [ 0 ] )

511 if 
ver
 not in 
vc_vers
 :

512 
vc_vers
 . 
append
 ( 
ver
 )

513 except 
ValueError
 :

515 for 
i
 in 
range
 ( 
subkeys
 ) :

517 
ver
 = 
float
 ( 
winreg
 . 
EnumKey
 ( 
bkey
 , 
i
 ) )

518 if 
ver
 not in 
vc_vers
 :

519 
vc_vers
 . 
append
 ( 
ver
 )

520 except 
ValueError
 :

522 return 
sorted
 ( 
vc_vers
 ) 
	}

524 @ 
property

525 def 
	$VSInstallDir
 ( 
self
 ) :

530 
name
 = 'Microsoft Visual Studio %0.1f' % 
self
 . 
vc_ver

531 
default
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ProgramFilesx86
 , 
name
 )

534 return 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
vs
 , '%0.1f' % 
self
 . 
vc_ver
 ) or 
default
 
	}

536 @ 
property

537 def 
	$VCInstallDir
 ( 
self
 ) :

541 
self
 . 
VSInstallDir

543 
guess_vc
 = 
self
 . 
_guess_vc
 ( ) or 
self
 . 
_guess_vc_legacy
 ( )

546 
reg_path
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
vc_for_python
 , '%0.1f' % 
self
 . 
vc_ver
 )

547 
python_vc
 = 
self
 . 
ri
 . 
lookup
 ( 
reg_path
 , 'installdir' )

548 
default_vc
 = 
os
 . 
path
 . 
join
 ( 
python_vc
 , 'VC' ) if 
python_vc
 else 
guess_vc

551 
path
 = 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
vc
 , '%0.1f' % 
self
 . 
vc_ver
 ) or 
default_vc

553 if not 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

554 
msg
 = 'Microsoft Visual C++ directory not found'

555 raise 
distutils
 . 
errors
 . 
DistutilsPlatformError
 ( 
msg
 )

557 return 
path
 
	}

559 def 
	$_guess_vc
 ( 
self
 ) :

563 if 
self
 . 
vc_ver
 <= 14.0 :

566 
default
 = r'VC\Tools\MSVC'

567 
guess_vc
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
VSInstallDir
 , 
default
 )

570 
vc_exact_ver
 = 
os
 . 
listdir
 ( 
guess_vc
 ) [ - 1 ]

571 return 
os
 . 
path
 . 
join
 ( 
guess_vc
 , 
vc_exact_ver
 )

572 except ( 
OSError
 , 
IOError
 , 
IndexError
 ) :

573 pass 
	}

575 def 
	$_guess_vc_legacy
 ( 
self
 ) :

579 
default
 = r'Microsoft Visual Studio %0.1f\VC' % 
self
 . 
vc_ver

580 return 
os
 . 
path
 . 
join
 ( 
self
 . 
ProgramFilesx86
 , 
default
 ) 
	}

582 @ 
property

583 def 
	$WindowsSdkVersion
 ( 
self
 ) :

587 if 
self
 . 
vc_ver
 <= 9.0 :

589 elif 
self
 . 
vc_ver
 == 10.0 :

591 elif 
self
 . 
vc_ver
 == 11.0 :

593 elif 
self
 . 
vc_ver
 == 12.0 :

595 elif 
self
 . 
vc_ver
 >= 14.0 :

596 return ( '10.0' , '8.1' ) 
	}

598 @ 
property

599 def 
	$WindowsSdkLastVersion
 ( 
self
 ) :

603 return 
self
 . 
_use_last_dir_name
 ( 
os
 . 
path
 . 
join
 (

604 
self
 . 
WindowsSdkDir
 , 'lib' ) ) 
	}

606 @ 
property

607 def 
	$WindowsSdkDir
 ( 
self
 ) :

611 
sdkdir
 = ''

612 for 
ver
 in 
self
 . 
WindowsSdkVersion
 :

614 
loc
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
windows_sdk
 , 'v%s' % 
ver
 )

615 
sdkdir
 = 
self
 . 
ri
 . 
lookup
 ( 
loc
 , 'installationfolder' )

616 if 
sdkdir
 :

618 if not 
sdkdir
 or not 
os
 . 
path
 . 
isdir
 ( 
sdkdir
 ) :

620 
path
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
vc_for_python
 , '%0.1f' % 
self
 . 
vc_ver
 )

621 
install_base
 = 
self
 . 
ri
 . 
lookup
 ( 
path
 , 'installdir' )

622 if 
install_base
 :

623 
sdkdir
 = 
os
 . 
path
 . 
join
 ( 
install_base
 , 'WinSDK' )

624 if not 
sdkdir
 or not 
os
 . 
path
 . 
isdir
 ( 
sdkdir
 ) :

626 for 
ver
 in 
self
 . 
WindowsSdkVersion
 :

627 
intver
 = 
ver
 [ : 
ver
 . 
rfind
 ( '.' ) ]

628 
path
 = r'Microsoft SDKs\Windows Kits\%s' % ( 
intver
 )

629 
d
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ProgramFiles
 , 
path
 )

630 if 
os
 . 
path
 . 
isdir
 ( 
d
 ) :

631 
sdkdir
 = 
d

632 if not 
sdkdir
 or not 
os
 . 
path
 . 
isdir
 ( 
sdkdir
 ) :

634 for 
ver
 in 
self
 . 
WindowsSdkVersion
 :

635 
path
 = r'Microsoft SDKs\Windows\v%s' % 
ver

636 
d
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ProgramFiles
 , 
path
 )

637 if 
os
 . 
path
 . 
isdir
 ( 
d
 ) :

638 
sdkdir
 = 
d

639 if not 
sdkdir
 :

641 
sdkdir
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
VCInstallDir
 , 'PlatformSDK' )

642 return 
sdkdir
 
	}

644 @ 
property

645 def 
	$WindowsSDKExecutablePath
 ( 
self
 ) :

650 if 
self
 . 
vc_ver
 <= 11.0 :

651 
netfxver
 = 35

652 
arch
 = ''

654 
netfxver
 = 40

655 
hidex86
 = True if 
self
 . 
vc_ver
 <= 12.0 else False

656 
arch
 = 
self
 . 
pi
 . 
current_dir
 ( 
x64
 = True , 
hidex86
 = 
hidex86
 )

657 
fx
 = 'WinSDK-NetFx%dTools%s' % ( 
netfxver
 , 
arch
 . 
replace
 ( '\\' , '-' ) )

660 
regpaths
 = [ ]

661 if 
self
 . 
vc_ver
 >= 14.0 :

662 for 
ver
 in 
self
 . 
NetFxSdkVersion
 :

663 
regpaths
 += [ 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
netfx_sdk
 , 
ver
 , 
fx
 ) ]

665 for 
ver
 in 
self
 . 
WindowsSdkVersion
 :

666 
regpaths
 += [ 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
windows_sdk
 , 'v%sA' % 
ver
 , 
fx
 ) ]

669 for 
path
 in 
regpaths
 :

670 
execpath
 = 
self
 . 
ri
 . 
lookup
 ( 
path
 , 'installationfolder' )

671 if 
execpath
 :

673 return 
execpath
 
	}

675 @ 
property

676 def 
	$FSharpInstallDir
 ( 
self
 ) :

680 
path
 = r'%0.1f\Setup\F#' % 
self
 . 
vc_ver

681 
path
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
visualstudio
 , 
path
 )

682 return 
self
 . 
ri
 . 
lookup
 ( 
path
 , 'productdir' ) or '' 
	}

684 @ 
property

685 def 
	$UniversalCRTSdkDir
 ( 
self
 ) :

690 if 
self
 . 
vc_ver
 >= 14.0 :

691 
vers
 = ( '10' , '81' )

693 
vers
 = ( )

696 for 
ver
 in 
vers
 :

697 
sdkdir
 = 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
windows_kits_roots
 , 'kitsroot%s'

698 % 
ver
 )

699 if 
sdkdir
 :

701 return 
sdkdir
 or '' 
	}

703 @ 
property

704 def 
	$UniversalCRTSdkLastVersion
 ( 
self
 ) :

708 return 
self
 . 
_use_last_dir_name
 ( 
os
 . 
path
 . 
join
 (

709 
self
 . 
UniversalCRTSdkDir
 , 'lib' ) ) 
	}

711 @ 
property

712 def 
	$NetFxSdkVersion
 ( 
self
 ) :

717 if 
self
 . 
vc_ver
 >= 14.0 :

720 return ( ) 
	}

722 @ 
property

723 def 
	$NetFxSdkDir
 ( 
self
 ) :

727 for 
ver
 in 
self
 . 
NetFxSdkVersion
 :

728 
loc
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
ri
 . 
netfx_sdk
 , 
ver
 )

729 
sdkdir
 = 
self
 . 
ri
 . 
lookup
 ( 
loc
 , 'kitsinstallationfolder' )

730 if 
sdkdir
 :

732 return 
sdkdir
 or '' 
	}

734 @ 
property

735 def 
	$FrameworkDir32
 ( 
self
 ) :

740 
guess_fw
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
WinDir
 , r'Microsoft.NET\Framework' )

743 return 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
vc
 , 'frameworkdir32' ) or 
guess_fw
 
	}

745 @ 
property

746 def 
	$FrameworkDir64
 ( 
self
 ) :

751 
guess_fw
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
WinDir
 , r'Microsoft.NET\Framework64' )

754 return 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
vc
 , 'frameworkdir64' ) or 
guess_fw
 
	}

756 @ 
property

757 def 
	$FrameworkVersion32
 ( 
self
 ) :

761 return 
self
 . 
_find_dot_net_versions
 ( 32 ) 
	}

763 @ 
property

764 def 
	$FrameworkVersion64
 ( 
self
 ) :

768 return 
self
 . 
_find_dot_net_versions
 ( 64 ) 
	}

770 def 
	$_find_dot_net_versions
 ( 
self
 , 
bits
 ) :

780 
reg_ver
 = 
self
 . 
ri
 . 
lookup
 ( 
self
 . 
ri
 . 
vc
 , 'frameworkver%d' % 
bits
 )

781 
dot_net_dir
 = 
getattr
 ( 
self
 , 'FrameworkDir%d' % 
bits
 )

782 
ver
 = 
reg_ver
 or 
self
 . 
_use_last_dir_name
 ( 
dot_net_dir
 , 'v' ) or ''

785 if 
self
 . 
vc_ver
 >= 12.0 :

786 
frameworkver
 = ( 
ver
 , 'v4.0' )

787 elif 
self
 . 
vc_ver
 >= 10.0 :

788 
frameworkver
 = ( 'v4.0.30319' if 
ver
 . 
lower
 ( ) [ : 2 ] != 'v4' else 
ver
 , 'v3.5'

790 elif 
self
 . 
vc_ver
 == 9.0 :

791 
frameworkver
 = ( 'v3.5' , 'v2.0.50727' )

792 if 
self
 . 
vc_ver
 == 8.0 :

793 
frameworkver
 = ( 'v3.0' , 'v2.0.50727' )

794 return 
frameworkver
 
	}

796 def 
	$_use_last_dir_name
 ( 
self
 , 
path
 , 
prefix
 = '' ) :

807 
matching_dirs
 = (

808 
dir_name

809 for 
dir_name
 in 
reversed
 ( 
os
 . 
listdir
 ( 
path
 ) )

810 if 
os
 . 
path
 . 
isdir
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
dir_name
 ) ) and

811 
dir_name
 . 
startswith
 ( 
prefix
 )

813 return 
next
 ( 
matching_dirs
 , None ) or '' 
	}

816 class 
	cEnvironmentInfo
 :

840 def 
	$__init__
 ( 
self
 , 
arch
 , 
vc_ver
 = None , 
vc_min_ver
 = 0 ) :

841 
self
 . 
pi
 = 
PlatformInfo
 ( 
arch
 )

842 
self
 . 
ri
 = 
RegistryInfo
 ( 
self
 . 
pi
 )

843 
self
 . 
si
 = 
SystemInfo
 ( 
self
 . 
ri
 , 
vc_ver
 )

845 if 
self
 . 
vc_ver
 < 
vc_min_ver
 :

846 
err
 = 'No suitable Microsoft Visual C++ version found'

847 raise 
distutils
 . 
errors
 . 
DistutilsPlatformError
 ( 
err
 ) 
	}

849 @ 
property

850 def 
	$vc_ver
 ( 
self
 ) :

854 return 
self
 . 
si
 . 
vc_ver
 
	}

856 @ 
property

857 def 
	$VSTools
 ( 
self
 ) :

861 
paths
 = [ r'Common7\IDE' , r'Common7\Tools' ]

863 if 
self
 . 
vc_ver
 >= 14.0 :

864 
arch_subdir
 = 
self
 . 
pi
 . 
current_dir
 ( 
hidex86
 = True , 
x64
 = True )

865 
paths
 += [ r'Common7\IDE\CommonExtensions\Microsoft\TestWindow' ]

866 
paths
 += [ r'Team Tools\Performance Tools' ]

867 
paths
 += [ r'Team Tools\Performance Tools%s' % 
arch_subdir
 ]

869 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VSInstallDir
 , 
path
 ) for 
path
 in 
paths
 ] 
	}

871 @ 
property

872 def 
	$VCIncludes
 ( 
self
 ) :

876 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VCInstallDir
 , 'Include' ) ,

877 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VCInstallDir
 , r'ATLMFC\Include' ) ] 
	}

879 @ 
property

880 def 
	$VCLibraries
 ( 
self
 ) :

884 if 
self
 . 
vc_ver
 >= 15.0 :

885 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True )

887 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
hidex86
 = True )

888 
paths
 = [ 'Lib%s' % 
arch_subdir
 , r'ATLMFC\Lib%s' % 
arch_subdir
 ]

890 if 
self
 . 
vc_ver
 >= 14.0 :

891 
paths
 += [ r'Lib\store%s' % 
arch_subdir
 ]

893 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VCInstallDir
 , 
path
 ) for 
path
 in 
paths
 ] 
	}

895 @ 
property

896 def 
	$VCStoreRefs
 ( 
self
 ) :

900 if 
self
 . 
vc_ver
 < 14.0 :

902 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VCInstallDir
 , r'Lib\store\references' ) ] 
	}

904 @ 
property

905 def 
	$VCTools
 ( 
self
 ) :

909 
si
 = 
self
 . 
si

910 
tools
 = [ 
os
 . 
path
 . 
join
 ( 
si
 . 
VCInstallDir
 , 'VCPackages' ) ]

912 
forcex86
 = True if 
self
 . 
vc_ver
 <= 10.0 else False

913 
arch_subdir
 = 
self
 . 
pi
 . 
cross_dir
 ( 
forcex86
 )

914 if 
arch_subdir
 :

915 
tools
 += [ 
os
 . 
path
 . 
join
 ( 
si
 . 
VCInstallDir
 , 'Bin%s' % 
arch_subdir
 ) ]

917 if 
self
 . 
vc_ver
 == 14.0 :

918 
path
 = 'Bin%s' % 
self
 . 
pi
 . 
current_dir
 ( 
hidex86
 = True )

919 
tools
 += [ 
os
 . 
path
 . 
join
 ( 
si
 . 
VCInstallDir
 , 
path
 ) ]

921 elif 
self
 . 
vc_ver
 >= 15.0 :

922 
host_dir
 = ( r'bin\HostX86%s' if 
self
 . 
pi
 . 
current_is_x86
 ( ) else r'bin\HostX64%s'

924 
tools
 += [ 
os
 . 
path
 . 
join
 (

925 
si
 . 
VCInstallDir
 , 
host_dir
 % 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True ) ) ]

927 if 
self
 . 
pi
 . 
current_cpu
 != 
self
 . 
pi
 . 
target_cpu
 :

928 
tools
 += [ 
os
 . 
path
 . 
join
 (

929 
si
 . 
VCInstallDir
 , 
host_dir
 % 
self
 . 
pi
 . 
current_dir
 ( 
x64
 = True ) ) ]

932 
tools
 += [ 
os
 . 
path
 . 
join
 ( 
si
 . 
VCInstallDir
 , 'Bin' ) ]

934 return 
tools
 
	}

936 @ 
property

937 def 
	$OSLibraries
 ( 
self
 ) :

941 if 
self
 . 
vc_ver
 <= 10.0 :

942 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
hidex86
 = True , 
x64
 = True )

943 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'Lib%s' % 
arch_subdir
 ) ]

946 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True )

947 
lib
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'lib' )

948 
libver
 = 
self
 . 
_sdk_subdir

949 return [ 
os
 . 
path
 . 
join
 ( 
lib
 , '%sum%s' % ( 
libver
 , 
arch_subdir
 ) ) ] 
	}

951 @ 
property

952 def 
	$OSIncludes
 ( 
self
 ) :

956 
include
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'include' )

958 if 
self
 . 
vc_ver
 <= 10.0 :

959 return [ 
include
 , 
os
 . 
path
 . 
join
 ( 
include
 , 'gl' ) ]

962 if 
self
 . 
vc_ver
 >= 14.0 :

963 
sdkver
 = 
self
 . 
_sdk_subdir

965 
sdkver
 = ''

966 return [ 
os
 . 
path
 . 
join
 ( 
include
 , '%sshared' % 
sdkver
 ) ,

967 
os
 . 
path
 . 
join
 ( 
include
 , '%sum' % 
sdkver
 ) ,

968 
os
 . 
path
 . 
join
 ( 
include
 , '%swinrt' % 
sdkver
 ) ] 
	}

970 @ 
property

971 def 
	$OSLibpath
 ( 
self
 ) :

975 
ref
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'References' )

976 
libpath
 = [ ]

978 if 
self
 . 
vc_ver
 <= 9.0 :

979 
libpath
 += 
self
 . 
OSLibraries

981 if 
self
 . 
vc_ver
 >= 11.0 :

982 
libpath
 += [ 
os
 . 
path
 . 
join
 ( 
ref
 , r'CommonConfiguration\Neutral' ) ]

984 if 
self
 . 
vc_ver
 >= 14.0 :

985 
libpath
 += [

986 
ref
 ,

987 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'UnionMetadata' ) ,

988 
os
 . 
path
 . 
join
 (

989 
ref
 , 'Windows.Foundation.UniversalApiContract'

993 
os
 . 
path
 . 
join
 (

994 
ref
 , 'Windows.Foundation.FoundationContract'

998 
os
 . 
path
 . 
join
 (

999 
ref
 , 'Windows.Networking.Connectivity.WwanContract'

1003 
os
 . 
path
 . 
join
 (

1004 
self
 . 
si
 . 
WindowsSdkDir
 , 'ExtensionSDKs'

1007 % 
self
 . 
vc_ver
 , 'References'

1013 return 
libpath
 
	}

1015 @ 
property

1016 def 
	$SdkTools
 ( 
self
 ) :

1020 return 
list
 ( 
self
 . 
_sdk_tools
 ( ) ) 
	}

1022 def 
	$_sdk_tools
 ( 
self
 ) :

1026 if 
self
 . 
vc_ver
 < 15.0 :

1027 
bin_dir
 = 'Bin' if 
self
 . 
vc_ver
 <= 11.0 else r'Bin\x86'

1028 yield 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 
bin_dir
 )

1030 if not 
self
 . 
pi
 . 
current_is_x86
 ( ) :

1031 
arch_subdir
 = 
self
 . 
pi
 . 
current_dir
 ( 
x64
 = True )

1032 
path
 = 'Bin%s' % 
arch_subdir

1033 yield 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 
path
 )

1035 if 
self
 . 
vc_ver
 == 10.0 or 
self
 . 
vc_ver
 == 11.0 :

1036 if 
self
 . 
pi
 . 
target_is_x86
 ( ) :

1037 
arch_subdir
 = ''

1039 
arch_subdir
 = 
self
 . 
pi
 . 
current_dir
 ( 
hidex86
 = True , 
x64
 = True )

1040 
path
 = r'Bin\NETFX 4.0 Tools%s' % 
arch_subdir

1041 yield 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 
path
 )

1043 elif 
self
 . 
vc_ver
 >= 15.0 :

1044 
path
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'Bin' )

1045 
arch_subdir
 = 
self
 . 
pi
 . 
current_dir
 ( 
x64
 = True )

1046 
sdkver
 = 
self
 . 
si
 . 
WindowsSdkLastVersion

1047 yield 
os
 . 
path
 . 
join
 ( 
path
 , '%s%s' % ( 
sdkver
 , 
arch_subdir
 ) )

1049 if 
self
 . 
si
 . 
WindowsSDKExecutablePath
 :

1050 yield 
self
 . 
si
 . 
WindowsSDKExecutablePath
 
	}

1052 @ 
property

1053 def 
	$_sdk_subdir
 ( 
self
 ) :

1057 
ucrtver
 = 
self
 . 
si
 . 
WindowsSdkLastVersion

1058 return ( '%s\\' % 
ucrtver
 ) if 
ucrtver
 else '' 
	}

1060 @ 
property

1061 def 
	$SdkSetup
 ( 
self
 ) :

1065 if 
self
 . 
vc_ver
 > 9.0 :

1068 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
WindowsSdkDir
 , 'Setup' ) ] 
	}

1070 @ 
property

1071 def 
	$FxTools
 ( 
self
 ) :

1075 
pi
 = 
self
 . 
pi

1076 
si
 = 
self
 . 
si

1078 if 
self
 . 
vc_ver
 <= 10.0 :

1079 
include32
 = True

1080 
include64
 = not 
pi
 . 
target_is_x86
 ( ) and not 
pi
 . 
current_is_x86
 ( )

1082 
include32
 = 
pi
 . 
target_is_x86
 ( ) or 
pi
 . 
current_is_x86
 ( )

1083 
include64
 = 
pi
 . 
current_cpu
 == 'amd64' or 
pi
 . 
target_cpu
 == 'amd64'

1085 
tools
 = [ ]

1086 if 
include32
 :

1087 
tools
 += [ 
os
 . 
path
 . 
join
 ( 
si
 . 
FrameworkDir32
 , 
ver
 )

1088 for 
ver
 in 
si
 . 
FrameworkVersion32
 ]

1089 if 
include64
 :

1090 
tools
 += [ 
os
 . 
path
 . 
join
 ( 
si
 . 
FrameworkDir64
 , 
ver
 )

1091 for 
ver
 in 
si
 . 
FrameworkVersion64
 ]

1092 return 
tools
 
	}

1094 @ 
property

1095 def 
	$NetFxSDKLibraries
 ( 
self
 ) :

1099 if 
self
 . 
vc_ver
 < 14.0 or not 
self
 . 
si
 . 
NetFxSdkDir
 :

1102 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True )

1103 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
NetFxSdkDir
 , r'lib\um%s' % 
arch_subdir
 ) ] 
	}

1105 @ 
property

1106 def 
	$NetFxSDKIncludes
 ( 
self
 ) :

1110 if 
self
 . 
vc_ver
 < 14.0 or not 
self
 . 
si
 . 
NetFxSdkDir
 :

1113 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
NetFxSdkDir
 , r'include\um' ) ] 
	}

1115 @ 
property

1116 def 
	$VsTDb
 ( 
self
 ) :

1120 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
VSInstallDir
 , r'VSTSDB\Deploy' ) ] 
	}

1122 @ 
property

1123 def 
	$MSBuild
 ( 
self
 ) :

1127 if 
self
 . 
vc_ver
 < 12.0 :

1129 elif 
self
 . 
vc_ver
 < 15.0 :

1130 
base_path
 = 
self
 . 
si
 . 
ProgramFilesx86

1131 
arch_subdir
 = 
self
 . 
pi
 . 
current_dir
 ( 
hidex86
 = True )

1133 
base_path
 = 
self
 . 
si
 . 
VSInstallDir

1134 
arch_subdir
 = ''

1136 
path
 = r'MSBuild\%0.1f\bin%s' % ( 
self
 . 
vc_ver
 , 
arch_subdir
 )

1137 
build
 = [ 
os
 . 
path
 . 
join
 ( 
base_path
 , 
path
 ) ]

1139 if 
self
 . 
vc_ver
 >= 15.0 :

1141 
build
 += [ 
os
 . 
path
 . 
join
 ( 
base_path
 , 
path
 , 'Roslyn' ) ]

1143 return 
build
 
	}

1145 @ 
property

1146 def 
	$HTMLHelpWorkshop
 ( 
self
 ) :

1150 if 
self
 . 
vc_ver
 < 11.0 :

1153 return [ 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
ProgramFilesx86
 , 'HTML Help Workshop' ) ] 
	}

1155 @ 
property

1156 def 
	$UCRTLibraries
 ( 
self
 ) :

1160 if 
self
 . 
vc_ver
 < 14.0 :

1163 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True )

1164 
lib
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
UniversalCRTSdkDir
 , 'lib' )

1165 
ucrtver
 = 
self
 . 
_ucrt_subdir

1166 return [ 
os
 . 
path
 . 
join
 ( 
lib
 , '%sucrt%s' % ( 
ucrtver
 , 
arch_subdir
 ) ) ] 
	}

1168 @ 
property

1169 def 
	$UCRTIncludes
 ( 
self
 ) :

1173 if 
self
 . 
vc_ver
 < 14.0 :

1176 
include
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
si
 . 
UniversalCRTSdkDir
 , 'include' )

1177 return [ 
os
 . 
path
 . 
join
 ( 
include
 , '%sucrt' % 
self
 . 
_ucrt_subdir
 ) ] 
	}

1179 @ 
property

1180 def 
	$_ucrt_subdir
 ( 
self
 ) :

1184 
ucrtver
 = 
self
 . 
si
 . 
UniversalCRTSdkLastVersion

1185 return ( '%s\\' % 
ucrtver
 ) if 
ucrtver
 else '' 
	}

1187 @ 
property

1188 def 
	$FSharp
 ( 
self
 ) :

1192 if 
self
 . 
vc_ver
 < 11.0 and 
self
 . 
vc_ver
 > 12.0 :

1195 return 
self
 . 
si
 . 
FSharpInstallDir
 
	}

1197 @ 
property

1198 def 
	$VCRuntimeRedist
 ( 
self
 ) :

1202 
arch_subdir
 = 
self
 . 
pi
 . 
target_dir
 ( 
x64
 = True )

1203 if 
self
 . 
vc_ver
 < 15 :

1204 
redist_path
 = 
self
 . 
si
 . 
VCInstallDir

1205 
vcruntime
 = 'redist%s\\Microsoft.VC%d0.CRT\\vcruntime%d0.dll'

1207 
redist_path
 = 
self
 . 
si
 . 
VCInstallDir
 . 
replace
 ( '\\Tools' , '\\Redist' )

1208 
vcruntime
 = 'onecore%s\\Microsoft.VC%d0.CRT\\vcruntime%d0.dll'

1211 
dll_ver
 = 14.0 if 
self
 . 
vc_ver
 == 15 else 
self
 . 
vc_ver

1213 
vcruntime
 = 
vcruntime
 % ( 
arch_subdir
 , 
self
 . 
vc_ver
 , 
dll_ver
 )

1214 return 
os
 . 
path
 . 
join
 ( 
redist_path
 , 
vcruntime
 ) 
	}

1216 def 
	$return_env
 ( 
self
 , 
exists
 = True ) :

1225 
env
 = 
dict
 (

1226 
include
 = 
self
 . 
_build_paths
 ( 'include' ,

1227 [ 
self
 . 
VCIncludes
 ,

1228 
self
 . 
OSIncludes
 ,

1229 
self
 . 
UCRTIncludes
 ,

1230 
self
 . 
NetFxSDKIncludes
 ] ,

1231 
exists
 ) ,

1232 
lib
 = 
self
 . 
_build_paths
 ( 'lib' ,

1233 [ 
self
 . 
VCLibraries
 ,

1234 
self
 . 
OSLibraries
 ,

1235 
self
 . 
FxTools
 ,

1236 
self
 . 
UCRTLibraries
 ,

1237 
self
 . 
NetFxSDKLibraries
 ] ,

1238 
exists
 ) ,

1239 
libpath
 = 
self
 . 
_build_paths
 ( 'libpath' ,

1240 [ 
self
 . 
VCLibraries
 ,

1241 
self
 . 
FxTools
 ,

1242 
self
 . 
VCStoreRefs
 ,

1243 
self
 . 
OSLibpath
 ] ,

1244 
exists
 ) ,

1245 
path
 = 
self
 . 
_build_paths
 ( 'path' ,

1246 [ 
self
 . 
VCTools
 ,

1247 
self
 . 
VSTools
 ,

1248 
self
 . 
VsTDb
 ,

1249 
self
 . 
SdkTools
 ,

1250 
self
 . 
SdkSetup
 ,

1251 
self
 . 
FxTools
 ,

1252 
self
 . 
MSBuild
 ,

1253 
self
 . 
HTMLHelpWorkshop
 ,

1254 
self
 . 
FSharp
 ] ,

1255 
exists
 ) ,

1257 if 
self
 . 
vc_ver
 >= 14 and 
os
 . 
path
 . 
isfile
 ( 
self
 . 
VCRuntimeRedist
 ) :

1258 
env
 [ 'py_vcruntime_redist' ] = 
self
 . 
VCRuntimeRedist

1259 return 
env
 
	}

1261 def 
	$_build_paths
 ( 
self
 , 
name
 , 
spec_path_lists
 , 
exists
 ) :

1270 
spec_paths
 = 
itertools
 . 
chain
 . 
from_iterable
 ( 
spec_path_lists
 )

1271 
env_paths
 = 
safe_env
 . 
get
 ( 
name
 , '' ) . 
split
 ( 
os
 . 
pathsep
 )

1272 
paths
 = 
itertools
 . 
chain
 ( 
spec_paths
 , 
env_paths
 )

1273 
extant_paths
 = 
list
 ( 
filter
 ( 
os
 . 
path
 . 
isdir
 , 
paths
 ) ) if 
exists
 else 
paths

1274 if not 
extant_paths
 :

1275 
msg
 = "%s environment variable is empty" % 
name
 . 
upper
 ( )

1276 raise 
distutils
 . 
errors
 . 
DistutilsPlatformError
 ( 
msg
 )

1277 
unique_paths
 = 
self
 . 
_unique_everseen
 ( 
extant_paths
 )

1278 return 
os
 . 
pathsep
 . 
join
 ( 
unique_paths
 ) 
	}

1281 def 
	$_unique_everseen
 ( 
self
 , 
iterable
 , 
key
 = None ) :

1290 
seen
 = 
set
 ( )

1291 
seen_add
 = 
seen
 . 
add

1292 if 
key
 is None :

1293 for 
element
 in 
filterfalse
 ( 
seen
 . 
__contains__
 , 
iterable
 ) :

1294 
seen_add
 ( 
element
 )

1295 yield 
element

1297 for 
element
 in 
iterable
 :

1298 
k
 = 
key
 ( 
element
 )

1299 if 
k
 not in 
seen
 :

1300 
seen_add
 ( 
k
 )

1301 yield 
element
 
	}


	@./env/lib/python3.7/site-packages/setuptools/extension.py

1 import 
	~re

2 import 
	~functools

3 import 
	~distutils.core

4 import 
	~distutils.errors

5 import 
	~distutils.extension

7 from 
	~setuptools.extern.six.moves
 import 
map

9 from . 
	~monkey
 import 
get_unpatched

12 def 
	$_have_cython
 ( ) :

16 
cython_impl
 = 'Cython.Distutils.build_ext'

19 
__import__
 ( 
cython_impl
 , 
fromlist
 = [ 'build_ext' ] ) . 
build_ext

21 except 
Exception
 :

23 return False 
	}

27 
have_pyrex
 = 
_have_cython

29 
_Extension
 = 
get_unpatched
 ( 
distutils
 . 
core
 . 
Extension
 )

32 class 
	cExtension
 ( 
_Extension
 ) :

35 def 
	$__init__
 ( 
self
 , 
name
 , 
sources
 , * 
args
 , ** 
kw
 ) :

38 
self
 . 
py_limited_api
 = 
kw
 . 
pop
 ( "py_limited_api" , False )

39 
_Extension
 . 
__init__
 ( 
self
 , 
name
 , 
sources
 , * 
args
 , ** 
kw
 ) 
	}

41 def 
	$_convert_pyx_sources_to_lang
 ( 
self
 ) :

47 if 
_have_cython
 ( ) :

50 
lang
 = 
self
 . 
language
 or ''

51 
target_ext
 = '.cpp' if 
lang
 . 
lower
 ( ) == 'c++' else '.c'

52 
sub
 = 
functools
 . 
partial
 ( 
re
 . 
sub
 , '.pyx$' , 
target_ext
 )

53 
self
 . 
sources
 = 
list
 ( 
map
 ( 
sub
 , 
self
 . 
sources
 ) ) 
	}

56 class 
	cLibrary
 ( 
Extension
 ) :


	@./env/lib/python3.7/site-packages/setuptools/dist.py

2 
__all__
 = [ 'Distribution' ]

4 import 
	~io

5 import 
	~sys

6 import 
	~re

7 import 
	~os

8 import 
	~warnings

9 import 
	~numbers

10 import 
	~distutils.log

11 import 
	~distutils.core

12 import 
	~distutils.cmd

13 import 
	~distutils.dist

14 from 
	~distutils.errors
 import 
DistutilsOptionError

15 from 
	~distutils.util
 import 
strtobool

16 from 
	~distutils.debug
 import 
DEBUG

17 from 
	~distutils.fancy_getopt
 import 
translate_longopt

18 import 
	~itertools

20 from 
	~collections
 import 
defaultdict

21 from 
	~email
 import 
message_from_file

23 from 
	~distutils.errors
 import (

24 
DistutilsOptionError
 , 
DistutilsPlatformError
 , 
DistutilsSetupError
 ,

26 from 
	~distutils.util
 import 
rfc822_escape

27 from 
	~distutils.version
 import 
StrictVersion

29 from 
	~setuptools.extern
 import 
six

30 from 
	~setuptools.extern
 import 
packaging

31 from 
	~setuptools.extern.six.moves
 import 
map
 , 
filter
 , 
filterfalse

33 from . import 
SetuptoolsDeprecationWarning

35 from 
	~setuptools.depends
 import 
Require

36 from 
	~setuptools
 import 
windows_support

37 from 
	~setuptools.monkey
 import 
get_unpatched

38 from 
	~setuptools.config
 import 
parse_configuration

39 from . 
	~unicode_utils
 import 
detect_encoding

40 import 
	~pkg_resources

42 
__import__
 ( 'setuptools.extern.packaging.specifiers' )

43 
__import__
 ( 'setuptools.extern.packaging.version' )

46 def 
	$_get_unpatched
 ( 
cls
 ) :

47 
warnings
 . 
warn
 ( "Do not call this function" , 
DistDeprecationWarning
 )

48 return 
get_unpatched
 ( 
cls
 ) 
	}

51 def 
	$get_metadata_version
 ( 
self
 ) :

52 
mv
 = 
getattr
 ( 
self
 , 'metadata_version' , None )

54 if 
mv
 is None :

55 if 
self
 . 
long_description_content_type
 or 
self
 . 
provides_extras
 :

56 
mv
 = 
StrictVersion
 ( '2.1' )

57 elif ( 
self
 . 
maintainer
 is not None or

58 
self
 . 
maintainer_email
 is not None or

59 
getattr
 ( 
self
 , 'python_requires' , None ) is not None ) :

60 
mv
 = 
StrictVersion
 ( '1.2' )

61 elif ( 
self
 . 
provides
 or 
self
 . 
requires
 or 
self
 . 
obsoletes
 or

62 
self
 . 
classifiers
 or 
self
 . 
download_url
 ) :

63 
mv
 = 
StrictVersion
 ( '1.1' )

65 
mv
 = 
StrictVersion
 ( '1.0' )

67 
self
 . 
metadata_version
 = 
mv

69 return 
mv
 
	}

72 def 
	$read_pkg_file
 ( 
self
 , 
file
 ) :

74 
msg
 = 
message_from_file
 ( 
file
 )

76 def 
_read_field
 ( 
name
 ) :

77 
value
 = 
msg
 [ 
name
 ]

78 if 
value
 == 'UNKNOWN' :

80 return 
value

82 def 
_read_list
 ( 
name
 ) :

83 
values
 = 
msg
 . 
get_all
 ( 
name
 , None )

84 if 
values
 == [ ] :

86 return 
values

88 
self
 . 
metadata_version
 = 
StrictVersion
 ( 
msg
 [ 'metadata-version' ] )

89 
self
 . 
name
 = 
_read_field
 ( 'name' )

90 
self
 . 
version
 = 
_read_field
 ( 'version' )

91 
self
 . 
description
 = 
_read_field
 ( 'summary' )

93 
self
 . 
author
 = 
_read_field
 ( 'author' )

94 
self
 . 
maintainer
 = None

95 
self
 . 
author_email
 = 
_read_field
 ( 'author-email' )

96 
self
 . 
maintainer_email
 = None

97 
self
 . 
url
 = 
_read_field
 ( 'home-page' )

98 
self
 . 
license
 = 
_read_field
 ( 'license' )

100 if 'download-url' in 
msg
 :

101 
self
 . 
download_url
 = 
_read_field
 ( 'download-url' )

103 
self
 . 
download_url
 = None

105 
self
 . 
long_description
 = 
_read_field
 ( 'description' )

106 
self
 . 
description
 = 
_read_field
 ( 'summary' )

108 if 'keywords' in 
msg
 :

109 
self
 . 
keywords
 = 
_read_field
 ( 'keywords' ) . 
split
 ( ',' )

111 
self
 . 
platforms
 = 
_read_list
 ( 'platform' )

112 
self
 . 
classifiers
 = 
_read_list
 ( 'classifier' )

115 if 
self
 . 
metadata_version
 == 
StrictVersion
 ( '1.1' ) :

116 
self
 . 
requires
 = 
_read_list
 ( 'requires' )

117 
self
 . 
provides
 = 
_read_list
 ( 'provides' )

118 
self
 . 
obsoletes
 = 
_read_list
 ( 'obsoletes' )

120 
self
 . 
requires
 = None

121 
self
 . 
provides
 = None

122 
self
 . 
obsoletes
 = None 
	}

126 def 
	$write_pkg_file
 ( 
self
 , 
file
 ) :

129 
version
 = 
self
 . 
get_metadata_version
 ( )

131 if 
six
 . 
PY2
 :

132 def 
write_field
 ( 
key
 , 
value
 ) :

133 
file
 . 
write
 ( "%s: %s\n" % ( 
key
 , 
self
 . 
_encode_field
 ( 
value
 ) ) )

135 def 
write_field
 ( 
key
 , 
value
 ) :

136 
file
 . 
write
 ( "%s: %s\n" % ( 
key
 , 
value
 ) )

139 
write_field
 ( 'Metadata-Version' , 
str
 ( 
version
 ) )

140 
write_field
 ( 'Name' , 
self
 . 
get_name
 ( ) )

141 
write_field
 ( 'Version' , 
self
 . 
get_version
 ( ) )

142 
write_field
 ( 'Summary' , 
self
 . 
get_description
 ( ) )

143 
write_field
 ( 'Home-page' , 
self
 . 
get_url
 ( ) )

145 if 
version
 < 
StrictVersion
 ( '1.2' ) :

146 
write_field
 ( 'Author' , 
self
 . 
get_contact
 ( ) )

147 
write_field
 ( 'Author-email' , 
self
 . 
get_contact_email
 ( ) )

149 
optional_fields
 = (

156 for 
field
 , 
attr
 in 
optional_fields
 :

157 
attr_val
 = 
getattr
 ( 
self
 , 
attr
 )

159 if 
attr_val
 is not None :

160 
write_field
 ( 
field
 , 
attr_val
 )

162 
write_field
 ( 'License' , 
self
 . 
get_license
 ( ) )

163 if 
self
 . 
download_url
 :

164 
write_field
 ( 'Download-URL' , 
self
 . 
download_url
 )

165 for 
project_url
 in 
self
 . 
project_urls
 . 
items
 ( ) :

166 
write_field
 ( 'Project-URL' , '%s, %s' % 
project_url
 )

168 
long_desc
 = 
rfc822_escape
 ( 
self
 . 
get_long_description
 ( ) )

169 
write_field
 ( 'Description' , 
long_desc
 )

171 
keywords
 = ',' . 
join
 ( 
self
 . 
get_keywords
 ( ) )

172 if 
keywords
 :

173 
write_field
 ( 'Keywords' , 
keywords
 )

175 if 
version
 >= 
StrictVersion
 ( '1.2' ) :

176 for 
platform
 in 
self
 . 
get_platforms
 ( ) :

177 
write_field
 ( 'Platform' , 
platform
 )

179 
self
 . 
_write_list
 ( 
file
 , 'Platform' , 
self
 . 
get_platforms
 ( ) )

181 
self
 . 
_write_list
 ( 
file
 , 'Classifier' , 
self
 . 
get_classifiers
 ( ) )

184 
self
 . 
_write_list
 ( 
file
 , 'Requires' , 
self
 . 
get_requires
 ( ) )

185 
self
 . 
_write_list
 ( 
file
 , 'Provides' , 
self
 . 
get_provides
 ( ) )

186 
self
 . 
_write_list
 ( 
file
 , 'Obsoletes' , 
self
 . 
get_obsoletes
 ( ) )

189 if 
hasattr
 ( 
self
 , 'python_requires' ) :

190 
write_field
 ( 'Requires-Python' , 
self
 . 
python_requires
 )

193 if 
self
 . 
long_description_content_type
 :

194 
write_field
 ( 'Description-Content-Type'

196 
self
 . 
long_description_content_type

198 if 
self
 . 
provides_extras
 :

199 for 
extra
 in 
sorted
 ( 
self
 . 
provides_extras
 ) :

200 
write_field
 ( 'Provides-Extra' , 
extra
 ) 
	}

203 
sequence
 = 
tuple
 , 
list

206 def 
	$check_importable
 ( 
dist
 , 
attr
 , 
value
 ) :

208 
ep
 = 
pkg_resources
 . 
EntryPoint
 . 
parse
 ( 'x=' + 
value
 )

209 assert not 
ep
 . 
extras

210 except ( 
TypeError
 , 
ValueError
 , 
AttributeError
 , 
AssertionError
 ) :

211 raise 
DistutilsSetupError
 ( "%r must be importable 'module:attrs' string (got %r)"

213 % ( 
attr
 , 
value
 )

214 ) 
	}

217 def 
	$assert_string_list
 ( 
dist
 , 
attr
 , 
value
 ) :

220 assert '' . 
join
 ( 
value
 ) != 
value

221 except ( 
TypeError
 , 
ValueError
 , 
AttributeError
 , 
AssertionError
 ) :

222 raise 
DistutilsSetupError
 ( "%r must be a list of strings (got %r)"

223 % ( 
attr
 , 
value
 )

224 ) 
	}

227 def 
	$check_nsp
 ( 
dist
 , 
attr
 , 
value
 ) :

229 
ns_packages
 = 
value

230 
assert_string_list
 ( 
dist
 , 
attr
 , 
ns_packages
 )

231 for 
nsp
 in 
ns_packages
 :

232 if not 
dist
 . 
has_contents_for
 ( 
nsp
 ) :

233 raise 
DistutilsSetupError
 ( "Distribution contains no modules or packages for "

235 % 
nsp

237 
parent
 , 
sep
 , 
child
 = 
nsp
 . 
rpartition
 ( '.' )

238 if 
parent
 and 
parent
 not in 
ns_packages
 :

239 
distutils
 . 
log
 . 
warn
 ( "WARNING: %r is declared as a package namespace, but %r" " is not: please correct this in setup.py"

241 , 
nsp
 , 
parent

242 ) 
	}

245 def 
	$check_extras
 ( 
dist
 , 
attr
 , 
value
 ) :

248 
list
 ( 
itertools
 . 
starmap
 ( 
_check_extra
 , 
value
 . 
items
 ( ) ) )

249 except ( 
TypeError
 , 
ValueError
 , 
AttributeError
 ) :

250 raise 
DistutilsSetupError
 ( "'extras_require' must be a dictionary whose values are " "strings or lists of strings containing valid project/version " "requirement specifiers."

254 ) 
	}

257 def 
	$_check_extra
 ( 
extra
 , 
reqs
 ) :

258 
name
 , 
sep
 , 
marker
 = 
extra
 . 
partition
 ( ':' )

259 if 
marker
 and 
pkg_resources
 . 
invalid_marker
 ( 
marker
 ) :

260 raise 
DistutilsSetupError
 ( "Invalid environment marker: " + 
marker
 )

261 
list
 ( 
pkg_resources
 . 
parse_requirements
 ( 
reqs
 ) ) 
	}

264 def 
	$assert_bool
 ( 
dist
 , 
attr
 , 
value
 ) :

266 if 
bool
 ( 
value
 ) != 
value
 :

267 
tmpl
 = "{attr!r} must be a boolean value (got {value!r})"

268 raise 
DistutilsSetupError
 ( 
tmpl
 . 
format
 ( 
attr
 = 
attr
 , 
value
 = 
value
 ) ) 
	}

271 def 
	$check_requirements
 ( 
dist
 , 
attr
 , 
value
 ) :

274 
list
 ( 
pkg_resources
 . 
parse_requirements
 ( 
value
 ) )

275 if 
isinstance
 ( 
value
 , ( 
dict
 , 
set
 ) ) :

276 raise 
TypeError
 ( "Unordered types are not allowed" )

277 except ( 
TypeError
 , 
ValueError
 ) as 
error
 :

278 
tmpl
 = ( "{attr!r} must be a string or list of strings " "containing valid project/version requirement specifiers; {error}"

282 raise 
DistutilsSetupError
 ( 
tmpl
 . 
format
 ( 
attr
 = 
attr
 , 
error
 = 
error
 ) ) 
	}

285 def 
	$check_specifier
 ( 
dist
 , 
attr
 , 
value
 ) :

288 
packaging
 . 
specifiers
 . 
SpecifierSet
 ( 
value
 )

289 except 
packaging
 . 
specifiers
 . 
InvalidSpecifier
 as 
error
 :

290 
tmpl
 = ( "{attr!r} must be a string " "containing valid version specifiers; {error}"

294 raise 
DistutilsSetupError
 ( 
tmpl
 . 
format
 ( 
attr
 = 
attr
 , 
error
 = 
error
 ) ) 
	}

297 def 
	$check_entry_points
 ( 
dist
 , 
attr
 , 
value
 ) :

300 
pkg_resources
 . 
EntryPoint
 . 
parse_map
 ( 
value
 )

301 except 
ValueError
 as 
e
 :

302 raise 
DistutilsSetupError
 ( 
e
 ) 
	}

305 def 
	$check_test_suite
 ( 
dist
 , 
attr
 , 
value
 ) :

306 if not 
isinstance
 ( 
value
 , 
six
 . 
string_types
 ) :

307 raise 
DistutilsSetupError
 ( "test_suite must be a string" ) 
	}

310 def 
	$check_package_data
 ( 
dist
 , 
attr
 , 
value
 ) :

312 if 
isinstance
 ( 
value
 , 
dict
 ) :

313 for 
k
 , 
v
 in 
value
 . 
items
 ( ) :

314 if not 
isinstance
 ( 
k
 , 
str
 ) :

317 
iter
 ( 
v
 )

318 except 
TypeError
 :

322 raise 
DistutilsSetupError
 (

323 
attr
 + " must be a dictionary mapping package names to lists of " "wildcard patterns"

325 ) 
	}

328 def 
	$check_packages
 ( 
dist
 , 
attr
 , 
value
 ) :

329 for 
pkgname
 in 
value
 :

330 if not 
re
 . 
match
 ( r'\w+(\.\w+)*' , 
pkgname
 ) :

331 
distutils
 . 
log
 . 
warn
 ( "WARNING: %r not a valid package name; please use only " ".-separated package names in setup.py"

333 , 
pkgname

334 ) 
	}

337 
_Distribution
 = 
get_unpatched
 ( 
distutils
 . 
core
 . 
Distribution
 )

340 class 
	cDistribution
 ( 
_Distribution
 ) :

408 
_DISTUTILS_UNSUPPORTED_METADATA
 = { 'long_description_content_type'

410 : 
dict
 , 'provides_extras'

411 : 
set
 ,

414 
_patched_dist
 = None

416 def 
	$patch_missing_pkg_info
 ( 
self
 , 
attrs
 ) :

421 if not 
attrs
 or 'name' not in 
attrs
 or 'version' not in 
attrs
 :

423 
key
 = 
pkg_resources
 . 
safe_name
 ( 
str
 ( 
attrs
 [ 'name' ] ) ) . 
lower
 ( )

424 
dist
 = 
pkg_resources
 . 
working_set
 . 
by_key
 . 
get
 ( 
key
 )

425 if 
dist
 is not None and not 
dist
 . 
has_metadata
 ( 'PKG-INFO' ) :

426 
dist
 . 
_version
 = 
pkg_resources
 . 
safe_version
 ( 
str
 ( 
attrs
 [ 'version' ] ) )

427 
self
 . 
_patched_dist
 = 
dist
 
	}

429 def 
	$__init__
 ( 
self
 , 
attrs
 = None ) :

430 
have_package_data
 = 
hasattr
 ( 
self
 , "package_data" )

431 if not 
have_package_data
 :

432 
self
 . 
package_data
 = { }

433 
attrs
 = 
attrs
 or { }

434 if 'features' in 
attrs
 or 'require_features' in 
attrs
 :

435 
Feature
 . 
warn_deprecated
 ( )

436 
self
 . 
require_features
 = [ ]

437 
self
 . 
features
 = { }

438 
self
 . 
dist_files
 = [ ]

440 
self
 . 
src_root
 = 
attrs
 . 
pop
 ( "src_root" , None )

441 
self
 . 
patch_missing_pkg_info
 ( 
attrs
 )

442 
self
 . 
dependency_links
 = 
attrs
 . 
pop
 ( 'dependency_links' , [ ] )

443 
self
 . 
setup_requires
 = 
attrs
 . 
pop
 ( 'setup_requires' , [ ] )

444 for 
ep
 in 
pkg_resources
 . 
iter_entry_points
 ( 'distutils.setup_keywords' ) :

445 
vars
 ( 
self
 ) . 
setdefault
 ( 
ep
 . 
name
 , None )

446 
_Distribution
 . 
__init__
 ( 
self
 , {

447 
k
 : 
v
 for 
k
 , 
v
 in 
attrs
 . 
items
 ( )

448 if 
k
 not in 
self
 . 
_DISTUTILS_UNSUPPORTED_METADATA

454 for 
option
 , 
default
 in 
self
 . 
_DISTUTILS_UNSUPPORTED_METADATA
 . 
items
 ( ) :

455 for 
source
 in 
self
 . 
metadata
 . 
__dict__
 , 
attrs
 :

456 if 
option
 in 
source
 :

457 
value
 = 
source
 [ 
option
 ]

460 
value
 = 
default
 ( ) if 
default
 else None

461 
setattr
 ( 
self
 . 
metadata
 , 
option
 , 
value
 )

463 if 
isinstance
 ( 
self
 . 
metadata
 . 
version
 , 
numbers
 . 
Number
 ) :

465 
self
 . 
metadata
 . 
version
 = 
str
 ( 
self
 . 
metadata
 . 
version
 )

467 if 
self
 . 
metadata
 . 
version
 is not None :

469 
ver
 = 
packaging
 . 
version
 . 
Version
 ( 
self
 . 
metadata
 . 
version
 )

470 
normalized_version
 = 
str
 ( 
ver
 )

471 if 
self
 . 
metadata
 . 
version
 != 
normalized_version
 :

472 
warnings
 . 
warn
 ( "Normalizing '%s' to '%s'"

474 
self
 . 
metadata
 . 
version
 ,

475 
normalized_version
 ,

478 
self
 . 
metadata
 . 
version
 = 
normalized_version

479 except ( 
packaging
 . 
version
 . 
InvalidVersion
 , 
TypeError
 ) :

480 
warnings
 . 
warn
 ( "The version specified (%r) is an invalid version, this " "may not work as expected with newer versions of " "setuptools, pip, and PyPI. Please see PEP 440 for more " "details."

484 % 
self
 . 
metadata
 . 
version

486 
self
 . 
_finalize_requires
 ( ) 
	}

488 def 
	$_finalize_requires
 ( 
self
 ) :

493 if 
getattr
 ( 
self
 , 'python_requires' , None ) :

494 
self
 . 
metadata
 . 
python_requires
 = 
self
 . 
python_requires

496 if 
getattr
 ( 
self
 , 'extras_require' , None ) :

497 for 
extra
 in 
self
 . 
extras_require
 . 
keys
 ( ) :

501 
extra
 = 
extra
 . 
split
 ( ':' ) [ 0 ]

502 if 
extra
 :

503 
self
 . 
metadata
 . 
provides_extras
 . 
add
 ( 
extra
 )

505 
self
 . 
_convert_extras_requirements
 ( )

506 
self
 . 
_move_install_requirements_markers
 ( ) 
	}

508 def 
	$_convert_extras_requirements
 ( 
self
 ) :

514 
spec_ext_reqs
 = 
getattr
 ( 
self
 , 'extras_require' , None ) or { }

515 
self
 . 
_tmp_extras_require
 = 
defaultdict
 ( 
list
 )

516 for 
section
 , 
v
 in 
spec_ext_reqs
 . 
items
 ( ) :

518 
self
 . 
_tmp_extras_require
 [ 
section
 ]

519 for 
r
 in 
pkg_resources
 . 
parse_requirements
 ( 
v
 ) :

520 
suffix
 = 
self
 . 
_suffix_for
 ( 
r
 )

521 
self
 . 
_tmp_extras_require
 [ 
section
 + 
suffix
 ] . 
append
 ( 
r
 ) 
	}

523 @ 
	`staticmethod

524 def 
	$_suffix_for
 ( 
req
 ) :

529 return ':' + 
str
 ( 
req
 . 
marker
 ) if 
req
 . 
marker
 else '' 
	}

531 def 
	$_move_install_requirements_markers
 ( 
self
 ) :

541 def 
is_simple_req
 ( 
req
 ) :

542 return not 
req
 . 
marker

544 
spec_inst_reqs
 = 
getattr
 ( 
self
 , 'install_requires' , None ) or ( )

545 
inst_reqs
 = 
list
 ( 
pkg_resources
 . 
parse_requirements
 ( 
spec_inst_reqs
 ) )

546 
simple_reqs
 = 
filter
 ( 
is_simple_req
 , 
inst_reqs
 )

547 
complex_reqs
 = 
filterfalse
 ( 
is_simple_req
 , 
inst_reqs
 )

548 
self
 . 
install_requires
 = 
list
 ( 
map
 ( 
str
 , 
simple_reqs
 ) )

550 for 
r
 in 
complex_reqs
 :

551 
self
 . 
_tmp_extras_require
 [ ':' + 
str
 ( 
r
 . 
marker
 ) ] . 
append
 ( 
r
 )

552 
self
 . 
extras_require
 = 
dict
 (

553 ( 
k
 , [ 
str
 ( 
r
 ) for 
r
 in 
map
 ( 
self
 . 
_clean_req
 , 
v
 ) ] )

554 for 
k
 , 
v
 in 
self
 . 
_tmp_extras_require
 . 
items
 ( )

555 ) 
	}

557 def 
	$_clean_req
 ( 
self
 , 
req
 ) :

561 
req
 . 
marker
 = None

562 return 
req
 
	}

564 def 
	$_parse_config_files
 ( 
self
 , 
filenames
 = None ) :

570 from 
	~setuptools.extern.six.moves.configparser
 import 
ConfigParser

573 if 
six
 . 
PY3
 and 
sys
 . 
prefix
 != 
sys
 . 
base_prefix
 :

574 
ignore_options
 = [ 'install-base'

580 
ignore_options
 = [ ]

582 
ignore_options
 = 
frozenset
 ( 
ignore_options
 )

584 if 
filenames
 is None :

585 
filenames
 = 
self
 . 
find_config_files
 ( )

587 if 
DEBUG
 :

588 
self
 . 
announce
 ( "Distribution.parse_config_files():" )

590 
parser
 = 
ConfigParser
 ( )

591 for 
filename
 in 
filenames
 :

592 with 
io
 . 
open
 ( 
filename
 , 'rb' ) as 
fp
 :

593 
encoding
 = 
detect_encoding
 ( 
fp
 )

594 if 
DEBUG
 :

595 
self
 . 
announce
 ( "  reading %s [%s]" % (

596 
filename
 , 
encoding
 or 'locale' )

598 
reader
 = 
io
 . 
TextIOWrapper
 ( 
fp
 , 
encoding
 = 
encoding
 )

599 ( 
parser
 . 
read_file
 if 
six
 . 
PY3
 else 
parser
 . 
readfp
 ) ( 
reader
 )

600 for 
section
 in 
parser
 . 
sections
 ( ) :

601 
options
 = 
parser
 . 
options
 ( 
section
 )

602 
opt_dict
 = 
self
 . 
get_option_dict
 ( 
section
 )

604 for 
opt
 in 
options
 :

605 if 
opt
 != '__name__' and 
opt
 not in 
ignore_options
 :

606 
val
 = 
self
 . 
_try_str
 ( 
parser
 . 
get
 ( 
section
 , 
opt
 ) )

607 
opt
 = 
opt
 . 
replace
 ( '-' , '_' )

608 
opt_dict
 [ 
opt
 ] = ( 
filename
 , 
val
 )

612 
parser
 . 
__init__
 ( )

617 if 'global' in 
self
 . 
command_options
 :

618 for ( 
opt
 , ( 
src
 , 
val
 ) ) in 
self
 . 
command_options
 [ 'global' ] . 
items
 ( ) :

619 
alias
 = 
self
 . 
negative_opt
 . 
get
 ( 
opt
 )

621 if 
alias
 :

622 
setattr
 ( 
self
 , 
alias
 , not 
strtobool
 ( 
val
 ) )

623 elif 
opt
 in ( 'verbose' , 'dry_run' ) :

624 
setattr
 ( 
self
 , 
opt
 , 
strtobool
 ( 
val
 ) )

626 
setattr
 ( 
self
 , 
opt
 , 
val
 )

627 except 
ValueError
 as 
msg
 :

628 raise 
DistutilsOptionError
 ( 
msg
 ) 
	}

630 @ 
	`staticmethod

631 def 
	$_try_str
 ( 
val
 ) :

642 if 
six
 . 
PY3
 :

643 return 
val

645 return 
val
 . 
encode
 ( )

646 except 
UnicodeEncodeError
 :

648 return 
val
 
	}

650 def 
	$_set_command_options
 ( 
self
 , 
command_obj
 , 
option_dict
 = None ) :

662 
command_name
 = 
command_obj
 . 
get_command_name
 ( )

663 if 
option_dict
 is None :

664 
option_dict
 = 
self
 . 
get_option_dict
 ( 
command_name
 )

666 if 
DEBUG
 :

667 
self
 . 
announce
 ( "  setting options for '%s' command:" % 
command_name
 )

668 for ( 
option
 , ( 
source
 , 
value
 ) ) in 
option_dict
 . 
items
 ( ) :

669 if 
DEBUG
 :

670 
self
 . 
announce
 ( "    %s = %s (from %s)" % ( 
option
 , 
value
 ,

671 
source
 ) )

673 
bool_opts
 = [ 
translate_longopt
 ( 
o
 )

674 for 
o
 in 
command_obj
 . 
boolean_options
 ]

675 except 
AttributeError
 :

676 
bool_opts
 = [ ]

678 
neg_opt
 = 
command_obj
 . 
negative_opt

679 except 
AttributeError
 :

680 
neg_opt
 = { }

683 
is_string
 = 
isinstance
 ( 
value
 , 
six
 . 
string_types
 )

684 if 
option
 in 
neg_opt
 and 
is_string
 :

685 
setattr
 ( 
command_obj
 , 
neg_opt
 [ 
option
 ] , not 
strtobool
 ( 
value
 ) )

686 elif 
option
 in 
bool_opts
 and 
is_string
 :

687 
setattr
 ( 
command_obj
 , 
option
 , 
strtobool
 ( 
value
 ) )

688 elif 
hasattr
 ( 
command_obj
 , 
option
 ) :

689 
setattr
 ( 
command_obj
 , 
option
 , 
value
 )

691 raise 
DistutilsOptionError
 ( "error in %s: command '%s' has no such option '%s'"

693 % ( 
source
 , 
command_name
 , 
option
 ) )

694 except 
ValueError
 as 
msg
 :

695 raise 
DistutilsOptionError
 ( 
msg
 ) 
	}

697 def 
	$parse_config_files
 ( 
self
 , 
filenames
 = None , 
ignore_option_errors
 = False ) :

702 
self
 . 
_parse_config_files
 ( 
filenames
 = 
filenames
 )

704 
parse_configuration
 ( 
self
 , 
self
 . 
command_options
 ,

705 
ignore_option_errors
 = 
ignore_option_errors
 )

706 
self
 . 
_finalize_requires
 ( ) 
	}

708 def 
	$parse_command_line
 ( 
self
 ) :

710 
result
 = 
_Distribution
 . 
parse_command_line
 ( 
self
 )

711 if 
self
 . 
features
 :

712 
self
 . 
_finalize_features
 ( )

713 return 
result
 
	}

715 def 
	$_feature_attrname
 ( 
self
 , 
name
 ) :

717 return 'with_' + 
name
 . 
replace
 ( '-' , '_' ) 
	}

719 def 
	$fetch_build_eggs
 ( 
self
 , 
requires
 ) :

721 
resolved_dists
 = 
pkg_resources
 . 
working_set
 . 
resolve
 (

722 
pkg_resources
 . 
parse_requirements
 ( 
requires
 ) ,

723 
installer
 = 
self
 . 
fetch_build_egg
 ,

724 
replace_conflicting
 = True ,

726 for 
dist
 in 
resolved_dists
 :

727 
pkg_resources
 . 
working_set
 . 
add
 ( 
dist
 , 
replace
 = True )

728 return 
resolved_dists
 
	}

730 def 
	$finalize_options
 ( 
self
 ) :

731 
_Distribution
 . 
finalize_options
 ( 
self
 )

732 if 
self
 . 
features
 :

733 
self
 . 
_set_global_opts_from_features
 ( )

735 for 
ep
 in 
pkg_resources
 . 
iter_entry_points
 ( 'distutils.setup_keywords' ) :

736 
value
 = 
getattr
 ( 
self
 , 
ep
 . 
name
 , None )

737 if 
value
 is not None :

738 
ep
 . 
require
 ( 
installer
 = 
self
 . 
fetch_build_egg
 )

739 
ep
 . 
load
 ( ) ( 
self
 , 
ep
 . 
name
 , 
value
 )

740 if 
getattr
 ( 
self
 , 'convert_2to3_doctests' , None ) :

742 
self
 . 
convert_2to3_doctests
 = [

743 
os
 . 
path
 . 
abspath
 ( 
p
 )

744 for 
p
 in 
self
 . 
convert_2to3_doctests

747 
self
 . 
convert_2to3_doctests
 = [ ] 
	}

749 def 
	$get_egg_cache_dir
 ( 
self
 ) :

750 
egg_cache_dir
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
curdir
 , '.eggs' )

751 if not 
os
 . 
path
 . 
exists
 ( 
egg_cache_dir
 ) :

752 
os
 . 
mkdir
 ( 
egg_cache_dir
 )

753 
windows_support
 . 
hide_file
 ( 
egg_cache_dir
 )

754 
readme_txt_filename
 = 
os
 . 
path
 . 
join
 ( 
egg_cache_dir
 , 'README.txt' )

755 with 
open
 ( 
readme_txt_filename
 , 'w' ) as 
f
 :

756 
f
 . 
write
 ( 'This directory contains eggs that were downloaded ' 'by setuptools to build, test, and run plug-ins.\n\n'

758 
f
 . 
write
 ( 'This directory caches those eggs to prevent ' 'repeated downloads.\n\n'

760 
f
 . 
write
 ( 'However, it is safe to delete this directory.\n\n' )

762 return 
egg_cache_dir
 
	}

764 def 
	$fetch_build_egg
 ( 
self
 , 
req
 ) :

766 from 
	~setuptools.command.easy_install
 import 
easy_install

767 
dist
 = 
self
 . 
__class__
 ( { 'script_args' : [ 'easy_install' ] } )

768 
opts
 = 
dist
 . 
get_option_dict
 ( 'easy_install' )

769 
opts
 . 
clear
 ( )

770 
opts
 . 
update
 (

771 ( 
k
 , 
v
 )

772 for 
k
 , 
v
 in 
self
 . 
get_option_dict
 ( 'easy_install' ) . 
items
 ( )

773 if 
k
 in ( 'find_links'

778 if 
self
 . 
dependency_links
 :

779 
links
 = 
self
 . 
dependency_links
 [ : ]

780 if 'find_links' in 
opts
 :

781 
links
 = 
opts
 [ 'find_links' ] [ 1 ] + 
links

782 
opts
 [ 'find_links' ] = ( 'setup' , 
links
 )

783 
install_dir
 = 
self
 . 
get_egg_cache_dir
 ( )

784 
cmd
 = 
easy_install
 (

785 
dist
 , 
args
 = [ "x" ] , 
install_dir
 = 
install_dir
 ,

786 
exclude_scripts
 = True ,

787 
always_copy
 = False , 
build_directory
 = None , 
editable
 = False ,

788 
upgrade
 = False , 
multi_version
 = True , 
no_report
 = True , 
user
 = False

790 
cmd
 . 
ensure_finalized
 ( )

791 return 
cmd
 . 
easy_install
 ( 
req
 ) 
	}

793 def 
	$_set_global_opts_from_features
 ( 
self
 ) :

796 
go
 = [ ]

797 
no
 = 
self
 . 
negative_opt
 . 
copy
 ( )

799 for 
name
 , 
feature
 in 
self
 . 
features
 . 
items
 ( ) :

800 
self
 . 
_set_feature
 ( 
name
 , None )

801 
feature
 . 
validate
 ( 
self
 )

803 if 
feature
 . 
optional
 :

804 
descr
 = 
feature
 . 
description

805 
incdef
 = ' (default)'

806 
excdef
 = ''

807 if not 
feature
 . 
include_by_default
 ( ) :

808 
excdef
 , 
incdef
 = 
incdef
 , 
excdef

810 
new
 = (

811 ( 'with-' + 
name
 , None , 'include ' + 
descr
 + 
incdef
 ) ,

812 ( 'without-' + 
name
 , None , 'exclude ' + 
descr
 + 
excdef
 ) ,

814 
go
 . 
extend
 ( 
new
 )

815 
no
 [ 'without-' + 
name
 ] = 'with-' + 
name

817 
self
 . 
global_options
 = 
self
 . 
feature_options
 = 
go
 + 
self
 . 
global_options

818 
self
 . 
negative_opt
 = 
self
 . 
feature_negopt
 = 
no
 
	}

820 def 
	$_finalize_features
 ( 
self
 ) :

824 for 
name
 , 
feature
 in 
self
 . 
features
 . 
items
 ( ) :

825 
enabled
 = 
self
 . 
feature_is_included
 ( 
name
 )

826 if 
enabled
 or ( 
enabled
 is None and 
feature
 . 
include_by_default
 ( ) ) :

827 
feature
 . 
include_in
 ( 
self
 )

828 
self
 . 
_set_feature
 ( 
name
 , 1 )

832 for 
name
 , 
feature
 in 
self
 . 
features
 . 
items
 ( ) :

833 if not 
self
 . 
feature_is_included
 ( 
name
 ) :

834 
feature
 . 
exclude_from
 ( 
self
 )

835 
self
 . 
_set_feature
 ( 
name
 , 0 ) 
	}

837 def 
	$get_command_class
 ( 
self
 , 
command
 ) :

839 if 
command
 in 
self
 . 
cmdclass
 :

840 return 
self
 . 
cmdclass
 [ 
command
 ]

842 
eps
 = 
pkg_resources
 . 
iter_entry_points
 ( 'distutils.commands' , 
command
 )

843 for 
ep
 in 
eps
 :

844 
ep
 . 
require
 ( 
installer
 = 
self
 . 
fetch_build_egg
 )

845 
self
 . 
cmdclass
 [ 
command
 ] = 
cmdclass
 = 
ep
 . 
load
 ( )

846 return 
cmdclass

848 return 
_Distribution
 . 
get_command_class
 ( 
self
 , 
command
 ) 
	}

850 def 
	$print_commands
 ( 
self
 ) :

851 for 
ep
 in 
pkg_resources
 . 
iter_entry_points
 ( 'distutils.commands' ) :

852 if 
ep
 . 
name
 not in 
self
 . 
cmdclass
 :

854 
cmdclass
 = 
ep
 . 
resolve
 ( )

855 
self
 . 
cmdclass
 [ 
ep
 . 
name
 ] = 
cmdclass

856 return 
_Distribution
 . 
print_commands
 ( 
self
 ) 
	}

858 def 
	$get_command_list
 ( 
self
 ) :

859 for 
ep
 in 
pkg_resources
 . 
iter_entry_points
 ( 'distutils.commands' ) :

860 if 
ep
 . 
name
 not in 
self
 . 
cmdclass
 :

862 
cmdclass
 = 
ep
 . 
resolve
 ( )

863 
self
 . 
cmdclass
 [ 
ep
 . 
name
 ] = 
cmdclass

864 return 
_Distribution
 . 
get_command_list
 ( 
self
 ) 
	}

866 def 
	$_set_feature
 ( 
self
 , 
name
 , 
status
 ) :

868 
setattr
 ( 
self
 , 
self
 . 
_feature_attrname
 ( 
name
 ) , 
status
 ) 
	}

870 def 
	$feature_is_included
 ( 
self
 , 
name
 ) :

872 return 
getattr
 ( 
self
 , 
self
 . 
_feature_attrname
 ( 
name
 ) ) 
	}

874 def 
	$include_feature
 ( 
self
 , 
name
 ) :

877 if 
self
 . 
feature_is_included
 ( 
name
 ) == 0 :

878 
descr
 = 
self
 . 
features
 [ 
name
 ] . 
description

879 raise 
DistutilsOptionError
 (

880 
descr
 + " is required, but was excluded or is not available"

882 
self
 . 
features
 [ 
name
 ] . 
include_in
 ( 
self
 )

883 
self
 . 
_set_feature
 ( 
name
 , 1 ) 
	}

885 def 
	$include
 ( 
self
 , ** 
attrs
 ) :

900 for 
k
 , 
v
 in 
attrs
 . 
items
 ( ) :

901 
include
 = 
getattr
 ( 
self
 , '_include_' + 
k
 , None )

902 if 
include
 :

903 
include
 ( 
v
 )

905 
self
 . 
_include_misc
 ( 
k
 , 
v
 ) 
	}

907 def 
	$exclude_package
 ( 
self
 , 
package
 ) :

910 
pfx
 = 
package
 + '.'

911 if 
self
 . 
packages
 :

912 
self
 . 
packages
 = [

913 
p
 for 
p
 in 
self
 . 
packages

914 if 
p
 != 
package
 and not 
p
 . 
startswith
 ( 
pfx
 )

917 if 
self
 . 
py_modules
 :

918 
self
 . 
py_modules
 = [

919 
p
 for 
p
 in 
self
 . 
py_modules

920 if 
p
 != 
package
 and not 
p
 . 
startswith
 ( 
pfx
 )

923 if 
self
 . 
ext_modules
 :

924 
self
 . 
ext_modules
 = [

925 
p
 for 
p
 in 
self
 . 
ext_modules

926 if 
p
 . 
name
 != 
package
 and not 
p
 . 
name
 . 
startswith
 ( 
pfx
 )

927 ] 
	}

929 def 
	$has_contents_for
 ( 
self
 , 
package
 ) :

932 
pfx
 = 
package
 + '.'

934 for 
p
 in 
self
 . 
iter_distribution_names
 ( ) :

935 if 
p
 == 
package
 or 
p
 . 
startswith
 ( 
pfx
 ) :

936 return True 
	}

938 def 
	$_exclude_misc
 ( 
self
 , 
name
 , 
value
 ) :

940 if not 
isinstance
 ( 
value
 , 
sequence
 ) :

941 raise 
DistutilsSetupError
 ( "%s: setting must be a list or tuple (%r)"

942 % ( 
name
 , 
value
 )

945 
old
 = 
getattr
 ( 
self
 , 
name
 )

946 except 
AttributeError
 :

947 raise 
DistutilsSetupError
 ( "%s: No such distribution setting"

948 % 
name

950 if 
old
 is not None and not 
isinstance
 ( 
old
 , 
sequence
 ) :

951 raise 
DistutilsSetupError
 (

952 
name
 + ": this setting cannot be changed via include/exclude"

954 elif 
old
 :

955 
setattr
 ( 
self
 , 
name
 , [ 
item
 for 
item
 in 
old
 if 
item
 not in 
value
 ] ) 
	}

957 def 
	$_include_misc
 ( 
self
 , 
name
 , 
value
 ) :

960 if not 
isinstance
 ( 
value
 , 
sequence
 ) :

961 raise 
DistutilsSetupError
 ( "%s: setting must be a list (%r)"

962 % ( 
name
 , 
value
 )

965 
old
 = 
getattr
 ( 
self
 , 
name
 )

966 except 
AttributeError
 :

967 raise 
DistutilsSetupError
 ( "%s: No such distribution setting"

968 % 
name

970 if 
old
 is None :

971 
setattr
 ( 
self
 , 
name
 , 
value
 )

972 elif not 
isinstance
 ( 
old
 , 
sequence
 ) :

973 raise 
DistutilsSetupError
 (

974 
name
 + ": this setting cannot be changed via include/exclude"

977 
new
 = [ 
item
 for 
item
 in 
value
 if 
item
 not in 
old
 ]

978 
setattr
 ( 
self
 , 
name
 , 
old
 + 
new
 ) 
	}

980 def 
	$exclude
 ( 
self
 , ** 
attrs
 ) :

996 for 
k
 , 
v
 in 
attrs
 . 
items
 ( ) :

997 
exclude
 = 
getattr
 ( 
self
 , '_exclude_' + 
k
 , None )

998 if 
exclude
 :

999 
exclude
 ( 
v
 )

1001 
self
 . 
_exclude_misc
 ( 
k
 , 
v
 ) 
	}

1003 def 
	$_exclude_packages
 ( 
self
 , 
packages
 ) :

1004 if not 
isinstance
 ( 
packages
 , 
sequence
 ) :

1005 raise 
DistutilsSetupError
 ( "packages: setting must be a list or tuple (%r)"

1006 % ( 
packages
 , )

1008 
list
 ( 
map
 ( 
self
 . 
exclude_package
 , 
packages
 ) ) 
	}

1010 def 
	$_parse_command_opts
 ( 
self
 , 
parser
 , 
args
 ) :

1012 
self
 . 
global_options
 = 
self
 . 
__class__
 . 
global_options

1013 
self
 . 
negative_opt
 = 
self
 . 
__class__
 . 
negative_opt

1016 
command
 = 
args
 [ 0 ]

1017 
aliases
 = 
self
 . 
get_option_dict
 ( 'aliases' )

1018 while 
command
 in 
aliases
 :

1019 
src
 , 
alias
 = 
aliases
 [ 
command
 ]

1020 del 
aliases
 [ 
command
 ]

1021 import 
	~shlex

1022 
args
 [ : 1 ] = 
shlex
 . 
split
 ( 
alias
 , True )

1023 
command
 = 
args
 [ 0 ]

1025 
nargs
 = 
_Distribution
 . 
_parse_command_opts
 ( 
self
 , 
parser
 , 
args
 )

1028 
cmd_class
 = 
self
 . 
get_command_class
 ( 
command
 )

1029 if 
getattr
 ( 
cmd_class
 , 'command_consumes_arguments' , None ) :

1030 
self
 . 
get_option_dict
 ( 
command
 ) [ 'args' ] = ( "command line" , 
nargs
 )

1031 if 
nargs
 is not None :

1034 return 
nargs
 
	}

1036 def 
	$get_cmdline_options
 ( 
self
 ) :

1046 
d
 = { }

1048 for 
cmd
 , 
opts
 in 
self
 . 
command_options
 . 
items
 ( ) :

1050 for 
opt
 , ( 
src
 , 
val
 ) in 
opts
 . 
items
 ( ) :

1052 if 
src
 != "command line" :

1055 
opt
 = 
opt
 . 
replace
 ( '_' , '-' )

1057 if 
val
 == 0 :

1058 
cmdobj
 = 
self
 . 
get_command_obj
 ( 
cmd
 )

1059 
neg_opt
 = 
self
 . 
negative_opt
 . 
copy
 ( )

1060 
neg_opt
 . 
update
 ( 
getattr
 ( 
cmdobj
 , 'negative_opt' , { } ) )

1061 for 
neg
 , 
pos
 in 
neg_opt
 . 
items
 ( ) :

1062 if 
pos
 == 
opt
 :

1063 
opt
 = 
neg

1064 
val
 = None

1067 raise 
AssertionError
 ( "Shouldn't be able to get here" )

1069 elif 
val
 == 1 :

1070 
val
 = None

1072 
d
 . 
setdefault
 ( 
cmd
 , { } ) [ 
opt
 ] = 
val

1074 return 
d
 
	}

1076 def 
	$iter_distribution_names
 ( 
self
 ) :

1079 for 
pkg
 in 
self
 . 
packages
 or ( ) :

1080 yield 
pkg

1082 for 
module
 in 
self
 . 
py_modules
 or ( ) :

1083 yield 
module

1085 for 
ext
 in 
self
 . 
ext_modules
 or ( ) :

1086 if 
isinstance
 ( 
ext
 , 
tuple
 ) :

1087 
name
 , 
buildinfo
 = 
ext

1089 
name
 = 
ext
 . 
name

1090 if 
name
 . 
endswith
 ( 'module' ) :

1091 
name
 = 
name
 [ : - 6 ]

1092 yield 
name
 
	}

1094 def 
	$handle_display_options
 ( 
self
 , 
option_order
 ) :

1100 import 
	~sys

1102 if 
six
 . 
PY2
 or 
self
 . 
help_commands
 :

1103 return 
_Distribution
 . 
handle_display_options
 ( 
self
 , 
option_order
 )

1106 import 
	~io

1107 if not 
isinstance
 ( 
sys
 . 
stdout
 , 
io
 . 
TextIOWrapper
 ) :

1108 return 
_Distribution
 . 
handle_display_options
 ( 
self
 , 
option_order
 )

1112 if 
sys
 . 
stdout
 . 
encoding
 . 
lower
 ( ) in ( 'utf-8' , 'utf8' ) :

1113 return 
_Distribution
 . 
handle_display_options
 ( 
self
 , 
option_order
 )

1116 
encoding
 = 
sys
 . 
stdout
 . 
encoding

1117 
errors
 = 
sys
 . 
stdout
 . 
errors

1118 
newline
 = 
sys
 . 
platform
 != 'win32' and '\n' or None

1119 
line_buffering
 = 
sys
 . 
stdout
 . 
line_buffering

1121 
sys
 . 
stdout
 = 
io
 . 
TextIOWrapper
 (

1122 
sys
 . 
stdout
 . 
detach
 ( ) , 'utf-8' , 
errors
 , 
newline
 , 
line_buffering
 )

1124 return 
_Distribution
 . 
handle_display_options
 ( 
self
 , 
option_order
 )

1126 
sys
 . 
stdout
 = 
io
 . 
TextIOWrapper
 (

1127 
sys
 . 
stdout
 . 
detach
 ( ) , 
encoding
 , 
errors
 , 
newline
 , 
line_buffering
 ) 
	}

1130 class 
	cFeature
 :

1187 @ 
	`staticmethod

1188 def 
	$warn_deprecated
 ( ) :

1189 
msg
 = ( "Features are deprecated and will be removed in a future " "version. See https://github.com/pypa/setuptools/issues/65."

1193 
warnings
 . 
warn
 ( 
msg
 , 
DistDeprecationWarning
 , 
stacklevel
 = 3 ) 
	}

1195 def 
	$__init__
 (

1196 
self
 , 
description
 , 
standard
 = False , 
available
 = True ,

1197 
optional
 = True , 
require_features
 = ( ) , 
remove
 = ( ) , ** 
extras
 ) :

1198 
self
 . 
warn_deprecated
 ( )

1200 
self
 . 
description
 = 
description

1201 
self
 . 
standard
 = 
standard

1202 
self
 . 
available
 = 
available

1203 
self
 . 
optional
 = 
optional

1204 if 
isinstance
 ( 
require_features
 , ( 
str
 , 
Require
 ) ) :

1205 
require_features
 = 
require_features
 ,

1207 
self
 . 
require_features
 = [

1208 
r
 for 
r
 in 
require_features
 if 
isinstance
 ( 
r
 , 
str
 )

1210 
er
 = [ 
r
 for 
r
 in 
require_features
 if not 
isinstance
 ( 
r
 , 
str
 ) ]

1211 if 
er
 :

1212 
extras
 [ 'require_features' ] = 
er

1214 if 
isinstance
 ( 
remove
 , 
str
 ) :

1215 
remove
 = 
remove
 ,

1216 
self
 . 
remove
 = 
remove

1217 
self
 . 
extras
 = 
extras

1219 if not 
remove
 and not 
require_features
 and not 
extras
 :

1220 raise 
DistutilsSetupError
 ( "Feature %s: must define 'require_features', 'remove', or " "at least one of 'packages', 'py_modules', etc."

1223 ) 
	}

1225 def 
	$include_by_default
 ( 
self
 ) :

1227 return 
self
 . 
available
 and 
self
 . 
standard
 
	}

1229 def 
	$include_in
 ( 
self
 , 
dist
 ) :

1238 if not 
self
 . 
available
 :

1239 raise 
DistutilsPlatformError
 (

1240 
self
 . 
description
 + " is required, " "but is not available on this platform"

1244 
dist
 . 
include
 ( ** 
self
 . 
extras
 )

1246 for 
f
 in 
self
 . 
require_features
 :

1247 
dist
 . 
include_feature
 ( 
f
 ) 
	}

1249 def 
	$exclude_from
 ( 
self
 , 
dist
 ) :

1258 
dist
 . 
exclude
 ( ** 
self
 . 
extras
 )

1260 if 
self
 . 
remove
 :

1261 for 
item
 in 
self
 . 
remove
 :

1262 
dist
 . 
exclude_package
 ( 
item
 ) 
	}

1264 def 
	$validate
 ( 
self
 , 
dist
 ) :

1275 for 
item
 in 
self
 . 
remove
 :

1276 if not 
dist
 . 
has_contents_for
 ( 
item
 ) :

1277 raise 
DistutilsSetupError
 ( "%s wants to be able to remove %s, but the distribution" " doesn't contain any packages or modules under %s"

1280 % ( 
self
 . 
description
 , 
item
 , 
item
 )

1281 ) 
	}

1284 class 
	cDistDeprecationWarning
 ( 
SetuptoolsDeprecationWarning
 ) :


	@./env/lib/python3.7/site-packages/setuptools/py33compat.py

1 import 
	~dis

2 import 
	~array

3 import 
	~collections

6 import 
	~html

7 except 
ImportError
 :

8 
html
 = None

10 from 
	~setuptools.extern
 import 
six

11 from 
	~setuptools.extern.six.moves
 import 
html_parser

13 
__metaclass__
 = 
type

15 
OpArg
 = 
collections
 . 
namedtuple
 ( 'OpArg' , 'opcode arg' )

18 class 
	cBytecode_compat
 :

19 def 
	$__init__
 ( 
self
 , 
code
 ) :

20 
self
 . 
code
 = 
code
 
	}

22 def 
	$__iter__
 ( 
self
 ) :

25 
bytes
 = 
array
 . 
array
 ( 'b' , 
self
 . 
code
 . 
co_code
 )

26 
eof
 = 
len
 ( 
self
 . 
code
 . 
co_code
 )

28 
ptr
 = 0

29 
extended_arg
 = 0

31 while 
ptr
 < 
eof
 :

33 
op
 = 
bytes
 [ 
ptr
 ]

35 if 
op
 >= 
dis
 . 
HAVE_ARGUMENT
 :

37 
arg
 = 
bytes
 [ 
ptr
 + 1 ] + 
bytes
 [ 
ptr
 + 2 ] * 256 + 
extended_arg

38 
ptr
 += 3

40 if 
op
 == 
dis
 . 
EXTENDED_ARG
 :

41 
long_type
 = 
six
 . 
integer_types
 [ - 1 ]

42 
extended_arg
 = 
arg
 * 
long_type
 ( 65536 )

46 
arg
 = None

47 
ptr
 += 1

49 yield 
OpArg
 ( 
op
 , 
arg
 ) 
	}

52 
Bytecode
 = 
getattr
 ( 
dis
 , 'Bytecode' , 
Bytecode_compat
 )

55 
unescape
 = 
getattr
 ( 
html
 , 'unescape' , 
html_parser
 . 
HTMLParser
 ( ) . 
unescape
 )


	@./env/lib/python3.7/site-packages/setuptools/__init__.py

3 import 
	~os

4 import 
	~sys

5 import 
	~functools

6 import 
	~distutils.core

7 import 
	~distutils.filelist

8 import 
	~re

9 from 
	~distutils.errors
 import 
DistutilsOptionError

10 from 
	~distutils.util
 import 
convert_path

11 from 
	~fnmatch
 import 
fnmatchcase

13 from . 
	~_deprecation_warning
 import 
SetuptoolsDeprecationWarning

15 from 
	~setuptools.extern.six
 import 
PY3
 , 
string_types

16 from 
	~setuptools.extern.six.moves
 import 
filter
 , 
map

18 import 
	~setuptools.version

19 from 
	~setuptools.extension
 import 
Extension

20 from 
	~setuptools.dist
 import 
Distribution
 , 
Feature

21 from 
	~setuptools.depends
 import 
Require

22 from . import 
monkey

24 
__metaclass__
 = 
type

27 
__all__
 = [ 'setup'

33 if 
PY3
 :

34 
__all__
 . 
append
 ( 'find_namespace_packages' )

36 
__version__
 = 
setuptools
 . 
version
 . 
__version__

38 
bootstrap_install_from
 = None

42 
run_2to3_on_doctests
 = True

44 
lib2to3_fixer_packages
 = [ 'lib2to3.fixes' ]

47 class 
	cPackageFinder
 :

52 @ 
classmethod

53 def 
	$find
 ( 
cls
 , 
where
 = '.' , 
exclude
 = ( ) , 
include
 = ( '*' , ) ) :

70 return 
list
 ( 
cls
 . 
_find_packages_iter
 (

71 
convert_path
 ( 
where
 ) ,

72 
cls
 . 
_build_filter
 ( 'ez_setup' , '*__pycache__' , * 
exclude
 ) ,

73 
cls
 . 
_build_filter
 ( * 
include
 ) ) ) 
	}

75 @ 
classmethod

76 def 
	$_find_packages_iter
 ( 
cls
 , 
where
 , 
exclude
 , 
include
 ) :

81 for 
root
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
where
 , 
followlinks
 = True ) :

83 
all_dirs
 = 
dirs
 [ : ]

84 
dirs
 [ : ] = [ ]

86 for 
dir
 in 
all_dirs
 :

87 
full_path
 = 
os
 . 
path
 . 
join
 ( 
root
 , 
dir
 )

88 
rel_path
 = 
os
 . 
path
 . 
relpath
 ( 
full_path
 , 
where
 )

89 
package
 = 
rel_path
 . 
replace
 ( 
os
 . 
path
 . 
sep
 , '.' )

92 if ( '.' in 
dir
 or not 
cls
 . 
_looks_like_package
 ( 
full_path
 ) ) :

96 if 
include
 ( 
package
 ) and not 
exclude
 ( 
package
 ) :

97 yield 
package

101 
dirs
 . 
append
 ( 
dir
 ) 
	}

103 @ 
	`staticmethod

104 def 
	$_looks_like_package
 ( 
path
 ) :

106 return 
os
 . 
path
 . 
isfile
 ( 
os
 . 
path
 . 
join
 ( 
path
 , '__init__.py' ) ) 
	}

108 @ 
	`staticmethod

109 def 
	$_build_filter
 ( * 
patterns
 ) :

114 return lambda 
name
 : 
any
 ( 
fnmatchcase
 ( 
name
 , 
pat
 = 
pat
 ) for 
pat
 in 
patterns
 ) 
	}

117 class 
	cPEP420PackageFinder
 ( 
PackageFinder
 ) :

118 @ 
	`staticmethod

119 def 
	$_looks_like_package
 ( 
path
 ) :

120 return True 
	}

123 
find_packages
 = 
PackageFinder
 . 
find

125 if 
PY3
 :

126 
find_namespace_packages
 = 
PEP420PackageFinder
 . 
find

129 def 
	$_install_setup_requires
 ( 
attrs
 ) :

132 
dist
 = 
distutils
 . 
core
 . 
Distribution
 ( 
dict
 (

133 ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
attrs
 . 
items
 ( )

134 if 
k
 in ( 'dependency_links' , 'setup_requires' )

137 
dist
 . 
parse_config_files
 ( 
ignore_option_errors
 = True )

138 if 
dist
 . 
setup_requires
 :

139 
dist
 . 
fetch_build_eggs
 ( 
dist
 . 
setup_requires
 ) 
	}

142 def 
	$setup
 ( ** 
attrs
 ) :

144 
_install_setup_requires
 ( 
attrs
 )

145 return 
distutils
 . 
core
 . 
setup
 ( ** 
attrs
 ) 
	}

147 
setup
 . 
__doc__
 = 
distutils
 . 
core
 . 
setup
 . 
__doc__

150 
_Command
 = 
monkey
 . 
get_unpatched
 ( 
distutils
 . 
core
 . 
Command
 )

153 class 
	cCommand
 ( 
_Command
 ) :

154 
__doc__
 = 
_Command
 . 
__doc__

156 
command_consumes_arguments
 = False

158 def 
	$__init__
 ( 
self
 , 
dist
 , ** 
kw
 ) :

163 
_Command
 . 
__init__
 ( 
self
 , 
dist
 )

164 
vars
 ( 
self
 ) . 
update
 ( 
kw
 ) 
	}

166 def 
	$_ensure_stringlike
 ( 
self
 , 
option
 , 
what
 , 
default
 = None ) :

167 
val
 = 
getattr
 ( 
self
 , 
option
 )

168 if 
val
 is None :

169 
setattr
 ( 
self
 , 
option
 , 
default
 )

170 return 
default

171 elif not 
isinstance
 ( 
val
 , 
string_types
 ) :

172 raise 
DistutilsOptionError
 ( "'%s' must be a %s (got `%s`)"

173 % ( 
option
 , 
what
 , 
val
 ) )

174 return 
val
 
	}

176 def 
	$ensure_string_list
 ( 
self
 , 
option
 ) :

182 
val
 = 
getattr
 ( 
self
 , 
option
 )

183 if 
val
 is None :

185 elif 
isinstance
 ( 
val
 , 
string_types
 ) :

186 
setattr
 ( 
self
 , 
option
 , 
re
 . 
split
 ( r',\s*|\s+' , 
val
 ) )

188 if 
isinstance
 ( 
val
 , 
list
 ) :

189 
ok
 = 
all
 ( 
isinstance
 ( 
v
 , 
string_types
 ) for 
v
 in 
val
 )

191 
ok
 = False

192 if not 
ok
 :

193 raise 
DistutilsOptionError
 ( "'%s' must be a list of strings (got %r)"

195 % ( 
option
 , 
val
 ) ) 
	}

197 def 
	$reinitialize_command
 ( 
self
 , 
command
 , 
reinit_subcommands
 = 0 , ** 
kw
 ) :

198 
cmd
 = 
_Command
 . 
reinitialize_command
 ( 
self
 , 
command
 , 
reinit_subcommands
 )

199 
vars
 ( 
cmd
 ) . 
update
 ( 
kw
 )

200 return 
cmd
 
	}

203 def 
	$_find_all_simple
 ( 
path
 ) :

207 
results
 = (

208 
os
 . 
path
 . 
join
 ( 
base
 , 
file
 )

209 for 
base
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
path
 , 
followlinks
 = True )

210 for 
file
 in 
files

212 return 
filter
 ( 
os
 . 
path
 . 
isfile
 , 
results
 ) 
	}

215 def 
	$findall
 ( 
dir
 = 
os
 . 
curdir
 ) :

220 
files
 = 
_find_all_simple
 ( 
dir
 )

221 if 
dir
 == 
os
 . 
curdir
 :

222 
make_rel
 = 
functools
 . 
partial
 ( 
os
 . 
path
 . 
relpath
 , 
start
 = 
dir
 )

223 
files
 = 
map
 ( 
make_rel
 , 
files
 )

224 return 
list
 ( 
files
 ) 
	}

228 
monkey
 . 
patch_all
 ( )


	@./env/lib/python3.7/site-packages/setuptools/launch.py

9 import 
	~tokenize

10 import 
	~sys

13 def 
	$run
 ( ) :

18 
__builtins__

19 
script_name
 = 
sys
 . 
argv
 [ 1 ]

20 
namespace
 = 
dict
 (

21 
__file__
 = 
script_name
 ,

22 
__name__
 = '__main__' ,

23 
__doc__
 = None ,

25 
sys
 . 
argv
 [ : ] = 
sys
 . 
argv
 [ 1 : ]

27 
open_
 = 
getattr
 ( 
tokenize
 , 'open' , 
open
 )

28 
script
 = 
open_
 ( 
script_name
 ) . 
read
 ( )

29 
norm_script
 = 
script
 . 
replace
 ( '\\r\\n' , '\\n' )

30 
code
 = 
compile
 ( 
norm_script
 , 
script_name
 , 'exec' )

31 
exec
 ( 
code
 , 
namespace
 ) 
	}

34 if 
__name__
 == '__main__' :

35 
run
 ( )


	@./env/lib/python3.7/site-packages/setuptools/namespaces.py

1 import 
	~os

2 from 
	~distutils
 import 
log

3 import 
	~itertools

5 from 
	~setuptools.extern.six.moves
 import 
map

8 
flatten
 = 
itertools
 . 
chain
 . 
from_iterable

11 class 
	cInstaller
 :

13 
nspkg_ext
 = '-nspkg.pth'

15 def 
	$install_namespaces
 ( 
self
 ) :

16 
nsp
 = 
self
 . 
_get_all_ns_packages
 ( )

17 if not 
nsp
 :

19 
filename
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
self
 . 
_get_target
 ( ) )

20 
filename
 += 
self
 . 
nspkg_ext

21 
self
 . 
outputs
 . 
append
 ( 
filename
 )

22 
log
 . 
info
 ( "Installing %s" , 
filename
 )

23 
lines
 = 
map
 ( 
self
 . 
_gen_nspkg_line
 , 
nsp
 )

25 if 
self
 . 
dry_run
 :

27 
list
 ( 
lines
 )

30 with 
open
 ( 
filename
 , 'wt' ) as 
f
 :

31 
f
 . 
writelines
 ( 
lines
 ) 
	}

33 def 
	$uninstall_namespaces
 ( 
self
 ) :

34 
filename
 , 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
self
 . 
_get_target
 ( ) )

35 
filename
 += 
self
 . 
nspkg_ext

36 if not 
os
 . 
path
 . 
exists
 ( 
filename
 ) :

38 
log
 . 
info
 ( "Removing %s" , 
filename
 )

39 
os
 . 
remove
 ( 
filename
 ) 
	}

41 def 
	$_get_target
 ( 
self
 ) :

42 return 
self
 . 
target
 
	}

44 
_nspkg_tmpl
 = ( "import sys, types, os"

62 
_nspkg_tmpl_multi
 = ( 'm and setattr(sys.modules[%(parent)r], %(child)r, m)'

67 def 
	$_get_root
 ( 
self
 ) :

68 return "sys._getframe(1).f_locals['sitedir']" 
	}

70 def 
	$_gen_nspkg_line
 ( 
self
 , 
pkg
 ) :

72 
pkg
 = 
str
 ( 
pkg
 )

73 
pth
 = 
tuple
 ( 
pkg
 . 
split
 ( '.' ) )

74 
root
 = 
self
 . 
_get_root
 ( )

75 
tmpl_lines
 = 
self
 . 
_nspkg_tmpl

76 
parent
 , 
sep
 , 
child
 = 
pkg
 . 
rpartition
 ( '.' )

77 if 
parent
 :

78 
tmpl_lines
 += 
self
 . 
_nspkg_tmpl_multi

79 return ';' . 
join
 ( 
tmpl_lines
 ) % 
locals
 ( ) + '\n' 
	}

81 def 
	$_get_all_ns_packages
 ( 
self
 ) :

83 
pkgs
 = 
self
 . 
distribution
 . 
namespace_packages
 or [ ]

84 return 
sorted
 ( 
flatten
 ( 
map
 ( 
self
 . 
_pkg_names
 , 
pkgs
 ) ) ) 
	}

86 @ 
	`staticmethod

87 def 
	$_pkg_names
 ( 
pkg
 ) :

96 
parts
 = 
pkg
 . 
split
 ( '.' )

97 while 
parts
 :

98 yield '.' . 
join
 ( 
parts
 )

99 
parts
 . 
pop
 ( ) 
	}

102 class 
	cDevelopInstaller
 ( 
Installer
 ) :

103 def 
	$_get_root
 ( 
self
 ) :

104 return 
repr
 ( 
str
 ( 
self
 . 
egg_path
 ) ) 
	}

106 def 
	$_get_target
 ( 
self
 ) :

107 return 
self
 . 
egg_link
 
	}


	@./env/lib/python3.7/site-packages/setuptools/sandbox.py

1 import 
	~os

2 import 
	~sys

3 import 
	~tempfile

4 import 
	~operator

5 import 
	~functools

6 import 
	~itertools

7 import 
	~re

8 import 
	~contextlib

9 import 
	~pickle

10 import 
	~textwrap

12 from 
	~setuptools.extern
 import 
six

13 from 
	~setuptools.extern.six.moves
 import 
builtins
 , 
map

15 import 
	~pkg_resources.py31compat

17 if 
sys
 . 
platform
 . 
startswith
 ( 'java' ) :

18 import 
	~org.python.modules.posix.PosixModule
 as 
_os

20 
_os
 = 
sys
 . 
modules
 [ 
os
 . 
name
 ]

22 
_file
 = 
file

23 except 
NameError
 :

24 
_file
 = None

25 
_open
 = 
open

26 from 
	~distutils.errors
 import 
DistutilsError

27 from 
	~pkg_resources
 import 
working_set

30 
__all__
 = [ "AbstractSandbox"

35 def 
	$_execfile
 ( 
filename
 , 
globals
 , 
locals
 = None ) :

39 
mode
 = 'rb'

40 with 
open
 ( 
filename
 , 
mode
 ) as 
stream
 :

41 
script
 = 
stream
 . 
read
 ( )

42 if 
locals
 is None :

43 
locals
 = 
globals

44 
code
 = 
compile
 ( 
script
 , 
filename
 , 'exec' )

45 
exec
 ( 
code
 , 
globals
 , 
locals
 ) 
	}

48 @ 
contextlib
 . 
	`contextmanager

49 def 
	$save_argv
 ( 
repl
 = None ) :

50 
saved
 = 
sys
 . 
argv
 [ : ]

51 if 
repl
 is not None :

52 
sys
 . 
argv
 [ : ] = 
repl

54 yield 
saved

56 
sys
 . 
argv
 [ : ] = 
saved
 
	}

59 @ 
contextlib
 . 
	`contextmanager

60 def 
	$save_path
 ( ) :

61 
saved
 = 
sys
 . 
path
 [ : ]

63 yield 
saved

65 
sys
 . 
path
 [ : ] = 
saved
 
	}

68 @ 
contextlib
 . 
	`contextmanager

69 def 
	$override_temp
 ( 
replacement
 ) :

73 
pkg_resources
 . 
py31compat
 . 
makedirs
 ( 
replacement
 , 
exist_ok
 = True )

75 
saved
 = 
tempfile
 . 
tempdir

77 
tempfile
 . 
tempdir
 = 
replacement

82 
tempfile
 . 
tempdir
 = 
saved
 
	}

85 @ 
contextlib
 . 
	`contextmanager

86 def 
	$pushd
 ( 
target
 ) :

87 
saved
 = 
os
 . 
getcwd
 ( )

88 
os
 . 
chdir
 ( 
target
 )

90 yield 
saved

92 
os
 . 
chdir
 ( 
saved
 ) 
	}

95 class 
	cUnpickleableException
 ( 
Exception
 ) :

100 @ 
	`staticmethod

101 def 
	$dump
 ( 
type
 , 
exc
 ) :

107 return 
pickle
 . 
dumps
 ( 
type
 ) , 
pickle
 . 
dumps
 ( 
exc
 )

108 except 
Exception
 :

110 from 
	~setuptools.sandbox
 import 
UnpickleableException
 as 
cls

111 return 
cls
 . 
dump
 ( 
cls
 , 
cls
 ( 
repr
 ( 
exc
 ) ) ) 
	}

114 class 
	cExceptionSaver
 :

120 def 
	$__enter__
 ( 
self
 ) :

121 return 
self
 
	}

123 def 
	$__exit__
 ( 
self
 , 
type
 , 
exc
 , 
tb
 ) :

124 if not 
exc
 :

128 
self
 . 
_saved
 = 
UnpickleableException
 . 
dump
 ( 
type
 , 
exc
 )

129 
self
 . 
_tb
 = 
tb

132 return True 
	}

134 def 
	$resume
 ( 
self
 ) :

137 if '_saved' not in 
vars
 ( 
self
 ) :

140 
type
 , 
exc
 = 
map
 ( 
pickle
 . 
loads
 , 
self
 . 
_saved
 )

141 
six
 . 
reraise
 ( 
type
 , 
exc
 , 
self
 . 
_tb
 ) 
	}

144 @ 
contextlib
 . 
	`contextmanager

145 def 
	$save_modules
 ( ) :

152 
saved
 = 
sys
 . 
modules
 . 
copy
 ( )

153 with 
ExceptionSaver
 ( ) as 
saved_exc
 :

154 yield 
saved

156 
sys
 . 
modules
 . 
update
 ( 
saved
 )

158 
del_modules
 = (

159 
mod_name
 for 
mod_name
 in 
sys
 . 
modules

160 if 
mod_name
 not in 
saved

162 and not 
mod_name
 . 
startswith
 ( 'encodings.' )

164 
_clear_modules
 ( 
del_modules
 )

166 
saved_exc
 . 
resume
 ( ) 
	}

169 def 
	$_clear_modules
 ( 
module_names
 ) :

170 for 
mod_name
 in 
list
 ( 
module_names
 ) :

171 del 
sys
 . 
modules
 [ 
mod_name
 ] 
	}

174 @ 
contextlib
 . 
	`contextmanager

175 def 
	$save_pkg_resources_state
 ( ) :

176 
saved
 = 
pkg_resources
 . 
__getstate__
 ( )

178 yield 
saved

180 
pkg_resources
 . 
__setstate__
 ( 
saved
 ) 
	}

183 @ 
contextlib
 . 
	`contextmanager

184 def 
	$setup_context
 ( 
setup_dir
 ) :

185 
temp_dir
 = 
os
 . 
path
 . 
join
 ( 
setup_dir
 , 'temp' )

186 with 
save_pkg_resources_state
 ( ) :

187 with 
save_modules
 ( ) :

188 
hide_setuptools
 ( )

189 with 
save_path
 ( ) :

190 with 
save_argv
 ( ) :

191 with 
override_temp
 ( 
temp_dir
 ) :

192 with 
pushd
 ( 
setup_dir
 ) :

194 
__import__
 ( 'setuptools' )

195 yield 
	}

198 def 
	$_needs_hiding
 ( 
mod_name
 ) :

215 
pattern
 = 
re
 . 
compile
 ( r'(setuptools|pkg_resources|distutils|Cython)(\.|$)' )

216 return 
bool
 ( 
pattern
 . 
match
 ( 
mod_name
 ) ) 
	}

219 def 
	$hide_setuptools
 ( ) :

226 
modules
 = 
filter
 ( 
_needs_hiding
 , 
sys
 . 
modules
 )

227 
_clear_modules
 ( 
modules
 ) 
	}

230 def 
	$run_setup
 ( 
setup_script
 , 
args
 ) :

232 
setup_dir
 = 
os
 . 
path
 . 
abspath
 ( 
os
 . 
path
 . 
dirname
 ( 
setup_script
 ) )

233 with 
setup_context
 ( 
setup_dir
 ) :

235 
sys
 . 
argv
 [ : ] = [ 
setup_script
 ] + 
list
 ( 
args
 )

236 
sys
 . 
path
 . 
insert
 ( 0 , 
setup_dir
 )

238 
working_set
 . 
__init__
 ( )

239 
working_set
 . 
callbacks
 . 
append
 ( lambda 
dist
 : 
dist
 . 
activate
 ( ) )

242 
dunder_file
 = (

243 
setup_script

244 if 
isinstance
 ( 
setup_script
 , 
str
 ) else

245 
setup_script
 . 
encode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

248 with 
DirectorySandbox
 ( 
setup_dir
 ) :

249 
ns
 = 
dict
 ( 
__file__
 = 
dunder_file
 , 
__name__
 = '__main__' )

250 
_execfile
 ( 
setup_script
 , 
ns
 )

251 except 
SystemExit
 as 
v
 :

252 if 
v
 . 
args
 and 
v
 . 
args
 [ 0 ] :

253 raise 
	}

257 class 
	cAbstractSandbox
 :

260 
_active
 = False

262 def 
	$__init__
 ( 
self
 ) :

263 
self
 . 
_attrs
 = [

264 
name
 for 
name
 in 
dir
 ( 
_os
 )

265 if not 
name
 . 
startswith
 ( '_' ) and 
hasattr
 ( 
self
 , 
name
 )

266 ] 
	}

268 def 
	$_copy
 ( 
self
 , 
source
 ) :

269 for 
name
 in 
self
 . 
_attrs
 :

270 
setattr
 ( 
os
 , 
name
 , 
getattr
 ( 
source
 , 
name
 ) ) 
	}

272 def 
	$__enter__
 ( 
self
 ) :

273 
self
 . 
_copy
 ( 
self
 )

274 if 
_file
 :

275 
builtins
 . 
file
 = 
self
 . 
_file

276 
builtins
 . 
open
 = 
self
 . 
_open

277 
self
 . 
_active
 = True 
	}

279 def 
	$__exit__
 ( 
self
 , 
exc_type
 , 
exc_value
 , 
traceback
 ) :

280 
self
 . 
_active
 = False

281 if 
_file
 :

282 
builtins
 . 
file
 = 
_file

283 
builtins
 . 
open
 = 
_open

284 
self
 . 
_copy
 ( 
_os
 ) 
	}

286 def 
	$run
 ( 
self
 , 
func
 ) :

288 with 
self
 :

289 return 
func
 ( ) 
	}

291 def 
	$_mk_dual_path_wrapper
 ( 
name
 ) :

292 
original
 = 
getattr
 ( 
_os
 , 
name
 )

294 def 
wrap
 ( 
self
 , 
src
 , 
dst
 , * 
args
 , ** 
kw
 ) :

295 if 
self
 . 
_active
 :

296 
src
 , 
dst
 = 
self
 . 
_remap_pair
 ( 
name
 , 
src
 , 
dst
 , * 
args
 , ** 
kw
 )

297 return 
original
 ( 
src
 , 
dst
 , * 
args
 , ** 
kw
 )

299 return 
wrap
 
	}

301 for 
name
 in [ "rename" , "link" , "symlink" ] :

302 if 
hasattr
 ( 
_os
 , 
name
 ) :

303 
locals
 ( ) [ 
name
 ] = 
_mk_dual_path_wrapper
 ( 
name
 )

305 def 
	$_mk_single_path_wrapper
 ( 
name
 , 
original
 = None ) :

306 
original
 = 
original
 or 
getattr
 ( 
_os
 , 
name
 )

308 def 
wrap
 ( 
self
 , 
path
 , * 
args
 , ** 
kw
 ) :

309 if 
self
 . 
_active
 :

310 
path
 = 
self
 . 
_remap_input
 ( 
name
 , 
path
 , * 
args
 , ** 
kw
 )

311 return 
original
 ( 
path
 , * 
args
 , ** 
kw
 )

313 return 
wrap
 
	}

315 if 
_file
 :

316 
_file
 = 
_mk_single_path_wrapper
 ( 'file' , 
_file
 )

317 
_open
 = 
_mk_single_path_wrapper
 ( 'open' , 
_open
 )

318 for 
name
 in [ "stat"

323 if 
hasattr
 ( 
_os
 , 
name
 ) :

324 
locals
 ( ) [ 
name
 ] = 
_mk_single_path_wrapper
 ( 
name
 )

326 def 
	$_mk_single_with_return
 ( 
name
 ) :

327 
original
 = 
getattr
 ( 
_os
 , 
name
 )

329 def 
wrap
 ( 
self
 , 
path
 , * 
args
 , ** 
kw
 ) :

330 if 
self
 . 
_active
 :

331 
path
 = 
self
 . 
_remap_input
 ( 
name
 , 
path
 , * 
args
 , ** 
kw
 )

332 return 
self
 . 
_remap_output
 ( 
name
 , 
original
 ( 
path
 , * 
args
 , ** 
kw
 ) )

333 return 
original
 ( 
path
 , * 
args
 , ** 
kw
 )

335 return 
wrap
 
	}

337 for 
name
 in [ 'readlink' , 'tempnam' ] :

338 if 
hasattr
 ( 
_os
 , 
name
 ) :

339 
locals
 ( ) [ 
name
 ] = 
_mk_single_with_return
 ( 
name
 )

341 def 
	$_mk_query
 ( 
name
 ) :

342 
original
 = 
getattr
 ( 
_os
 , 
name
 )

344 def 
wrap
 ( 
self
 , * 
args
 , ** 
kw
 ) :

345 
retval
 = 
original
 ( * 
args
 , ** 
kw
 )

346 if 
self
 . 
_active
 :

347 return 
self
 . 
_remap_output
 ( 
name
 , 
retval
 )

348 return 
retval

350 return 
wrap
 
	}

352 for 
name
 in [ 'getcwd' , 'tmpnam' ] :

353 if 
hasattr
 ( 
_os
 , 
name
 ) :

354 
locals
 ( ) [ 
name
 ] = 
_mk_query
 ( 
name
 )

356 def 
	$_validate_path
 ( 
self
 , 
path
 ) :

358 return 
path
 
	}

360 def 
	$_remap_input
 ( 
self
 , 
operation
 , 
path
 , * 
args
 , ** 
kw
 ) :

362 return 
self
 . 
_validate_path
 ( 
path
 ) 
	}

364 def 
	$_remap_output
 ( 
self
 , 
operation
 , 
path
 ) :

366 return 
self
 . 
_validate_path
 ( 
path
 ) 
	}

368 def 
	$_remap_pair
 ( 
self
 , 
operation
 , 
src
 , 
dst
 , * 
args
 , ** 
kw
 ) :

371 
self
 . 
_remap_input
 ( 
operation
 + '-from' , 
src
 , * 
args
 , ** 
kw
 ) ,

372 
self
 . 
_remap_input
 ( 
operation
 + '-to' , 
dst
 , * 
args
 , ** 
kw
 )

373 ) 
	}

376 if 
hasattr
 ( 
os
 , 'devnull' ) :

377 
_EXCEPTIONS
 = [ 
os
 . 
devnull
 , ]

379 
_EXCEPTIONS
 = [ ]

382 class 
	cDirectorySandbox
 ( 
AbstractSandbox
 ) :

385 
write_ops
 = 
dict
 . 
fromkeys
 ( [ "open"

390 
_exception_patterns
 = [ r'.*lib2to3.*\.pickle$'

396 def 
	$__init__
 ( 
self
 , 
sandbox
 , 
exceptions
 = 
_EXCEPTIONS
 ) :

397 
self
 . 
_sandbox
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
realpath
 ( 
sandbox
 ) )

398 
self
 . 
_prefix
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
_sandbox
 , '' )

399 
self
 . 
_exceptions
 = [

400 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
realpath
 ( 
path
 ) )

401 for 
path
 in 
exceptions

403 
AbstractSandbox
 . 
__init__
 ( 
self
 ) 
	}

405 def 
	$_violation
 ( 
self
 , 
operation
 , * 
args
 , ** 
kw
 ) :

406 from 
	~setuptools.sandbox
 import 
SandboxViolation

407 raise 
SandboxViolation
 ( 
operation
 , 
args
 , 
kw
 ) 
	}

409 if 
_file
 :

411 def 
	$_file
 ( 
self
 , 
path
 , 
mode
 = 'r' , * 
args
 , ** 
kw
 ) :

412 if 
mode
 not in ( 'r' , 'rt' , 'rb' , 'rU' , 'U' ) and not 
self
 . 
_ok
 ( 
path
 ) :

413 
self
 . 
_violation
 ( "file" , 
path
 , 
mode
 , * 
args
 , ** 
kw
 )

414 return 
_file
 ( 
path
 , 
mode
 , * 
args
 , ** 
kw
 ) 
	}

416 def 
	$_open
 ( 
self
 , 
path
 , 
mode
 = 'r' , * 
args
 , ** 
kw
 ) :

417 if 
mode
 not in ( 'r' , 'rt' , 'rb' , 'rU' , 'U' ) and not 
self
 . 
_ok
 ( 
path
 ) :

418 
self
 . 
_violation
 ( "open" , 
path
 , 
mode
 , * 
args
 , ** 
kw
 )

419 return 
_open
 ( 
path
 , 
mode
 , * 
args
 , ** 
kw
 ) 
	}

421 def 
	$tmpnam
 ( 
self
 ) :

422 
self
 . 
_violation
 ( "tmpnam" ) 
	}

424 def 
	$_ok
 ( 
self
 , 
path
 ) :

425 
active
 = 
self
 . 
_active

427 
self
 . 
_active
 = False

428 
realpath
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
realpath
 ( 
path
 ) )

430 
self
 . 
_exempted
 ( 
realpath
 )

431 or 
realpath
 == 
self
 . 
_sandbox

432 or 
realpath
 . 
startswith
 ( 
self
 . 
_prefix
 )

435 
self
 . 
_active
 = 
active
 
	}

437 def 
	$_exempted
 ( 
self
 , 
filepath
 ) :

438 
start_matches
 = (

439 
filepath
 . 
startswith
 ( 
exception
 )

440 for 
exception
 in 
self
 . 
_exceptions

442 
pattern_matches
 = (

443 
re
 . 
match
 ( 
pattern
 , 
filepath
 )

444 for 
pattern
 in 
self
 . 
_exception_patterns

446 
candidates
 = 
itertools
 . 
chain
 ( 
start_matches
 , 
pattern_matches
 )

447 return 
any
 ( 
candidates
 ) 
	}

449 def 
	$_remap_input
 ( 
self
 , 
operation
 , 
path
 , * 
args
 , ** 
kw
 ) :

451 if 
operation
 in 
self
 . 
write_ops
 and not 
self
 . 
_ok
 ( 
path
 ) :

452 
self
 . 
_violation
 ( 
operation
 , 
os
 . 
path
 . 
realpath
 ( 
path
 ) , * 
args
 , ** 
kw
 )

453 return 
path
 
	}

455 def 
	$_remap_pair
 ( 
self
 , 
operation
 , 
src
 , 
dst
 , * 
args
 , ** 
kw
 ) :

457 if not 
self
 . 
_ok
 ( 
src
 ) or not 
self
 . 
_ok
 ( 
dst
 ) :

458 
self
 . 
_violation
 ( 
operation
 , 
src
 , 
dst
 , * 
args
 , ** 
kw
 )

459 return ( 
src
 , 
dst
 ) 
	}

461 def 
	$open
 ( 
self
 , 
file
 , 
flags
 , 
mode
 = 0o777 , * 
args
 , ** 
kw
 ) :

463 if 
flags
 & 
WRITE_FLAGS
 and not 
self
 . 
_ok
 ( 
file
 ) :

464 
self
 . 
_violation
 ( "os.open" , 
file
 , 
flags
 , 
mode
 , * 
args
 , ** 
kw
 )

465 return 
_os
 . 
open
 ( 
file
 , 
flags
 , 
mode
 , * 
args
 , ** 
kw
 ) 
	}

468 
WRITE_FLAGS
 = 
functools
 . 
reduce
 (

469 
operator
 . 
or_
 , [ 
getattr
 ( 
_os
 , 
a
 , 0 ) for 
a
 in "O_WRONLY O_RDWR O_APPEND O_CREAT O_TRUNC O_TEMPORARY"

470 . 
split
 ( ) ]

474 class 
	cSandboxViolation
 ( 
DistutilsError
 ) :

477 
tmpl
 = 
textwrap
 . 
dedent
 ( """\n        SandboxViolation: {cmd}{args!r} {kwargs}\n\n        The package setup script has attempted to modify files on your system\n        that are not within the EasyInstall build area, and has been aborted.\n\n        This package cannot be safely installed by EasyInstall, and may not\n        support alternate installation locations even if you run its setup\n        script by hand.  Please inform the package's author and the EasyInstall\n        maintainers to find out if a fix or workaround is available.\n        """

487 ) . 
lstrip
 ( )

489 def 
	$__str__
 ( 
self
 ) :

490 
cmd
 , 
args
 , 
kwargs
 = 
self
 . 
args

491 return 
self
 . 
tmpl
 . 
format
 ( ** 
locals
 ( ) ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/six.py

23 from 
	~__future__
 import 
absolute_import

25 import 
	~functools

26 import 
	~itertools

27 import 
	~operator

28 import 
	~sys

29 import 
	~types

31 
__author__
 = "Benjamin Peterson <benjamin@python.org>"

32 
__version__
 = "1.10.0"

36 
PY2
 = 
sys
 . 
version_info
 [ 0 ] == 2

37 
PY3
 = 
sys
 . 
version_info
 [ 0 ] == 3

38 
PY34
 = 
sys
 . 
version_info
 [ 0 : 2 ] >= ( 3 , 4 )

40 if 
PY3
 :

41 
string_types
 = 
str
 ,

42 
integer_types
 = 
int
 ,

43 
class_types
 = 
type
 ,

44 
text_type
 = 
str

45 
binary_type
 = 
bytes

47 
MAXSIZE
 = 
sys
 . 
maxsize

49 
string_types
 = 
basestring
 ,

50 
integer_types
 = ( 
int
 , 
long
 )

51 
class_types
 = ( 
type
 , 
types
 . 
ClassType
 )

52 
text_type
 = 
unicode

53 
binary_type
 = 
str

55 if 
sys
 . 
platform
 . 
startswith
 ( "java" ) :

57 
MAXSIZE
 = 
int
 ( ( 1 << 31 ) - 1 )

60 class 
	cX
 ( 
object
 ) :

62 def 
	$__len__
 ( 
self
 ) :

63 return 1 << 31 
	}

65 
len
 ( 
X
 ( ) )

66 except 
OverflowError
 :

68 
MAXSIZE
 = 
int
 ( ( 1 << 31 ) - 1 )

71 
MAXSIZE
 = 
int
 ( ( 1 << 63 ) - 1 )

72 del 
X

75 def 
	$_add_doc
 ( 
func
 , 
doc
 ) :

77 
func
 . 
__doc__
 = 
doc
 
	}

80 def 
	$_import_module
 ( 
name
 ) :

82 
__import__
 ( 
name
 )

83 return 
sys
 . 
modules
 [ 
name
 ] 
	}

86 class 
	c_LazyDescr
 ( 
object
 ) :

88 def 
	$__init__
 ( 
self
 , 
name
 ) :

89 
self
 . 
name
 = 
name
 
	}

91 def 
	$__get__
 ( 
self
 , 
obj
 , 
tp
 ) :

92 
result
 = 
self
 . 
_resolve
 ( )

93 
setattr
 ( 
obj
 , 
self
 . 
name
 , 
result
 )

97 
delattr
 ( 
obj
 . 
__class__
 , 
self
 . 
name
 )

98 except 
AttributeError
 :

100 return 
result
 
	}

103 class 
	cMovedModule
 ( 
_LazyDescr
 ) :

105 def 
	$__init__
 ( 
self
 , 
name
 , 
old
 , 
new
 = None ) :

106 
super
 ( 
MovedModule
 , 
self
 ) . 
__init__
 ( 
name
 )

107 if 
PY3
 :

108 if 
new
 is None :

109 
new
 = 
name

110 
self
 . 
mod
 = 
new

112 
self
 . 
mod
 = 
old
 
	}

114 def 
	$_resolve
 ( 
self
 ) :

115 return 
_import_module
 ( 
self
 . 
mod
 ) 
	}

117 def 
	$__getattr__
 ( 
self
 , 
attr
 ) :

118 
_module
 = 
self
 . 
_resolve
 ( )

119 
value
 = 
getattr
 ( 
_module
 , 
attr
 )

120 
setattr
 ( 
self
 , 
attr
 , 
value
 )

121 return 
value
 
	}

124 class 
	c_LazyModule
 ( 
types
 . 
ModuleType
 ) :

126 def 
	$__init__
 ( 
self
 , 
name
 ) :

127 
super
 ( 
_LazyModule
 , 
self
 ) . 
__init__
 ( 
name
 )

128 
self
 . 
__doc__
 = 
self
 . 
__class__
 . 
__doc__
 
	}

130 def 
	$__dir__
 ( 
self
 ) :

131 
attrs
 = [ "__doc__" , "__name__" ]

132 
attrs
 += [ 
attr
 . 
name
 for 
attr
 in 
self
 . 
_moved_attributes
 ]

133 return 
attrs
 
	}

136 
_moved_attributes
 = [ ]

139 class 
	cMovedAttribute
 ( 
_LazyDescr
 ) :

141 def 
	$__init__
 ( 
self
 , 
name
 , 
old_mod
 , 
new_mod
 , 
old_attr
 = None , 
new_attr
 = None ) :

142 
super
 ( 
MovedAttribute
 , 
self
 ) . 
__init__
 ( 
name
 )

143 if 
PY3
 :

144 if 
new_mod
 is None :

145 
new_mod
 = 
name

146 
self
 . 
mod
 = 
new_mod

147 if 
new_attr
 is None :

148 if 
old_attr
 is None :

149 
new_attr
 = 
name

151 
new_attr
 = 
old_attr

152 
self
 . 
attr
 = 
new_attr

154 
self
 . 
mod
 = 
old_mod

155 if 
old_attr
 is None :

156 
old_attr
 = 
name

157 
self
 . 
attr
 = 
old_attr
 
	}

159 def 
	$_resolve
 ( 
self
 ) :

160 
module
 = 
_import_module
 ( 
self
 . 
mod
 )

161 return 
getattr
 ( 
module
 , 
self
 . 
attr
 ) 
	}

164 class 
	c_SixMetaPathImporter
 ( 
object
 ) :

173 def 
	$__init__
 ( 
self
 , 
six_module_name
 ) :

174 
self
 . 
name
 = 
six_module_name

175 
self
 . 
known_modules
 = { } 
	}

177 def 
	$_add_module
 ( 
self
 , 
mod
 , * 
fullnames
 ) :

178 for 
fullname
 in 
fullnames
 :

179 
self
 . 
known_modules
 [ 
self
 . 
name
 + "." + 
fullname
 ] = 
mod
 
	}

181 def 
	$_get_module
 ( 
self
 , 
fullname
 ) :

182 return 
self
 . 
known_modules
 [ 
self
 . 
name
 + "." + 
fullname
 ] 
	}

184 def 
	$find_module
 ( 
self
 , 
fullname
 , 
path
 = None ) :

185 if 
fullname
 in 
self
 . 
known_modules
 :

186 return 
self

187 return None 
	}

189 def 
	$__get_module
 ( 
self
 , 
fullname
 ) :

191 return 
self
 . 
known_modules
 [ 
fullname
 ]

192 except 
KeyError
 :

193 raise 
ImportError
 ( "This loader does not know module " + 
fullname
 ) 
	}

195 def 
	$load_module
 ( 
self
 , 
fullname
 ) :

198 return 
sys
 . 
modules
 [ 
fullname
 ]

199 except 
KeyError
 :

201 
mod
 = 
self
 . 
__get_module
 ( 
fullname
 )

202 if 
isinstance
 ( 
mod
 , 
MovedModule
 ) :

203 
mod
 = 
mod
 . 
_resolve
 ( )

205 
mod
 . 
__loader__
 = 
self

206 
sys
 . 
modules
 [ 
fullname
 ] = 
mod

207 return 
mod
 
	}

209 def 
	$is_package
 ( 
self
 , 
fullname
 ) :

216 return 
hasattr
 ( 
self
 . 
__get_module
 ( 
fullname
 ) , "__path__" ) 
	}

218 def 
	$get_code
 ( 
self
 , 
fullname
 ) :

222 
self
 . 
__get_module
 ( 
fullname
 )

223 return None 
	}

224 
get_source
 = 
get_code

226 
_importer
 = 
_SixMetaPathImporter
 ( 
__name__
 )

229 class 
	c_MovedItems
 ( 
_LazyModule
 ) :

232 
__path__
 = [ ]

235 
_moved_attributes
 = [

236 
MovedAttribute
 ( "cStringIO" , "cStringIO" , "io" , "StringIO" ) ,

237 
MovedAttribute
 ( "filter" , "itertools" , "builtins" , "ifilter" , "filter" ) ,

238 
MovedAttribute
 ( "filterfalse" , "itertools" , "itertools" , "ifilterfalse" , "filterfalse" ) ,

239 
MovedAttribute
 ( "input" , "__builtin__" , "builtins" , "raw_input" , "input" ) ,

240 
MovedAttribute
 ( "intern" , "__builtin__" , "sys" ) ,

241 
MovedAttribute
 ( "map" , "itertools" , "builtins" , "imap" , "map" ) ,

242 
MovedAttribute
 ( "getcwd" , "os" , "os" , "getcwdu" , "getcwd" ) ,

243 
MovedAttribute
 ( "getcwdb" , "os" , "os" , "getcwd" , "getcwdb" ) ,

244 
MovedAttribute
 ( "range" , "__builtin__" , "builtins" , "xrange" , "range" ) ,

245 
MovedAttribute
 ( "reload_module" , "__builtin__" , "importlib" if 
PY34
 else "imp" , "reload" ) ,

246 
MovedAttribute
 ( "reduce" , "__builtin__" , "functools" ) ,

247 
MovedAttribute
 ( "shlex_quote" , "pipes" , "shlex" , "quote" ) ,

248 
MovedAttribute
 ( "StringIO" , "StringIO" , "io" ) ,

249 
MovedAttribute
 ( "UserDict" , "UserDict" , "collections" ) ,

250 
MovedAttribute
 ( "UserList" , "UserList" , "collections" ) ,

251 
MovedAttribute
 ( "UserString" , "UserString" , "collections" ) ,

252 
MovedAttribute
 ( "xrange" , "__builtin__" , "builtins" , "xrange" , "range" ) ,

253 
MovedAttribute
 ( "zip" , "itertools" , "builtins" , "izip" , "zip" ) ,

254 
MovedAttribute
 ( "zip_longest" , "itertools" , "itertools" , "izip_longest" , "zip_longest" ) ,

255 
MovedModule
 ( "builtins" , "__builtin__" ) ,

256 
MovedModule
 ( "configparser" , "ConfigParser" ) ,

257 
MovedModule
 ( "copyreg" , "copy_reg" ) ,

258 
MovedModule
 ( "dbm_gnu" , "gdbm" , "dbm.gnu" ) ,

259 
MovedModule
 ( "_dummy_thread" , "dummy_thread" , "_dummy_thread" ) ,

260 
MovedModule
 ( "http_cookiejar" , "cookielib" , "http.cookiejar" ) ,

261 
MovedModule
 ( "http_cookies" , "Cookie" , "http.cookies" ) ,

262 
MovedModule
 ( "html_entities" , "htmlentitydefs" , "html.entities" ) ,

263 
MovedModule
 ( "html_parser" , "HTMLParser" , "html.parser" ) ,

264 
MovedModule
 ( "http_client" , "httplib" , "http.client" ) ,

265 
MovedModule
 ( "email_mime_multipart" , "email.MIMEMultipart" , "email.mime.multipart" ) ,

266 
MovedModule
 ( "email_mime_nonmultipart" , "email.MIMENonMultipart" , "email.mime.nonmultipart" ) ,

267 
MovedModule
 ( "email_mime_text" , "email.MIMEText" , "email.mime.text" ) ,

268 
MovedModule
 ( "email_mime_base" , "email.MIMEBase" , "email.mime.base" ) ,

269 
MovedModule
 ( "BaseHTTPServer" , "BaseHTTPServer" , "http.server" ) ,

270 
MovedModule
 ( "CGIHTTPServer" , "CGIHTTPServer" , "http.server" ) ,

271 
MovedModule
 ( "SimpleHTTPServer" , "SimpleHTTPServer" , "http.server" ) ,

272 
MovedModule
 ( "cPickle" , "cPickle" , "pickle" ) ,

273 
MovedModule
 ( "queue" , "Queue" ) ,

274 
MovedModule
 ( "reprlib" , "repr" ) ,

275 
MovedModule
 ( "socketserver" , "SocketServer" ) ,

276 
MovedModule
 ( "_thread" , "thread" , "_thread" ) ,

277 
MovedModule
 ( "tkinter" , "Tkinter" ) ,

278 
MovedModule
 ( "tkinter_dialog" , "Dialog" , "tkinter.dialog" ) ,

279 
MovedModule
 ( "tkinter_filedialog" , "FileDialog" , "tkinter.filedialog" ) ,

280 
MovedModule
 ( "tkinter_scrolledtext" , "ScrolledText" , "tkinter.scrolledtext" ) ,

281 
MovedModule
 ( "tkinter_simpledialog" , "SimpleDialog" , "tkinter.simpledialog" ) ,

282 
MovedModule
 ( "tkinter_tix" , "Tix" , "tkinter.tix" ) ,

283 
MovedModule
 ( "tkinter_ttk" , "ttk" , "tkinter.ttk" ) ,

284 
MovedModule
 ( "tkinter_constants" , "Tkconstants" , "tkinter.constants" ) ,

285 
MovedModule
 ( "tkinter_dnd" , "Tkdnd" , "tkinter.dnd" ) ,

286 
MovedModule
 ( "tkinter_colorchooser" , "tkColorChooser" , "tkinter.colorchooser"

288 
MovedModule
 ( "tkinter_commondialog" , "tkCommonDialog" , "tkinter.commondialog"

290 
MovedModule
 ( "tkinter_tkfiledialog" , "tkFileDialog" , "tkinter.filedialog" ) ,

291 
MovedModule
 ( "tkinter_font" , "tkFont" , "tkinter.font" ) ,

292 
MovedModule
 ( "tkinter_messagebox" , "tkMessageBox" , "tkinter.messagebox" ) ,

293 
MovedModule
 ( "tkinter_tksimpledialog" , "tkSimpleDialog" , "tkinter.simpledialog"

295 
MovedModule
 ( "urllib_parse" , 
__name__
 + ".moves.urllib_parse" , "urllib.parse" ) ,

296 
MovedModule
 ( "urllib_error" , 
__name__
 + ".moves.urllib_error" , "urllib.error" ) ,

297 
MovedModule
 ( "urllib" , 
__name__
 + ".moves.urllib" , 
__name__
 + ".moves.urllib" ) ,

298 
MovedModule
 ( "urllib_robotparser" , "robotparser" , "urllib.robotparser" ) ,

299 
MovedModule
 ( "xmlrpc_client" , "xmlrpclib" , "xmlrpc.client" ) ,

300 
MovedModule
 ( "xmlrpc_server" , "SimpleXMLRPCServer" , "xmlrpc.server" ) ,

303 if 
sys
 . 
platform
 == "win32" :

304 
_moved_attributes
 += [

305 
MovedModule
 ( "winreg" , "_winreg" ) ,

308 for 
attr
 in 
_moved_attributes
 :

309 
setattr
 ( 
_MovedItems
 , 
attr
 . 
name
 , 
attr
 )

310 if 
isinstance
 ( 
attr
 , 
MovedModule
 ) :

311 
_importer
 . 
_add_module
 ( 
attr
 , "moves." + 
attr
 . 
name
 )

312 del 
attr

314 
_MovedItems
 . 
_moved_attributes
 = 
_moved_attributes

316 
moves
 = 
_MovedItems
 ( 
__name__
 + ".moves" )

317 
_importer
 . 
_add_module
 ( 
moves
 , "moves" )

320 class 
	cModule_six_moves_urllib_parse
 ( 
_LazyModule
 ) :

325 
_urllib_parse_moved_attributes
 = [

326 
MovedAttribute
 ( "ParseResult" , "urlparse" , "urllib.parse" ) ,

327 
MovedAttribute
 ( "SplitResult" , "urlparse" , "urllib.parse" ) ,

328 
MovedAttribute
 ( "parse_qs" , "urlparse" , "urllib.parse" ) ,

329 
MovedAttribute
 ( "parse_qsl" , "urlparse" , "urllib.parse" ) ,

330 
MovedAttribute
 ( "urldefrag" , "urlparse" , "urllib.parse" ) ,

331 
MovedAttribute
 ( "urljoin" , "urlparse" , "urllib.parse" ) ,

332 
MovedAttribute
 ( "urlparse" , "urlparse" , "urllib.parse" ) ,

333 
MovedAttribute
 ( "urlsplit" , "urlparse" , "urllib.parse" ) ,

334 
MovedAttribute
 ( "urlunparse" , "urlparse" , "urllib.parse" ) ,

335 
MovedAttribute
 ( "urlunsplit" , "urlparse" , "urllib.parse" ) ,

336 
MovedAttribute
 ( "quote" , "urllib" , "urllib.parse" ) ,

337 
MovedAttribute
 ( "quote_plus" , "urllib" , "urllib.parse" ) ,

338 
MovedAttribute
 ( "unquote" , "urllib" , "urllib.parse" ) ,

339 
MovedAttribute
 ( "unquote_plus" , "urllib" , "urllib.parse" ) ,

340 
MovedAttribute
 ( "urlencode" , "urllib" , "urllib.parse" ) ,

341 
MovedAttribute
 ( "splitquery" , "urllib" , "urllib.parse" ) ,

342 
MovedAttribute
 ( "splittag" , "urllib" , "urllib.parse" ) ,

343 
MovedAttribute
 ( "splituser" , "urllib" , "urllib.parse" ) ,

344 
MovedAttribute
 ( "uses_fragment" , "urlparse" , "urllib.parse" ) ,

345 
MovedAttribute
 ( "uses_netloc" , "urlparse" , "urllib.parse" ) ,

346 
MovedAttribute
 ( "uses_params" , "urlparse" , "urllib.parse" ) ,

347 
MovedAttribute
 ( "uses_query" , "urlparse" , "urllib.parse" ) ,

348 
MovedAttribute
 ( "uses_relative" , "urlparse" , "urllib.parse" ) ,

350 for 
attr
 in 
_urllib_parse_moved_attributes
 :

351 
setattr
 ( 
Module_six_moves_urllib_parse
 , 
attr
 . 
name
 , 
attr
 )

352 del 
attr

354 
Module_six_moves_urllib_parse
 . 
_moved_attributes
 = 
_urllib_parse_moved_attributes

356 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_parse
 ( 
__name__
 + ".moves.urllib_parse" ) , "moves.urllib_parse"

360 class 
	cModule_six_moves_urllib_error
 ( 
_LazyModule
 ) :

365 
_urllib_error_moved_attributes
 = [

366 
MovedAttribute
 ( "URLError" , "urllib2" , "urllib.error" ) ,

367 
MovedAttribute
 ( "HTTPError" , "urllib2" , "urllib.error" ) ,

368 
MovedAttribute
 ( "ContentTooShortError" , "urllib" , "urllib.error" ) ,

370 for 
attr
 in 
_urllib_error_moved_attributes
 :

371 
setattr
 ( 
Module_six_moves_urllib_error
 , 
attr
 . 
name
 , 
attr
 )

372 del 
attr

374 
Module_six_moves_urllib_error
 . 
_moved_attributes
 = 
_urllib_error_moved_attributes

376 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_error
 ( 
__name__
 + ".moves.urllib.error" ) , "moves.urllib_error"

380 class 
	cModule_six_moves_urllib_request
 ( 
_LazyModule
 ) :

385 
_urllib_request_moved_attributes
 = [

386 
MovedAttribute
 ( "urlopen" , "urllib2" , "urllib.request" ) ,

387 
MovedAttribute
 ( "install_opener" , "urllib2" , "urllib.request" ) ,

388 
MovedAttribute
 ( "build_opener" , "urllib2" , "urllib.request" ) ,

389 
MovedAttribute
 ( "pathname2url" , "urllib" , "urllib.request" ) ,

390 
MovedAttribute
 ( "url2pathname" , "urllib" , "urllib.request" ) ,

391 
MovedAttribute
 ( "getproxies" , "urllib" , "urllib.request" ) ,

392 
MovedAttribute
 ( "Request" , "urllib2" , "urllib.request" ) ,

393 
MovedAttribute
 ( "OpenerDirector" , "urllib2" , "urllib.request" ) ,

394 
MovedAttribute
 ( "HTTPDefaultErrorHandler" , "urllib2" , "urllib.request" ) ,

395 
MovedAttribute
 ( "HTTPRedirectHandler" , "urllib2" , "urllib.request" ) ,

396 
MovedAttribute
 ( "HTTPCookieProcessor" , "urllib2" , "urllib.request" ) ,

397 
MovedAttribute
 ( "ProxyHandler" , "urllib2" , "urllib.request" ) ,

398 
MovedAttribute
 ( "BaseHandler" , "urllib2" , "urllib.request" ) ,

399 
MovedAttribute
 ( "HTTPPasswordMgr" , "urllib2" , "urllib.request" ) ,

400 
MovedAttribute
 ( "HTTPPasswordMgrWithDefaultRealm" , "urllib2" , "urllib.request" ) ,

401 
MovedAttribute
 ( "AbstractBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

402 
MovedAttribute
 ( "HTTPBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

403 
MovedAttribute
 ( "ProxyBasicAuthHandler" , "urllib2" , "urllib.request" ) ,

404 
MovedAttribute
 ( "AbstractDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

405 
MovedAttribute
 ( "HTTPDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

406 
MovedAttribute
 ( "ProxyDigestAuthHandler" , "urllib2" , "urllib.request" ) ,

407 
MovedAttribute
 ( "HTTPHandler" , "urllib2" , "urllib.request" ) ,

408 
MovedAttribute
 ( "HTTPSHandler" , "urllib2" , "urllib.request" ) ,

409 
MovedAttribute
 ( "FileHandler" , "urllib2" , "urllib.request" ) ,

410 
MovedAttribute
 ( "FTPHandler" , "urllib2" , "urllib.request" ) ,

411 
MovedAttribute
 ( "CacheFTPHandler" , "urllib2" , "urllib.request" ) ,

412 
MovedAttribute
 ( "UnknownHandler" , "urllib2" , "urllib.request" ) ,

413 
MovedAttribute
 ( "HTTPErrorProcessor" , "urllib2" , "urllib.request" ) ,

414 
MovedAttribute
 ( "urlretrieve" , "urllib" , "urllib.request" ) ,

415 
MovedAttribute
 ( "urlcleanup" , "urllib" , "urllib.request" ) ,

416 
MovedAttribute
 ( "URLopener" , "urllib" , "urllib.request" ) ,

417 
MovedAttribute
 ( "FancyURLopener" , "urllib" , "urllib.request" ) ,

418 
MovedAttribute
 ( "proxy_bypass" , "urllib" , "urllib.request" ) ,

420 for 
attr
 in 
_urllib_request_moved_attributes
 :

421 
setattr
 ( 
Module_six_moves_urllib_request
 , 
attr
 . 
name
 , 
attr
 )

422 del 
attr

424 
Module_six_moves_urllib_request
 . 
_moved_attributes
 = 
_urllib_request_moved_attributes

426 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_request
 ( 
__name__
 + ".moves.urllib.request" ) , "moves.urllib_request"

430 class 
	cModule_six_moves_urllib_response
 ( 
_LazyModule
 ) :

435 
_urllib_response_moved_attributes
 = [

436 
MovedAttribute
 ( "addbase" , "urllib" , "urllib.response" ) ,

437 
MovedAttribute
 ( "addclosehook" , "urllib" , "urllib.response" ) ,

438 
MovedAttribute
 ( "addinfo" , "urllib" , "urllib.response" ) ,

439 
MovedAttribute
 ( "addinfourl" , "urllib" , "urllib.response" ) ,

441 for 
attr
 in 
_urllib_response_moved_attributes
 :

442 
setattr
 ( 
Module_six_moves_urllib_response
 , 
attr
 . 
name
 , 
attr
 )

443 del 
attr

445 
Module_six_moves_urllib_response
 . 
_moved_attributes
 = 
_urllib_response_moved_attributes

447 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_response
 ( 
__name__
 + ".moves.urllib.response" ) , "moves.urllib_response"

451 class 
	cModule_six_moves_urllib_robotparser
 ( 
_LazyModule
 ) :

456 
_urllib_robotparser_moved_attributes
 = [

457 
MovedAttribute
 ( "RobotFileParser" , "robotparser" , "urllib.robotparser" ) ,

459 for 
attr
 in 
_urllib_robotparser_moved_attributes
 :

460 
setattr
 ( 
Module_six_moves_urllib_robotparser
 , 
attr
 . 
name
 , 
attr
 )

461 del 
attr

463 
Module_six_moves_urllib_robotparser
 . 
_moved_attributes
 = 
_urllib_robotparser_moved_attributes

465 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib_robotparser
 ( 
__name__
 + ".moves.urllib.robotparser" ) , "moves.urllib_robotparser"

469 class 
	cModule_six_moves_urllib
 ( 
types
 . 
ModuleType
 ) :

472 
__path__
 = [ ]

473 
parse
 = 
_importer
 . 
_get_module
 ( "moves.urllib_parse" )

474 
error
 = 
_importer
 . 
_get_module
 ( "moves.urllib_error" )

475 
request
 = 
_importer
 . 
_get_module
 ( "moves.urllib_request" )

476 
response
 = 
_importer
 . 
_get_module
 ( "moves.urllib_response" )

477 
robotparser
 = 
_importer
 . 
_get_module
 ( "moves.urllib_robotparser" )

479 def 
	$__dir__
 ( 
self
 ) :

480 return [ 'parse' , 'error' , 'request' , 'response' , 'robotparser' ] 
	}

482 
_importer
 . 
_add_module
 ( 
Module_six_moves_urllib
 ( 
__name__
 + ".moves.urllib" ) , "moves.urllib"

486 def 
	$add_move
 ( 
move
 ) :

488 
setattr
 ( 
_MovedItems
 , 
move
 . 
name
 , 
move
 ) 
	}

491 def 
	$remove_move
 ( 
name
 ) :

494 
delattr
 ( 
_MovedItems
 , 
name
 )

495 except 
AttributeError
 :

497 del 
moves
 . 
__dict__
 [ 
name
 ]

498 except 
KeyError
 :

499 raise 
AttributeError
 ( "no such move, %r" % ( 
name
 , ) ) 
	}

502 if 
PY3
 :

503 
_meth_func
 = "__func__"

504 
_meth_self
 = "__self__"

506 
_func_closure
 = "__closure__"

507 
_func_code
 = "__code__"

508 
_func_defaults
 = "__defaults__"

509 
_func_globals
 = "__globals__"

511 
_meth_func
 = "im_func"

512 
_meth_self
 = "im_self"

514 
_func_closure
 = "func_closure"

515 
_func_code
 = "func_code"

516 
_func_defaults
 = "func_defaults"

517 
_func_globals
 = "func_globals"

521 
advance_iterator
 = 
next

522 except 
NameError
 :

523 def 
	$advance_iterator
 ( 
it
 ) :

524 return 
it
 . 
next
 ( ) 
	}

525 
next
 = 
advance_iterator

529 
callable
 = 
callable

530 except 
NameError
 :

531 def 
	$callable
 ( 
obj
 ) :

532 return 
any
 ( "__call__" in 
klass
 . 
__dict__
 for 
klass
 in 
type
 ( 
obj
 ) . 
__mro__
 ) 
	}

535 if 
PY3
 :

536 def 
	$get_unbound_function
 ( 
unbound
 ) :

537 return 
unbound
 
	}

539 
create_bound_method
 = 
types
 . 
MethodType

541 def 
	$create_unbound_method
 ( 
func
 , 
cls
 ) :

542 return 
func
 
	}

544 
Iterator
 = 
object

546 def 
	$get_unbound_function
 ( 
unbound
 ) :

547 return 
unbound
 . 
im_func
 
	}

549 def 
	$create_bound_method
 ( 
func
 , 
obj
 ) :

550 return 
types
 . 
MethodType
 ( 
func
 , 
obj
 , 
obj
 . 
__class__
 ) 
	}

552 def 
	$create_unbound_method
 ( 
func
 , 
cls
 ) :

553 return 
types
 . 
MethodType
 ( 
func
 , None , 
cls
 ) 
	}

555 class 
	cIterator
 ( 
object
 ) :

557 def 
	$next
 ( 
self
 ) :

558 return 
type
 ( 
self
 ) . 
__next__
 ( 
self
 ) 
	}

560 
callable
 = 
callable

561 
_add_doc
 ( 
get_unbound_function
 , """Get the function out of a possibly unbound function"""

565 
get_method_function
 = 
operator
 . 
attrgetter
 ( 
_meth_func
 )

566 
get_method_self
 = 
operator
 . 
attrgetter
 ( 
_meth_self
 )

567 
get_function_closure
 = 
operator
 . 
attrgetter
 ( 
_func_closure
 )

568 
get_function_code
 = 
operator
 . 
attrgetter
 ( 
_func_code
 )

569 
get_function_defaults
 = 
operator
 . 
attrgetter
 ( 
_func_defaults
 )

570 
get_function_globals
 = 
operator
 . 
attrgetter
 ( 
_func_globals
 )

573 if 
PY3
 :

574 def 
	$iterkeys
 ( 
d
 , ** 
kw
 ) :

575 return 
iter
 ( 
d
 . 
keys
 ( ** 
kw
 ) ) 
	}

577 def 
	$itervalues
 ( 
d
 , ** 
kw
 ) :

578 return 
iter
 ( 
d
 . 
values
 ( ** 
kw
 ) ) 
	}

580 def 
	$iteritems
 ( 
d
 , ** 
kw
 ) :

581 return 
iter
 ( 
d
 . 
items
 ( ** 
kw
 ) ) 
	}

583 def 
	$iterlists
 ( 
d
 , ** 
kw
 ) :

584 return 
iter
 ( 
d
 . 
lists
 ( ** 
kw
 ) ) 
	}

586 
viewkeys
 = 
operator
 . 
methodcaller
 ( "keys" )

588 
viewvalues
 = 
operator
 . 
methodcaller
 ( "values" )

590 
viewitems
 = 
operator
 . 
methodcaller
 ( "items" )

592 def 
	$iterkeys
 ( 
d
 , ** 
kw
 ) :

593 return 
d
 . 
iterkeys
 ( ** 
kw
 ) 
	}

595 def 
	$itervalues
 ( 
d
 , ** 
kw
 ) :

596 return 
d
 . 
itervalues
 ( ** 
kw
 ) 
	}

598 def 
	$iteritems
 ( 
d
 , ** 
kw
 ) :

599 return 
d
 . 
iteritems
 ( ** 
kw
 ) 
	}

601 def 
	$iterlists
 ( 
d
 , ** 
kw
 ) :

602 return 
d
 . 
iterlists
 ( ** 
kw
 ) 
	}

604 
viewkeys
 = 
operator
 . 
methodcaller
 ( "viewkeys" )

606 
viewvalues
 = 
operator
 . 
methodcaller
 ( "viewvalues" )

608 
viewitems
 = 
operator
 . 
methodcaller
 ( "viewitems" )

610 
_add_doc
 ( 
iterkeys
 , "Return an iterator over the keys of a dictionary." )

611 
_add_doc
 ( 
itervalues
 , "Return an iterator over the values of a dictionary." )

612 
_add_doc
 ( 
iteritems
 , "Return an iterator over the (key, value) pairs of a dictionary."

614 
_add_doc
 ( 
iterlists
 , "Return an iterator over the (key, [values]) pairs of a dictionary."

618 if 
PY3
 :

619 def 
	$b
 ( 
s
 ) :

620 return 
s
 . 
encode
 ( "latin-1" ) 
	}

622 def 
	$u
 ( 
s
 ) :

623 return 
s
 
	}

624 
unichr
 = 
chr

625 import 
	~struct

626 
int2byte
 = 
struct
 . 
Struct
 ( ">B" ) . 
pack

627 del 
struct

628 
byte2int
 = 
operator
 . 
itemgetter
 ( 0 )

629 
indexbytes
 = 
operator
 . 
getitem

630 
iterbytes
 = 
iter

631 import 
	~io

632 
StringIO
 = 
io
 . 
StringIO

633 
BytesIO
 = 
io
 . 
BytesIO

634 
_assertCountEqual
 = "assertCountEqual"

635 if 
sys
 . 
version_info
 [ 1 ] <= 1 :

636 
_assertRaisesRegex
 = "assertRaisesRegexp"

637 
_assertRegex
 = "assertRegexpMatches"

639 
_assertRaisesRegex
 = "assertRaisesRegex"

640 
_assertRegex
 = "assertRegex"

642 def 
	$b
 ( 
s
 ) :

643 return 
s
 
	}

646 def 
	$u
 ( 
s
 ) :

647 return 
unicode
 ( 
s
 . 
replace
 ( r'\\' , r'\\\\' ) , "unicode_escape" ) 
	}

648 
unichr
 = 
unichr

649 
int2byte
 = 
chr

651 def 
	$byte2int
 ( 
bs
 ) :

652 return 
ord
 ( 
bs
 [ 0 ] ) 
	}

654 def 
	$indexbytes
 ( 
buf
 , 
i
 ) :

655 return 
ord
 ( 
buf
 [ 
i
 ] ) 
	}

656 
iterbytes
 = 
functools
 . 
partial
 ( 
itertools
 . 
imap
 , 
ord
 )

657 import 
	~StringIO

658 
StringIO
 = 
BytesIO
 = 
StringIO
 . 
StringIO

659 
_assertCountEqual
 = "assertItemsEqual"

660 
_assertRaisesRegex
 = "assertRaisesRegexp"

661 
_assertRegex
 = "assertRegexpMatches"

662 
_add_doc
 ( 
b
 , """Byte literal""" )

663 
_add_doc
 ( 
u
 , """Text literal""" )

666 def 
	$assertCountEqual
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

667 return 
getattr
 ( 
self
 , 
_assertCountEqual
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

670 def 
	$assertRaisesRegex
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

671 return 
getattr
 ( 
self
 , 
_assertRaisesRegex
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

674 def 
	$assertRegex
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

675 return 
getattr
 ( 
self
 , 
_assertRegex
 ) ( * 
args
 , ** 
kwargs
 ) 
	}

678 if 
PY3
 :

679 
exec_
 = 
getattr
 ( 
moves
 . 
builtins
 , "exec" )

681 def 
	$reraise
 ( 
tp
 , 
value
 , 
tb
 = None ) :

682 if 
value
 is None :

683 
value
 = 
tp
 ( )

684 if 
value
 . 
__traceback__
 is not 
tb
 :

685 raise 
value
 . 
with_traceback
 ( 
tb
 )

686 raise 
value
 
	}

689 def 
	$exec_
 ( 
_code_
 , 
_globs_
 = None , 
_locs_
 = None ) :

691 if 
_globs_
 is None :

692 
frame
 = 
sys
 . 
_getframe
 ( 1 )

693 
_globs_
 = 
frame
 . 
f_globals

694 if 
_locs_
 is None :

695 
_locs_
 = 
frame
 . 
f_locals

696 del 
frame

697 elif 
_locs_
 is None :

698 
_locs_
 = 
_globs_

699 
exec
 ( """exec _code_ in _globs_, _locs_""" ) 
	}

701 
exec_
 ( """def reraise(tp, value, tb=None):\n    raise tp, value, tb\n"""

706 if 
sys
 . 
version_info
 [ : 2 ] == ( 3 , 2 ) :

707 
exec_
 ( """def raise_from(value, from_value):\n    if from_value is None:\n        raise value\n    raise value from from_value\n"""

712 elif 
sys
 . 
version_info
 [ : 2 ] > ( 3 , 2 ) :

713 
exec_
 ( """def raise_from(value, from_value):\n    raise value from from_value\n"""

717 def 
	$raise_from
 ( 
value
 , 
from_value
 ) :

718 raise 
value
 
	}

721 
print_
 = 
getattr
 ( 
moves
 . 
builtins
 , "print" , None )

722 if 
print_
 is None :

723 def 
	$print_
 ( * 
args
 , ** 
kwargs
 ) :

725 
fp
 = 
kwargs
 . 
pop
 ( "file" , 
sys
 . 
stdout
 )

726 if 
fp
 is None :

729 def 
write
 ( 
data
 ) :

730 if not 
isinstance
 ( 
data
 , 
basestring
 ) :

731 
data
 = 
str
 ( 
data
 )

733 if ( 
isinstance
 ( 
fp
 , 
file
 ) and

734 
isinstance
 ( 
data
 , 
unicode
 ) and

735 
fp
 . 
encoding
 is not None ) :

736 
errors
 = 
getattr
 ( 
fp
 , "errors" , None )

737 if 
errors
 is None :

738 
errors
 = "strict"

739 
data
 = 
data
 . 
encode
 ( 
fp
 . 
encoding
 , 
errors
 )

740 
fp
 . 
write
 ( 
data
 )

741 
want_unicode
 = False

742 
sep
 = 
kwargs
 . 
pop
 ( "sep" , None )

743 if 
sep
 is not None :

744 if 
isinstance
 ( 
sep
 , 
unicode
 ) :

745 
want_unicode
 = True

746 elif not 
isinstance
 ( 
sep
 , 
str
 ) :

747 raise 
TypeError
 ( "sep must be None or a string" )

748 
end
 = 
kwargs
 . 
pop
 ( "end" , None )

749 if 
end
 is not None :

750 if 
isinstance
 ( 
end
 , 
unicode
 ) :

751 
want_unicode
 = True

752 elif not 
isinstance
 ( 
end
 , 
str
 ) :

753 raise 
TypeError
 ( "end must be None or a string" )

754 if 
kwargs
 :

755 raise 
TypeError
 ( "invalid keyword arguments to print()" )

756 if not 
want_unicode
 :

757 for 
arg
 in 
args
 :

758 if 
isinstance
 ( 
arg
 , 
unicode
 ) :

759 
want_unicode
 = True

761 if 
want_unicode
 :

762 
newline
 = 
unicode
 ( "\n" )

763 
space
 = 
unicode
 ( " " )

765 
newline
 = "\n"

766 
space
 = " "

767 if 
sep
 is None :

768 
sep
 = 
space

769 if 
end
 is None :

770 
end
 = 
newline

771 for 
i
 , 
arg
 in 
enumerate
 ( 
args
 ) :

772 if 
i
 :

773 
write
 ( 
sep
 )

774 
write
 ( 
arg
 )

775 
write
 ( 
end
 ) 
	}

776 if 
sys
 . 
version_info
 [ : 2 ] < ( 3 , 3 ) :

777 
_print
 = 
print_

779 def 
	$print_
 ( * 
args
 , ** 
kwargs
 ) :

780 
fp
 = 
kwargs
 . 
get
 ( "file" , 
sys
 . 
stdout
 )

781 
flush
 = 
kwargs
 . 
pop
 ( "flush" , False )

782 
_print
 ( * 
args
 , ** 
kwargs
 )

783 if 
flush
 and 
fp
 is not None :

784 
fp
 . 
flush
 ( ) 
	}

786 
_add_doc
 ( 
reraise
 , """Reraise an exception.""" )

788 if 
sys
 . 
version_info
 [ 0 : 2 ] < ( 3 , 4 ) :

789 def 
	$wraps
 ( 
wrapped
 , 
assigned
 = 
functools
 . 
WRAPPER_ASSIGNMENTS
 ,

790 
updated
 = 
functools
 . 
WRAPPER_UPDATES
 ) :

791 def 
wrapper
 ( 
f
 ) :

792 
f
 = 
functools
 . 
wraps
 ( 
wrapped
 , 
assigned
 , 
updated
 ) ( 
f
 )

793 
f
 . 
__wrapped__
 = 
wrapped

794 return 
f

795 return 
wrapper
 
	}

797 
wraps
 = 
functools
 . 
wraps

800 def 
	$with_metaclass
 ( 
meta
 , * 
bases
 ) :

805 class 
	cmetaclass
 ( 
meta
 ) :

807 def 
__new__
 ( 
cls
 , 
name
 , 
this_bases
 , 
d
 ) :

808 return 
meta
 ( 
name
 , 
bases
 , 
d
 )

809 return 
type
 . 
__new__
 ( 
metaclass
 , 'temporary_class' , ( ) , { } ) 
	}

812 def 
	$add_metaclass
 ( 
metaclass
 ) :

814 def 
wrapper
 ( 
cls
 ) :

815 
orig_vars
 = 
cls
 . 
__dict__
 . 
copy
 ( )

816 
slots
 = 
orig_vars
 . 
get
 ( '__slots__' )

817 if 
slots
 is not None :

818 if 
isinstance
 ( 
slots
 , 
str
 ) :

819 
slots
 = [ 
slots
 ]

820 for 
slots_var
 in 
slots
 :

821 
orig_vars
 . 
pop
 ( 
slots_var
 )

822 
orig_vars
 . 
pop
 ( '__dict__' , None )

823 
orig_vars
 . 
pop
 ( '__weakref__' , None )

824 return 
metaclass
 ( 
cls
 . 
__name__
 , 
cls
 . 
__bases__
 , 
orig_vars
 )

825 return 
wrapper
 
	}

828 def 
	$python_2_unicode_compatible
 ( 
klass
 ) :

836 if 
PY2
 :

837 if '__str__' not in 
klass
 . 
__dict__
 :

838 raise 
ValueError
 ( "@python_2_unicode_compatible cannot be applied " "to %s because it doesn't define __str__()."

840 
klass
 . 
__name__
 )

841 
klass
 . 
__unicode__
 = 
klass
 . 
__str__

842 
klass
 . 
__str__
 = lambda 
self
 : 
self
 . 
__unicode__
 ( ) . 
encode
 ( 'utf-8' )

843 return 
klass
 
	}

849 
__path__
 = [ ]

850 
__package__
 = 
__name__

851 if 
globals
 ( ) . 
get
 ( "__spec__" ) is not None :

852 
__spec__
 . 
submodule_search_locations
 = [ ]

856 if 
sys
 . 
meta_path
 :

857 for 
i
 , 
importer
 in 
enumerate
 ( 
sys
 . 
meta_path
 ) :

862 if ( 
type
 ( 
importer
 ) . 
__name__
 == "_SixMetaPathImporter" and

863 
importer
 . 
name
 == 
__name__
 ) :

864 del 
sys
 . 
meta_path
 [ 
i
 ]

866 del 
i
 , 
importer

868 
sys
 . 
meta_path
 . 
append
 ( 
_importer
 )


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/_compat.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~sys

9 
PY2
 = 
sys
 . 
version_info
 [ 0 ] == 2

10 
PY3
 = 
sys
 . 
version_info
 [ 0 ] == 3

14 if 
PY3
 :

15 
string_types
 = 
str
 ,

17 
string_types
 = 
basestring
 ,

20 def 
	$with_metaclass
 ( 
meta
 , * 
bases
 ) :

27 class 
	cmetaclass
 ( 
meta
 ) :

28 def 
__new__
 ( 
cls
 , 
name
 , 
this_bases
 , 
d
 ) :

29 return 
meta
 ( 
name
 , 
bases
 , 
d
 )

30 return 
type
 . 
__new__
 ( 
metaclass
 , 'temporary_class' , ( ) , { } ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/specifiers.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~abc

7 import 
	~functools

8 import 
	~itertools

9 import 
	~re

11 from . 
	~_compat
 import 
string_types
 , 
with_metaclass

12 from . 
	~version
 import 
Version
 , 
LegacyVersion
 , 
parse

15 class 
	cInvalidSpecifier
 ( 
ValueError
 ) :

21 class 
	cBaseSpecifier
 ( 
with_metaclass
 ( 
abc
 . 
ABCMeta
 , 
object
 ) ) :

23 @ 
abc
 . 
	`abstractmethod

24 def 
	$__str__
 ( 
self
 ) :

28 
	}

30 @ 
abc
 . 
	`abstractmethod

31 def 
	$__hash__
 ( 
self
 ) :

34 
	}

36 @ 
abc
 . 
	`abstractmethod

37 def 
	$__eq__
 ( 
self
 , 
other
 ) :

41 
	}

43 @ 
abc
 . 
	`abstractmethod

44 def 
	$__ne__
 ( 
self
 , 
other
 ) :

48 
	}

50 @ 
abc
 . 
	`abstractproperty

51 def 
	$prereleases
 ( 
self
 ) :

55 
	}

57 @ 
prereleases
 . 
	`setter

58 def 
	$prereleases
 ( 
self
 , 
value
 ) :

62 
	}

64 @ 
abc
 . 
	`abstractmethod

65 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

68 
	}

70 @ 
abc
 . 
	`abstractmethod

71 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

75 
	}

78 class 
	c_IndividualSpecifier
 ( 
BaseSpecifier
 ) :

80 
_operators
 = { }

82 def 
	$__init__
 ( 
self
 , 
spec
 = "" , 
prereleases
 = None ) :

83 
match
 = 
self
 . 
_regex
 . 
search
 ( 
spec
 )

84 if not 
match
 :

85 raise 
InvalidSpecifier
 ( "Invalid specifier: '{0}'" . 
format
 ( 
spec
 ) )

87 
self
 . 
_spec
 = (

88 
match
 . 
group
 ( "operator" ) . 
strip
 ( ) ,

89 
match
 . 
group
 ( "version" ) . 
strip
 ( ) ,

93 
self
 . 
_prereleases
 = 
prereleases
 
	}

95 def 
	$__repr__
 ( 
self
 ) :

96 
pre
 = ( ", prereleases={0!r}"

97 . 
format
 ( 
self
 . 
prereleases
 )

98 if 
self
 . 
_prereleases
 is not None

102 return "<{0}({1!r}{2})>" . 
format
 (

103 
self
 . 
__class__
 . 
__name__
 ,

104 
str
 ( 
self
 ) ,

105 
pre
 ,

106 ) 
	}

108 def 
	$__str__
 ( 
self
 ) :

109 return "{0}{1}" . 
format
 ( * 
self
 . 
_spec
 ) 
	}

111 def 
	$__hash__
 ( 
self
 ) :

112 return 
hash
 ( 
self
 . 
_spec
 ) 
	}

114 def 
	$__eq__
 ( 
self
 , 
other
 ) :

115 if 
isinstance
 ( 
other
 , 
string_types
 ) :

117 
other
 = 
self
 . 
__class__
 ( 
other
 )

118 except 
InvalidSpecifier
 :

119 return 
NotImplemented

120 elif not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) :

121 return 
NotImplemented

123 return 
self
 . 
_spec
 == 
other
 . 
_spec
 
	}

125 def 
	$__ne__
 ( 
self
 , 
other
 ) :

126 if 
isinstance
 ( 
other
 , 
string_types
 ) :

128 
other
 = 
self
 . 
__class__
 ( 
other
 )

129 except 
InvalidSpecifier
 :

130 return 
NotImplemented

131 elif not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) :

132 return 
NotImplemented

134 return 
self
 . 
_spec
 != 
other
 . 
_spec
 
	}

136 def 
	$_get_operator
 ( 
self
 , 
op
 ) :

137 return 
getattr
 ( 
self
 , "_compare_{0}" . 
format
 ( 
self
 . 
_operators
 [ 
op
 ] ) ) 
	}

139 def 
	$_coerce_version
 ( 
self
 , 
version
 ) :

140 if not 
isinstance
 ( 
version
 , ( 
LegacyVersion
 , 
Version
 ) ) :

141 
version
 = 
parse
 ( 
version
 )

142 return 
version
 
	}

144 @ 
property

145 def 
	$operator
 ( 
self
 ) :

146 return 
self
 . 
_spec
 [ 0 ] 
	}

148 @ 
property

149 def 
	$version
 ( 
self
 ) :

150 return 
self
 . 
_spec
 [ 1 ] 
	}

152 @ 
property

153 def 
	$prereleases
 ( 
self
 ) :

154 return 
self
 . 
_prereleases
 
	}

156 @ 
prereleases
 . 
	`setter

157 def 
	$prereleases
 ( 
self
 , 
value
 ) :

158 
self
 . 
_prereleases
 = 
value
 
	}

160 def 
	$__contains__
 ( 
self
 , 
item
 ) :

161 return 
self
 . 
contains
 ( 
item
 ) 
	}

163 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

165 if 
prereleases
 is None :

166 
prereleases
 = 
self
 . 
prereleases

170 
item
 = 
self
 . 
_coerce_version
 ( 
item
 )

175 if 
item
 . 
is_prerelease
 and not 
prereleases
 :

180 return 
self
 . 
_get_operator
 ( 
self
 . 
operator
 ) ( 
item
 , 
self
 . 
version
 ) 
	}

182 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

183 
yielded
 = False

184 
found_prereleases
 = [ ]

186 
kw
 = { "prereleases" : 
prereleases
 if 
prereleases
 is not None else True }

190 for 
version
 in 
iterable
 :

191 
parsed_version
 = 
self
 . 
_coerce_version
 ( 
version
 )

193 if 
self
 . 
contains
 ( 
parsed_version
 , ** 
kw
 ) :

197 if ( 
parsed_version
 . 
is_prerelease
 and not

198 ( 
prereleases
 or 
self
 . 
prereleases
 ) ) :

199 
found_prereleases
 . 
append
 ( 
version
 )

203 
yielded
 = True

204 yield 
version

209 if not 
yielded
 and 
found_prereleases
 :

210 for 
version
 in 
found_prereleases
 :

211 yield 
version
 
	}

214 class 
	cLegacySpecifier
 ( 
_IndividualSpecifier
 ) :

216 
_regex_str
 = ( r"""\n        (?P<operator>(==|!=|<=|>=|<|>))\n        \s*\n        (?P<version>\n            [^,;\s)]* # Since this is a "legacy" specifier, and the version\n                      # string can be just about anything, we match everything\n                      # except for whitespace, a semi-colon for marker support,\n                      # a closing paren since versions can be enclosed in\n                      # them, and a comma since it's a version separator.\n        )\n        """

230 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

231 + 
_regex_str
 + r"\s*$" , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

233 
_operators
 = { "=="

242 def 
	$_coerce_version
 ( 
self
 , 
version
 ) :

243 if not 
isinstance
 ( 
version
 , 
LegacyVersion
 ) :

244 
version
 = 
LegacyVersion
 ( 
str
 ( 
version
 ) )

245 return 
version
 
	}

247 def 
	$_compare_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

248 return 
prospective
 == 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

250 def 
	$_compare_not_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

251 return 
prospective
 != 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

253 def 
	$_compare_less_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

254 return 
prospective
 <= 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

256 def 
	$_compare_greater_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

257 return 
prospective
 >= 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

259 def 
	$_compare_less_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

260 return 
prospective
 < 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

262 def 
	$_compare_greater_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

263 return 
prospective
 > 
self
 . 
_coerce_version
 ( 
spec
 ) 
	}

266 def 
	$_require_version_compare
 ( 
fn
 ) :

267 @ 
functools
 . 
	`wraps
 ( 
fn
 )

268 def 
wrapped
 ( 
self
 , 
prospective
 , 
spec
 ) :

269 if not 
isinstance
 ( 
prospective
 , 
Version
 ) :

271 return 
fn
 ( 
self
 , 
prospective
 , 
spec
 )

272 return 
wrapped
 
	}

275 class 
	cSpecifier
 ( 
_IndividualSpecifier
 ) :

277 
_regex_str
 = ( r"""\n        (?P<operator>(~=|==|!=|<=|>=|<|>|===))\n        (?P<version>\n            (?:\n                # The identity operators allow for an escape hatch that will\n                # do an exact string match of the version you wish to install.\n                # This will not be parsed by PEP 440 and we cannot determine\n                # any semantic meaning from it. This operator is discouraged\n                # but included entirely as an escape hatch.\n                (?<====)  # Only match for the identity operator\n                \s*\n                [^\s]*    # We just match everything, except for whitespace\n                          # since we are only testing for strict identity.\n            )\n            |\n            (?:\n                # The (non)equality operators allow for wild card and local\n                # versions to be specified so we have to define these two\n                # operators separately to enable that.\n                (?<===|!=)            # Only match for equals and not equals\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n\n                # You cannot use a wild card and a dev or local version\n                # together so group them with a | and make them optional.\n                (?:\n                    (?:[-_\.]?dev[-_\.]?[0-9]*)?         # dev release\n                    (?:\+[a-z0-9]+(?:[-_\.][a-z0-9]+)*)? # local\n                    |\n                    \.\*  # Wild card syntax of .*\n                )?\n            )\n            |\n            (?:\n                # The compatible operator requires at least two digits in the\n                # release segment.\n                (?<=~=)               # Only match for the compatible operator\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)+   # release  (We have a + instead of a *)\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release\n            )\n            |\n            (?:\n                # All other operators only allow a sub set of what the\n                # (non)equality operators do. Specifically they do not allow\n                # local versions to be specified nor do they allow the prefix\n                # matching wild cards.\n                (?<!==|!=|~=)         # We have special cases for these\n                                      # operators so we want to make sure they\n                                      # don't match here.\n\n                \s*\n                v?\n                (?:[0-9]+!)?          # epoch\n                [0-9]+(?:\.[0-9]+)*   # release\n                (?:                   # pre release\n                    [-_\.]?\n                    (a|b|c|rc|alpha|beta|pre|preview)\n                    [-_\.]?\n                    [0-9]*\n                )?\n                (?:                                   # post release\n                    (?:-[0-9]+)|(?:[-_\.]?(post|rev|r)[-_\.]?[0-9]*)\n                )?\n                (?:[-_\.]?dev[-_\.]?[0-9]*)?          # dev release\n            )\n        )\n        """

372 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

373 + 
_regex_str
 + r"\s*$" , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

375 
_operators
 = { "~="

386 @ 
	`_require_version_compare

387 def 
	$_compare_compatible
 ( 
self
 , 
prospective
 , 
spec
 ) :

397 
prefix
 = "." . 
join
 (

398 
list
 (

399 
itertools
 . 
takewhile
 (

400 lambda 
x
 : ( not 
x
 . 
startswith
 ( "post" ) and not

401 
x
 . 
startswith
 ( "dev" ) ) ,

402 
_version_split
 ( 
spec
 ) ,

408 
prefix
 += ".*"

410 return ( 
self
 . 
_get_operator
 ( ">=" ) ( 
prospective
 , 
spec
 ) and

411 
self
 . 
_get_operator
 ( "==" ) ( 
prospective
 , 
prefix
 ) ) 
	}

413 @ 
	`_require_version_compare

414 def 
	$_compare_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

416 if 
spec
 . 
endswith
 ( ".*" ) :

418 
prospective
 = 
Version
 ( 
prospective
 . 
public
 )

421 
spec
 = 
_version_split
 ( 
spec
 [ : - 2 ] )

426 
prospective
 = 
_version_split
 ( 
str
 ( 
prospective
 ) )

431 
prospective
 = 
prospective
 [ : 
len
 ( 
spec
 ) ]

435 
spec
 , 
prospective
 = 
_pad_version
 ( 
spec
 , 
prospective
 )

438 
spec
 = 
Version
 ( 
spec
 )

443 if not 
spec
 . 
local
 :

444 
prospective
 = 
Version
 ( 
prospective
 . 
public
 )

446 return 
prospective
 == 
spec
 
	}

448 @ 
	`_require_version_compare

449 def 
	$_compare_not_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

450 return not 
self
 . 
_compare_equal
 ( 
prospective
 , 
spec
 ) 
	}

452 @ 
	`_require_version_compare

453 def 
	$_compare_less_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

454 return 
prospective
 <= 
Version
 ( 
spec
 ) 
	}

456 @ 
	`_require_version_compare

457 def 
	$_compare_greater_than_equal
 ( 
self
 , 
prospective
 , 
spec
 ) :

458 return 
prospective
 >= 
Version
 ( 
spec
 ) 
	}

460 @ 
	`_require_version_compare

461 def 
	$_compare_less_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

464 
spec
 = 
Version
 ( 
spec
 )

469 if not 
prospective
 < 
spec
 :

476 if not 
spec
 . 
is_prerelease
 and 
prospective
 . 
is_prerelease
 :

477 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

483 return True 
	}

485 @ 
	`_require_version_compare

486 def 
	$_compare_greater_than
 ( 
self
 , 
prospective
 , 
spec
 ) :

489 
spec
 = 
Version
 ( 
spec
 )

494 if not 
prospective
 > 
spec
 :

501 if not 
spec
 . 
is_postrelease
 and 
prospective
 . 
is_postrelease
 :

502 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

507 if 
prospective
 . 
local
 is not None :

508 if 
Version
 ( 
prospective
 . 
base_version
 ) == 
Version
 ( 
spec
 . 
base_version
 ) :

514 return True 
	}

516 def 
	$_compare_arbitrary
 ( 
self
 , 
prospective
 , 
spec
 ) :

517 return 
str
 ( 
prospective
 ) . 
lower
 ( ) == 
str
 ( 
spec
 ) . 
lower
 ( ) 
	}

519 @ 
property

520 def 
	$prereleases
 ( 
self
 ) :

523 if 
self
 . 
_prereleases
 is not None :

524 return 
self
 . 
_prereleases

529 
operator
 , 
version
 = 
self
 . 
_spec

530 if 
operator
 in [ "==" , ">=" , "<=" , "~=" , "===" ] :

533 if 
operator
 == "==" and 
version
 . 
endswith
 ( ".*" ) :

534 
version
 = 
version
 [ : - 2 ]

538 if 
parse
 ( 
version
 ) . 
is_prerelease
 :

541 return False 
	}

543 @ 
prereleases
 . 
	`setter

544 def 
	$prereleases
 ( 
self
 , 
value
 ) :

545 
self
 . 
_prereleases
 = 
value
 
	}

548 
_prefix_regex
 = 
re
 . 
compile
 ( r"^([0-9]+)((?:a|b|c|rc)[0-9]+)$" )

551 def 
	$_version_split
 ( 
version
 ) :

552 
result
 = [ ]

553 for 
item
 in 
version
 . 
split
 ( "." ) :

554 
match
 = 
_prefix_regex
 . 
search
 ( 
item
 )

555 if 
match
 :

556 
result
 . 
extend
 ( 
match
 . 
groups
 ( ) )

558 
result
 . 
append
 ( 
item
 )

559 return 
result
 
	}

562 def 
	$_pad_version
 ( 
left
 , 
right
 ) :

563 
left_split
 , 
right_split
 = [ ] , [ ]

566 
left_split
 . 
append
 ( 
list
 ( 
itertools
 . 
takewhile
 ( lambda 
x
 : 
x
 . 
isdigit
 ( ) , 
left
 ) ) )

567 
right_split
 . 
append
 ( 
list
 ( 
itertools
 . 
takewhile
 ( lambda 
x
 : 
x
 . 
isdigit
 ( ) , 
right
 ) ) )

570 
left_split
 . 
append
 ( 
left
 [ 
len
 ( 
left_split
 [ 0 ] ) : ] )

571 
right_split
 . 
append
 ( 
right
 [ 
len
 ( 
right_split
 [ 0 ] ) : ] )

574 
left_split
 . 
insert
 (

576 [ "0" ] * 
max
 ( 0 , 
len
 ( 
right_split
 [ 0 ] ) - 
len
 ( 
left_split
 [ 0 ] ) ) ,

578 
right_split
 . 
insert
 (

580 [ "0" ] * 
max
 ( 0 , 
len
 ( 
left_split
 [ 0 ] ) - 
len
 ( 
right_split
 [ 0 ] ) ) ,

584 
list
 ( 
itertools
 . 
chain
 ( * 
left_split
 ) ) ,

585 
list
 ( 
itertools
 . 
chain
 ( * 
right_split
 ) ) ,

586 ) 
	}

589 class 
	cSpecifierSet
 ( 
BaseSpecifier
 ) :

591 def 
	$__init__
 ( 
self
 , 
specifiers
 = "" , 
prereleases
 = None ) :

594 
specifiers
 = [ 
s
 . 
strip
 ( ) for 
s
 in 
specifiers
 . 
split
 ( "," ) if 
s
 . 
strip
 ( ) ]

598 
parsed
 = 
set
 ( )

599 for 
specifier
 in 
specifiers
 :

601 
parsed
 . 
add
 ( 
Specifier
 ( 
specifier
 ) )

602 except 
InvalidSpecifier
 :

603 
parsed
 . 
add
 ( 
LegacySpecifier
 ( 
specifier
 ) )

606 
self
 . 
_specs
 = 
frozenset
 ( 
parsed
 )

610 
self
 . 
_prereleases
 = 
prereleases
 
	}

612 def 
	$__repr__
 ( 
self
 ) :

613 
pre
 = ( ", prereleases={0!r}"

614 . 
format
 ( 
self
 . 
prereleases
 )

615 if 
self
 . 
_prereleases
 is not None

619 return "<SpecifierSet({0!r}{1})>" . 
format
 ( 
str
 ( 
self
 ) , 
pre
 ) 
	}

621 def 
	$__str__
 ( 
self
 ) :

622 return "," . 
join
 ( 
sorted
 ( 
str
 ( 
s
 ) for 
s
 in 
self
 . 
_specs
 ) ) 
	}

624 def 
	$__hash__
 ( 
self
 ) :

625 return 
hash
 ( 
self
 . 
_specs
 ) 
	}

627 def 
	$__and__
 ( 
self
 , 
other
 ) :

628 if 
isinstance
 ( 
other
 , 
string_types
 ) :

629 
other
 = 
SpecifierSet
 ( 
other
 )

630 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

631 return 
NotImplemented

633 
specifier
 = 
SpecifierSet
 ( )

634 
specifier
 . 
_specs
 = 
frozenset
 ( 
self
 . 
_specs
 | 
other
 . 
_specs
 )

636 if 
self
 . 
_prereleases
 is None and 
other
 . 
_prereleases
 is not None :

637 
specifier
 . 
_prereleases
 = 
other
 . 
_prereleases

638 elif 
self
 . 
_prereleases
 is not None and 
other
 . 
_prereleases
 is None :

639 
specifier
 . 
_prereleases
 = 
self
 . 
_prereleases

640 elif 
self
 . 
_prereleases
 == 
other
 . 
_prereleases
 :

641 
specifier
 . 
_prereleases
 = 
self
 . 
_prereleases

643 raise 
ValueError
 ( "Cannot combine SpecifierSets with True and False prerelease " "overrides."

648 return 
specifier
 
	}

650 def 
	$__eq__
 ( 
self
 , 
other
 ) :

651 if 
isinstance
 ( 
other
 , 
string_types
 ) :

652 
other
 = 
SpecifierSet
 ( 
other
 )

653 elif 
isinstance
 ( 
other
 , 
_IndividualSpecifier
 ) :

654 
other
 = 
SpecifierSet
 ( 
str
 ( 
other
 ) )

655 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

656 return 
NotImplemented

658 return 
self
 . 
_specs
 == 
other
 . 
_specs
 
	}

660 def 
	$__ne__
 ( 
self
 , 
other
 ) :

661 if 
isinstance
 ( 
other
 , 
string_types
 ) :

662 
other
 = 
SpecifierSet
 ( 
other
 )

663 elif 
isinstance
 ( 
other
 , 
_IndividualSpecifier
 ) :

664 
other
 = 
SpecifierSet
 ( 
str
 ( 
other
 ) )

665 elif not 
isinstance
 ( 
other
 , 
SpecifierSet
 ) :

666 return 
NotImplemented

668 return 
self
 . 
_specs
 != 
other
 . 
_specs
 
	}

670 def 
	$__len__
 ( 
self
 ) :

671 return 
len
 ( 
self
 . 
_specs
 ) 
	}

673 def 
	$__iter__
 ( 
self
 ) :

674 return 
iter
 ( 
self
 . 
_specs
 ) 
	}

676 @ 
property

677 def 
	$prereleases
 ( 
self
 ) :

680 if 
self
 . 
_prereleases
 is not None :

681 return 
self
 . 
_prereleases

686 if not 
self
 . 
_specs
 :

691 return 
any
 ( 
s
 . 
prereleases
 for 
s
 in 
self
 . 
_specs
 ) 
	}

693 @ 
prereleases
 . 
	`setter

694 def 
	$prereleases
 ( 
self
 , 
value
 ) :

695 
self
 . 
_prereleases
 = 
value
 
	}

697 def 
	$__contains__
 ( 
self
 , 
item
 ) :

698 return 
self
 . 
contains
 ( 
item
 ) 
	}

700 def 
	$contains
 ( 
self
 , 
item
 , 
prereleases
 = None ) :

702 if not 
isinstance
 ( 
item
 , ( 
LegacyVersion
 , 
Version
 ) ) :

703 
item
 = 
parse
 ( 
item
 )

708 if 
prereleases
 is None :

709 
prereleases
 = 
self
 . 
prereleases

717 if not 
prereleases
 and 
item
 . 
is_prerelease
 :

724 return 
all
 (

725 
s
 . 
contains
 ( 
item
 , 
prereleases
 = 
prereleases
 )

726 for 
s
 in 
self
 . 
_specs

727 ) 
	}

729 def 
	$filter
 ( 
self
 , 
iterable
 , 
prereleases
 = None ) :

733 if 
prereleases
 is None :

734 
prereleases
 = 
self
 . 
prereleases

739 if 
self
 . 
_specs
 :

740 for 
spec
 in 
self
 . 
_specs
 :

741 
iterable
 = 
spec
 . 
filter
 ( 
iterable
 , 
prereleases
 = 
bool
 ( 
prereleases
 ) )

742 return 
iterable

747 
filtered
 = [ ]

748 
found_prereleases
 = [ ]

750 for 
item
 in 
iterable
 :

752 if not 
isinstance
 ( 
item
 , ( 
LegacyVersion
 , 
Version
 ) ) :

753 
parsed_version
 = 
parse
 ( 
item
 )

755 
parsed_version
 = 
item

758 if 
isinstance
 ( 
parsed_version
 , 
LegacyVersion
 ) :

763 if 
parsed_version
 . 
is_prerelease
 and not 
prereleases
 :

764 if not 
filtered
 :

765 
found_prereleases
 . 
append
 ( 
item
 )

767 
filtered
 . 
append
 ( 
item
 )

771 if not 
filtered
 and 
found_prereleases
 and 
prereleases
 is None :

772 return 
found_prereleases

774 return 
filtered
 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/version.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~collections

7 import 
	~itertools

8 import 
	~re

10 from . 
	~_structures
 import 
Infinity

13 
__all__
 = [ "parse"

18 
_Version
 = 
collections
 . 
namedtuple
 ( "_Version"

24 def 
	$parse
 ( 
version
 ) :

31 return 
Version
 ( 
version
 )

32 except 
InvalidVersion
 :

33 return 
LegacyVersion
 ( 
version
 ) 
	}

36 class 
	cInvalidVersion
 ( 
ValueError
 ) :

42 class 
	c_BaseVersion
 ( 
object
 ) :

44 def 
	$__hash__
 ( 
self
 ) :

45 return 
hash
 ( 
self
 . 
_key
 ) 
	}

47 def 
	$__lt__
 ( 
self
 , 
other
 ) :

48 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 < 
o
 ) 
	}

50 def 
	$__le__
 ( 
self
 , 
other
 ) :

51 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 <= 
o
 ) 
	}

53 def 
	$__eq__
 ( 
self
 , 
other
 ) :

54 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 == 
o
 ) 
	}

56 def 
	$__ge__
 ( 
self
 , 
other
 ) :

57 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 >= 
o
 ) 
	}

59 def 
	$__gt__
 ( 
self
 , 
other
 ) :

60 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 > 
o
 ) 
	}

62 def 
	$__ne__
 ( 
self
 , 
other
 ) :

63 return 
self
 . 
_compare
 ( 
other
 , lambda 
s
 , 
o
 : 
s
 != 
o
 ) 
	}

65 def 
	$_compare
 ( 
self
 , 
other
 , 
method
 ) :

66 if not 
isinstance
 ( 
other
 , 
_BaseVersion
 ) :

67 return 
NotImplemented

69 return 
method
 ( 
self
 . 
_key
 , 
other
 . 
_key
 ) 
	}

72 class 
	cLegacyVersion
 ( 
_BaseVersion
 ) :

74 def 
	$__init__
 ( 
self
 , 
version
 ) :

75 
self
 . 
_version
 = 
str
 ( 
version
 )

76 
self
 . 
_key
 = 
_legacy_cmpkey
 ( 
self
 . 
_version
 ) 
	}

78 def 
	$__str__
 ( 
self
 ) :

79 return 
self
 . 
_version
 
	}

81 def 
	$__repr__
 ( 
self
 ) :

82 return "<LegacyVersion({0})>" . 
format
 ( 
repr
 ( 
str
 ( 
self
 ) ) ) 
	}

84 @ 
property

85 def 
	$public
 ( 
self
 ) :

86 return 
self
 . 
_version
 
	}

88 @ 
property

89 def 
	$base_version
 ( 
self
 ) :

90 return 
self
 . 
_version
 
	}

92 @ 
property

93 def 
	$local
 ( 
self
 ) :

94 return None 
	}

96 @ 
property

97 def 
	$is_prerelease
 ( 
self
 ) :

98 return False 
	}

100 @ 
property

101 def 
	$is_postrelease
 ( 
self
 ) :

102 return False 
	}

105 
_legacy_version_component_re
 = 
re
 . 
compile
 ( r"(\d+ | [a-z]+ | \.| -)"

106 , 
re
 . 
VERBOSE
 ,

109 
_legacy_version_replacement_map
 = { "pre"

114 def 
	$_parse_version_parts
 ( 
s
 ) :

115 for 
part
 in 
_legacy_version_component_re
 . 
split
 ( 
s
 ) :

116 
part
 = 
_legacy_version_replacement_map
 . 
get
 ( 
part
 , 
part
 )

118 if not 
part
 or 
part
 == "." :

121 if 
part
 [ : 1 ] in "0123456789" :

123 yield 
part
 . 
zfill
 ( 8 )

125 yield "*" + 
part

128 yield "*final" 
	}

131 def 
	$_legacy_cmpkey
 ( 
version
 ) :

136 
epoch
 = - 1

140 
parts
 = [ ]

141 for 
part
 in 
_parse_version_parts
 ( 
version
 . 
lower
 ( ) ) :

142 if 
part
 . 
startswith
 ( "*" ) :

144 if 
part
 < "*final" :

145 while 
parts
 and 
parts
 [ - 1 ] == "*final-" :

146 
parts
 . 
pop
 ( )

149 while 
parts
 and 
parts
 [ - 1 ] == "00000000" :

150 
parts
 . 
pop
 ( )

152 
parts
 . 
append
 ( 
part
 )

153 
parts
 = 
tuple
 ( 
parts
 )

155 return 
epoch
 , 
parts
 
	}

159 
VERSION_PATTERN
 = r"""\n    v?\n    (?:\n        (?:(?P<epoch>[0-9]+)!)?                           # epoch\n        (?P<release>[0-9]+(?:\.[0-9]+)*)                  # release segment\n        (?P<pre>                                          # pre-release\n            [-_\.]?\n            (?P<pre_l>(a|b|c|rc|alpha|beta|pre|preview))\n            [-_\.]?\n            (?P<pre_n>[0-9]+)?\n        )?\n        (?P<post>                                         # post release\n            (?:-(?P<post_n1>[0-9]+))\n            |\n            (?:\n                [-_\.]?\n                (?P<post_l>post|rev|r)\n                [-_\.]?\n                (?P<post_n2>[0-9]+)?\n            )\n        )?\n        (?P<dev>                                          # dev release\n            [-_\.]?\n            (?P<dev_l>dev)\n            [-_\.]?\n            (?P<dev_n>[0-9]+)?\n        )?\n    )\n    (?:\+(?P<local>[a-z0-9]+(?:[-_\.][a-z0-9]+)*))?       # local version\n"""

191 class 
	cVersion
 ( 
_BaseVersion
 ) :

193 
_regex
 = 
re
 . 
compile
 ( r"^\s*"

194 + 
VERSION_PATTERN
 + r"\s*$" ,

195 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 ,

198 def 
	$__init__
 ( 
self
 , 
version
 ) :

200 
match
 = 
self
 . 
_regex
 . 
search
 ( 
version
 )

201 if not 
match
 :

202 raise 
InvalidVersion
 ( "Invalid version: '{0}'" . 
format
 ( 
version
 ) )

205 
self
 . 
_version
 = 
_Version
 (

206 
epoch
 = 
int
 ( 
match
 . 
group
 ( "epoch" ) ) if 
match
 . 
group
 ( "epoch" ) else 0 ,

207 
release
 = 
tuple
 ( 
int
 ( 
i
 ) for 
i
 in 
match
 . 
group
 ( "release" ) . 
split
 ( "." ) ) ,

208 
pre
 = 
_parse_letter_version
 (

209 
match
 . 
group
 ( "pre_l" ) ,

210 
match
 . 
group
 ( "pre_n" ) ,

212 
post
 = 
_parse_letter_version
 (

213 
match
 . 
group
 ( "post_l" ) ,

214 
match
 . 
group
 ( "post_n1" ) or 
match
 . 
group
 ( "post_n2" ) ,

216 
dev
 = 
_parse_letter_version
 (

217 
match
 . 
group
 ( "dev_l" ) ,

218 
match
 . 
group
 ( "dev_n" ) ,

220 
local
 = 
_parse_local_version
 ( 
match
 . 
group
 ( "local" ) ) ,

224 
self
 . 
_key
 = 
_cmpkey
 (

225 
self
 . 
_version
 . 
epoch
 ,

226 
self
 . 
_version
 . 
release
 ,

227 
self
 . 
_version
 . 
pre
 ,

228 
self
 . 
_version
 . 
post
 ,

229 
self
 . 
_version
 . 
dev
 ,

230 
self
 . 
_version
 . 
local
 ,

231 ) 
	}

233 def 
	$__repr__
 ( 
self
 ) :

234 return "<Version({0})>" . 
format
 ( 
repr
 ( 
str
 ( 
self
 ) ) ) 
	}

236 def 
	$__str__
 ( 
self
 ) :

237 
parts
 = [ ]

240 if 
self
 . 
_version
 . 
epoch
 != 0 :

241 
parts
 . 
append
 ( "{0}!" . 
format
 ( 
self
 . 
_version
 . 
epoch
 ) )

244 
parts
 . 
append
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
release
 ) )

247 if 
self
 . 
_version
 . 
pre
 is not None :

248 
parts
 . 
append
 ( "" . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
pre
 ) )

251 if 
self
 . 
_version
 . 
post
 is not None :

252 
parts
 . 
append
 ( ".post{0}" . 
format
 ( 
self
 . 
_version
 . 
post
 [ 1 ] ) )

255 if 
self
 . 
_version
 . 
dev
 is not None :

256 
parts
 . 
append
 ( ".dev{0}" . 
format
 ( 
self
 . 
_version
 . 
dev
 [ 1 ] ) )

259 if 
self
 . 
_version
 . 
local
 is not None :

260 
parts
 . 
append
 ( "+{0}"

261 . 
format
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
local
 ) )

264 return "" . 
join
 ( 
parts
 ) 
	}

266 @ 
property

267 def 
	$public
 ( 
self
 ) :

268 return 
str
 ( 
self
 ) . 
split
 ( "+" , 1 ) [ 0 ] 
	}

270 @ 
property

271 def 
	$base_version
 ( 
self
 ) :

272 
parts
 = [ ]

275 if 
self
 . 
_version
 . 
epoch
 != 0 :

276 
parts
 . 
append
 ( "{0}!" . 
format
 ( 
self
 . 
_version
 . 
epoch
 ) )

279 
parts
 . 
append
 ( "." . 
join
 ( 
str
 ( 
x
 ) for 
x
 in 
self
 . 
_version
 . 
release
 ) )

281 return "" . 
join
 ( 
parts
 ) 
	}

283 @ 
property

284 def 
	$local
 ( 
self
 ) :

285 
version_string
 = 
str
 ( 
self
 )

286 if "+" in 
version_string
 :

287 return 
version_string
 . 
split
 ( "+" , 1 ) [ 1 ] 
	}

289 @ 
property

290 def 
	$is_prerelease
 ( 
self
 ) :

291 return 
bool
 ( 
self
 . 
_version
 . 
dev
 or 
self
 . 
_version
 . 
pre
 ) 
	}

293 @ 
property

294 def 
	$is_postrelease
 ( 
self
 ) :

295 return 
bool
 ( 
self
 . 
_version
 . 
post
 ) 
	}

298 def 
	$_parse_letter_version
 ( 
letter
 , 
number
 ) :

299 if 
letter
 :

302 if 
number
 is None :

303 
number
 = 0

306 
letter
 = 
letter
 . 
lower
 ( )

311 if 
letter
 == "alpha" :

312 
letter
 = "a"

313 elif 
letter
 == "beta" :

314 
letter
 = "b"

315 elif 
letter
 in [ "c" , "pre" , "preview" ] :

316 
letter
 = "rc"

317 elif 
letter
 in [ "rev" , "r" ] :

318 
letter
 = "post"

320 return 
letter
 , 
int
 ( 
number
 )

321 if not 
letter
 and 
number
 :

324 
letter
 = "post"

326 return 
letter
 , 
int
 ( 
number
 ) 
	}

329 
_local_version_seperators
 = 
re
 . 
compile
 ( r"[\._-]" )

332 def 
	$_parse_local_version
 ( 
local
 ) :

336 if 
local
 is not None :

337 return 
tuple
 (

338 
part
 . 
lower
 ( ) if not 
part
 . 
isdigit
 ( ) else 
int
 ( 
part
 )

339 for 
part
 in 
_local_version_seperators
 . 
split
 ( 
local
 )

340 ) 
	}

343 def 
	$_cmpkey
 ( 
epoch
 , 
release
 , 
pre
 , 
post
 , 
dev
 , 
local
 ) :

349 
release
 = 
tuple
 (

350 
reversed
 ( 
list
 (

351 
itertools
 . 
dropwhile
 (

352 lambda 
x
 : 
x
 == 0 ,

353 
reversed
 ( 
release
 ) ,

362 if 
pre
 is None and 
post
 is None and 
dev
 is not None :

363 
pre
 = - 
Infinity

366 elif 
pre
 is None :

367 
pre
 = 
Infinity

370 if 
post
 is None :

371 
post
 = - 
Infinity

374 if 
dev
 is None :

375 
dev
 = 
Infinity

377 if 
local
 is None :

379 
local
 = - 
Infinity

388 
local
 = 
tuple
 (

389 ( 
i
 , "" ) if 
isinstance
 ( 
i
 , 
int
 ) else ( - 
Infinity
 , 
i
 )

390 for 
i
 in 
local

393 return 
epoch
 , 
release
 , 
pre
 , 
post
 , 
dev
 , 
local
 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/markers.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~operator

7 import 
	~os

8 import 
	~platform

9 import 
	~sys

11 from 
	~setuptools.extern.pyparsing
 import 
ParseException
 , 
ParseResults
 , 
stringStart
 , 
stringEnd

12 from 
	~setuptools.extern.pyparsing
 import 
ZeroOrMore
 , 
Group
 , 
Forward
 , 
QuotedString

13 from 
	~setuptools.extern.pyparsing
 import 
Literal
 as 
L

15 from . 
	~_compat
 import 
string_types

16 from . 
	~specifiers
 import 
Specifier
 , 
InvalidSpecifier

19 
__all__
 = [ "InvalidMarker"

25 class 
	cInvalidMarker
 ( 
ValueError
 ) :

31 class 
	cUndefinedComparison
 ( 
ValueError
 ) :

37 class 
	cUndefinedEnvironmentName
 ( 
ValueError
 ) :

44 class 
	cNode
 ( 
object
 ) :

46 def 
	$__init__
 ( 
self
 , 
value
 ) :

47 
self
 . 
value
 = 
value
 
	}

49 def 
	$__str__
 ( 
self
 ) :

50 return 
str
 ( 
self
 . 
value
 ) 
	}

52 def 
	$__repr__
 ( 
self
 ) :

53 return "<{0}({1!r})>" . 
format
 ( 
self
 . 
__class__
 . 
__name__
 , 
str
 ( 
self
 ) ) 
	}

55 def 
	$serialize
 ( 
self
 ) :

56 raise 
NotImplementedError
 
	}

59 class 
	cVariable
 ( 
Node
 ) :

61 def 
	$serialize
 ( 
self
 ) :

62 return 
str
 ( 
self
 ) 
	}

65 class 
	cValue
 ( 
Node
 ) :

67 def 
	$serialize
 ( 
self
 ) :

68 return '"{0}"' . 
format
 ( 
self
 ) 
	}

71 class 
	cOp
 ( 
Node
 ) :

73 def 
	$serialize
 ( 
self
 ) :

74 return 
str
 ( 
self
 ) 
	}

77 
VARIABLE
 = (

78 
L
 ( "implementation_version" ) |

79 
L
 ( "platform_python_implementation" ) |

80 
L
 ( "implementation_name" ) |

81 
L
 ( "python_full_version" ) |

82 
L
 ( "platform_release" ) |

83 
L
 ( "platform_version" ) |

84 
L
 ( "platform_machine" ) |

85 
L
 ( "platform_system" ) |

86 
L
 ( "python_version" ) |

87 
L
 ( "sys_platform" ) |

88 
L
 ( "os_name" ) |

89 
L
 ( "os.name" ) |

90 
L
 ( "sys.platform" ) |

91 
L
 ( "platform.version" ) |

92 
L
 ( "platform.machine" ) |

93 
L
 ( "platform.python_implementation" ) |

94 
L
 ( "python_implementation" ) |

95 
L
 ( "extra" )

97 
ALIASES
 = { 'os.name'

105 
VARIABLE
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Variable
 ( 
ALIASES
 . 
get
 ( 
t
 [ 0 ] , 
t
 [ 0 ] ) ) )

107 
VERSION_CMP
 = (

108 
L
 ( "===" ) |

109 
L
 ( "==" ) |

110 
L
 ( ">=" ) |

111 
L
 ( "<=" ) |

112 
L
 ( "!=" ) |

113 
L
 ( "~=" ) |

114 
L
 ( ">" ) |

115 
L
 ( "<" )

118 
MARKER_OP
 = 
VERSION_CMP
 | 
L
 ( "not in" ) | 
L
 ( "in" )

119 
MARKER_OP
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Op
 ( 
t
 [ 0 ] ) )

121 
MARKER_VALUE
 = 
QuotedString
 ( "'" ) | 
QuotedString
 ( '"' )

122 
MARKER_VALUE
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
Value
 ( 
t
 [ 0 ] ) )

124 
BOOLOP
 = 
L
 ( "and" ) | 
L
 ( "or" )

126 
MARKER_VAR
 = 
VARIABLE
 | 
MARKER_VALUE

128 
MARKER_ITEM
 = 
Group
 ( 
MARKER_VAR
 + 
MARKER_OP
 + 
MARKER_VAR
 )

129 
MARKER_ITEM
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
tuple
 ( 
t
 [ 0 ] ) )

131 
LPAREN
 = 
L
 ( "(" ) . 
suppress
 ( )

132 
RPAREN
 = 
L
 ( ")" ) . 
suppress
 ( )

134 
MARKER_EXPR
 = 
Forward
 ( )

135 
MARKER_ATOM
 = 
MARKER_ITEM
 | 
Group
 ( 
LPAREN
 + 
MARKER_EXPR
 + 
RPAREN
 )

136 
MARKER_EXPR
 << 
MARKER_ATOM
 + 
ZeroOrMore
 ( 
BOOLOP
 + 
MARKER_EXPR
 )

138 
MARKER
 = 
stringStart
 + 
MARKER_EXPR
 + 
stringEnd

141 def 
	$_coerce_parse_result
 ( 
results
 ) :

142 if 
isinstance
 ( 
results
 , 
ParseResults
 ) :

143 return [ 
_coerce_parse_result
 ( 
i
 ) for 
i
 in 
results
 ]

145 return 
results
 
	}

148 def 
	$_format_marker
 ( 
marker
 , 
first
 = True ) :

149 assert 
isinstance
 ( 
marker
 , ( 
list
 , 
tuple
 , 
string_types
 ) )

155 if ( 
isinstance
 ( 
marker
 , 
list
 ) and 
len
 ( 
marker
 ) == 1 and

156 
isinstance
 ( 
marker
 [ 0 ] , ( 
list
 , 
tuple
 ) ) ) :

157 return 
_format_marker
 ( 
marker
 [ 0 ] )

159 if 
isinstance
 ( 
marker
 , 
list
 ) :

160 
inner
 = ( 
_format_marker
 ( 
m
 , 
first
 = False ) for 
m
 in 
marker
 )

161 if 
first
 :

162 return " " . 
join
 ( 
inner
 )

164 return "(" + " " . 
join
 ( 
inner
 ) + ")"

165 elif 
isinstance
 ( 
marker
 , 
tuple
 ) :

166 return " " . 
join
 ( [ 
m
 . 
serialize
 ( ) for 
m
 in 
marker
 ] )

168 return 
marker
 
	}

171 
_operators
 = { "in"

172 : lambda 
lhs
 , 
rhs
 : 
lhs
 in 
rhs
 , "not in"

173 : lambda 
lhs
 , 
rhs
 : 
lhs
 not in 
rhs
 , "<"

174 : 
operator
 . 
lt
 , "<="

175 : 
operator
 . 
le
 , "=="

176 : 
operator
 . 
eq
 , "!="

177 : 
operator
 . 
ne
 , ">="

178 : 
operator
 . 
ge
 , ">"

179 : 
operator
 . 
gt
 ,

183 def 
	$_eval_op
 ( 
lhs
 , 
op
 , 
rhs
 ) :

185 
spec
 = 
Specifier
 ( "" . 
join
 ( [ 
op
 . 
serialize
 ( ) , 
rhs
 ] ) )

186 except 
InvalidSpecifier
 :

189 return 
spec
 . 
contains
 ( 
lhs
 )

191 
oper
 = 
_operators
 . 
get
 ( 
op
 . 
serialize
 ( ) )

192 if 
oper
 is None :

193 raise 
UndefinedComparison
 ( "Undefined {0!r} on {1!r} and {2!r}."

194 . 
format
 ( 
op
 , 
lhs
 , 
rhs
 )

197 return 
oper
 ( 
lhs
 , 
rhs
 ) 
	}

200 
_undefined
 = 
object
 ( )

203 def 
	$_get_env
 ( 
environment
 , 
name
 ) :

204 
value
 = 
environment
 . 
get
 ( 
name
 , 
_undefined
 )

206 if 
value
 is 
_undefined
 :

207 raise 
UndefinedEnvironmentName
 ( "{0!r} does not exist in evaluation environment."

208 . 
format
 ( 
name
 )

211 return 
value
 
	}

214 def 
	$_evaluate_markers
 ( 
markers
 , 
environment
 ) :

215 
groups
 = [ [ ] ]

217 for 
marker
 in 
markers
 :

218 assert 
isinstance
 ( 
marker
 , ( 
list
 , 
tuple
 , 
string_types
 ) )

220 if 
isinstance
 ( 
marker
 , 
list
 ) :

221 
groups
 [ - 1 ] . 
append
 ( 
_evaluate_markers
 ( 
marker
 , 
environment
 ) )

222 elif 
isinstance
 ( 
marker
 , 
tuple
 ) :

223 
lhs
 , 
op
 , 
rhs
 = 
marker

225 if 
isinstance
 ( 
lhs
 , 
Variable
 ) :

226 
lhs_value
 = 
_get_env
 ( 
environment
 , 
lhs
 . 
value
 )

227 
rhs_value
 = 
rhs
 . 
value

229 
lhs_value
 = 
lhs
 . 
value

230 
rhs_value
 = 
_get_env
 ( 
environment
 , 
rhs
 . 
value
 )

232 
groups
 [ - 1 ] . 
append
 ( 
_eval_op
 ( 
lhs_value
 , 
op
 , 
rhs_value
 ) )

234 assert 
marker
 in [ "and" , "or" ]

235 if 
marker
 == "or" :

236 
groups
 . 
append
 ( [ ] )

238 return 
any
 ( 
all
 ( 
item
 ) for 
item
 in 
groups
 ) 
	}

241 def 
	$format_full_version
 ( 
info
 ) :

242 
version
 = '{0.major}.{0.minor}.{0.micro}' . 
format
 ( 
info
 )

243 
kind
 = 
info
 . 
releaselevel

244 if 
kind
 != 'final' :

245 
version
 += 
kind
 [ 0 ] + 
str
 ( 
info
 . 
serial
 )

246 return 
version
 
	}

249 def 
	$default_environment
 ( ) :

250 if 
hasattr
 ( 
sys
 , 'implementation' ) :

251 
iver
 = 
format_full_version
 ( 
sys
 . 
implementation
 . 
version
 )

252 
implementation_name
 = 
sys
 . 
implementation
 . 
name

254 
iver
 = '0'

255 
implementation_name
 = ''

258 : 
implementation_name
 , "implementation_version"

259 : 
iver
 , "os_name"

260 : 
os
 . 
name
 , "platform_machine"

261 : 
platform
 . 
machine
 ( ) , "platform_release"

262 : 
platform
 . 
release
 ( ) , "platform_system"

263 : 
platform
 . 
system
 ( ) , "platform_version"

264 : 
platform
 . 
version
 ( ) , "python_full_version"

265 : 
platform
 . 
python_version
 ( ) , "platform_python_implementation"

266 : 
platform
 . 
python_implementation
 ( ) , "python_version"

267 : 
platform
 . 
python_version
 ( ) [ : 3 ] , "sys_platform"

268 : 
sys
 . 
platform
 ,

269 } 
	}

272 class 
	cMarker
 ( 
object
 ) :

274 def 
	$__init__
 ( 
self
 , 
marker
 ) :

276 
self
 . 
_markers
 = 
_coerce_parse_result
 ( 
MARKER
 . 
parseString
 ( 
marker
 ) )

277 except 
ParseException
 as 
e
 :

278 
err_str
 = "Invalid marker: {0!r}, parse error at {1!r}" . 
format
 (

279 
marker
 , 
marker
 [ 
e
 . 
loc
 : 
e
 . 
loc
 + 8 ] )

280 raise 
InvalidMarker
 ( 
err_str
 ) 
	}

282 def 
	$__str__
 ( 
self
 ) :

283 return 
_format_marker
 ( 
self
 . 
_markers
 ) 
	}

285 def 
	$__repr__
 ( 
self
 ) :

286 return "<Marker({0!r})>" . 
format
 ( 
str
 ( 
self
 ) ) 
	}

288 def 
	$evaluate
 ( 
self
 , 
environment
 = None ) :

297 
current_environment
 = 
default_environment
 ( )

298 if 
environment
 is not None :

299 
current_environment
 . 
update
 ( 
environment
 )

301 return 
_evaluate_markers
 ( 
self
 . 
_markers
 , 
current_environment
 ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/requirements.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~string

7 import 
	~re

9 from 
	~setuptools.extern.pyparsing
 import 
stringStart
 , 
stringEnd
 , 
originalTextFor
 , 
ParseException

10 from 
	~setuptools.extern.pyparsing
 import 
ZeroOrMore
 , 
Word
 , 
Optional
 , 
Regex
 , 
Combine

11 from 
	~setuptools.extern.pyparsing
 import 
Literal
 as 
L

12 from 
	~setuptools.extern.six.moves.urllib
 import 
parse
 as 
urlparse

14 from . 
	~markers
 import 
MARKER_EXPR
 , 
Marker

15 from . 
	~specifiers
 import 
LegacySpecifier
 , 
Specifier
 , 
SpecifierSet

18 class 
	cInvalidRequirement
 ( 
ValueError
 ) :

24 
ALPHANUM
 = 
Word
 ( 
string
 . 
ascii_letters
 + 
string
 . 
digits
 )

26 
LBRACKET
 = 
L
 ( "[" ) . 
suppress
 ( )

27 
RBRACKET
 = 
L
 ( "]" ) . 
suppress
 ( )

28 
LPAREN
 = 
L
 ( "(" ) . 
suppress
 ( )

29 
RPAREN
 = 
L
 ( ")" ) . 
suppress
 ( )

30 
COMMA
 = 
L
 ( "," ) . 
suppress
 ( )

31 
SEMICOLON
 = 
L
 ( ";" ) . 
suppress
 ( )

32 
AT
 = 
L
 ( "@" ) . 
suppress
 ( )

34 
PUNCTUATION
 = 
Word
 ( "-_." )

35 
IDENTIFIER_END
 = 
ALPHANUM
 | ( 
ZeroOrMore
 ( 
PUNCTUATION
 ) + 
ALPHANUM
 )

36 
IDENTIFIER
 = 
Combine
 ( 
ALPHANUM
 + 
ZeroOrMore
 ( 
IDENTIFIER_END
 ) )

38 
NAME
 = 
IDENTIFIER
 ( "name" )

39 
EXTRA
 = 
IDENTIFIER

41 
URI
 = 
Regex
 ( r'[^ ]+' ) ( "url" )

42 
URL
 = ( 
AT
 + 
URI
 )

44 
EXTRAS_LIST
 = 
EXTRA
 + 
ZeroOrMore
 ( 
COMMA
 + 
EXTRA
 )

45 
EXTRAS
 = ( 
LBRACKET
 + 
Optional
 ( 
EXTRAS_LIST
 ) + 
RBRACKET
 ) ( "extras" )

47 
VERSION_PEP440
 = 
Regex
 ( 
Specifier
 . 
_regex_str
 , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

48 
VERSION_LEGACY
 = 
Regex
 ( 
LegacySpecifier
 . 
_regex_str
 , 
re
 . 
VERBOSE
 | 
re
 . 
IGNORECASE
 )

50 
VERSION_ONE
 = 
VERSION_PEP440
 ^ 
VERSION_LEGACY

51 
VERSION_MANY
 = 
Combine
 ( 
VERSION_ONE
 + 
ZeroOrMore
 ( 
COMMA
 + 
VERSION_ONE
 ) ,

52 
joinString
 = "," , 
adjacent
 = False ) ( "_raw_spec" )

53 
_VERSION_SPEC
 = 
Optional
 ( ( ( 
LPAREN
 + 
VERSION_MANY
 + 
RPAREN
 ) | 
VERSION_MANY
 ) )

54 
_VERSION_SPEC
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 . 
_raw_spec
 or '' )

56 
VERSION_SPEC
 = 
originalTextFor
 ( 
_VERSION_SPEC
 ) ( "specifier" )

57 
VERSION_SPEC
 . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 1 ] )

59 
MARKER_EXPR
 = 
originalTextFor
 ( 
MARKER_EXPR
 ( ) ) ( "marker" )

60 
MARKER_EXPR
 . 
setParseAction
 (

61 lambda 
s
 , 
l
 , 
t
 : 
Marker
 ( 
s
 [ 
t
 . 
_original_start
 : 
t
 . 
_original_end
 ] )

63 
MARKER_SEPERATOR
 = 
SEMICOLON

64 
MARKER
 = 
MARKER_SEPERATOR
 + 
MARKER_EXPR

66 
VERSION_AND_MARKER
 = 
VERSION_SPEC
 + 
Optional
 ( 
MARKER
 )

67 
URL_AND_MARKER
 = 
URL
 + 
Optional
 ( 
MARKER
 )

69 
NAMED_REQUIREMENT
 =

70 
NAME
 + 
Optional
 ( 
EXTRAS
 ) + ( 
URL_AND_MARKER
 | 
VERSION_AND_MARKER
 )

72 
REQUIREMENT
 = 
stringStart
 + 
NAMED_REQUIREMENT
 + 
stringEnd

75 class 
	cRequirement
 ( 
object
 ) :

88 def 
	$__init__
 ( 
self
 , 
requirement_string
 ) :

90 
req
 = 
REQUIREMENT
 . 
parseString
 ( 
requirement_string
 )

91 except 
ParseException
 as 
e
 :

92 raise 
InvalidRequirement
 ( "Invalid requirement, parse error at \"{0!r}\""

93 . 
format
 (

94 
requirement_string
 [ 
e
 . 
loc
 : 
e
 . 
loc
 + 8 ] ) )

96 
self
 . 
name
 = 
req
 . 
name

97 if 
req
 . 
url
 :

98 
parsed_url
 = 
urlparse
 . 
urlparse
 ( 
req
 . 
url
 )

99 if not ( 
parsed_url
 . 
scheme
 and 
parsed_url
 . 
netloc
 ) or (

100 not 
parsed_url
 . 
scheme
 and not 
parsed_url
 . 
netloc
 ) :

101 raise 
InvalidRequirement
 ( "Invalid URL given" )

102 
self
 . 
url
 = 
req
 . 
url

104 
self
 . 
url
 = None

105 
self
 . 
extras
 = 
set
 ( 
req
 . 
extras
 . 
asList
 ( ) if 
req
 . 
extras
 else [ ] )

106 
self
 . 
specifier
 = 
SpecifierSet
 ( 
req
 . 
specifier
 )

107 
self
 . 
marker
 = 
req
 . 
marker
 if 
req
 . 
marker
 else None 
	}

109 def 
	$__str__
 ( 
self
 ) :

110 
parts
 = [ 
self
 . 
name
 ]

112 if 
self
 . 
extras
 :

113 
parts
 . 
append
 ( "[{0}]" . 
format
 ( "," . 
join
 ( 
sorted
 ( 
self
 . 
extras
 ) ) ) )

115 if 
self
 . 
specifier
 :

116 
parts
 . 
append
 ( 
str
 ( 
self
 . 
specifier
 ) )

118 if 
self
 . 
url
 :

119 
parts
 . 
append
 ( "@ {0}" . 
format
 ( 
self
 . 
url
 ) )

121 if 
self
 . 
marker
 :

122 
parts
 . 
append
 ( "; {0}" . 
format
 ( 
self
 . 
marker
 ) )

124 return "" . 
join
 ( 
parts
 ) 
	}

126 def 
	$__repr__
 ( 
self
 ) :

127 return "<Requirement({0!r})>" . 
format
 ( 
str
 ( 
self
 ) ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/__about__.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 
__all__
 = [ "__title__"

11 
__title__
 = "packaging"

12 
__summary__
 = "Core utilities for Python packages"

13 
__uri__
 = "https://github.com/pypa/packaging"

15 
__version__
 = "16.8"

17 
__author__
 = "Donald Stufft and individual contributors"

18 
__email__
 = "donald@stufft.io"

20 
__license__
 = "BSD or Apache License, Version 2.0"

21 
__copyright__
 = "Copyright 2014-2016 %s" % 
__author__


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/__init__.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 from . 
	~__about__
 import (

7 
__author__
 , 
__copyright__
 , 
__email__
 , 
__license__
 , 
__summary__
 , 
__title__
 ,

8 
__uri__
 , 
__version__

11 
__all__
 = [ "__title__"


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/_structures.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

7 class 
	cInfinity
 ( 
object
 ) :

9 def 
	$__repr__
 ( 
self
 ) :

10 return "Infinity" 
	}

12 def 
	$__hash__
 ( 
self
 ) :

13 return 
hash
 ( 
repr
 ( 
self
 ) ) 
	}

15 def 
	$__lt__
 ( 
self
 , 
other
 ) :

16 return False 
	}

18 def 
	$__le__
 ( 
self
 , 
other
 ) :

19 return False 
	}

21 def 
	$__eq__
 ( 
self
 , 
other
 ) :

22 return 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

24 def 
	$__ne__
 ( 
self
 , 
other
 ) :

25 return not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

27 def 
	$__gt__
 ( 
self
 , 
other
 ) :

28 return True 
	}

30 def 
	$__ge__
 ( 
self
 , 
other
 ) :

31 return True 
	}

33 def 
	$__neg__
 ( 
self
 ) :

34 return 
NegativeInfinity
 
	}

36 
Infinity
 = 
Infinity
 ( )

39 class 
	cNegativeInfinity
 ( 
object
 ) :

41 def 
	$__repr__
 ( 
self
 ) :

42 return "-Infinity" 
	}

44 def 
	$__hash__
 ( 
self
 ) :

45 return 
hash
 ( 
repr
 ( 
self
 ) ) 
	}

47 def 
	$__lt__
 ( 
self
 , 
other
 ) :

48 return True 
	}

50 def 
	$__le__
 ( 
self
 , 
other
 ) :

51 return True 
	}

53 def 
	$__eq__
 ( 
self
 , 
other
 ) :

54 return 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

56 def 
	$__ne__
 ( 
self
 , 
other
 ) :

57 return not 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) 
	}

59 def 
	$__gt__
 ( 
self
 , 
other
 ) :

60 return False 
	}

62 def 
	$__ge__
 ( 
self
 , 
other
 ) :

63 return False 
	}

65 def 
	$__neg__
 ( 
self
 ) :

66 return 
Infinity
 
	}

68 
NegativeInfinity
 = 
NegativeInfinity
 ( )


	@./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/utils.py

4 from 
	~__future__
 import 
absolute_import
 , 
division
 , 
print_function

6 import 
	~re

9 
_canonicalize_regex
 = 
re
 . 
compile
 ( r"[-_.]+" )

12 def 
	$canonicalize_name
 ( 
name
 ) :

14 return 
_canonicalize_regex
 . 
sub
 ( "-" , 
name
 ) . 
lower
 ( ) 
	}


	@./env/lib/python3.7/site-packages/setuptools/_vendor/__init__.py


	@./env/lib/python3.7/site-packages/setuptools/_vendor/pyparsing.py

25 
__doc__
 = """\npyparsing module - Classes and methods to define and execute parsing grammars\n=============================================================================\n\nThe pyparsing module is an alternative approach to creating and executing simple grammars,\nvs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you\ndon't need to learn a new syntax for defining grammars or matching expressions - the parsing module\nprovides a library of classes that you use to construct the grammar directly in Python.\n\nHere is a program to parse "Hello, World!" (or any greeting of the form \nC{"<salutation>, <addressee>!"}), built up using L{Word}, L{Literal}, and L{And} elements \n(L{'+'<ParserElement.__add__>} operator gives L{And} expressions, strings are auto-converted to\nL{Literal} expressions)::\n\n    from pyparsing import Word, alphas\n\n    # define grammar of a greeting\n    greet = Word(alphas) + "," + Word(alphas) + "!"\n\n    hello = "Hello, World!"\n    print (hello, "->", greet.parseString(hello))\n\nThe program outputs the following::\n\n    Hello, World! -> ['Hello', ',', 'World', '!']\n\nThe Python representation of the grammar is quite readable, owing to the self-explanatory\nclass names, and the use of '+', '|' and '^' operators.\n\nThe L{ParseResults} object returned from L{ParserElement.parseString<ParserElement.parseString>} can be accessed as a nested list, a dictionary, or an\nobject with named attributes.\n\nThe pyparsing module handles some of the problems that are typically vexing when writing text parsers:\n - extra or missing whitespace (the above program will also handle "Hello,World!", "Hello  ,  World  !", etc.)\n - quoted strings\n - embedded comments\n\n\nGetting Started -\n-----------------\nVisit the classes L{ParserElement} and L{ParseResults} to see the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:\n - construct literal match expressions from L{Literal} and L{CaselessLiteral} classes\n - construct character word-group expressions using the L{Word} class\n - see how to create repetitive expressions using L{ZeroOrMore} and L{OneOrMore} classes\n - use L{'+'<And>}, L{'|'<MatchFirst>}, L{'^'<Or>}, and L{'&'<Each>} operators to combine simple expressions into more complex ones\n - associate names with your parsed results using L{ParserElement.setResultsName}\n - find some helpful expression short-cuts like L{delimitedList} and L{oneOf}\n - find more useful common expressions in the L{pyparsing_common} namespace class\n"""

77 
__version__
 = "2.2.1"

78 
__versionTime__
 = "18 Sep 2018 00:49 UTC"

79 
__author__
 = "Paul McGuire <ptmcg@users.sourceforge.net>"

81 import 
	~string

82 from 
	~weakref
 import 
ref
 as 
wkref

83 import 
	~copy

84 import 
	~sys

85 import 
	~warnings

86 import 
	~re

87 import 
	~sre_constants

88 import 
	~collections

89 import 
	~pprint

90 import 
	~traceback

91 import 
	~types

92 from 
	~datetime
 import 
datetime

95 from 
	~_thread
 import 
RLock

96 except 
ImportError
 :

97 from 
	~threading
 import 
RLock

101 from 
	~collections.abc
 import 
Iterable

102 from 
	~collections.abc
 import 
MutableMapping

103 except 
ImportError
 :

105 from 
	~collections
 import 
Iterable

106 from 
	~collections
 import 
MutableMapping

109 from 
	~collections
 import 
OrderedDict
 as 
_OrderedDict

110 except 
ImportError
 :

112 from 
	~ordereddict
 import 
OrderedDict
 as 
_OrderedDict

113 except 
ImportError
 :

114 
_OrderedDict
 = None

118 
__all__
 = [ 'And'

139 
system_version
 = 
tuple
 ( 
sys
 . 
version_info
 ) [ : 3 ]

140 
PY_3
 = 
system_version
 [ 0 ] == 3

141 if 
PY_3
 :

142 
_MAX_INT
 = 
sys
 . 
maxsize

143 
basestring
 = 
str

144 
unichr
 = 
chr

145 
_ustr
 = 
str

148 
singleArgBuiltins
 = [ 
sum
 , 
len
 , 
sorted
 , 
reversed
 , 
list
 , 
tuple
 , 
set
 , 
any
 , 
all
 , 
min
 , 
max
 ]

151 
_MAX_INT
 = 
sys
 . 
maxint

152 
range
 = 
xrange

154 def 
	$_ustr
 ( 
obj
 ) :

159 if 
isinstance
 ( 
obj
 , 
unicode
 ) :

160 return 
obj

165 return 
str
 ( 
obj
 )

167 except 
UnicodeEncodeError
 :

169 
ret
 = 
unicode
 ( 
obj
 ) . 
encode
 ( 
sys
 . 
getdefaultencoding
 ( ) , 'xmlcharrefreplace' )

170 
xmlcharref
 = 
Regex
 ( r'&#\d+;' )

171 
xmlcharref
 . 
setParseAction
 ( lambda 
t
 : '\\u' + 
hex
 ( 
int
 ( 
t
 [ 0 ] [ 2 : - 1 ] ) ) [ 2 : ] )

172 return 
xmlcharref
 . 
transformString
 ( 
ret
 ) 
	}

175 
singleArgBuiltins
 = [ ]

176 import 
	~__builtin__

177 for 
fname
 in "sum len sorted reversed list tuple set any all min max" . 
split
 ( ) :

179 
singleArgBuiltins
 . 
append
 ( 
getattr
 ( 
__builtin__
 , 
fname
 ) )

180 except 
AttributeError
 :

183 
_generatorType
 = 
type
 ( ( 
y
 for 
y
 in 
range
 ( 1 ) ) )

185 def 
	$_xml_escape
 ( 
data
 ) :

189 
from_symbols
 = '&><"\''

190 
to_symbols
 = ( '&' + 
s
 + ';' for 
s
 in "amp gt lt quot apos" . 
split
 ( ) )

191 for 
from_
 , 
to_
 in 
zip
 ( 
from_symbols
 , 
to_symbols
 ) :

192 
data
 = 
data
 . 
replace
 ( 
from_
 , 
to_
 )

193 return 
data
 
	}

195 class 
	c_Constants
 ( 
object
 ) :

198 
alphas
 = 
string
 . 
ascii_uppercase
 + 
string
 . 
ascii_lowercase

199 
nums
 = "0123456789"

200 
hexnums
 = 
nums
 + "ABCDEFabcdef"

201 
alphanums
 = 
alphas
 + 
nums

202 
_bslash
 = 
chr
 ( 92 )

203 
printables
 = "" . 
join
 ( 
c
 for 
c
 in 
string
 . 
printable
 if 
c
 not in 
string
 . 
whitespace
 )

205 class 
	cParseBaseException
 ( 
Exception
 ) :

209 def 
	$__init__
 ( 
self
 , 
pstr
 , 
loc
 = 0 , 
msg
 = None , 
elem
 = None ) :

210 
self
 . 
loc
 = 
loc

211 if 
msg
 is None :

212 
self
 . 
msg
 = 
pstr

213 
self
 . 
pstr
 = ""

215 
self
 . 
msg
 = 
msg

216 
self
 . 
pstr
 = 
pstr

217 
self
 . 
parserElement
 = 
elem

218 
self
 . 
args
 = ( 
pstr
 , 
loc
 , 
msg
 ) 
	}

220 @ 
classmethod

221 def 
	$_from_exception
 ( 
cls
 , 
pe
 ) :

226 return 
cls
 ( 
pe
 . 
pstr
 , 
pe
 . 
loc
 , 
pe
 . 
msg
 , 
pe
 . 
parserElement
 ) 
	}

228 def 
	$__getattr__
 ( 
self
 , 
aname
 ) :

234 if ( 
aname
 == "lineno" ) :

235 return 
lineno
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

236 elif ( 
aname
 in ( "col" , "column" ) ) :

237 return 
col
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

238 elif ( 
aname
 == "line" ) :

239 return 
line
 ( 
self
 . 
loc
 , 
self
 . 
pstr
 )

241 raise 
AttributeError
 ( 
aname
 ) 
	}

243 def 
	$__str__
 ( 
self
 ) :

245 ( 
self
 . 
msg
 , 
self
 . 
loc
 , 
self
 . 
lineno
 , 
self
 . 
column
 ) 
	}

246 def 
	$__repr__
 ( 
self
 ) :

247 return 
_ustr
 ( 
self
 ) 
	}

248 def 
	$markInputline
 ( 
self
 , 
markerString
 = ">!<" ) :

252 
line_str
 = 
self
 . 
line

253 
line_column
 = 
self
 . 
column
 - 1

254 if 
markerString
 :

255 
line_str
 = "" . 
join
 ( ( 
line_str
 [ : 
line_column
 ] ,

256 
markerString
 , 
line_str
 [ 
line_column
 : ] ) )

257 return 
line_str
 . 
strip
 ( ) 
	}

258 def 
	$__dir__
 ( 
self
 ) :

259 return "lineno col line" . 
split
 ( ) + 
dir
 ( 
type
 ( 
self
 ) ) 
	}

261 class 
	cParseException
 ( 
ParseBaseException
 ) :

282 class 
	cParseFatalException
 ( 
ParseBaseException
 ) :

287 class 
	cParseSyntaxException
 ( 
ParseFatalException
 ) :

306 class 
	cRecursiveGrammarException
 ( 
Exception
 ) :

308 def 
	$__init__
 ( 
self
 , 
parseElementList
 ) :

309 
self
 . 
parseElementTrace
 = 
parseElementList
 
	}

311 def 
	$__str__
 ( 
self
 ) :

312 return "RecursiveGrammarException: %s" % 
self
 . 
parseElementTrace
 
	}

314 class 
	c_ParseResultsWithOffset
 ( 
object
 ) :

315 def 
	$__init__
 ( 
self
 , 
p1
 , 
p2
 ) :

316 
self
 . 
tup
 = ( 
p1
 , 
p2
 ) 
	}

317 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

318 return 
self
 . 
tup
 [ 
i
 ] 
	}

319 def 
	$__repr__
 ( 
self
 ) :

320 return 
repr
 ( 
self
 . 
tup
 [ 0 ] ) 
	}

321 def 
	$setOffset
 ( 
self
 , 
i
 ) :

322 
self
 . 
tup
 = ( 
self
 . 
tup
 [ 0 ] , 
i
 ) 
	}

324 class 
	cParseResults
 ( 
object
 ) :

363 def 
	$__new__
 ( 
cls
 , 
toklist
 = None , 
name
 = None , 
asList
 = True , 
modal
 = True ) :

364 if 
isinstance
 ( 
toklist
 , 
cls
 ) :

365 return 
toklist

366 
retobj
 = 
object
 . 
__new__
 ( 
cls
 )

367 
retobj
 . 
__doinit
 = True

368 return 
retobj
 
	}

372 def 
	$__init__
 ( 
self
 , 
toklist
 = None , 
name
 = None , 
asList
 = True , 
modal
 = True , 
isinstance
 = 
isinstance
 ) :

373 if 
self
 . 
__doinit
 :

374 
self
 . 
__doinit
 = False

375 
self
 . 
__name
 = None

376 
self
 . 
__parent
 = None

377 
self
 . 
__accumNames
 = { }

378 
self
 . 
__asList
 = 
asList

379 
self
 . 
__modal
 = 
modal

380 if 
toklist
 is None :

381 
toklist
 = [ ]

382 if 
isinstance
 ( 
toklist
 , 
list
 ) :

383 
self
 . 
__toklist
 = 
toklist
 [ : ]

384 elif 
isinstance
 ( 
toklist
 , 
_generatorType
 ) :

385 
self
 . 
__toklist
 = 
list
 ( 
toklist
 )

387 
self
 . 
__toklist
 = [ 
toklist
 ]

388 
self
 . 
__tokdict
 = 
dict
 ( )

390 if 
name
 is not None and 
name
 :

391 if not 
modal
 :

392 
self
 . 
__accumNames
 [ 
name
 ] = 0

393 if 
isinstance
 ( 
name
 , 
int
 ) :

394 
name
 = 
_ustr
 ( 
name
 )

395 
self
 . 
__name
 = 
name

396 if not ( 
isinstance
 ( 
toklist
 , ( 
type
 ( None ) , 
basestring
 , 
list
 ) ) and 
toklist
 in ( None , '' , [ ] ) ) :

397 if 
isinstance
 ( 
toklist
 , 
basestring
 ) :

398 
toklist
 = [ 
toklist
 ]

399 if 
asList
 :

400 if 
isinstance
 ( 
toklist
 , 
ParseResults
 ) :

401 
self
 [ 
name
 ] = 
_ParseResultsWithOffset
 ( 
toklist
 . 
copy
 ( ) , 0 )

403 
self
 [ 
name
 ] = 
_ParseResultsWithOffset
 ( 
ParseResults
 ( 
toklist
 [ 0 ] ) , 0 )

404 
self
 [ 
name
 ] . 
__name
 = 
name

407 
self
 [ 
name
 ] = 
toklist
 [ 0 ]

408 except ( 
KeyError
 , 
TypeError
 , 
IndexError
 ) :

409 
self
 [ 
name
 ] = 
toklist
 
	}

411 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

412 if 
isinstance
 ( 
i
 , ( 
int
 , 
slice
 ) ) :

413 return 
self
 . 
__toklist
 [ 
i
 ]

415 if 
i
 not in 
self
 . 
__accumNames
 :

416 return 
self
 . 
__tokdict
 [ 
i
 ] [ - 1 ] [ 0 ]

418 return 
ParseResults
 ( [ 
v
 [ 0 ] for 
v
 in 
self
 . 
__tokdict
 [ 
i
 ] ] ) 
	}

420 def 
	$__setitem__
 ( 
self
 , 
k
 , 
v
 , 
isinstance
 = 
isinstance
 ) :

421 if 
isinstance
 ( 
v
 , 
_ParseResultsWithOffset
 ) :

422 
self
 . 
__tokdict
 [ 
k
 ] = 
self
 . 
__tokdict
 . 
get
 ( 
k
 , 
list
 ( ) ) + [ 
v
 ]

423 
sub
 = 
v
 [ 0 ]

424 elif 
isinstance
 ( 
k
 , ( 
int
 , 
slice
 ) ) :

425 
self
 . 
__toklist
 [ 
k
 ] = 
v

426 
sub
 = 
v

428 
self
 . 
__tokdict
 [ 
k
 ] = 
self
 . 
__tokdict
 . 
get
 ( 
k
 , 
list
 ( ) ) + [ 
_ParseResultsWithOffset
 ( 
v
 , 0 ) ]

429 
sub
 = 
v

430 if 
isinstance
 ( 
sub
 , 
ParseResults
 ) :

431 
sub
 . 
__parent
 = 
wkref
 ( 
self
 ) 
	}

433 def 
	$__delitem__
 ( 
self
 , 
i
 ) :

434 if 
isinstance
 ( 
i
 , ( 
int
 , 
slice
 ) ) :

435 
mylen
 = 
len
 ( 
self
 . 
__toklist
 )

436 del 
self
 . 
__toklist
 [ 
i
 ]

439 if 
isinstance
 ( 
i
 , 
int
 ) :

440 if 
i
 < 0 :

441 
i
 += 
mylen

442 
i
 = 
slice
 ( 
i
 , 
i
 + 1 )

444 
removed
 = 
list
 ( 
range
 ( * 
i
 . 
indices
 ( 
mylen
 ) ) )

445 
removed
 . 
reverse
 ( )

447 for 
name
 , 
occurrences
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

448 for 
j
 in 
removed
 :

449 for 
k
 , ( 
value
 , 
position
 ) in 
enumerate
 ( 
occurrences
 ) :

450 
occurrences
 [ 
k
 ] = 
_ParseResultsWithOffset
 ( 
value
 , 
position
 - ( 
position
 > 
j
 ) )

452 del 
self
 . 
__tokdict
 [ 
i
 ] 
	}

454 def 
	$__contains__
 ( 
self
 , 
k
 ) :

455 return 
k
 in 
self
 . 
__tokdict
 
	}

457 def 
	$__len__
 ( 
self
 ) : return 
len
 ( 
self
 . 
__toklist
 )

458 def 
__bool__
 ( 
self
 ) : return ( not not 
self
 . 
__toklist
 )

459 
__nonzero__
 = 
__bool__

460 def 
__iter__
 ( 
self
 ) : return 
iter
 ( 
self
 . 
__toklist
 )

461 def 
__reversed__
 ( 
self
 ) : return 
iter
 ( 
self
 . 
__toklist
 [ : : - 1 ] )

462 def 
_iterkeys
 ( 
self
 ) :

463 if 
hasattr
 ( 
self
 . 
__tokdict
 , "iterkeys" ) :

464 return 
self
 . 
__tokdict
 . 
iterkeys
 ( )

466 return 
iter
 ( 
self
 . 
__tokdict
 ) 
	}

468 def 
	$_itervalues
 ( 
self
 ) :

469 return ( 
self
 [ 
k
 ] for 
k
 in 
self
 . 
_iterkeys
 ( ) ) 
	}

471 def 
	$_iteritems
 ( 
self
 ) :

472 return ( ( 
k
 , 
self
 [ 
k
 ] ) for 
k
 in 
self
 . 
_iterkeys
 ( ) ) 
	}

474 if 
PY_3
 :

475 
keys
 = 
_iterkeys
 """Returns an iterator of all named result keys (Python 3.x only)."""

478 
values
 = 
_itervalues
 """Returns an iterator of all named result values (Python 3.x only)."""

481 
items
 = 
_iteritems
 """Returns an iterator of all named result key-value tuples (Python 3.x only)."""

485 
iterkeys
 = 
_iterkeys
 """Returns an iterator of all named result keys (Python 2.x only)."""

488 
itervalues
 = 
_itervalues
 """Returns an iterator of all named result values (Python 2.x only)."""

491 
iteritems
 = 
_iteritems
 """Returns an iterator of all named result key-value tuples (Python 2.x only)."""

494 def 
	$keys
 ( 
self
 ) :

496 return 
list
 ( 
self
 . 
iterkeys
 ( ) ) 
	}

498 def 
	$values
 ( 
self
 ) :

500 return 
list
 ( 
self
 . 
itervalues
 ( ) ) 
	}

502 def 
	$items
 ( 
self
 ) :

504 return 
list
 ( 
self
 . 
iteritems
 ( ) ) 
	}

506 def 
	$haskeys
 ( 
self
 ) :

509 return 
bool
 ( 
self
 . 
__tokdict
 ) 
	}

511 def 
	$pop
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

545 if not 
args
 :

546 
args
 = [ - 1 ]

547 for 
k
 , 
v
 in 
kwargs
 . 
items
 ( ) :

548 if 
k
 == 'default' :

549 
args
 = ( 
args
 [ 0 ] , 
v
 )

551 raise 
TypeError
 ( "pop() got an unexpected keyword argument '%s'" % 
k
 )

552 if ( 
isinstance
 ( 
args
 [ 0 ] , 
int
 ) or

553 
len
 ( 
args
 ) == 1 or

554 
args
 [ 0 ] in 
self
 ) :

555 
index
 = 
args
 [ 0 ]

556 
ret
 = 
self
 [ 
index
 ]

557 del 
self
 [ 
index
 ]

558 return 
ret

560 
defaultvalue
 = 
args
 [ 1 ]

561 return 
defaultvalue
 
	}

563 def 
	$get
 ( 
self
 , 
key
 , 
defaultValue
 = None ) :

580 if 
key
 in 
self
 :

581 return 
self
 [ 
key
 ]

583 return 
defaultValue
 
	}

585 def 
	$insert
 ( 
self
 , 
index
 , 
insStr
 ) :

599 
self
 . 
__toklist
 . 
insert
 ( 
index
 , 
insStr
 )

601 for 
name
 , 
occurrences
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

602 for 
k
 , ( 
value
 , 
position
 ) in 
enumerate
 ( 
occurrences
 ) :

603 
occurrences
 [ 
k
 ] = 
_ParseResultsWithOffset
 ( 
value
 , 
position
 + ( 
position
 > 
index
 ) ) 
	}

605 def 
	$append
 ( 
self
 , 
item
 ) :

617 
self
 . 
__toklist
 . 
append
 ( 
item
 ) 
	}

619 def 
	$extend
 ( 
self
 , 
itemseq
 ) :

632 if 
isinstance
 ( 
itemseq
 , 
ParseResults
 ) :

633 
self
 += 
itemseq

635 
self
 . 
__toklist
 . 
extend
 ( 
itemseq
 ) 
	}

637 def 
	$clear
 ( 
self
 ) :

641 del 
self
 . 
__toklist
 [ : ]

642 
self
 . 
__tokdict
 . 
clear
 ( ) 
	}

644 def 
	$__getattr__
 ( 
self
 , 
name
 ) :

646 return 
self
 [ 
name
 ]

647 except 
KeyError
 :

650 if 
name
 in 
self
 . 
__tokdict
 :

651 if 
name
 not in 
self
 . 
__accumNames
 :

652 return 
self
 . 
__tokdict
 [ 
name
 ] [ - 1 ] [ 0 ]

654 return 
ParseResults
 ( [ 
v
 [ 0 ] for 
v
 in 
self
 . 
__tokdict
 [ 
name
 ] ] )

656 return "" 
	}

658 def 
	$__add__
 ( 
self
 , 
other
 ) :

659 
ret
 = 
self
 . 
copy
 ( )

660 
ret
 += 
other

661 return 
ret
 
	}

663 def 
	$__iadd__
 ( 
self
 , 
other
 ) :

664 if 
other
 . 
__tokdict
 :

665 
offset
 = 
len
 ( 
self
 . 
__toklist
 )

666 
addoffset
 = lambda 
a
 : 
offset
 if 
a
 < 0 else 
a
 + 
offset

667 
otheritems
 = 
other
 . 
__tokdict
 . 
items
 ( )

668 
otherdictitems
 = [ ( 
k
 , 
_ParseResultsWithOffset
 ( 
v
 [ 0 ] , 
addoffset
 ( 
v
 [ 1 ] ) ) )

669 for ( 
k
 , 
vlist
 ) in 
otheritems
 for 
v
 in 
vlist
 ]

670 for 
k
 , 
v
 in 
otherdictitems
 :

671 
self
 [ 
k
 ] = 
v

672 if 
isinstance
 ( 
v
 [ 0 ] , 
ParseResults
 ) :

673 
v
 [ 0 ] . 
__parent
 = 
wkref
 ( 
self
 )

675 
self
 . 
__toklist
 += 
other
 . 
__toklist

676 
self
 . 
__accumNames
 . 
update
 ( 
other
 . 
__accumNames
 )

677 return 
self
 
	}

679 def 
	$__radd__
 ( 
self
 , 
other
 ) :

680 if 
isinstance
 ( 
other
 , 
int
 ) and 
other
 == 0 :

682 return 
self
 . 
copy
 ( )

685 return 
other
 + 
self
 
	}

687 def 
	$__repr__
 ( 
self
 ) :

688 return "(%s, %s)" % ( 
repr
 ( 
self
 . 
__toklist
 ) , 
repr
 ( 
self
 . 
__tokdict
 ) ) 
	}

690 def 
	$__str__
 ( 
self
 ) :

691 return '[' + ', ' . 
join
 ( 
_ustr
 ( 
i
 ) if 
isinstance
 ( 
i
 , 
ParseResults
 ) else 
repr
 ( 
i
 ) for 
i
 in 
self
 . 
__toklist
 ) + ']' 
	}

693 def 
	$_asStringList
 ( 
self
 , 
sep
 = '' ) :

694 
out
 = [ ]

695 for 
item
 in 
self
 . 
__toklist
 :

696 if 
out
 and 
sep
 :

697 
out
 . 
append
 ( 
sep
 )

698 if 
isinstance
 ( 
item
 , 
ParseResults
 ) :

699 
out
 += 
item
 . 
_asStringList
 ( )

701 
out
 . 
append
 ( 
_ustr
 ( 
item
 ) )

702 return 
out
 
	}

704 def 
	$asList
 ( 
self
 ) :

718 return [ 
res
 . 
asList
 ( ) if 
isinstance
 ( 
res
 , 
ParseResults
 ) else 
res
 for 
res
 in 
self
 . 
__toklist
 ] 
	}

720 def 
	$asDict
 ( 
self
 ) :

739 if 
PY_3
 :

740 
item_fn
 = 
self
 . 
items

742 
item_fn
 = 
self
 . 
iteritems

744 def 
toItem
 ( 
obj
 ) :

745 if 
isinstance
 ( 
obj
 , 
ParseResults
 ) :

746 if 
obj
 . 
haskeys
 ( ) :

747 return 
obj
 . 
asDict
 ( )

749 return [ 
toItem
 ( 
v
 ) for 
v
 in 
obj
 ]

751 return 
obj

753 return 
dict
 ( ( 
k
 , 
toItem
 ( 
v
 ) ) for 
k
 , 
v
 in 
item_fn
 ( ) ) 
	}

755 def 
	$copy
 ( 
self
 ) :

759 
ret
 = 
ParseResults
 ( 
self
 . 
__toklist
 )

760 
ret
 . 
__tokdict
 = 
self
 . 
__tokdict
 . 
copy
 ( )

761 
ret
 . 
__parent
 = 
self
 . 
__parent

762 
ret
 . 
__accumNames
 . 
update
 ( 
self
 . 
__accumNames
 )

763 
ret
 . 
__name
 = 
self
 . 
__name

764 return 
ret
 
	}

766 def 
	$asXML
 ( 
self
 , 
doctag
 = None , 
namedItemsOnly
 = False , 
indent
 = "" , 
formatted
 = True ) :

770 
nl
 = "\n"

771 
out
 = [ ]

772 
namedItems
 = 
dict
 ( ( 
v
 [ 1 ] , 
k
 ) for ( 
k
 , 
vlist
 ) in 
self
 . 
__tokdict
 . 
items
 ( )

773 for 
v
 in 
vlist
 )

774 
nextLevelIndent
 = 
indent
 + "  "

777 if not 
formatted
 :

778 
indent
 = ""

779 
nextLevelIndent
 = ""

780 
nl
 = ""

782 
selfTag
 = None

783 if 
doctag
 is not None :

784 
selfTag
 = 
doctag

786 if 
self
 . 
__name
 :

787 
selfTag
 = 
self
 . 
__name

789 if not 
selfTag
 :

790 if 
namedItemsOnly
 :

793 
selfTag
 = "ITEM"

795 
out
 += [ 
nl
 , 
indent
 , "<" , 
selfTag
 , ">" ]

797 for 
i
 , 
res
 in 
enumerate
 ( 
self
 . 
__toklist
 ) :

798 if 
isinstance
 ( 
res
 , 
ParseResults
 ) :

799 if 
i
 in 
namedItems
 :

800 
out
 += [ 
res
 . 
asXML
 ( 
namedItems
 [ 
i
 ] ,

801 
namedItemsOnly
 and 
doctag
 is None ,

802 
nextLevelIndent
 ,

803 
formatted
 ) ]

805 
out
 += [ 
res
 . 
asXML
 ( None ,

806 
namedItemsOnly
 and 
doctag
 is None ,

807 
nextLevelIndent
 ,

808 
formatted
 ) ]

811 
resTag
 = None

812 if 
i
 in 
namedItems
 :

813 
resTag
 = 
namedItems
 [ 
i
 ]

814 if not 
resTag
 :

815 if 
namedItemsOnly
 :

818 
resTag
 = "ITEM"

819 
xmlBodyText
 = 
_xml_escape
 ( 
_ustr
 ( 
res
 ) )

820 
out
 += [ 
nl
 , 
nextLevelIndent
 , "<" , 
resTag
 , ">" ,

821 
xmlBodyText
 , "</"

822 , 
resTag
 , ">" ]

824 
out
 += [ 
nl
 , 
indent
 , "</" , 
selfTag
 , ">" ]

825 return "" . 
join
 ( 
out
 ) 
	}

827 def 
	$__lookup
 ( 
self
 , 
sub
 ) :

828 for 
k
 , 
vlist
 in 
self
 . 
__tokdict
 . 
items
 ( ) :

829 for 
v
 , 
loc
 in 
vlist
 :

830 if 
sub
 is 
v
 :

831 return 
k

832 return None 
	}

834 def 
	$getName
 ( 
self
 ) :

856 if 
self
 . 
__name
 :

857 return 
self
 . 
__name

858 elif 
self
 . 
__parent
 :

859 
par
 = 
self
 . 
__parent
 ( )

860 if 
par
 :

861 return 
par
 . 
__lookup
 ( 
self
 )

864 elif ( 
len
 ( 
self
 ) == 1 and

865 
len
 ( 
self
 . 
__tokdict
 ) == 1 and

866 
next
 ( 
iter
 ( 
self
 . 
__tokdict
 . 
values
 ( ) ) ) [ 0 ] [ 1 ] in ( 0 , - 1 ) ) :

867 return 
next
 ( 
iter
 ( 
self
 . 
__tokdict
 . 
keys
 ( ) ) )

869 return None 
	}

871 def 
	$dump
 ( 
self
 , 
indent
 = '' , 
depth
 = 0 , 
full
 = True ) :

889 
out
 = [ ]

890 
NL
 = '\n'

891 
out
 . 
append
 ( 
indent
 + 
_ustr
 ( 
self
 . 
asList
 ( ) ) )

892 if 
full
 :

893 if 
self
 . 
haskeys
 ( ) :

894 
items
 = 
sorted
 ( ( 
str
 ( 
k
 ) , 
v
 ) for 
k
 , 
v
 in 
self
 . 
items
 ( ) )

895 for 
k
 , 
v
 in 
items
 :

896 if 
out
 :

897 
out
 . 
append
 ( 
NL
 )

898 
out
 . 
append
 ( "%s%s- %s: " % ( 
indent
 , ( '  ' * 
depth
 ) , 
k
 ) )

899 if 
isinstance
 ( 
v
 , 
ParseResults
 ) :

900 if 
v
 :

901 
out
 . 
append
 ( 
v
 . 
dump
 ( 
indent
 , 
depth
 + 1 ) )

903 
out
 . 
append
 ( 
_ustr
 ( 
v
 ) )

905 
out
 . 
append
 ( 
repr
 ( 
v
 ) )

906 elif 
any
 ( 
isinstance
 ( 
vv
 , 
ParseResults
 ) for 
vv
 in 
self
 ) :

907 
v
 = 
self

908 for 
i
 , 
vv
 in 
enumerate
 ( 
v
 ) :

909 if 
isinstance
 ( 
vv
 , 
ParseResults
 ) :

910 
out
 . 
append
 ( "\n%s%s[%d]:\n%s%s%s" % ( 
indent
 , ( '  ' * ( 
depth
 ) ) , 
i
 , 
indent
 , ( '  ' * ( 
depth
 + 1 ) ) , 
vv
 . 
dump
 ( 
indent
 , 
depth
 + 1 ) ) )

912 
out
 . 
append
 ( "\n%s%s[%d]:\n%s%s%s" % ( 
indent
 , ( '  ' * ( 
depth
 ) ) , 
i
 , 
indent
 , ( '  ' * ( 
depth
 + 1 ) ) , 
_ustr
 ( 
vv
 ) ) )

914 return "" . 
join
 ( 
out
 ) 
	}

916 def 
	$pprint
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

937 
pprint
 . 
pprint
 ( 
self
 . 
asList
 ( ) , * 
args
 , ** 
kwargs
 ) 
	}

940 def 
	$__getstate__
 ( 
self
 ) :

941 return ( 
self
 . 
__toklist
 ,

942 ( 
self
 . 
__tokdict
 . 
copy
 ( ) ,

943 
self
 . 
__parent
 is not None and 
self
 . 
__parent
 ( ) or None ,

944 
self
 . 
__accumNames
 ,

945 
self
 . 
__name
 ) ) 
	}

947 def 
	$__setstate__
 ( 
self
 , 
state
 ) :

948 
self
 . 
__toklist
 = 
state
 [ 0 ]

949 ( 
self
 . 
__tokdict
 ,

950 
par
 ,

951 
inAccumNames
 ,

952 
self
 . 
__name
 ) = 
state
 [ 1 ]

953 
self
 . 
__accumNames
 = { }

954 
self
 . 
__accumNames
 . 
update
 ( 
inAccumNames
 )

955 if 
par
 is not None :

956 
self
 . 
__parent
 = 
wkref
 ( 
par
 )

958 
self
 . 
__parent
 = None 
	}

960 def 
	$__getnewargs__
 ( 
self
 ) :

961 return 
self
 . 
__toklist
 , 
self
 . 
__name
 , 
self
 . 
__asList
 , 
self
 . 
__modal
 
	}

963 def 
	$__dir__
 ( 
self
 ) :

964 return ( 
dir
 ( 
type
 ( 
self
 ) ) + 
list
 ( 
self
 . 
keys
 ( ) ) ) 
	}

966 
MutableMapping
 . 
register
 ( 
ParseResults
 )

968 def 
	$col
 ( 
loc
 , 
strg
 ) :

978 
s
 = 
strg

979 return 1 if 0 < 
loc
 < 
len
 ( 
s
 ) and 
s
 [ 
loc
 - 1 ] == '\n' else 
loc
 - 
s
 . 
rfind
 ( "\n" , 0 , 
loc
 ) 
	}

981 def 
	$lineno
 ( 
loc
 , 
strg
 ) :

991 return 
strg
 . 
count
 ( "\n" , 0 , 
loc
 ) + 1 
	}

993 def 
	$line
 ( 
loc
 , 
strg
 ) :

996 
lastCR
 = 
strg
 . 
rfind
 ( "\n" , 0 , 
loc
 )

997 
nextCR
 = 
strg
 . 
find
 ( "\n" , 
loc
 )

998 if 
nextCR
 >= 0 :

999 return 
strg
 [ 
lastCR
 + 1 : 
nextCR
 ]

1001 return 
strg
 [ 
lastCR
 + 1 : ] 
	}

1003 def 
	$_defaultStartDebugAction
 ( 
instring
 , 
loc
 , 
expr
 ) :

1004 
print
 ( ( "Match " + 
_ustr
 ( 
expr
 ) + " at loc " + 
_ustr
 ( 
loc
 ) + "(%d,%d)" % ( 
lineno
 ( 
loc
 , 
instring
 ) , 
col
 ( 
loc
 , 
instring
 ) ) ) ) 
	}

1006 def 
	$_defaultSuccessDebugAction
 ( 
instring
 , 
startloc
 , 
endloc
 , 
expr
 , 
toks
 ) :

1007 
print
 ( "Matched " + 
_ustr
 ( 
expr
 ) + " -> " + 
str
 ( 
toks
 . 
asList
 ( ) ) ) 
	}

1009 def 
	$_defaultExceptionDebugAction
 ( 
instring
 , 
loc
 , 
expr
 , 
exc
 ) :

1010 
print
 ( "Exception raised:" + 
_ustr
 ( 
exc
 ) ) 
	}

1012 def 
	$nullDebugAction
 ( * 
args
 ) :

1014 pass 
	}
 'decorator to trim function calls to match the arity of the target'

1039 def 
	$_trim_arity
 ( 
func
 , 
maxargs
 = 2 ) :

1040 if 
func
 in 
singleArgBuiltins
 :

1041 return lambda 
s
 , 
l
 , 
t
 : 
func
 ( 
t
 )

1042 
limit
 = [ 0 ]

1043 
foundArity
 = [ False ]

1046 if 
system_version
 [ : 2 ] >= ( 3 , 5 ) :

1047 def 
extract_stack
 ( 
limit
 = 0 ) :

1049 
offset
 = - 3 if 
system_version
 == ( 3 , 5 , 0 ) else - 2

1050 
frame_summary
 = 
traceback
 . 
extract_stack
 ( 
limit
 = - 
offset
 + 
limit
 - 1 ) [ 
offset
 ]

1051 return [ 
frame_summary
 [ : 2 ] ]

1052 def 
extract_tb
 ( 
tb
 , 
limit
 = 0 ) :

1053 
frames
 = 
traceback
 . 
extract_tb
 ( 
tb
 , 
limit
 = 
limit
 )

1054 
frame_summary
 = 
frames
 [ - 1 ]

1055 return [ 
frame_summary
 [ : 2 ] ]

1057 
extract_stack
 = 
traceback
 . 
extract_stack

1058 
extract_tb
 = 
traceback
 . 
extract_tb

1063 
LINE_DIFF
 = 6

1066 
this_line
 = 
extract_stack
 ( 
limit
 = 2 ) [ - 1 ]

1067 
pa_call_line_synth
 = ( 
this_line
 [ 0 ] , 
this_line
 [ 1 ] + 
LINE_DIFF
 )

1069 def 
wrapper
 ( * 
args
 ) :

1072 
ret
 = 
func
 ( * 
args
 [ 
limit
 [ 0 ] : ] )

1073 
foundArity
 [ 0 ] = True

1074 return 
ret

1075 except 
TypeError
 :

1077 if 
foundArity
 [ 0 ] :

1081 
tb
 = 
sys
 . 
exc_info
 ( ) [ - 1 ]

1082 if not 
extract_tb
 ( 
tb
 , 
limit
 = 2 ) [ - 1 ] [ : 2 ] == 
pa_call_line_synth
 :

1085 del 
tb

1087 if 
limit
 [ 0 ] <= 
maxargs
 :

1088 
limit
 [ 0 ] += 1

1093 
func_name
 = "<parse action>"

1095 
func_name
 = 
getattr
 ( 
func
 , '__name__' ,

1096 
getattr
 ( 
func
 , '__class__' ) . 
__name__
 )

1097 except 
Exception
 :

1098 
func_name
 = 
str
 ( 
func
 )

1099 
wrapper
 . 
__name__
 = 
func_name

1101 return 
wrapper
 
	}

1103 class 
	cParserElement
 ( 
object
 ) :

1105 
DEFAULT_WHITE_CHARS
 = " \n\t\r"

1106 
verbose_stacktrace
 = False

1108 @ 
	`staticmethod

1109 def 
	$setDefaultWhitespaceChars
 ( 
chars
 ) :

1121 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 = 
chars
 
	}

1123 @ 
	`staticmethod

1124 def 
	$inlineLiteralsUsing
 ( 
cls
 ) :

1142 
ParserElement
 . 
_literalStringClass
 = 
cls
 
	}

1144 def 
	$__init__
 ( 
self
 , 
savelist
 = False ) :

1145 
self
 . 
parseAction
 = 
list
 ( )

1146 
self
 . 
failAction
 = None

1148 
self
 . 
strRepr
 = None

1149 
self
 . 
resultsName
 = None

1150 
self
 . 
saveAsList
 = 
savelist

1151 
self
 . 
skipWhitespace
 = True

1152 
self
 . 
whiteChars
 = 
ParserElement
 . 
DEFAULT_WHITE_CHARS

1153 
self
 . 
copyDefaultWhiteChars
 = True

1154 
self
 . 
mayReturnEmpty
 = False

1155 
self
 . 
keepTabs
 = False

1156 
self
 . 
ignoreExprs
 = 
list
 ( )

1157 
self
 . 
debug
 = False

1158 
self
 . 
streamlined
 = False

1159 
self
 . 
mayIndexError
 = True

1160 
self
 . 
errmsg
 = ""

1161 
self
 . 
modalResults
 = True

1162 
self
 . 
debugActions
 = ( None , None , None )

1163 
self
 . 
re
 = None

1164 
self
 . 
callPreparse
 = True

1165 
self
 . 
callDuringTry
 = False 
	}

1167 def 
	$copy
 ( 
self
 ) :

1183 
cpy
 = 
copy
 . 
copy
 ( 
self
 )

1184 
cpy
 . 
parseAction
 = 
self
 . 
parseAction
 [ : ]

1185 
cpy
 . 
ignoreExprs
 = 
self
 . 
ignoreExprs
 [ : ]

1186 if 
self
 . 
copyDefaultWhiteChars
 :

1187 
cpy
 . 
whiteChars
 = 
ParserElement
 . 
DEFAULT_WHITE_CHARS

1188 return 
cpy
 
	}

1190 def 
	$setName
 ( 
self
 , 
name
 ) :

1198 
self
 . 
name
 = 
name

1199 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

1200 if 
hasattr
 ( 
self
 , "exception" ) :

1201 
self
 . 
exception
 . 
msg
 = 
self
 . 
errmsg

1202 return 
self
 
	}

1204 def 
	$setResultsName
 ( 
self
 , 
name
 , 
listAllMatches
 = False ) :

1224 
newself
 = 
self
 . 
copy
 ( )

1225 if 
name
 . 
endswith
 ( "*" ) :

1226 
name
 = 
name
 [ : - 1 ]

1227 
listAllMatches
 = True

1228 
newself
 . 
resultsName
 = 
name

1229 
newself
 . 
modalResults
 = not 
listAllMatches

1230 return 
newself
 
	}

1232 def 
	$setBreak
 ( 
self
 , 
breakFlag
 = True ) :

1237 if 
breakFlag
 :

1238 
_parseMethod
 = 
self
 . 
_parse

1239 def 
breaker
 ( 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1240 import 
	~pdb

1241 
pdb
 . 
set_trace
 ( )

1242 return 
_parseMethod
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 )

1243 
breaker
 . 
_originalParseMethod
 = 
_parseMethod

1244 
self
 . 
_parse
 = 
breaker

1246 if 
hasattr
 ( 
self
 . 
_parse
 , "_originalParseMethod" ) :

1247 
self
 . 
_parse
 = 
self
 . 
_parse
 . 
_originalParseMethod

1248 return 
self
 
	}

1250 def 
	$setParseAction
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1284 
self
 . 
parseAction
 = 
list
 ( 
map
 ( 
_trim_arity
 , 
list
 ( 
fns
 ) ) )

1285 
self
 . 
callDuringTry
 = 
kwargs
 . 
get
 ( "callDuringTry" , False )

1286 return 
self
 
	}

1288 def 
	$addParseAction
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1294 
self
 . 
parseAction
 += 
list
 ( 
map
 ( 
_trim_arity
 , 
list
 ( 
fns
 ) ) )

1295 
self
 . 
callDuringTry
 = 
self
 . 
callDuringTry
 or 
kwargs
 . 
get
 ( "callDuringTry" , False )

1296 return 
self
 
	}

1298 def 
	$addCondition
 ( 
self
 , * 
fns
 , ** 
kwargs
 ) :

1315 
msg
 = 
kwargs
 . 
get
 ( "message" , "failed user-defined condition" )

1316 
exc_type
 = 
ParseFatalException
 if 
kwargs
 . 
get
 ( "fatal" , False ) else 
ParseException

1317 for 
fn
 in 
fns
 :

1318 def 
pa
 ( 
s
 , 
l
 , 
t
 ) :

1319 if not 
bool
 ( 
_trim_arity
 ( 
fn
 ) ( 
s
 , 
l
 , 
t
 ) ) :

1320 raise 
exc_type
 ( 
s
 , 
l
 , 
msg
 )

1321 
self
 . 
parseAction
 . 
append
 ( 
pa
 )

1322 
self
 . 
callDuringTry
 = 
self
 . 
callDuringTry
 or 
kwargs
 . 
get
 ( "callDuringTry" , False )

1323 return 
self
 
	}

1325 def 
	$setFailAction
 ( 
self
 , 
fn
 ) :

1335 
self
 . 
failAction
 = 
fn

1336 return 
self
 
	}

1338 def 
	$_skipIgnorables
 ( 
self
 , 
instring
 , 
loc
 ) :

1339 
exprsFound
 = True

1340 while 
exprsFound
 :

1341 
exprsFound
 = False

1342 for 
e
 in 
self
 . 
ignoreExprs
 :

1345 
loc
 , 
dummy
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 )

1346 
exprsFound
 = True

1347 except 
ParseException
 :

1349 return 
loc
 
	}

1351 def 
	$preParse
 ( 
self
 , 
instring
 , 
loc
 ) :

1352 if 
self
 . 
ignoreExprs
 :

1353 
loc
 = 
self
 . 
_skipIgnorables
 ( 
instring
 , 
loc
 )

1355 if 
self
 . 
skipWhitespace
 :

1356 
wt
 = 
self
 . 
whiteChars

1357 
instrlen
 = 
len
 ( 
instring
 )

1358 while 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
wt
 :

1359 
loc
 += 1

1361 return 
loc
 
	}

1363 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

1364 return 
loc
 , [ ] 
	}

1366 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

1367 return 
tokenlist
 
	}

1370 def 
	$_parseNoCache
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1371 
debugging
 = ( 
self
 . 
debug
 )

1373 if 
debugging
 or 
self
 . 
failAction
 :

1375 if ( 
self
 . 
debugActions
 [ 0 ] ) :

1376 
self
 . 
debugActions
 [ 0 ] ( 
instring
 , 
loc
 , 
self
 )

1377 if 
callPreParse
 and 
self
 . 
callPreparse
 :

1378 
preloc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1380 
preloc
 = 
loc

1381 
tokensStart
 = 
preloc

1384 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1385 except 
IndexError
 :

1386 raise 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

1387 except 
ParseBaseException
 as 
err
 :

1389 if 
self
 . 
debugActions
 [ 2 ] :

1390 
self
 . 
debugActions
 [ 2 ] ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1391 if 
self
 . 
failAction
 :

1392 
self
 . 
failAction
 ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1395 if 
callPreParse
 and 
self
 . 
callPreparse
 :

1396 
preloc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1398 
preloc
 = 
loc

1399 
tokensStart
 = 
preloc

1400 if 
self
 . 
mayIndexError
 or 
preloc
 >= 
len
 ( 
instring
 ) :

1402 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1403 except 
IndexError
 :

1404 raise 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

1406 
loc
 , 
tokens
 = 
self
 . 
parseImpl
 ( 
instring
 , 
preloc
 , 
doActions
 )

1408 
tokens
 = 
self
 . 
postParse
 ( 
instring
 , 
loc
 , 
tokens
 )

1410 
retTokens
 = 
ParseResults
 ( 
tokens
 , 
self
 . 
resultsName
 , 
asList
 = 
self
 . 
saveAsList
 , 
modal
 = 
self
 . 
modalResults
 )

1411 if 
self
 . 
parseAction
 and ( 
doActions
 or 
self
 . 
callDuringTry
 ) :

1412 if 
debugging
 :

1414 for 
fn
 in 
self
 . 
parseAction
 :

1415 
tokens
 = 
fn
 ( 
instring
 , 
tokensStart
 , 
retTokens
 )

1416 if 
tokens
 is not None :

1417 
retTokens
 = 
ParseResults
 ( 
tokens
 ,

1418 
self
 . 
resultsName
 ,

1419 
asList
 = 
self
 . 
saveAsList
 and 
isinstance
 ( 
tokens
 , ( 
ParseResults
 , 
list
 ) ) ,

1420 
modal
 = 
self
 . 
modalResults
 )

1421 except 
ParseBaseException
 as 
err
 :

1423 if ( 
self
 . 
debugActions
 [ 2 ] ) :

1424 
self
 . 
debugActions
 [ 2 ] ( 
instring
 , 
tokensStart
 , 
self
 , 
err
 )

1427 for 
fn
 in 
self
 . 
parseAction
 :

1428 
tokens
 = 
fn
 ( 
instring
 , 
tokensStart
 , 
retTokens
 )

1429 if 
tokens
 is not None :

1430 
retTokens
 = 
ParseResults
 ( 
tokens
 ,

1431 
self
 . 
resultsName
 ,

1432 
asList
 = 
self
 . 
saveAsList
 and 
isinstance
 ( 
tokens
 , ( 
ParseResults
 , 
list
 ) ) ,

1433 
modal
 = 
self
 . 
modalResults
 )

1434 if 
debugging
 :

1436 if ( 
self
 . 
debugActions
 [ 1 ] ) :

1437 
self
 . 
debugActions
 [ 1 ] ( 
instring
 , 
tokensStart
 , 
loc
 , 
self
 , 
retTokens
 )

1439 return 
loc
 , 
retTokens
 
	}

1441 def 
	$tryParse
 ( 
self
 , 
instring
 , 
loc
 ) :

1443 return 
self
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 = False ) [ 0 ]

1444 except 
ParseFatalException
 :

1445 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

1447 def 
	$canParseNext
 ( 
self
 , 
instring
 , 
loc
 ) :

1449 
self
 . 
tryParse
 ( 
instring
 , 
loc
 )

1450 except ( 
ParseException
 , 
IndexError
 ) :

1453 return True 
	}

1455 class 
	c_UnboundedCache
 ( 
object
 ) :

1456 def 
	$__init__
 ( 
self
 ) :

1457 
cache
 = { }

1458 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1460 def 
get
 ( 
self
 , 
key
 ) :

1461 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1463 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1464 
cache
 [ 
key
 ] = 
value

1466 def 
clear
 ( 
self
 ) :

1467 
cache
 . 
clear
 ( )

1469 def 
cache_len
 ( 
self
 ) :

1470 return 
len
 ( 
cache
 )

1472 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1473 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1474 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1475 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1477 if 
_OrderedDict
 is not None :

1478 class 
	c_FifoCache
 ( 
object
 ) :

1479 def 
	$__init__
 ( 
self
 , 
size
 ) :

1480 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1482 
cache
 = 
_OrderedDict
 ( )

1484 def 
get
 ( 
self
 , 
key
 ) :

1485 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1487 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1488 
cache
 [ 
key
 ] = 
value

1489 while 
len
 ( 
cache
 ) > 
size
 :

1491 
cache
 . 
popitem
 ( False )

1492 except 
KeyError
 :

1495 def 
clear
 ( 
self
 ) :

1496 
cache
 . 
clear
 ( )

1498 def 
cache_len
 ( 
self
 ) :

1499 return 
len
 ( 
cache
 )

1501 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1502 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1503 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1504 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1507 class 
	c_FifoCache
 ( 
object
 ) :

1508 def 
	$__init__
 ( 
self
 , 
size
 ) :

1509 
self
 . 
not_in_cache
 = 
not_in_cache
 = 
object
 ( )

1511 
cache
 = { }

1512 
key_fifo
 = 
collections
 . 
deque
 ( [ ] , 
size
 )

1514 def 
get
 ( 
self
 , 
key
 ) :

1515 return 
cache
 . 
get
 ( 
key
 , 
not_in_cache
 )

1517 def 
set
 ( 
self
 , 
key
 , 
value
 ) :

1518 
cache
 [ 
key
 ] = 
value

1519 while 
len
 ( 
key_fifo
 ) > 
size
 :

1520 
cache
 . 
pop
 ( 
key_fifo
 . 
popleft
 ( ) , None )

1521 
key_fifo
 . 
append
 ( 
key
 )

1523 def 
clear
 ( 
self
 ) :

1524 
cache
 . 
clear
 ( )

1525 
key_fifo
 . 
clear
 ( )

1527 def 
cache_len
 ( 
self
 ) :

1528 return 
len
 ( 
cache
 )

1530 
self
 . 
get
 = 
types
 . 
MethodType
 ( 
get
 , 
self
 )

1531 
self
 . 
set
 = 
types
 . 
MethodType
 ( 
set
 , 
self
 )

1532 
self
 . 
clear
 = 
types
 . 
MethodType
 ( 
clear
 , 
self
 )

1533 
self
 . 
__len__
 = 
types
 . 
MethodType
 ( 
cache_len
 , 
self
 ) 
	}

1536 
packrat_cache
 = { }

1537 
packrat_cache_lock
 = 
RLock
 ( )

1538 
packrat_cache_stats
 = [ 0 , 0 ]

1542 def 
	$_parseCache
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True , 
callPreParse
 = True ) :

1543 
HIT
 , 
MISS
 = 0 , 1

1544 
lookup
 = ( 
self
 , 
instring
 , 
loc
 , 
callPreParse
 , 
doActions
 )

1545 with 
ParserElement
 . 
packrat_cache_lock
 :

1546 
cache
 = 
ParserElement
 . 
packrat_cache

1547 
value
 = 
cache
 . 
get
 ( 
lookup
 )

1548 if 
value
 is 
cache
 . 
not_in_cache
 :

1549 
ParserElement
 . 
packrat_cache_stats
 [ 
MISS
 ] += 1

1551 
value
 = 
self
 . 
_parseNoCache
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 )

1552 except 
ParseBaseException
 as 
pe
 :

1554 
cache
 . 
set
 ( 
lookup
 , 
pe
 . 
__class__
 ( * 
pe
 . 
args
 ) )

1557 
cache
 . 
set
 ( 
lookup
 , ( 
value
 [ 0 ] , 
value
 [ 1 ] . 
copy
 ( ) ) )

1558 return 
value

1560 
ParserElement
 . 
packrat_cache_stats
 [ 
HIT
 ] += 1

1561 if 
isinstance
 ( 
value
 , 
Exception
 ) :

1562 raise 
value

1563 return ( 
value
 [ 0 ] , 
value
 [ 1 ] . 
copy
 ( ) ) 
	}

1565 
_parse
 = 
_parseNoCache

1567 @ 
	`staticmethod

1568 def 
	$resetCache
 ( ) :

1569 
ParserElement
 . 
packrat_cache
 . 
clear
 ( )

1570 
ParserElement
 . 
packrat_cache_stats
 [ : ] = [ 0 ] * 
len
 ( 
ParserElement
 . 
packrat_cache_stats
 ) 
	}

1572 
_packratEnabled
 = False

1573 @ 
	`staticmethod

1574 def 
	$enablePackrat
 ( 
cache_size_limit
 = 128 ) :

1600 if not 
ParserElement
 . 
_packratEnabled
 :

1601 
ParserElement
 . 
_packratEnabled
 = True

1602 if 
cache_size_limit
 is None :

1603 
ParserElement
 . 
packrat_cache
 = 
ParserElement
 . 
_UnboundedCache
 ( )

1605 
ParserElement
 . 
packrat_cache
 = 
ParserElement
 . 
_FifoCache
 ( 
cache_size_limit
 )

1606 
ParserElement
 . 
_parse
 = 
ParserElement
 . 
_parseCache
 
	}

1608 def 
	$parseString
 ( 
self
 , 
instring
 , 
parseAll
 = False ) :

1635 
ParserElement
 . 
resetCache
 ( )

1636 if not 
self
 . 
streamlined
 :

1637 
self
 . 
streamline
 ( )

1639 for 
e
 in 
self
 . 
ignoreExprs
 :

1640 
e
 . 
streamline
 ( )

1641 if not 
self
 . 
keepTabs
 :

1642 
instring
 = 
instring
 . 
expandtabs
 ( )

1644 
loc
 , 
tokens
 = 
self
 . 
_parse
 ( 
instring
 , 0 )

1645 if 
parseAll
 :

1646 
loc
 = 
self
 . 
preParse
 ( 
instring
 , 
loc
 )

1647 
se
 = 
Empty
 ( ) + 
StringEnd
 ( )

1648 
se
 . 
_parse
 ( 
instring
 , 
loc
 )

1649 except 
ParseBaseException
 as 
exc
 :

1650 if 
ParserElement
 . 
verbose_stacktrace
 :

1654 raise 
exc

1656 return 
tokens
 
	}

1658 def 
	$scanString
 ( 
self
 , 
instring
 , 
maxMatches
 = 
_MAX_INT
 , 
overlap
 = False ) :

1688 if not 
self
 . 
streamlined
 :

1689 
self
 . 
streamline
 ( )

1690 for 
e
 in 
self
 . 
ignoreExprs
 :

1691 
e
 . 
streamline
 ( )

1693 if not 
self
 . 
keepTabs
 :

1694 
instring
 = 
_ustr
 ( 
instring
 ) . 
expandtabs
 ( )

1695 
instrlen
 = 
len
 ( 
instring
 )

1696 
loc
 = 0

1697 
preparseFn
 = 
self
 . 
preParse

1698 
parseFn
 = 
self
 . 
_parse

1699 
ParserElement
 . 
resetCache
 ( )

1700 
matches
 = 0

1702 while 
loc
 <= 
instrlen
 and 
matches
 < 
maxMatches
 :

1704 
preloc
 = 
preparseFn
 ( 
instring
 , 
loc
 )

1705 
nextLoc
 , 
tokens
 = 
parseFn
 ( 
instring
 , 
preloc
 , 
callPreParse
 = False )

1706 except 
ParseException
 :

1707 
loc
 = 
preloc
 + 1

1709 if 
nextLoc
 > 
loc
 :

1710 
matches
 += 1

1711 yield 
tokens
 , 
preloc
 , 
nextLoc

1712 if 
overlap
 :

1713 
nextloc
 = 
preparseFn
 ( 
instring
 , 
loc
 )

1714 if 
nextloc
 > 
loc
 :

1715 
loc
 = 
nextLoc

1717 
loc
 += 1

1719 
loc
 = 
nextLoc

1721 
loc
 = 
preloc
 + 1

1722 except 
ParseBaseException
 as 
exc
 :

1723 if 
ParserElement
 . 
verbose_stacktrace
 :

1727 raise 
exc
 
	}

1729 def 
	$transformString
 ( 
self
 , 
instring
 ) :

1746 
out
 = [ ]

1747 
lastE
 = 0

1750 
self
 . 
keepTabs
 = True

1752 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 ) :

1753 
out
 . 
append
 ( 
instring
 [ 
lastE
 : 
s
 ] )

1754 if 
t
 :

1755 if 
isinstance
 ( 
t
 , 
ParseResults
 ) :

1756 
out
 += 
t
 . 
asList
 ( )

1757 elif 
isinstance
 ( 
t
 , 
list
 ) :

1758 
out
 += 
t

1760 
out
 . 
append
 ( 
t
 )

1761 
lastE
 = 
e

1762 
out
 . 
append
 ( 
instring
 [ 
lastE
 : ] )

1763 
out
 = [ 
o
 for 
o
 in 
out
 if 
o
 ]

1764 return "" . 
join
 ( 
map
 ( 
_ustr
 , 
_flatten
 ( 
out
 ) ) )

1765 except 
ParseBaseException
 as 
exc
 :

1766 if 
ParserElement
 . 
verbose_stacktrace
 :

1770 raise 
exc
 
	}

1772 def 
	$searchString
 ( 
self
 , 
instring
 , 
maxMatches
 = 
_MAX_INT
 ) :

1791 return 
ParseResults
 ( [ 
t
 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 , 
maxMatches
 ) ] )

1792 except 
ParseBaseException
 as 
exc
 :

1793 if 
ParserElement
 . 
verbose_stacktrace
 :

1797 raise 
exc
 
	}

1799 def 
	$split
 ( 
self
 , 
instring
 , 
maxsplit
 = 
_MAX_INT
 , 
includeSeparators
 = False ) :

1812 
splits
 = 0

1813 
last
 = 0

1814 for 
t
 , 
s
 , 
e
 in 
self
 . 
scanString
 ( 
instring
 , 
maxMatches
 = 
maxsplit
 ) :

1815 yield 
instring
 [ 
last
 : 
s
 ]

1816 if 
includeSeparators
 :

1817 yield 
t
 [ 0 ]

1818 
last
 = 
e

1819 yield 
instring
 [ 
last
 : ] 
	}

1821 def 
	$__add__
 ( 
self
 , 
other
 ) :

1833 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1834 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1835 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1836 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1837 
SyntaxWarning
 , 
stacklevel
 = 2 )

1839 return 
And
 ( [ 
self
 , 
other
 ] ) 
	}

1841 def 
	$__radd__
 ( 
self
 , 
other
 ) :

1845 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1846 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1847 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1848 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1849 
SyntaxWarning
 , 
stacklevel
 = 2 )

1851 return 
other
 + 
self
 
	}

1853 def 
	$__sub__
 ( 
self
 , 
other
 ) :

1857 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1858 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1859 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1860 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1861 
SyntaxWarning
 , 
stacklevel
 = 2 )

1863 return 
self
 + 
And
 . 
_ErrorStop
 ( ) + 
other
 
	}

1865 def 
	$__rsub__
 ( 
self
 , 
other
 ) :

1869 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1870 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1871 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1872 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1873 
SyntaxWarning
 , 
stacklevel
 = 2 )

1875 return 
other
 - 
self
 
	}

1877 def 
	$__mul__
 ( 
self
 , 
other
 ) :

1897 if 
isinstance
 ( 
other
 , 
int
 ) :

1898 
minElements
 , 
optElements
 = 
other
 , 0

1899 elif 
isinstance
 ( 
other
 , 
tuple
 ) :

1900 
other
 = ( 
other
 + ( None , None ) ) [ : 2 ]

1901 if 
other
 [ 0 ] is None :

1902 
other
 = ( 0 , 
other
 [ 1 ] )

1903 if 
isinstance
 ( 
other
 [ 0 ] , 
int
 ) and 
other
 [ 1 ] is None :

1904 if 
other
 [ 0 ] == 0 :

1905 return 
ZeroOrMore
 ( 
self
 )

1906 if 
other
 [ 0 ] == 1 :

1907 return 
OneOrMore
 ( 
self
 )

1909 return 
self
 * 
other
 [ 0 ] + 
ZeroOrMore
 ( 
self
 )

1910 elif 
isinstance
 ( 
other
 [ 0 ] , 
int
 ) and 
isinstance
 ( 
other
 [ 1 ] , 
int
 ) :

1911 
minElements
 , 
optElements
 = 
other

1912 
optElements
 -= 
minElements

1914 raise 
TypeError
 ( "cannot multiply 'ParserElement' and ('%s','%s') objects" , 
type
 ( 
other
 [ 0 ] ) , 
type
 ( 
other
 [ 1 ] ) )

1916 raise 
TypeError
 ( "cannot multiply 'ParserElement' and '%s' objects" , 
type
 ( 
other
 ) )

1918 if 
minElements
 < 0 :

1919 raise 
ValueError
 ( "cannot multiply ParserElement by negative value" )

1920 if 
optElements
 < 0 :

1921 raise 
ValueError
 ( "second tuple value must be greater or equal to first tuple value" )

1922 if 
minElements
 == 
optElements
 == 0 :

1923 raise 
ValueError
 ( "cannot multiply ParserElement by 0 or (0,0)" )

1925 if ( 
optElements
 ) :

1926 def 
makeOptionalList
 ( 
n
 ) :

1927 if 
n
 > 1 :

1928 return 
Optional
 ( 
self
 + 
makeOptionalList
 ( 
n
 - 1 ) )

1930 return 
Optional
 ( 
self
 )

1931 if 
minElements
 :

1932 if 
minElements
 == 1 :

1933 
ret
 = 
self
 + 
makeOptionalList
 ( 
optElements
 )

1935 
ret
 = 
And
 ( [ 
self
 ] * 
minElements
 ) + 
makeOptionalList
 ( 
optElements
 )

1937 
ret
 = 
makeOptionalList
 ( 
optElements
 )

1939 if 
minElements
 == 1 :

1940 
ret
 = 
self

1942 
ret
 = 
And
 ( [ 
self
 ] * 
minElements
 )

1943 return 
ret
 
	}

1945 def 
	$__rmul__
 ( 
self
 , 
other
 ) :

1946 return 
self
 . 
__mul__
 ( 
other
 ) 
	}

1948 def 
	$__or__
 ( 
self
 , 
other
 ) :

1952 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1953 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1954 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1955 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1956 
SyntaxWarning
 , 
stacklevel
 = 2 )

1958 return 
MatchFirst
 ( [ 
self
 , 
other
 ] ) 
	}

1960 def 
	$__ror__
 ( 
self
 , 
other
 ) :

1964 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1965 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1966 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1967 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1968 
SyntaxWarning
 , 
stacklevel
 = 2 )

1970 return 
other
 | 
self
 
	}

1972 def 
	$__xor__
 ( 
self
 , 
other
 ) :

1976 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1977 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1978 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1979 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1980 
SyntaxWarning
 , 
stacklevel
 = 2 )

1982 return 
Or
 ( [ 
self
 , 
other
 ] ) 
	}

1984 def 
	$__rxor__
 ( 
self
 , 
other
 ) :

1988 if 
isinstance
 ( 
other
 , 
basestring
 ) :

1989 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

1990 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

1991 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

1992 
SyntaxWarning
 , 
stacklevel
 = 2 )

1994 return 
other
 ^ 
self
 
	}

1996 def 
	$__and__
 ( 
self
 , 
other
 ) :

2000 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2001 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

2002 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2003 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

2004 
SyntaxWarning
 , 
stacklevel
 = 2 )

2006 return 
Each
 ( [ 
self
 , 
other
 ] ) 
	}

2008 def 
	$__rand__
 ( 
self
 , 
other
 ) :

2012 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2013 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

2014 if not 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2015 
warnings
 . 
warn
 ( "Cannot combine element of type %s with ParserElement" % 
type
 ( 
other
 ) ,

2016 
SyntaxWarning
 , 
stacklevel
 = 2 )

2018 return 
other
 & 
self
 
	}

2020 def 
	$__invert__
 ( 
self
 ) :

2024 return 
NotAny
 ( 
self
 ) 
	}

2026 def 
	$__call__
 ( 
self
 , 
name
 = None ) :

2040 if 
name
 is not None :

2041 return 
self
 . 
setResultsName
 ( 
name
 )

2043 return 
self
 . 
copy
 ( ) 
	}

2045 def 
	$suppress
 ( 
self
 ) :

2050 return 
Suppress
 ( 
self
 ) 
	}

2052 def 
	$leaveWhitespace
 ( 
self
 ) :

2058 
self
 . 
skipWhitespace
 = False

2059 return 
self
 
	}

2061 def 
	$setWhitespaceChars
 ( 
self
 , 
chars
 ) :

2065 
self
 . 
skipWhitespace
 = True

2066 
self
 . 
whiteChars
 = 
chars

2067 
self
 . 
copyDefaultWhiteChars
 = False

2068 return 
self
 
	}

2070 def 
	$parseWithTabs
 ( 
self
 ) :

2076 
self
 . 
keepTabs
 = True

2077 return 
self
 
	}

2079 def 
	$ignore
 ( 
self
 , 
other
 ) :

2092 if 
isinstance
 ( 
other
 , 
basestring
 ) :

2093 
other
 = 
Suppress
 ( 
other
 )

2095 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

2096 if 
other
 not in 
self
 . 
ignoreExprs
 :

2097 
self
 . 
ignoreExprs
 . 
append
 ( 
other
 )

2099 
self
 . 
ignoreExprs
 . 
append
 ( 
Suppress
 ( 
other
 . 
copy
 ( ) ) )

2100 return 
self
 
	}

2102 def 
	$setDebugActions
 ( 
self
 , 
startAction
 , 
successAction
 , 
exceptionAction
 ) :

2106 
self
 . 
debugActions
 = ( 
startAction
 or 
_defaultStartDebugAction
 ,

2107 
successAction
 or 
_defaultSuccessDebugAction
 ,

2108 
exceptionAction
 or 
_defaultExceptionDebugAction
 )

2109 
self
 . 
debug
 = True

2110 return 
self
 
	}

2112 def 
	$setDebug
 ( 
self
 , 
flag
 = True ) :

2147 if 
flag
 :

2148 
self
 . 
setDebugActions
 ( 
_defaultStartDebugAction
 , 
_defaultSuccessDebugAction
 , 
_defaultExceptionDebugAction
 )

2150 
self
 . 
debug
 = False

2151 return 
self
 
	}

2153 def 
	$__str__
 ( 
self
 ) :

2154 return 
self
 . 
name
 
	}

2156 def 
	$__repr__
 ( 
self
 ) :

2157 return 
_ustr
 ( 
self
 ) 
	}

2159 def 
	$streamline
 ( 
self
 ) :

2160 
self
 . 
streamlined
 = True

2161 
self
 . 
strRepr
 = None

2162 return 
self
 
	}

2164 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

2165 pass 
	}

2167 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

2171 
self
 . 
checkRecursion
 ( [ ] ) 
	}

2173 def 
	$parseFile
 ( 
self
 , 
file_or_filename
 , 
parseAll
 = False ) :

2180 
file_contents
 = 
file_or_filename
 . 
read
 ( )

2181 except 
AttributeError
 :

2182 with 
open
 ( 
file_or_filename
 , "r" ) as 
f
 :

2183 
file_contents
 = 
f
 . 
read
 ( )

2185 return 
self
 . 
parseString
 ( 
file_contents
 , 
parseAll
 )

2186 except 
ParseBaseException
 as 
exc
 :

2187 if 
ParserElement
 . 
verbose_stacktrace
 :

2191 raise 
exc
 
	}

2193 def 
	$__eq__
 ( 
self
 , 
other
 ) :

2194 if 
isinstance
 ( 
other
 , 
ParserElement
 ) :

2195 return 
self
 is 
other
 or 
vars
 ( 
self
 ) == 
vars
 ( 
other
 )

2196 elif 
isinstance
 ( 
other
 , 
basestring
 ) :

2197 return 
self
 . 
matches
 ( 
other
 )

2199 return 
super
 ( 
ParserElement
 , 
self
 ) == 
other
 
	}

2201 def 
	$__ne__
 ( 
self
 , 
other
 ) :

2202 return not ( 
self
 == 
other
 ) 
	}

2204 def 
	$__hash__
 ( 
self
 ) :

2205 return 
hash
 ( 
id
 ( 
self
 ) ) 
	}

2207 def 
	$__req__
 ( 
self
 , 
other
 ) :

2208 return 
self
 == 
other
 
	}

2210 def 
	$__rne__
 ( 
self
 , 
other
 ) :

2211 return not ( 
self
 == 
other
 ) 
	}

2213 def 
	$matches
 ( 
self
 , 
testString
 , 
parseAll
 = True ) :

2227 
self
 . 
parseString
 ( 
_ustr
 ( 
testString
 ) , 
parseAll
 = 
parseAll
 )

2229 except 
ParseBaseException
 :

2230 return False 
	}

2232 def 
	$runTests
 ( 
self
 , 
tests
 , 
parseAll
 = True , 
comment
 = '#' , 
fullDump
 = True , 
printResults
 = True , 
failureTests
 = False ) :

2319 if 
isinstance
 ( 
tests
 , 
basestring
 ) :

2320 
tests
 = 
list
 ( 
map
 ( 
str
 . 
strip
 , 
tests
 . 
rstrip
 ( ) . 
splitlines
 ( ) ) )

2321 if 
isinstance
 ( 
comment
 , 
basestring
 ) :

2322 
comment
 = 
Literal
 ( 
comment
 )

2323 
allResults
 = [ ]

2324 
comments
 = [ ]

2325 
success
 = True

2326 for 
t
 in 
tests
 :

2327 if 
comment
 is not None and 
comment
 . 
matches
 ( 
t
 , False ) or 
comments
 and not 
t
 :

2328 
comments
 . 
append
 ( 
t
 )

2330 if not 
t
 :

2332 
out
 = [ '\n' . 
join
 ( 
comments
 ) , 
t
 ]

2333 
comments
 = [ ]

2335 
t
 = 
t
 . 
replace
 ( r'\n' , '\n' )

2336 
result
 = 
self
 . 
parseString
 ( 
t
 , 
parseAll
 = 
parseAll
 )

2337 
out
 . 
append
 ( 
result
 . 
dump
 ( 
full
 = 
fullDump
 ) )

2338 
success
 = 
success
 and not 
failureTests

2339 except 
ParseBaseException
 as 
pe
 :

2340 
fatal
 = "(FATAL)" if 
isinstance
 ( 
pe
 , 
ParseFatalException
 ) else ""

2341 if '\n' in 
t
 :

2342 
out
 . 
append
 ( 
line
 ( 
pe
 . 
loc
 , 
t
 ) )

2343 
out
 . 
append
 ( ' ' * ( 
col
 ( 
pe
 . 
loc
 , 
t
 ) - 1 ) + '^' + 
fatal
 )

2345 
out
 . 
append
 ( ' ' * 
pe
 . 
loc
 + '^' + 
fatal
 )

2346 
out
 . 
append
 ( "FAIL: " + 
str
 ( 
pe
 ) )

2347 
success
 = 
success
 and 
failureTests

2348 
result
 = 
pe

2349 except 
Exception
 as 
exc
 :

2350 
out
 . 
append
 ( "FAIL-EXCEPTION: " + 
str
 ( 
exc
 ) )

2351 
success
 = 
success
 and 
failureTests

2352 
result
 = 
exc

2354 if 
printResults
 :

2355 if 
fullDump
 :

2356 
out
 . 
append
 ( '' )

2357 
print
 ( '\n' . 
join
 ( 
out
 ) )

2359 
allResults
 . 
append
 ( ( 
t
 , 
result
 ) )

2361 return 
success
 , 
allResults
 
	}

2364 class 
	cToken
 ( 
ParserElement
 ) :

2368 def 
	$__init__
 ( 
self
 ) :

2369 
super
 ( 
Token
 , 
self
 ) . 
__init__
 ( 
savelist
 = False ) 
	}

2372 class 
	cEmpty
 ( 
Token
 ) :

2376 def 
	$__init__
 ( 
self
 ) :

2377 
super
 ( 
Empty
 , 
self
 ) . 
__init__
 ( )

2378 
self
 . 
name
 = "Empty"

2379 
self
 . 
mayReturnEmpty
 = True

2380 
self
 . 
mayIndexError
 = False 
	}

2383 class 
	cNoMatch
 ( 
Token
 ) :

2387 def 
	$__init__
 ( 
self
 ) :

2388 
super
 ( 
NoMatch
 , 
self
 ) . 
__init__
 ( )

2389 
self
 . 
name
 = "NoMatch"

2390 
self
 . 
mayReturnEmpty
 = True

2391 
self
 . 
mayIndexError
 = False

2392 
self
 . 
errmsg
 = "Unmatchable token" 
	}

2394 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2395 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2398 class 
	cLiteral
 ( 
Token
 ) :

2412 def 
	$__init__
 ( 
self
 , 
matchString
 ) :

2413 
super
 ( 
Literal
 , 
self
 ) . 
__init__
 ( )

2414 
self
 . 
match
 = 
matchString

2415 
self
 . 
matchLen
 = 
len
 ( 
matchString
 )

2417 
self
 . 
firstMatchChar
 = 
matchString
 [ 0 ]

2418 except 
IndexError
 :

2419 
warnings
 . 
warn
 ( "null string passed to Literal; use Empty() instead" ,

2420 
SyntaxWarning
 , 
stacklevel
 = 2 )

2421 
self
 . 
__class__
 = 
Empty

2422 
self
 . 
name
 = '"%s"' % 
_ustr
 ( 
self
 . 
match
 )

2423 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2424 
self
 . 
mayReturnEmpty
 = False

2425 
self
 . 
mayIndexError
 = False 
	}

2431 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2432 if ( 
instring
 [ 
loc
 ] == 
self
 . 
firstMatchChar
 and

2433 ( 
self
 . 
matchLen
 == 1 or 
instring
 . 
startswith
 ( 
self
 . 
match
 , 
loc
 ) ) ) :

2434 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2435 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2436 
_L
 = 
Literal

2437 
ParserElement
 . 
_literalStringClass
 = 
Literal

2439 class 
	cKeyword
 ( 
Token
 ) :

2456 
DEFAULT_KEYWORD_CHARS
 = 
alphanums
 + "_$"

2458 def 
	$__init__
 ( 
self
 , 
matchString
 , 
identChars
 = None , 
caseless
 = False ) :

2459 
super
 ( 
Keyword
 , 
self
 ) . 
__init__
 ( )

2460 if 
identChars
 is None :

2461 
identChars
 = 
Keyword
 . 
DEFAULT_KEYWORD_CHARS

2462 
self
 . 
match
 = 
matchString

2463 
self
 . 
matchLen
 = 
len
 ( 
matchString
 )

2465 
self
 . 
firstMatchChar
 = 
matchString
 [ 0 ]

2466 except 
IndexError
 :

2467 
warnings
 . 
warn
 ( "null string passed to Keyword; use Empty() instead" ,

2468 
SyntaxWarning
 , 
stacklevel
 = 2 )

2469 
self
 . 
name
 = '"%s"' % 
self
 . 
match

2470 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2471 
self
 . 
mayReturnEmpty
 = False

2472 
self
 . 
mayIndexError
 = False

2473 
self
 . 
caseless
 = 
caseless

2474 if 
caseless
 :

2475 
self
 . 
caselessmatch
 = 
matchString
 . 
upper
 ( )

2476 
identChars
 = 
identChars
 . 
upper
 ( )

2477 
self
 . 
identChars
 = 
set
 ( 
identChars
 ) 
	}

2479 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2480 if 
self
 . 
caseless
 :

2481 if ( ( 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
caselessmatch
 ) and

2482 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) and

2483 ( 
loc
 == 0 or 
instring
 [ 
loc
 - 1 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) ) :

2484 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2486 if ( 
instring
 [ 
loc
 ] == 
self
 . 
firstMatchChar
 and

2487 ( 
self
 . 
matchLen
 == 1 or 
instring
 . 
startswith
 ( 
self
 . 
match
 , 
loc
 ) ) and

2488 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] not in 
self
 . 
identChars
 ) and

2489 ( 
loc
 == 0 or 
instring
 [ 
loc
 - 1 ] not in 
self
 . 
identChars
 ) ) :

2490 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2491 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2493 def 
	$copy
 ( 
self
 ) :

2494 
c
 = 
super
 ( 
Keyword
 , 
self
 ) . 
copy
 ( )

2495 
c
 . 
identChars
 = 
Keyword
 . 
DEFAULT_KEYWORD_CHARS

2496 return 
c
 
	}

2498 @ 
	`staticmethod

2499 def 
	$setDefaultKeywordChars
 ( 
chars
 ) :

2502 
Keyword
 . 
DEFAULT_KEYWORD_CHARS
 = 
chars
 
	}

2504 class 
	cCaselessLiteral
 ( 
Literal
 ) :

2515 def 
	$__init__
 ( 
self
 , 
matchString
 ) :

2516 
super
 ( 
CaselessLiteral
 , 
self
 ) . 
__init__
 ( 
matchString
 . 
upper
 ( ) )

2518 
self
 . 
returnString
 = 
matchString

2519 
self
 . 
name
 = "'%s'" % 
self
 . 
returnString

2520 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name
 
	}

2522 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2523 if 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
match
 :

2524 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
returnString

2525 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2527 class 
	cCaselessKeyword
 ( 
Keyword
 ) :

2536 def 
	$__init__
 ( 
self
 , 
matchString
 , 
identChars
 = None ) :

2537 
super
 ( 
CaselessKeyword
 , 
self
 ) . 
__init__
 ( 
matchString
 , 
identChars
 , 
caseless
 = True ) 
	}

2539 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2540 if ( ( 
instring
 [ 
loc
 : 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) == 
self
 . 
caselessmatch
 ) and

2541 ( 
loc
 >= 
len
 ( 
instring
 ) - 
self
 . 
matchLen
 or 
instring
 [ 
loc
 + 
self
 . 
matchLen
 ] . 
upper
 ( ) not in 
self
 . 
identChars
 ) ) :

2542 return 
loc
 + 
self
 . 
matchLen
 , 
self
 . 
match

2543 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2545 class 
	cCloseMatch
 ( 
Token
 ) :

2570 def 
	$__init__
 ( 
self
 , 
match_string
 , 
maxMismatches
 = 1 ) :

2571 
super
 ( 
CloseMatch
 , 
self
 ) . 
__init__
 ( )

2572 
self
 . 
name
 = 
match_string

2573 
self
 . 
match_string
 = 
match_string

2574 
self
 . 
maxMismatches
 = 
maxMismatches

2575 
self
 . 
errmsg
 = "Expected %r (with up to %d mismatches)" % ( 
self
 . 
match_string
 , 
self
 . 
maxMismatches
 )

2576 
self
 . 
mayIndexError
 = False

2577 
self
 . 
mayReturnEmpty
 = False 
	}

2579 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2580 
start
 = 
loc

2581 
instrlen
 = 
len
 ( 
instring
 )

2582 
maxloc
 = 
start
 + 
len
 ( 
self
 . 
match_string
 )

2584 if 
maxloc
 <= 
instrlen
 :

2585 
match_string
 = 
self
 . 
match_string

2586 
match_stringloc
 = 0

2587 
mismatches
 = [ ]

2588 
maxMismatches
 = 
self
 . 
maxMismatches

2590 for 
match_stringloc
 , 
s_m
 in 
enumerate
 ( 
zip
 ( 
instring
 [ 
loc
 : 
maxloc
 ] , 
self
 . 
match_string
 ) ) :

2591 
src
 , 
mat
 = 
s_m

2592 if 
src
 != 
mat
 :

2593 
mismatches
 . 
append
 ( 
match_stringloc
 )

2594 if 
len
 ( 
mismatches
 ) > 
maxMismatches
 :

2597 
loc
 = 
match_stringloc
 + 1

2598 
results
 = 
ParseResults
 ( [ 
instring
 [ 
start
 : 
loc
 ] ] )

2599 
results
 [ 'original' ] = 
self
 . 
match_string

2600 
results
 [ 'mismatches' ] = 
mismatches

2601 return 
loc
 , 
results

2603 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

2606 class 
	cWord
 ( 
Token
 ) :

2653 def 
	$__init__
 ( 
self
 , 
initChars
 , 
bodyChars
 = None , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 , 
asKeyword
 = False , 
excludeChars
 = None ) :

2654 
super
 ( 
Word
 , 
self
 ) . 
__init__
 ( )

2655 if 
excludeChars
 :

2656 
initChars
 = '' . 
join
 ( 
c
 for 
c
 in 
initChars
 if 
c
 not in 
excludeChars
 )

2657 if 
bodyChars
 :

2658 
bodyChars
 = '' . 
join
 ( 
c
 for 
c
 in 
bodyChars
 if 
c
 not in 
excludeChars
 )

2659 
self
 . 
initCharsOrig
 = 
initChars

2660 
self
 . 
initChars
 = 
set
 ( 
initChars
 )

2661 if 
bodyChars
 :

2662 
self
 . 
bodyCharsOrig
 = 
bodyChars

2663 
self
 . 
bodyChars
 = 
set
 ( 
bodyChars
 )

2665 
self
 . 
bodyCharsOrig
 = 
initChars

2666 
self
 . 
bodyChars
 = 
set
 ( 
initChars
 )

2668 
self
 . 
maxSpecified
 = 
max
 > 0

2670 if 
min
 < 1 :

2671 raise 
ValueError
 ( "cannot specify a minimum length < 1; use Optional(Word()) if zero-length word is permitted" )

2673 
self
 . 
minLen
 = 
min

2675 if 
max
 > 0 :

2676 
self
 . 
maxLen
 = 
max

2678 
self
 . 
maxLen
 = 
_MAX_INT

2680 if 
exact
 > 0 :

2681 
self
 . 
maxLen
 = 
exact

2682 
self
 . 
minLen
 = 
exact

2684 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2685 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2686 
self
 . 
mayIndexError
 = False

2687 
self
 . 
asKeyword
 = 
asKeyword

2689 if ' ' not in 
self
 . 
initCharsOrig
 + 
self
 . 
bodyCharsOrig
 and ( 
min
 == 1 and 
max
 == 0 and 
exact
 == 0 ) :

2690 if 
self
 . 
bodyCharsOrig
 == 
self
 . 
initCharsOrig
 :

2691 
self
 . 
reString
 = "[%s]+" % 
_escapeRegexRangeChars
 ( 
self
 . 
initCharsOrig
 )

2692 elif 
len
 ( 
self
 . 
initCharsOrig
 ) == 1 :

2693 
self
 . 
reString
 = "%s[%s]*" %

2694 ( 
re
 . 
escape
 ( 
self
 . 
initCharsOrig
 ) ,

2695 
_escapeRegexRangeChars
 ( 
self
 . 
bodyCharsOrig
 ) , )

2697 
self
 . 
reString
 = "[%s][%s]*" %

2698 ( 
_escapeRegexRangeChars
 ( 
self
 . 
initCharsOrig
 ) ,

2699 
_escapeRegexRangeChars
 ( 
self
 . 
bodyCharsOrig
 ) , )

2700 if 
self
 . 
asKeyword
 :

2701 
self
 . 
reString
 = r"\b" + 
self
 . 
reString
 + r"\b"

2703 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
reString
 )

2704 except 
Exception
 :

2705 
self
 . 
re
 = None 
	}

2707 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2708 if 
self
 . 
re
 :

2709 
result
 = 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 )

2710 if not 
result
 :

2711 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2713 
loc
 = 
result
 . 
end
 ( )

2714 return 
loc
 , 
result
 . 
group
 ( )

2716 if not ( 
instring
 [ 
loc
 ] in 
self
 . 
initChars
 ) :

2717 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2719 
start
 = 
loc

2720 
loc
 += 1

2721 
instrlen
 = 
len
 ( 
instring
 )

2722 
bodychars
 = 
self
 . 
bodyChars

2723 
maxloc
 = 
start
 + 
self
 . 
maxLen

2724 
maxloc
 = 
min
 ( 
maxloc
 , 
instrlen
 )

2725 while 
loc
 < 
maxloc
 and 
instring
 [ 
loc
 ] in 
bodychars
 :

2726 
loc
 += 1

2728 
throwException
 = False

2729 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

2730 
throwException
 = True

2731 if 
self
 . 
maxSpecified
 and 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
bodychars
 :

2732 
throwException
 = True

2733 if 
self
 . 
asKeyword
 :

2734 if ( 
start
 > 0 and 
instring
 [ 
start
 - 1 ] in 
bodychars
 ) or ( 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] in 
bodychars
 ) :

2735 
throwException
 = True

2737 if 
throwException
 :

2738 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2740 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

2742 def 
	$__str__
 ( 
self
 ) :

2744 return 
super
 ( 
Word
 , 
self
 ) . 
__str__
 ( )

2745 except 
Exception
 :

2749 if 
self
 . 
strRepr
 is None :

2751 def 
charsAsStr
 ( 
s
 ) :

2752 if 
len
 ( 
s
 ) > 4 :

2753 return 
s
 [ : 4 ] + "..."

2755 return 
s

2757 if ( 
self
 . 
initCharsOrig
 != 
self
 . 
bodyCharsOrig
 ) :

2758 
self
 . 
strRepr
 = "W:(%s,%s)" % ( 
charsAsStr
 ( 
self
 . 
initCharsOrig
 ) , 
charsAsStr
 ( 
self
 . 
bodyCharsOrig
 ) )

2760 
self
 . 
strRepr
 = "W:(%s)" % 
charsAsStr
 ( 
self
 . 
initCharsOrig
 )

2762 return 
self
 . 
strRepr
 
	}

2765 class 
	cRegex
 ( 
Token
 ) :

2778 
compiledREtype
 = 
type
 ( 
re
 . 
compile
 ( "[A-Z]" ) )

2779 def 
	$__init__
 ( 
self
 , 
pattern
 , 
flags
 = 0 ) :

2781 
super
 ( 
Regex
 , 
self
 ) . 
__init__
 ( )

2783 if 
isinstance
 ( 
pattern
 , 
basestring
 ) :

2784 if not 
pattern
 :

2785 
warnings
 . 
warn
 ( "null string passed to Regex; use Empty() instead" ,

2786 
SyntaxWarning
 , 
stacklevel
 = 2 )

2788 
self
 . 
pattern
 = 
pattern

2789 
self
 . 
flags
 = 
flags

2792 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
pattern
 , 
self
 . 
flags
 )

2793 
self
 . 
reString
 = 
self
 . 
pattern

2794 except 
sre_constants
 . 
error
 :

2795 
warnings
 . 
warn
 ( "invalid pattern (%s) passed to Regex" % 
pattern
 ,

2796 
SyntaxWarning
 , 
stacklevel
 = 2 )

2799 elif 
isinstance
 ( 
pattern
 , 
Regex
 . 
compiledREtype
 ) :

2800 
self
 . 
re
 = 
pattern

2801 
self
 . 
pattern
 =

2802 
self
 . 
reString
 = 
str
 ( 
pattern
 )

2803 
self
 . 
flags
 = 
flags

2806 raise 
ValueError
 ( "Regex may only be constructed with a string or a compiled RE object" )

2808 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2809 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2810 
self
 . 
mayIndexError
 = False

2811 
self
 . 
mayReturnEmpty
 = True 
	}

2813 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2814 
result
 = 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 )

2815 if not 
result
 :

2816 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2818 
loc
 = 
result
 . 
end
 ( )

2819 
d
 = 
result
 . 
groupdict
 ( )

2820 
ret
 = 
ParseResults
 ( 
result
 . 
group
 ( ) )

2821 if 
d
 :

2822 for 
k
 in 
d
 :

2823 
ret
 [ 
k
 ] = 
d
 [ 
k
 ]

2824 return 
loc
 , 
ret
 
	}

2826 def 
	$__str__
 ( 
self
 ) :

2828 return 
super
 ( 
Regex
 , 
self
 ) . 
__str__
 ( )

2829 except 
Exception
 :

2832 if 
self
 . 
strRepr
 is None :

2833 
self
 . 
strRepr
 = "Re:(%s)" % 
repr
 ( 
self
 . 
pattern
 )

2835 return 
self
 . 
strRepr
 
	}

2838 class 
	cQuotedString
 ( 
Token
 ) :

2863 def 
	$__init__
 ( 
self
 , 
quoteChar
 , 
escChar
 = None , 
escQuote
 = None , 
multiline
 = False , 
unquoteResults
 = True , 
endQuoteChar
 = None , 
convertWhitespaceEscapes
 = True ) :

2864 
super
 ( 
QuotedString
 , 
self
 ) . 
__init__
 ( )

2867 
quoteChar
 = 
quoteChar
 . 
strip
 ( )

2868 if not 
quoteChar
 :

2869 
warnings
 . 
warn
 ( "quoteChar cannot be the empty string" , 
SyntaxWarning
 , 
stacklevel
 = 2 )

2870 raise 
SyntaxError
 ( )

2872 if 
endQuoteChar
 is None :

2873 
endQuoteChar
 = 
quoteChar

2875 
endQuoteChar
 = 
endQuoteChar
 . 
strip
 ( )

2876 if not 
endQuoteChar
 :

2877 
warnings
 . 
warn
 ( "endQuoteChar cannot be the empty string" , 
SyntaxWarning
 , 
stacklevel
 = 2 )

2878 raise 
SyntaxError
 ( )

2880 
self
 . 
quoteChar
 = 
quoteChar

2881 
self
 . 
quoteCharLen
 = 
len
 ( 
quoteChar
 )

2882 
self
 . 
firstQuoteChar
 = 
quoteChar
 [ 0 ]

2883 
self
 . 
endQuoteChar
 = 
endQuoteChar

2884 
self
 . 
endQuoteCharLen
 = 
len
 ( 
endQuoteChar
 )

2885 
self
 . 
escChar
 = 
escChar

2886 
self
 . 
escQuote
 = 
escQuote

2887 
self
 . 
unquoteResults
 = 
unquoteResults

2888 
self
 . 
convertWhitespaceEscapes
 = 
convertWhitespaceEscapes

2890 if 
multiline
 :

2891 
self
 . 
flags
 = 
re
 . 
MULTILINE
 | 
re
 . 
DOTALL

2892 
self
 . 
pattern
 = r'%s(?:[^%s%s]' %

2893 ( 
re
 . 
escape
 ( 
self
 . 
quoteChar
 ) ,

2894 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 0 ] ) ,

2895 ( 
escChar
 is not None and 
_escapeRegexRangeChars
 ( 
escChar
 ) or '' ) )

2897 
self
 . 
flags
 = 0

2898 
self
 . 
pattern
 = r'%s(?:[^%s\n\r%s]' %

2899 ( 
re
 . 
escape
 ( 
self
 . 
quoteChar
 ) ,

2900 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 0 ] ) ,

2901 ( 
escChar
 is not None and 
_escapeRegexRangeChars
 ( 
escChar
 ) or '' ) )

2902 if 
len
 ( 
self
 . 
endQuoteChar
 ) > 1 :

2903 
self
 . 
pattern
 += ( '|(?:'

2904 + ')|(?:' . 
join
 ( "%s[^%s]" % ( 
re
 . 
escape
 ( 
self
 . 
endQuoteChar
 [ : 
i
 ] ) ,

2905 
_escapeRegexRangeChars
 ( 
self
 . 
endQuoteChar
 [ 
i
 ] ) )

2906 for 
i
 in 
range
 ( 
len
 ( 
self
 . 
endQuoteChar
 ) - 1 , 0 , - 1 ) ) + ')'

2908 if 
escQuote
 :

2909 
self
 . 
pattern
 += ( r'|(?:%s)' % 
re
 . 
escape
 ( 
escQuote
 ) )

2910 if 
escChar
 :

2911 
self
 . 
pattern
 += ( r'|(?:%s.)' % 
re
 . 
escape
 ( 
escChar
 ) )

2912 
self
 . 
escCharReplacePattern
 = 
re
 . 
escape
 ( 
self
 . 
escChar
 ) + "(.)"

2913 
self
 . 
pattern
 += ( r')*%s' % 
re
 . 
escape
 ( 
self
 . 
endQuoteChar
 ) )

2916 
self
 . 
re
 = 
re
 . 
compile
 ( 
self
 . 
pattern
 , 
self
 . 
flags
 )

2917 
self
 . 
reString
 = 
self
 . 
pattern

2918 except 
sre_constants
 . 
error
 :

2919 
warnings
 . 
warn
 ( "invalid pattern (%s) passed to Regex" % 
self
 . 
pattern
 ,

2920 
SyntaxWarning
 , 
stacklevel
 = 2 )

2923 
self
 . 
name
 = 
_ustr
 ( 
self
 )

2924 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

2925 
self
 . 
mayIndexError
 = False

2926 
self
 . 
mayReturnEmpty
 = True 
	}

2928 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

2929 
result
 = 
instring
 [ 
loc
 ] == 
self
 . 
firstQuoteChar
 and 
self
 . 
re
 . 
match
 ( 
instring
 , 
loc
 ) or None

2930 if not 
result
 :

2931 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

2933 
loc
 = 
result
 . 
end
 ( )

2934 
ret
 = 
result
 . 
group
 ( )

2936 if 
self
 . 
unquoteResults
 :

2939 
ret
 = 
ret
 [ 
self
 . 
quoteCharLen
 : - 
self
 . 
endQuoteCharLen
 ]

2941 if 
isinstance
 ( 
ret
 , 
basestring
 ) :

2943 if '\\' in 
ret
 and 
self
 . 
convertWhitespaceEscapes
 :

2944 
ws_map
 = { r'\t'

2950 for 
wslit
 , 
wschar
 in 
ws_map
 . 
items
 ( ) :

2951 
ret
 = 
ret
 . 
replace
 ( 
wslit
 , 
wschar
 )

2954 if 
self
 . 
escChar
 :

2955 
ret
 = 
re
 . 
sub
 ( 
self
 . 
escCharReplacePattern
 , r"\g<1>" , 
ret
 )

2958 if 
self
 . 
escQuote
 :

2959 
ret
 = 
ret
 . 
replace
 ( 
self
 . 
escQuote
 , 
self
 . 
endQuoteChar
 )

2961 return 
loc
 , 
ret
 
	}

2963 def 
	$__str__
 ( 
self
 ) :

2965 return 
super
 ( 
QuotedString
 , 
self
 ) . 
__str__
 ( )

2966 except 
Exception
 :

2969 if 
self
 . 
strRepr
 is None :

2970 
self
 . 
strRepr
 = "quoted string, starting with %s ending with %s" % ( 
self
 . 
quoteChar
 , 
self
 . 
endQuoteChar
 )

2972 return 
self
 . 
strRepr
 
	}

2975 class 
	cCharsNotIn
 ( 
Token
 ) :

2991 def 
	$__init__
 ( 
self
 , 
notChars
 , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 ) :

2992 
super
 ( 
CharsNotIn
 , 
self
 ) . 
__init__
 ( )

2993 
self
 . 
skipWhitespace
 = False

2994 
self
 . 
notChars
 = 
notChars

2996 if 
min
 < 1 :

2997 raise 
ValueError
 ( "cannot specify a minimum length < 1; use Optional(CharsNotIn()) if zero-length char group is permitted" )

2999 
self
 . 
minLen
 = 
min

3001 if 
max
 > 0 :

3002 
self
 . 
maxLen
 = 
max

3004 
self
 . 
maxLen
 = 
_MAX_INT

3006 if 
exact
 > 0 :

3007 
self
 . 
maxLen
 = 
exact

3008 
self
 . 
minLen
 = 
exact

3010 
self
 . 
name
 = 
_ustr
 ( 
self
 )

3011 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

3012 
self
 . 
mayReturnEmpty
 = ( 
self
 . 
minLen
 == 0 )

3013 
self
 . 
mayIndexError
 = False 
	}

3015 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3016 if 
instring
 [ 
loc
 ] in 
self
 . 
notChars
 :

3017 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3019 
start
 = 
loc

3020 
loc
 += 1

3021 
notchars
 = 
self
 . 
notChars

3022 
maxlen
 = 
min
 ( 
start
 + 
self
 . 
maxLen
 , 
len
 ( 
instring
 ) )

3023 while 
loc
 < 
maxlen
 and

3024 ( 
instring
 [ 
loc
 ] not in 
notchars
 ) :

3025 
loc
 += 1

3027 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

3028 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3030 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

3032 def 
	$__str__
 ( 
self
 ) :

3034 return 
super
 ( 
CharsNotIn
 , 
self
 ) . 
__str__
 ( )

3035 except 
Exception
 :

3038 if 
self
 . 
strRepr
 is None :

3039 if 
len
 ( 
self
 . 
notChars
 ) > 4 :

3040 
self
 . 
strRepr
 = "!W:(%s...)" % 
self
 . 
notChars
 [ : 4 ]

3042 
self
 . 
strRepr
 = "!W:(%s)" % 
self
 . 
notChars

3044 return 
self
 . 
strRepr
 
	}

3046 class 
	cWhite
 ( 
Token
 ) :

3054 
whiteStrs
 = { " "

3061 def 
	$__init__
 ( 
self
 , 
ws
 = " \t\r\n" , 
min
 = 1 , 
max
 = 0 , 
exact
 = 0 ) :

3062 
super
 ( 
White
 , 
self
 ) . 
__init__
 ( )

3063 
self
 . 
matchWhite
 = 
ws

3064 
self
 . 
setWhitespaceChars
 ( "" . 
join
 ( 
c
 for 
c
 in 
self
 . 
whiteChars
 if 
c
 not in 
self
 . 
matchWhite
 ) )

3066 
self
 . 
name
 = ( "" . 
join
 ( 
White
 . 
whiteStrs
 [ 
c
 ] for 
c
 in 
self
 . 
matchWhite
 ) )

3067 
self
 . 
mayReturnEmpty
 = True

3068 
self
 . 
errmsg
 = "Expected " + 
self
 . 
name

3070 
self
 . 
minLen
 = 
min

3072 if 
max
 > 0 :

3073 
self
 . 
maxLen
 = 
max

3075 
self
 . 
maxLen
 = 
_MAX_INT

3077 if 
exact
 > 0 :

3078 
self
 . 
maxLen
 = 
exact

3079 
self
 . 
minLen
 = 
exact
 
	}

3081 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3082 if not ( 
instring
 [ 
loc
 ] in 
self
 . 
matchWhite
 ) :

3083 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3084 
start
 = 
loc

3085 
loc
 += 1

3086 
maxloc
 = 
start
 + 
self
 . 
maxLen

3087 
maxloc
 = 
min
 ( 
maxloc
 , 
len
 ( 
instring
 ) )

3088 while 
loc
 < 
maxloc
 and 
instring
 [ 
loc
 ] in 
self
 . 
matchWhite
 :

3089 
loc
 += 1

3091 if 
loc
 - 
start
 < 
self
 . 
minLen
 :

3092 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3094 return 
loc
 , 
instring
 [ 
start
 : 
loc
 ] 
	}

3097 class 
	c_PositionToken
 ( 
Token
 ) :

3098 def 
	$__init__
 ( 
self
 ) :

3099 
super
 ( 
_PositionToken
 , 
self
 ) . 
__init__
 ( )

3100 
self
 . 
name
 = 
self
 . 
__class__
 . 
__name__

3101 
self
 . 
mayReturnEmpty
 = True

3102 
self
 . 
mayIndexError
 = False 
	}

3104 class 
	cGoToColumn
 ( 
_PositionToken
 ) :

3108 def 
	$__init__
 ( 
self
 , 
colno
 ) :

3109 
super
 ( 
GoToColumn
 , 
self
 ) . 
__init__
 ( )

3110 
self
 . 
col
 = 
colno
 
	}

3112 def 
	$preParse
 ( 
self
 , 
instring
 , 
loc
 ) :

3113 if 
col
 ( 
loc
 , 
instring
 ) != 
self
 . 
col
 :

3114 
instrlen
 = 
len
 ( 
instring
 )

3115 if 
self
 . 
ignoreExprs
 :

3116 
loc
 = 
self
 . 
_skipIgnorables
 ( 
instring
 , 
loc
 )

3117 while 
loc
 < 
instrlen
 and 
instring
 [ 
loc
 ] . 
isspace
 ( ) and 
col
 ( 
loc
 , 
instring
 ) != 
self
 . 
col
 :

3118 
loc
 += 1

3119 return 
loc
 
	}

3121 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3122 
thiscol
 = 
col
 ( 
loc
 , 
instring
 )

3123 if 
thiscol
 > 
self
 . 
col
 :

3124 raise 
ParseException
 ( 
instring
 , 
loc
 , "Text not in expected column" , 
self
 )

3125 
newloc
 = 
loc
 + 
self
 . 
col
 - 
thiscol

3126 
ret
 = 
instring
 [ 
loc
 : 
newloc
 ]

3127 return 
newloc
 , 
ret
 
	}

3130 class 
	cLineStart
 ( 
_PositionToken
 ) :

3151 def 
	$__init__
 ( 
self
 ) :

3152 
super
 ( 
LineStart
 , 
self
 ) . 
__init__
 ( )

3153 
self
 . 
errmsg
 = "Expected start of line" 
	}

3155 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3156 if 
col
 ( 
loc
 , 
instring
 ) == 1 :

3157 return 
loc
 , [ ]

3158 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3160 class 
	cLineEnd
 ( 
_PositionToken
 ) :

3164 def 
	$__init__
 ( 
self
 ) :

3165 
super
 ( 
LineEnd
 , 
self
 ) . 
__init__
 ( )

3166 
self
 . 
setWhitespaceChars
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 . 
replace
 ( "\n" , "" ) )

3167 
self
 . 
errmsg
 = "Expected end of line" 
	}

3169 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3170 if 
loc
 < 
len
 ( 
instring
 ) :

3171 if 
instring
 [ 
loc
 ] == "\n" :

3172 return 
loc
 + 1 , "\n"

3174 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3175 elif 
loc
 == 
len
 ( 
instring
 ) :

3176 return 
loc
 + 1 , [ ]

3178 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3180 class 
	cStringStart
 ( 
_PositionToken
 ) :

3184 def 
	$__init__
 ( 
self
 ) :

3185 
super
 ( 
StringStart
 , 
self
 ) . 
__init__
 ( )

3186 
self
 . 
errmsg
 = "Expected start of text" 
	}

3188 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3189 if 
loc
 != 0 :

3191 if 
loc
 != 
self
 . 
preParse
 ( 
instring
 , 0 ) :

3192 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3193 return 
loc
 , [ ] 
	}

3195 class 
	cStringEnd
 ( 
_PositionToken
 ) :

3199 def 
	$__init__
 ( 
self
 ) :

3200 
super
 ( 
StringEnd
 , 
self
 ) . 
__init__
 ( )

3201 
self
 . 
errmsg
 = "Expected end of text" 
	}

3203 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3204 if 
loc
 < 
len
 ( 
instring
 ) :

3205 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3206 elif 
loc
 == 
len
 ( 
instring
 ) :

3207 return 
loc
 + 1 , [ ]

3208 elif 
loc
 > 
len
 ( 
instring
 ) :

3209 return 
loc
 , [ ]

3211 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3213 class 
	cWordStart
 ( 
_PositionToken
 ) :

3221 def 
	$__init__
 ( 
self
 , 
wordChars
 = 
printables
 ) :

3222 
super
 ( 
WordStart
 , 
self
 ) . 
__init__
 ( )

3223 
self
 . 
wordChars
 = 
set
 ( 
wordChars
 )

3224 
self
 . 
errmsg
 = "Not at the start of a word" 
	}

3226 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3227 if 
loc
 != 0 :

3228 if ( 
instring
 [ 
loc
 - 1 ] in 
self
 . 
wordChars
 or

3229 
instring
 [ 
loc
 ] not in 
self
 . 
wordChars
 ) :

3230 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3231 return 
loc
 , [ ] 
	}

3233 class 
	cWordEnd
 ( 
_PositionToken
 ) :

3241 def 
	$__init__
 ( 
self
 , 
wordChars
 = 
printables
 ) :

3242 
super
 ( 
WordEnd
 , 
self
 ) . 
__init__
 ( )

3243 
self
 . 
wordChars
 = 
set
 ( 
wordChars
 )

3244 
self
 . 
skipWhitespace
 = False

3245 
self
 . 
errmsg
 = "Not at the end of a word" 
	}

3247 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3248 
instrlen
 = 
len
 ( 
instring
 )

3249 if 
instrlen
 > 0 and 
loc
 < 
instrlen
 :

3250 if ( 
instring
 [ 
loc
 ] in 
self
 . 
wordChars
 or

3251 
instring
 [ 
loc
 - 1 ] not in 
self
 . 
wordChars
 ) :

3252 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3253 return 
loc
 , [ ] 
	}

3256 class 
	cParseExpression
 ( 
ParserElement
 ) :

3260 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3261 
super
 ( 
ParseExpression
 , 
self
 ) . 
__init__
 ( 
savelist
 )

3262 if 
isinstance
 ( 
exprs
 , 
_generatorType
 ) :

3263 
exprs
 = 
list
 ( 
exprs
 )

3265 if 
isinstance
 ( 
exprs
 , 
basestring
 ) :

3266 
self
 . 
exprs
 = [ 
ParserElement
 . 
_literalStringClass
 ( 
exprs
 ) ]

3267 elif 
isinstance
 ( 
exprs
 , 
Iterable
 ) :

3268 
exprs
 = 
list
 ( 
exprs
 )

3270 if 
all
 ( 
isinstance
 ( 
expr
 , 
basestring
 ) for 
expr
 in 
exprs
 ) :

3271 
exprs
 = 
map
 ( 
ParserElement
 . 
_literalStringClass
 , 
exprs
 )

3272 
self
 . 
exprs
 = 
list
 ( 
exprs
 )

3275 
self
 . 
exprs
 = 
list
 ( 
exprs
 )

3276 except 
TypeError
 :

3277 
self
 . 
exprs
 = [ 
exprs
 ]

3278 
self
 . 
callPreparse
 = False 
	}

3280 def 
	$__getitem__
 ( 
self
 , 
i
 ) :

3281 return 
self
 . 
exprs
 [ 
i
 ] 
	}

3283 def 
	$append
 ( 
self
 , 
other
 ) :

3284 
self
 . 
exprs
 . 
append
 ( 
other
 )

3285 
self
 . 
strRepr
 = None

3286 return 
self
 
	}

3288 def 
	$leaveWhitespace
 ( 
self
 ) :

3291 
self
 . 
skipWhitespace
 = False

3292 
self
 . 
exprs
 = [ 
e
 . 
copy
 ( ) for 
e
 in 
self
 . 
exprs
 ]

3293 for 
e
 in 
self
 . 
exprs
 :

3294 
e
 . 
leaveWhitespace
 ( )

3295 return 
self
 
	}

3297 def 
	$ignore
 ( 
self
 , 
other
 ) :

3298 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

3299 if 
other
 not in 
self
 . 
ignoreExprs
 :

3300 
super
 ( 
ParseExpression
 , 
self
 ) . 
ignore
 ( 
other
 )

3301 for 
e
 in 
self
 . 
exprs
 :

3302 
e
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3304 
super
 ( 
ParseExpression
 , 
self
 ) . 
ignore
 ( 
other
 )

3305 for 
e
 in 
self
 . 
exprs
 :

3306 
e
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3307 return 
self
 
	}

3309 def 
	$__str__
 ( 
self
 ) :

3311 return 
super
 ( 
ParseExpression
 , 
self
 ) . 
__str__
 ( )

3312 except 
Exception
 :

3315 if 
self
 . 
strRepr
 is None :

3316 
self
 . 
strRepr
 = "%s:(%s)" % ( 
self
 . 
__class__
 . 
__name__
 , 
_ustr
 ( 
self
 . 
exprs
 ) )

3317 return 
self
 . 
strRepr
 
	}

3319 def 
	$streamline
 ( 
self
 ) :

3320 
super
 ( 
ParseExpression
 , 
self
 ) . 
streamline
 ( )

3322 for 
e
 in 
self
 . 
exprs
 :

3323 
e
 . 
streamline
 ( )

3328 if ( 
len
 ( 
self
 . 
exprs
 ) == 2 ) :

3329 
other
 = 
self
 . 
exprs
 [ 0 ]

3330 if ( 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) and

3331 not ( 
other
 . 
parseAction
 ) and

3332 
other
 . 
resultsName
 is None and

3333 not 
other
 . 
debug
 ) :

3334 
self
 . 
exprs
 = 
other
 . 
exprs
 [ : ] + [ 
self
 . 
exprs
 [ 1 ] ]

3335 
self
 . 
strRepr
 = None

3336 
self
 . 
mayReturnEmpty
 |= 
other
 . 
mayReturnEmpty

3337 
self
 . 
mayIndexError
 |= 
other
 . 
mayIndexError

3339 
other
 = 
self
 . 
exprs
 [ - 1 ]

3340 if ( 
isinstance
 ( 
other
 , 
self
 . 
__class__
 ) and

3341 not ( 
other
 . 
parseAction
 ) and

3342 
other
 . 
resultsName
 is None and

3343 not 
other
 . 
debug
 ) :

3344 
self
 . 
exprs
 = 
self
 . 
exprs
 [ : - 1 ] + 
other
 . 
exprs
 [ : ]

3345 
self
 . 
strRepr
 = None

3346 
self
 . 
mayReturnEmpty
 |= 
other
 . 
mayReturnEmpty

3347 
self
 . 
mayIndexError
 |= 
other
 . 
mayIndexError

3349 
self
 . 
errmsg
 = "Expected " + 
_ustr
 ( 
self
 )

3351 return 
self
 
	}

3353 def 
	$setResultsName
 ( 
self
 , 
name
 , 
listAllMatches
 = False ) :

3354 
ret
 = 
super
 ( 
ParseExpression
 , 
self
 ) . 
setResultsName
 ( 
name
 , 
listAllMatches
 )

3355 return 
ret
 
	}

3357 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

3358 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

3359 for 
e
 in 
self
 . 
exprs
 :

3360 
e
 . 
validate
 ( 
tmp
 )

3361 
self
 . 
checkRecursion
 ( [ ] ) 
	}

3363 def 
	$copy
 ( 
self
 ) :

3364 
ret
 = 
super
 ( 
ParseExpression
 , 
self
 ) . 
copy
 ( )

3365 
ret
 . 
exprs
 = [ 
e
 . 
copy
 ( ) for 
e
 in 
self
 . 
exprs
 ]

3366 return 
ret
 
	}

3368 class 
	cAnd
 ( 
ParseExpression
 ) :

3384 class 
	c_ErrorStop
 ( 
Empty
 ) :

3385 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

3386 
super
 ( 
And
 . 
_ErrorStop
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

3387 
self
 . 
name
 = '-'

3388 
self
 . 
leaveWhitespace
 ( ) 
	}

3390 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = True ) :

3391 
super
 ( 
And
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3392 
self
 . 
mayReturnEmpty
 = 
all
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3393 
self
 . 
setWhitespaceChars
 ( 
self
 . 
exprs
 [ 0 ] . 
whiteChars
 )

3394 
self
 . 
skipWhitespace
 = 
self
 . 
exprs
 [ 0 ] . 
skipWhitespace

3395 
self
 . 
callPreparse
 = True 
	}

3397 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3400 
loc
 , 
resultlist
 = 
self
 . 
exprs
 [ 0 ] . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3401 
errorStop
 = False

3402 for 
e
 in 
self
 . 
exprs
 [ 1 : ] :

3403 if 
isinstance
 ( 
e
 , 
And
 . 
_ErrorStop
 ) :

3404 
errorStop
 = True

3406 if 
errorStop
 :

3408 
loc
 , 
exprtokens
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3409 except 
ParseSyntaxException
 :

3411 except 
ParseBaseException
 as 
pe
 :

3412 
pe
 . 
__traceback__
 = None

3413 raise 
ParseSyntaxException
 . 
_from_exception
 ( 
pe
 )

3414 except 
IndexError
 :

3415 raise 
ParseSyntaxException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
self
 . 
errmsg
 , 
self
 )

3417 
loc
 , 
exprtokens
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3418 if 
exprtokens
 or 
exprtokens
 . 
haskeys
 ( ) :

3419 
resultlist
 += 
exprtokens

3420 return 
loc
 , 
resultlist
 
	}

3422 def 
	$__iadd__
 ( 
self
 , 
other
 ) :

3423 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3424 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3425 return 
self
 . 
append
 ( 
other
 ) 
	}

3427 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3428 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3429 for 
e
 in 
self
 . 
exprs
 :

3430 
e
 . 
checkRecursion
 ( 
subRecCheckList
 )

3431 if not 
e
 . 
mayReturnEmpty
 :

3432 break 
	}

3434 def 
	$__str__
 ( 
self
 ) :

3435 if 
hasattr
 ( 
self
 , "name" ) :

3436 return 
self
 . 
name

3438 if 
self
 . 
strRepr
 is None :

3439 
self
 . 
strRepr
 = "{" + " " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3441 return 
self
 . 
strRepr
 
	}

3444 class 
	cOr
 ( 
ParseExpression
 ) :

3458 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3459 
super
 ( 
Or
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3460 if 
self
 . 
exprs
 :

3461 
self
 . 
mayReturnEmpty
 = 
any
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3463 
self
 . 
mayReturnEmpty
 = True 
	}

3465 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3466 
maxExcLoc
 = - 1

3467 
maxException
 = None

3468 
matches
 = [ ]

3469 for 
e
 in 
self
 . 
exprs
 :

3471 
loc2
 = 
e
 . 
tryParse
 ( 
instring
 , 
loc
 )

3472 except 
ParseException
 as 
err
 :

3473 
err
 . 
__traceback__
 = None

3474 if 
err
 . 
loc
 > 
maxExcLoc
 :

3475 
maxException
 = 
err

3476 
maxExcLoc
 = 
err
 . 
loc

3477 except 
IndexError
 :

3478 if 
len
 ( 
instring
 ) > 
maxExcLoc
 :

3479 
maxException
 = 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
e
 . 
errmsg
 , 
self
 )

3480 
maxExcLoc
 = 
len
 ( 
instring
 )

3483 
matches
 . 
append
 ( ( 
loc2
 , 
e
 ) )

3485 if 
matches
 :

3486 
matches
 . 
sort
 ( 
key
 = lambda 
x
 : - 
x
 [ 0 ] )

3487 for 
_
 , 
e
 in 
matches
 :

3489 return 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3490 except 
ParseException
 as 
err
 :

3491 
err
 . 
__traceback__
 = None

3492 if 
err
 . 
loc
 > 
maxExcLoc
 :

3493 
maxException
 = 
err

3494 
maxExcLoc
 = 
err
 . 
loc

3496 if 
maxException
 is not None :

3497 
maxException
 . 
msg
 = 
self
 . 
errmsg

3498 raise 
maxException

3500 raise 
ParseException
 ( 
instring
 , 
loc
 , "no defined alternatives to match" , 
self
 ) 
	}

3503 def 
	$__ixor__
 ( 
self
 , 
other
 ) :

3504 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3505 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3506 return 
self
 . 
append
 ( 
other
 ) 
	}

3508 def 
	$__str__
 ( 
self
 ) :

3509 if 
hasattr
 ( 
self
 , "name" ) :

3510 return 
self
 . 
name

3512 if 
self
 . 
strRepr
 is None :

3513 
self
 . 
strRepr
 = "{" + " ^ " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3515 return 
self
 . 
strRepr
 
	}

3517 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3518 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3519 for 
e
 in 
self
 . 
exprs
 :

3520 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3523 class 
	cMatchFirst
 ( 
ParseExpression
 ) :

3540 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = False ) :

3541 
super
 ( 
MatchFirst
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3542 if 
self
 . 
exprs
 :

3543 
self
 . 
mayReturnEmpty
 = 
any
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3545 
self
 . 
mayReturnEmpty
 = True 
	}

3547 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3548 
maxExcLoc
 = - 1

3549 
maxException
 = None

3550 for 
e
 in 
self
 . 
exprs
 :

3552 
ret
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3553 return 
ret

3554 except 
ParseException
 as 
err
 :

3555 if 
err
 . 
loc
 > 
maxExcLoc
 :

3556 
maxException
 = 
err

3557 
maxExcLoc
 = 
err
 . 
loc

3558 except 
IndexError
 :

3559 if 
len
 ( 
instring
 ) > 
maxExcLoc
 :

3560 
maxException
 = 
ParseException
 ( 
instring
 , 
len
 ( 
instring
 ) , 
e
 . 
errmsg
 , 
self
 )

3561 
maxExcLoc
 = 
len
 ( 
instring
 )

3565 if 
maxException
 is not None :

3566 
maxException
 . 
msg
 = 
self
 . 
errmsg

3567 raise 
maxException

3569 raise 
ParseException
 ( 
instring
 , 
loc
 , "no defined alternatives to match" , 
self
 ) 
	}

3571 def 
	$__ior__
 ( 
self
 , 
other
 ) :

3572 if 
isinstance
 ( 
other
 , 
basestring
 ) :

3573 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

3574 return 
self
 . 
append
 ( 
other
 ) 
	}

3576 def 
	$__str__
 ( 
self
 ) :

3577 if 
hasattr
 ( 
self
 , "name" ) :

3578 return 
self
 . 
name

3580 if 
self
 . 
strRepr
 is None :

3581 
self
 . 
strRepr
 = "{" + " | " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3583 return 
self
 . 
strRepr
 
	}

3585 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3586 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3587 for 
e
 in 
self
 . 
exprs
 :

3588 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3591 class 
	cEach
 ( 
ParseExpression
 ) :

3645 def 
	$__init__
 ( 
self
 , 
exprs
 , 
savelist
 = True ) :

3646 
super
 ( 
Each
 , 
self
 ) . 
__init__
 ( 
exprs
 , 
savelist
 )

3647 
self
 . 
mayReturnEmpty
 = 
all
 ( 
e
 . 
mayReturnEmpty
 for 
e
 in 
self
 . 
exprs
 )

3648 
self
 . 
skipWhitespace
 = True

3649 
self
 . 
initExprGroups
 = True 
	}

3651 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3652 if 
self
 . 
initExprGroups
 :

3653 
self
 . 
opt1map
 = 
dict
 ( ( 
id
 ( 
e
 . 
expr
 ) , 
e
 ) for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) )

3654 
opt1
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) ]

3655 
opt2
 = [ 
e
 for 
e
 in 
self
 . 
exprs
 if 
e
 . 
mayReturnEmpty
 and not 
isinstance
 ( 
e
 , 
Optional
 ) ]

3656 
self
 . 
optionals
 = 
opt1
 + 
opt2

3657 
self
 . 
multioptionals
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
ZeroOrMore
 ) ]

3658 
self
 . 
multirequired
 = [ 
e
 . 
expr
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
OneOrMore
 ) ]

3659 
self
 . 
required
 = [ 
e
 for 
e
 in 
self
 . 
exprs
 if not 
isinstance
 ( 
e
 , ( 
Optional
 , 
ZeroOrMore
 , 
OneOrMore
 ) ) ]

3660 
self
 . 
required
 += 
self
 . 
multirequired

3661 
self
 . 
initExprGroups
 = False

3662 
tmpLoc
 = 
loc

3663 
tmpReqd
 = 
self
 . 
required
 [ : ]

3664 
tmpOpt
 = 
self
 . 
optionals
 [ : ]

3665 
matchOrder
 = [ ]

3667 
keepMatching
 = True

3668 while 
keepMatching
 :

3669 
tmpExprs
 = 
tmpReqd
 + 
tmpOpt
 + 
self
 . 
multioptionals
 + 
self
 . 
multirequired

3670 
failed
 = [ ]

3671 for 
e
 in 
tmpExprs
 :

3673 
tmpLoc
 = 
e
 . 
tryParse
 ( 
instring
 , 
tmpLoc
 )

3674 except 
ParseException
 :

3675 
failed
 . 
append
 ( 
e
 )

3677 
matchOrder
 . 
append
 ( 
self
 . 
opt1map
 . 
get
 ( 
id
 ( 
e
 ) , 
e
 ) )

3678 if 
e
 in 
tmpReqd
 :

3679 
tmpReqd
 . 
remove
 ( 
e
 )

3680 elif 
e
 in 
tmpOpt
 :

3681 
tmpOpt
 . 
remove
 ( 
e
 )

3682 if 
len
 ( 
failed
 ) == 
len
 ( 
tmpExprs
 ) :

3683 
keepMatching
 = False

3685 if 
tmpReqd
 :

3686 
missing
 = ", " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
tmpReqd
 )

3687 raise 
ParseException
 ( 
instring
 , 
loc
 , "Missing one or more required elements (%s)" % 
missing
 )

3690 
matchOrder
 += [ 
e
 for 
e
 in 
self
 . 
exprs
 if 
isinstance
 ( 
e
 , 
Optional
 ) and 
e
 . 
expr
 in 
tmpOpt
 ]

3692 
resultlist
 = [ ]

3693 for 
e
 in 
matchOrder
 :

3694 
loc
 , 
results
 = 
e
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 )

3695 
resultlist
 . 
append
 ( 
results
 )

3697 
finalResults
 = 
sum
 ( 
resultlist
 , 
ParseResults
 ( [ ] ) )

3698 return 
loc
 , 
finalResults
 
	}

3700 def 
	$__str__
 ( 
self
 ) :

3701 if 
hasattr
 ( 
self
 , "name" ) :

3702 return 
self
 . 
name

3704 if 
self
 . 
strRepr
 is None :

3705 
self
 . 
strRepr
 = "{" + " & " . 
join
 ( 
_ustr
 ( 
e
 ) for 
e
 in 
self
 . 
exprs
 ) + "}"

3707 return 
self
 . 
strRepr
 
	}

3709 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3710 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3711 for 
e
 in 
self
 . 
exprs
 :

3712 
e
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3715 class 
	cParseElementEnhance
 ( 
ParserElement
 ) :

3719 def 
	$__init__
 ( 
self
 , 
expr
 , 
savelist
 = False ) :

3720 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
__init__
 ( 
savelist
 )

3721 if 
isinstance
 ( 
expr
 , 
basestring
 ) :

3722 if 
issubclass
 ( 
ParserElement
 . 
_literalStringClass
 , 
Token
 ) :

3723 
expr
 = 
ParserElement
 . 
_literalStringClass
 ( 
expr
 )

3725 
expr
 = 
ParserElement
 . 
_literalStringClass
 ( 
Literal
 ( 
expr
 ) )

3726 
self
 . 
expr
 = 
expr

3727 
self
 . 
strRepr
 = None

3728 if 
expr
 is not None :

3729 
self
 . 
mayIndexError
 = 
expr
 . 
mayIndexError

3730 
self
 . 
mayReturnEmpty
 = 
expr
 . 
mayReturnEmpty

3731 
self
 . 
setWhitespaceChars
 ( 
expr
 . 
whiteChars
 )

3732 
self
 . 
skipWhitespace
 = 
expr
 . 
skipWhitespace

3733 
self
 . 
saveAsList
 = 
expr
 . 
saveAsList

3734 
self
 . 
callPreparse
 = 
expr
 . 
callPreparse

3735 
self
 . 
ignoreExprs
 . 
extend
 ( 
expr
 . 
ignoreExprs
 ) 
	}

3737 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3738 if 
self
 . 
expr
 is not None :

3739 return 
self
 . 
expr
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3741 raise 
ParseException
 ( "" , 
loc
 , 
self
 . 
errmsg
 , 
self
 ) 
	}

3743 def 
	$leaveWhitespace
 ( 
self
 ) :

3744 
self
 . 
skipWhitespace
 = False

3745 
self
 . 
expr
 = 
self
 . 
expr
 . 
copy
 ( )

3746 if 
self
 . 
expr
 is not None :

3747 
self
 . 
expr
 . 
leaveWhitespace
 ( )

3748 return 
self
 
	}

3750 def 
	$ignore
 ( 
self
 , 
other
 ) :

3751 if 
isinstance
 ( 
other
 , 
Suppress
 ) :

3752 if 
other
 not in 
self
 . 
ignoreExprs
 :

3753 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
ignore
 ( 
other
 )

3754 if 
self
 . 
expr
 is not None :

3755 
self
 . 
expr
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3757 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
ignore
 ( 
other
 )

3758 if 
self
 . 
expr
 is not None :

3759 
self
 . 
expr
 . 
ignore
 ( 
self
 . 
ignoreExprs
 [ - 1 ] )

3760 return 
self
 
	}

3762 def 
	$streamline
 ( 
self
 ) :

3763 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
streamline
 ( )

3764 if 
self
 . 
expr
 is not None :

3765 
self
 . 
expr
 . 
streamline
 ( )

3766 return 
self
 
	}

3768 def 
	$checkRecursion
 ( 
self
 , 
parseElementList
 ) :

3769 if 
self
 in 
parseElementList
 :

3770 raise 
RecursiveGrammarException
 ( 
parseElementList
 + [ 
self
 ] )

3771 
subRecCheckList
 = 
parseElementList
 [ : ] + [ 
self
 ]

3772 if 
self
 . 
expr
 is not None :

3773 
self
 . 
expr
 . 
checkRecursion
 ( 
subRecCheckList
 ) 
	}

3775 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

3776 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

3777 if 
self
 . 
expr
 is not None :

3778 
self
 . 
expr
 . 
validate
 ( 
tmp
 )

3779 
self
 . 
checkRecursion
 ( [ ] ) 
	}

3781 def 
	$__str__
 ( 
self
 ) :

3783 return 
super
 ( 
ParseElementEnhance
 , 
self
 ) . 
__str__
 ( )

3784 except 
Exception
 :

3787 if 
self
 . 
strRepr
 is None and 
self
 . 
expr
 is not None :

3788 
self
 . 
strRepr
 = "%s:(%s)" % ( 
self
 . 
__class__
 . 
__name__
 , 
_ustr
 ( 
self
 . 
expr
 ) )

3789 return 
self
 . 
strRepr
 
	}

3792 class 
	cFollowedBy
 ( 
ParseElementEnhance
 ) :

3809 def 
	$__init__
 ( 
self
 , 
expr
 ) :

3810 
super
 ( 
FollowedBy
 , 
self
 ) . 
__init__
 ( 
expr
 )

3811 
self
 . 
mayReturnEmpty
 = True 
	}

3813 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3814 
self
 . 
expr
 . 
tryParse
 ( 
instring
 , 
loc
 )

3815 return 
loc
 , [ ] 
	}

3818 class 
	cNotAny
 ( 
ParseElementEnhance
 ) :

3829 def 
	$__init__
 ( 
self
 , 
expr
 ) :

3830 
super
 ( 
NotAny
 , 
self
 ) . 
__init__
 ( 
expr
 )

3832 
self
 . 
skipWhitespace
 = False

3833 
self
 . 
mayReturnEmpty
 = True

3834 
self
 . 
errmsg
 = "Found unwanted token, " + 
_ustr
 ( 
self
 . 
expr
 ) 
	}

3836 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3837 if 
self
 . 
expr
 . 
canParseNext
 ( 
instring
 , 
loc
 ) :

3838 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

3839 return 
loc
 , [ ] 
	}

3841 def 
	$__str__
 ( 
self
 ) :

3842 if 
hasattr
 ( 
self
 , "name" ) :

3843 return 
self
 . 
name

3845 if 
self
 . 
strRepr
 is None :

3846 
self
 . 
strRepr
 = "~{" + 
_ustr
 ( 
self
 . 
expr
 ) + "}"

3848 return 
self
 . 
strRepr
 
	}

3850 class 
	c_MultipleMatch
 ( 
ParseElementEnhance
 ) :

3851 def 
	$__init__
 ( 
self
 , 
expr
 , 
stopOn
 = None ) :

3852 
super
 ( 
_MultipleMatch
 , 
self
 ) . 
__init__
 ( 
expr
 )

3853 
self
 . 
saveAsList
 = True

3854 
ender
 = 
stopOn

3855 if 
isinstance
 ( 
ender
 , 
basestring
 ) :

3856 
ender
 = 
ParserElement
 . 
_literalStringClass
 ( 
ender
 )

3857 
self
 . 
not_ender
 = ~ 
ender
 if 
ender
 is not None else None 
	}

3859 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3860 
self_expr_parse
 = 
self
 . 
expr
 . 
_parse

3861 
self_skip_ignorables
 = 
self
 . 
_skipIgnorables

3862 
check_ender
 = 
self
 . 
not_ender
 is not None

3863 if 
check_ender
 :

3864 
try_not_ender
 = 
self
 . 
not_ender
 . 
tryParse

3868 if 
check_ender
 :

3869 
try_not_ender
 ( 
instring
 , 
loc
 )

3870 
loc
 , 
tokens
 = 
self_expr_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

3872 
hasIgnoreExprs
 = ( not not 
self
 . 
ignoreExprs
 )

3874 if 
check_ender
 :

3875 
try_not_ender
 ( 
instring
 , 
loc
 )

3876 if 
hasIgnoreExprs
 :

3877 
preloc
 = 
self_skip_ignorables
 ( 
instring
 , 
loc
 )

3879 
preloc
 = 
loc

3880 
loc
 , 
tmptokens
 = 
self_expr_parse
 ( 
instring
 , 
preloc
 , 
doActions
 )

3881 if 
tmptokens
 or 
tmptokens
 . 
haskeys
 ( ) :

3882 
tokens
 += 
tmptokens

3883 except ( 
ParseException
 , 
IndexError
 ) :

3886 return 
loc
 , 
tokens
 
	}

3888 class 
	cOneOrMore
 ( 
_MultipleMatch
 ) :

3914 def 
	$__str__
 ( 
self
 ) :

3915 if 
hasattr
 ( 
self
 , "name" ) :

3916 return 
self
 . 
name

3918 if 
self
 . 
strRepr
 is None :

3919 
self
 . 
strRepr
 = "{" + 
_ustr
 ( 
self
 . 
expr
 ) + "}..."

3921 return 
self
 . 
strRepr
 
	}

3923 class 
	cZeroOrMore
 ( 
_MultipleMatch
 ) :

3935 def 
	$__init__
 ( 
self
 , 
expr
 , 
stopOn
 = None ) :

3936 
super
 ( 
ZeroOrMore
 , 
self
 ) . 
__init__
 ( 
expr
 , 
stopOn
 = 
stopOn
 )

3937 
self
 . 
mayReturnEmpty
 = True 
	}

3939 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

3941 return 
super
 ( 
ZeroOrMore
 , 
self
 ) . 
parseImpl
 ( 
instring
 , 
loc
 , 
doActions
 )

3942 except ( 
ParseException
 , 
IndexError
 ) :

3943 return 
loc
 , [ ] 
	}

3945 def 
	$__str__
 ( 
self
 ) :

3946 if 
hasattr
 ( 
self
 , "name" ) :

3947 return 
self
 . 
name

3949 if 
self
 . 
strRepr
 is None :

3950 
self
 . 
strRepr
 = "[" + 
_ustr
 ( 
self
 . 
expr
 ) + "]..."

3952 return 
self
 . 
strRepr
 
	}

3954 class 
	c_NullToken
 ( 
object
 ) :

3955 def 
	$__bool__
 ( 
self
 ) :

3956 return False 
	}

3957 
__nonzero__
 = 
__bool__

3958 def 
	$__str__
 ( 
self
 ) :

3959 return "" 
	}

3961 
_optionalNotMatched
 = 
_NullToken
 ( )

3962 class 
	cOptional
 ( 
ParseElementEnhance
 ) :

3997 def 
	$__init__
 ( 
self
 , 
expr
 , 
default
 = 
_optionalNotMatched
 ) :

3998 
super
 ( 
Optional
 , 
self
 ) . 
__init__
 ( 
expr
 , 
savelist
 = False )

3999 
self
 . 
saveAsList
 = 
self
 . 
expr
 . 
saveAsList

4000 
self
 . 
defaultValue
 = 
default

4001 
self
 . 
mayReturnEmpty
 = True 
	}

4003 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

4005 
loc
 , 
tokens
 = 
self
 . 
expr
 . 
_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

4006 except ( 
ParseException
 , 
IndexError
 ) :

4007 if 
self
 . 
defaultValue
 is not 
_optionalNotMatched
 :

4008 if 
self
 . 
expr
 . 
resultsName
 :

4009 
tokens
 = 
ParseResults
 ( [ 
self
 . 
defaultValue
 ] )

4010 
tokens
 [ 
self
 . 
expr
 . 
resultsName
 ] = 
self
 . 
defaultValue

4012 
tokens
 = [ 
self
 . 
defaultValue
 ]

4014 
tokens
 = [ ]

4015 return 
loc
 , 
tokens
 
	}

4017 def 
	$__str__
 ( 
self
 ) :

4018 if 
hasattr
 ( 
self
 , "name" ) :

4019 return 
self
 . 
name

4021 if 
self
 . 
strRepr
 is None :

4022 
self
 . 
strRepr
 = "[" + 
_ustr
 ( 
self
 . 
expr
 ) + "]"

4024 return 
self
 . 
strRepr
 
	}

4026 class 
	cSkipTo
 ( 
ParseElementEnhance
 ) :

4081 def 
	$__init__
 ( 
self
 , 
other
 , 
include
 = False , 
ignore
 = None , 
failOn
 = None ) :

4082 
super
 ( 
SkipTo
 , 
self
 ) . 
__init__
 ( 
other
 )

4083 
self
 . 
ignoreExpr
 = 
ignore

4084 
self
 . 
mayReturnEmpty
 = True

4085 
self
 . 
mayIndexError
 = False

4086 
self
 . 
includeMatch
 = 
include

4087 
self
 . 
asList
 = False

4088 if 
isinstance
 ( 
failOn
 , 
basestring
 ) :

4089 
self
 . 
failOn
 = 
ParserElement
 . 
_literalStringClass
 ( 
failOn
 )

4091 
self
 . 
failOn
 = 
failOn

4092 
self
 . 
errmsg
 = "No match found for " + 
_ustr
 ( 
self
 . 
expr
 ) 
	}

4094 def 
	$parseImpl
 ( 
self
 , 
instring
 , 
loc
 , 
doActions
 = True ) :

4095 
startloc
 = 
loc

4096 
instrlen
 = 
len
 ( 
instring
 )

4097 
expr
 = 
self
 . 
expr

4098 
expr_parse
 = 
self
 . 
expr
 . 
_parse

4099 
self_failOn_canParseNext
 = 
self
 . 
failOn
 . 
canParseNext
 if 
self
 . 
failOn
 is not None else None

4100 
self_ignoreExpr_tryParse
 = 
self
 . 
ignoreExpr
 . 
tryParse
 if 
self
 . 
ignoreExpr
 is not None else None

4102 
tmploc
 = 
loc

4103 while 
tmploc
 <= 
instrlen
 :

4104 if 
self_failOn_canParseNext
 is not None :

4106 if 
self_failOn_canParseNext
 ( 
instring
 , 
tmploc
 ) :

4109 if 
self_ignoreExpr_tryParse
 is not None :

4113 
tmploc
 = 
self_ignoreExpr_tryParse
 ( 
instring
 , 
tmploc
 )

4114 except 
ParseBaseException
 :

4118 
expr_parse
 ( 
instring
 , 
tmploc
 , 
doActions
 = False , 
callPreParse
 = False )

4119 except ( 
ParseException
 , 
IndexError
 ) :

4121 
tmploc
 += 1

4128 raise 
ParseException
 ( 
instring
 , 
loc
 , 
self
 . 
errmsg
 , 
self
 )

4131 
loc
 = 
tmploc

4132 
skiptext
 = 
instring
 [ 
startloc
 : 
loc
 ]

4133 
skipresult
 = 
ParseResults
 ( 
skiptext
 )

4135 if 
self
 . 
includeMatch
 :

4136 
loc
 , 
mat
 = 
expr_parse
 ( 
instring
 , 
loc
 , 
doActions
 , 
callPreParse
 = False )

4137 
skipresult
 += 
mat

4139 return 
loc
 , 
skipresult
 
	}

4141 class 
	cForward
 ( 
ParseElementEnhance
 ) :

4160 def 
	$__init__
 ( 
self
 , 
other
 = None ) :

4161 
super
 ( 
Forward
 , 
self
 ) . 
__init__
 ( 
other
 , 
savelist
 = False ) 
	}

4163 def 
	$__lshift__
 ( 
self
 , 
other
 ) :

4164 if 
isinstance
 ( 
other
 , 
basestring
 ) :

4165 
other
 = 
ParserElement
 . 
_literalStringClass
 ( 
other
 )

4166 
self
 . 
expr
 = 
other

4167 
self
 . 
strRepr
 = None

4168 
self
 . 
mayIndexError
 = 
self
 . 
expr
 . 
mayIndexError

4169 
self
 . 
mayReturnEmpty
 = 
self
 . 
expr
 . 
mayReturnEmpty

4170 
self
 . 
setWhitespaceChars
 ( 
self
 . 
expr
 . 
whiteChars
 )

4171 
self
 . 
skipWhitespace
 = 
self
 . 
expr
 . 
skipWhitespace

4172 
self
 . 
saveAsList
 = 
self
 . 
expr
 . 
saveAsList

4173 
self
 . 
ignoreExprs
 . 
extend
 ( 
self
 . 
expr
 . 
ignoreExprs
 )

4174 return 
self
 
	}

4176 def 
	$__ilshift__
 ( 
self
 , 
other
 ) :

4177 return 
self
 << 
other
 
	}

4179 def 
	$leaveWhitespace
 ( 
self
 ) :

4180 
self
 . 
skipWhitespace
 = False

4181 return 
self
 
	}

4183 def 
	$streamline
 ( 
self
 ) :

4184 if not 
self
 . 
streamlined
 :

4185 
self
 . 
streamlined
 = True

4186 if 
self
 . 
expr
 is not None :

4187 
self
 . 
expr
 . 
streamline
 ( )

4188 return 
self
 
	}

4190 def 
	$validate
 ( 
self
 , 
validateTrace
 = [ ] ) :

4191 if 
self
 not in 
validateTrace
 :

4192 
tmp
 = 
validateTrace
 [ : ] + [ 
self
 ]

4193 if 
self
 . 
expr
 is not None :

4194 
self
 . 
expr
 . 
validate
 ( 
tmp
 )

4195 
self
 . 
checkRecursion
 ( [ ] ) 
	}

4197 def 
	$__str__
 ( 
self
 ) :

4198 if 
hasattr
 ( 
self
 , "name" ) :

4199 return 
self
 . 
name

4200 return 
self
 . 
__class__
 . 
__name__
 + ": ..."

4203 
self
 . 
_revertClass
 = 
self
 . 
__class__

4204 
self
 . 
__class__
 = 
_ForwardNoRecurse

4206 if 
self
 . 
expr
 is not None :

4207 
retString
 = 
_ustr
 ( 
self
 . 
expr
 )

4209 
retString
 = "None"

4211 
self
 . 
__class__
 = 
self
 . 
_revertClass

4212 return 
self
 . 
__class__
 . 
__name__
 + ": " + 
retString
 
	}

4214 def 
	$copy
 ( 
self
 ) :

4215 if 
self
 . 
expr
 is not None :

4216 return 
super
 ( 
Forward
 , 
self
 ) . 
copy
 ( )

4218 
ret
 = 
Forward
 ( )

4219 
ret
 <<= 
self

4220 return 
ret
 
	}

4222 class 
	c_ForwardNoRecurse
 ( 
Forward
 ) :

4223 def 
	$__str__
 ( 
self
 ) :

4224 return "..." 
	}

4226 class 
	cTokenConverter
 ( 
ParseElementEnhance
 ) :

4230 def 
	$__init__
 ( 
self
 , 
expr
 , 
savelist
 = False ) :

4231 
super
 ( 
TokenConverter
 , 
self
 ) . 
__init__
 ( 
expr
 )

4232 
self
 . 
saveAsList
 = False 
	}

4234 class 
	cCombine
 ( 
TokenConverter
 ) :

4251 def 
	$__init__
 ( 
self
 , 
expr
 , 
joinString
 = "" , 
adjacent
 = True ) :

4252 
super
 ( 
Combine
 , 
self
 ) . 
__init__
 ( 
expr
 )

4254 if 
adjacent
 :

4255 
self
 . 
leaveWhitespace
 ( )

4256 
self
 . 
adjacent
 = 
adjacent

4257 
self
 . 
skipWhitespace
 = True

4258 
self
 . 
joinString
 = 
joinString

4259 
self
 . 
callPreparse
 = True 
	}

4261 def 
	$ignore
 ( 
self
 , 
other
 ) :

4262 if 
self
 . 
adjacent
 :

4263 
ParserElement
 . 
ignore
 ( 
self
 , 
other
 )

4265 
super
 ( 
Combine
 , 
self
 ) . 
ignore
 ( 
other
 )

4266 return 
self
 
	}

4268 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4269 
retToks
 = 
tokenlist
 . 
copy
 ( )

4270 del 
retToks
 [ : ]

4271 
retToks
 += 
ParseResults
 ( [ "" . 
join
 ( 
tokenlist
 . 
_asStringList
 ( 
self
 . 
joinString
 ) ) ] , 
modal
 = 
self
 . 
modalResults
 )

4273 if 
self
 . 
resultsName
 and 
retToks
 . 
haskeys
 ( ) :

4274 return [ 
retToks
 ]

4276 return 
retToks
 
	}

4278 class 
	cGroup
 ( 
TokenConverter
 ) :

4292 def 
	$__init__
 ( 
self
 , 
expr
 ) :

4293 
super
 ( 
Group
 , 
self
 ) . 
__init__
 ( 
expr
 )

4294 
self
 . 
saveAsList
 = True 
	}

4296 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4297 return [ 
tokenlist
 ] 
	}

4299 class 
	cDict
 ( 
TokenConverter
 ) :

4335 def 
	$__init__
 ( 
self
 , 
expr
 ) :

4336 
super
 ( 
Dict
 , 
self
 ) . 
__init__
 ( 
expr
 )

4337 
self
 . 
saveAsList
 = True 
	}

4339 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4340 for 
i
 , 
tok
 in 
enumerate
 ( 
tokenlist
 ) :

4341 if 
len
 ( 
tok
 ) == 0 :

4343 
ikey
 = 
tok
 [ 0 ]

4344 if 
isinstance
 ( 
ikey
 , 
int
 ) :

4345 
ikey
 = 
_ustr
 ( 
tok
 [ 0 ] ) . 
strip
 ( )

4346 if 
len
 ( 
tok
 ) == 1 :

4347 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( "" , 
i
 )

4348 elif 
len
 ( 
tok
 ) == 2 and not 
isinstance
 ( 
tok
 [ 1 ] , 
ParseResults
 ) :

4349 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
tok
 [ 1 ] , 
i
 )

4351 
dictvalue
 = 
tok
 . 
copy
 ( )

4352 del 
dictvalue
 [ 0 ]

4353 if 
len
 ( 
dictvalue
 ) != 1 or ( 
isinstance
 ( 
dictvalue
 , 
ParseResults
 ) and 
dictvalue
 . 
haskeys
 ( ) ) :

4354 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
dictvalue
 , 
i
 )

4356 
tokenlist
 [ 
ikey
 ] = 
_ParseResultsWithOffset
 ( 
dictvalue
 [ 0 ] , 
i
 )

4358 if 
self
 . 
resultsName
 :

4359 return [ 
tokenlist
 ]

4361 return 
tokenlist
 
	}

4364 class 
	cSuppress
 ( 
TokenConverter
 ) :

4383 def 
	$postParse
 ( 
self
 , 
instring
 , 
loc
 , 
tokenlist
 ) :

4384 return [ ] 
	}

4386 def 
	$suppress
 ( 
self
 ) :

4387 return 
self
 
	}

4390 class 
	cOnlyOnce
 ( 
object
 ) :

4394 def 
	$__init__
 ( 
self
 , 
methodCall
 ) :

4395 
self
 . 
callable
 = 
_trim_arity
 ( 
methodCall
 )

4396 
self
 . 
called
 = False 
	}

4397 def 
	$__call__
 ( 
self
 , 
s
 , 
l
 , 
t
 ) :

4398 if not 
self
 . 
called
 :

4399 
results
 = 
self
 . 
callable
 ( 
s
 , 
l
 , 
t
 )

4400 
self
 . 
called
 = True

4401 return 
results

4402 raise 
ParseException
 ( 
s
 , 
l
 , "" ) 
	}

4403 def 
	$reset
 ( 
self
 ) :

4404 
self
 . 
called
 = False 
	}

4406 def 
	$traceParseAction
 ( 
f
 ) :

4427 
f
 = 
_trim_arity
 ( 
f
 )

4428 def 
z
 ( * 
paArgs
 ) :

4429 
thisFunc
 = 
f
 . 
__name__

4430 
s
 , 
l
 , 
t
 = 
paArgs
 [ - 3 : ]

4431 if 
len
 ( 
paArgs
 ) > 3 :

4432 
thisFunc
 = 
paArgs
 [ 0 ] . 
__class__
 . 
__name__
 + '.' + 
thisFunc

4433 
sys
 . 
stderr
 . 
write
 ( ">>entering %s(line: '%s', %d, %r)\n" % ( 
thisFunc
 , 
line
 ( 
l
 , 
s
 ) , 
l
 , 
t
 ) )

4435 
ret
 = 
f
 ( * 
paArgs
 )

4436 except 
Exception
 as 
exc
 :

4437 
sys
 . 
stderr
 . 
write
 ( "<<leaving %s (exception: %s)\n" % ( 
thisFunc
 , 
exc
 ) )

4439 
sys
 . 
stderr
 . 
write
 ( "<<leaving %s (ret: %r)\n" % ( 
thisFunc
 , 
ret
 ) )

4440 return 
ret

4442 
z
 . 
__name__
 = 
f
 . 
__name__

4443 except 
AttributeError
 :

4445 return 
z
 
	}

4450 def 
	$delimitedList
 ( 
expr
 , 
delim
 = "," , 
combine
 = False ) :

4463 
dlName
 = 
_ustr
 ( 
expr
 ) + " [" + 
_ustr
 ( 
delim
 ) + " " + 
_ustr
 ( 
expr
 ) + "]..."

4464 if 
combine
 :

4465 return 
Combine
 ( 
expr
 + 
ZeroOrMore
 ( 
delim
 + 
expr
 ) ) . 
setName
 ( 
dlName
 )

4467 return ( 
expr
 + 
ZeroOrMore
 ( 
Suppress
 ( 
delim
 ) + 
expr
 ) ) . 
setName
 ( 
dlName
 ) 
	}

4469 def 
	$countedArray
 ( 
expr
 , 
intExpr
 = None ) :

4487 
arrayExpr
 = 
Forward
 ( )

4488 def 
countFieldParseAction
 ( 
s
 , 
l
 , 
t
 ) :

4489 
n
 = 
t
 [ 0 ]

4490 
arrayExpr
 << ( 
n
 and 
Group
 ( 
And
 ( [ 
expr
 ] * 
n
 ) ) or 
Group
 ( 
empty
 ) )

4492 if 
intExpr
 is None :

4493 
intExpr
 = 
Word
 ( 
nums
 ) . 
setParseAction
 ( lambda 
t
 : 
int
 ( 
t
 [ 0 ] ) )

4495 
intExpr
 = 
intExpr
 . 
copy
 ( )

4496 
intExpr
 . 
setName
 ( "arrayLen" )

4497 
intExpr
 . 
addParseAction
 ( 
countFieldParseAction
 , 
callDuringTry
 = True )

4498 return ( 
intExpr
 + 
arrayExpr
 ) . 
setName
 ( '(len) ' + 
_ustr
 ( 
expr
 ) + '...' ) 
	}

4500 def 
	$_flatten
 ( 
L
 ) :

4501 
ret
 = [ ]

4502 for 
i
 in 
L
 :

4503 if 
isinstance
 ( 
i
 , 
list
 ) :

4504 
ret
 . 
extend
 ( 
_flatten
 ( 
i
 ) )

4506 
ret
 . 
append
 ( 
i
 )

4507 return 
ret
 
	}

4509 def 
	$matchPreviousLiteral
 ( 
expr
 ) :

4522 
rep
 = 
Forward
 ( )

4523 def 
copyTokenToRepeater
 ( 
s
 , 
l
 , 
t
 ) :

4524 if 
t
 :

4525 if 
len
 ( 
t
 ) == 1 :

4526 
rep
 << 
t
 [ 0 ]

4529 
tflat
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4530 
rep
 << 
And
 ( 
Literal
 ( 
tt
 ) for 
tt
 in 
tflat
 )

4532 
rep
 << 
Empty
 ( )

4533 
expr
 . 
addParseAction
 ( 
copyTokenToRepeater
 , 
callDuringTry
 = True )

4534 
rep
 . 
setName
 ( '(prev) ' + 
_ustr
 ( 
expr
 ) )

4535 return 
rep
 
	}

4537 def 
	$matchPreviousExpr
 ( 
expr
 ) :

4551 
rep
 = 
Forward
 ( )

4552 
e2
 = 
expr
 . 
copy
 ( )

4553 
rep
 <<= 
e2

4554 def 
copyTokenToRepeater
 ( 
s
 , 
l
 , 
t
 ) :

4555 
matchTokens
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4556 def 
mustMatchTheseTokens
 ( 
s
 , 
l
 , 
t
 ) :

4557 
theseTokens
 = 
_flatten
 ( 
t
 . 
asList
 ( ) )

4558 if 
theseTokens
 != 
matchTokens
 :

4559 raise 
ParseException
 ( "" , 0 , "" )

4560 
rep
 . 
setParseAction
 ( 
mustMatchTheseTokens
 , 
callDuringTry
 = True )

4561 
expr
 . 
addParseAction
 ( 
copyTokenToRepeater
 , 
callDuringTry
 = True )

4562 
rep
 . 
setName
 ( '(prev) ' + 
_ustr
 ( 
expr
 ) )

4563 return 
rep
 
	}

4565 def 
	$_escapeRegexRangeChars
 ( 
s
 ) :

4567 for 
c
 in r"\^-]" :

4568 
s
 = 
s
 . 
replace
 ( 
c
 , 
_bslash
 + 
c
 )

4569 
s
 = 
s
 . 
replace
 ( "\n" , r"\n" )

4570 
s
 = 
s
 . 
replace
 ( "\t" , r"\t" )

4571 return 
_ustr
 ( 
s
 ) 
	}

4573 def 
	$oneOf
 ( 
strs
 , 
caseless
 = False , 
useRegex
 = True ) :

4596 if 
caseless
 :

4597 
isequal
 = ( lambda 
a
 , 
b
 : 
a
 . 
upper
 ( ) == 
b
 . 
upper
 ( ) )

4598 
masks
 = ( lambda 
a
 , 
b
 : 
b
 . 
upper
 ( ) . 
startswith
 ( 
a
 . 
upper
 ( ) ) )

4599 
parseElementClass
 = 
CaselessLiteral

4601 
isequal
 = ( lambda 
a
 , 
b
 : 
a
 == 
b
 )

4602 
masks
 = ( lambda 
a
 , 
b
 : 
b
 . 
startswith
 ( 
a
 ) )

4603 
parseElementClass
 = 
Literal

4605 
symbols
 = [ ]

4606 if 
isinstance
 ( 
strs
 , 
basestring
 ) :

4607 
symbols
 = 
strs
 . 
split
 ( )

4608 elif 
isinstance
 ( 
strs
 , 
Iterable
 ) :

4609 
symbols
 = 
list
 ( 
strs
 )

4611 
warnings
 . 
warn
 ( "Invalid argument to oneOf, expected string or iterable" ,

4612 
SyntaxWarning
 , 
stacklevel
 = 2 )

4613 if not 
symbols
 :

4614 return 
NoMatch
 ( )

4616 
i
 = 0

4617 while 
i
 < 
len
 ( 
symbols
 ) - 1 :

4618 
cur
 = 
symbols
 [ 
i
 ]

4619 for 
j
 , 
other
 in 
enumerate
 ( 
symbols
 [ 
i
 + 1 : ] ) :

4620 if ( 
isequal
 ( 
other
 , 
cur
 ) ) :

4621 del 
symbols
 [ 
i
 + 
j
 + 1 ]

4623 elif ( 
masks
 ( 
cur
 , 
other
 ) ) :

4624 del 
symbols
 [ 
i
 + 
j
 + 1 ]

4625 
symbols
 . 
insert
 ( 
i
 , 
other
 )

4626 
cur
 = 
other

4629 
i
 += 1

4631 if not 
caseless
 and 
useRegex
 :

4634 if 
len
 ( 
symbols
 ) == 
len
 ( "" . 
join
 ( 
symbols
 ) ) :

4635 return 
Regex
 ( "[%s]" % "" . 
join
 ( 
_escapeRegexRangeChars
 ( 
sym
 ) for 
sym
 in 
symbols
 ) ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) )

4637 return 
Regex
 ( "|" . 
join
 ( 
re
 . 
escape
 ( 
sym
 ) for 
sym
 in 
symbols
 ) ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) )

4638 except 
Exception
 :

4639 
warnings
 . 
warn
 ( "Exception creating Regex for oneOf, building MatchFirst" ,

4640 
SyntaxWarning
 , 
stacklevel
 = 2 )

4644 return 
MatchFirst
 ( 
parseElementClass
 ( 
sym
 ) for 
sym
 in 
symbols
 ) . 
setName
 ( ' | ' . 
join
 ( 
symbols
 ) ) 
	}

4646 def 
	$dictOf
 ( 
key
 , 
value
 ) :

4679 return 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
key
 + 
value
 ) ) ) 
	}

4681 def 
	$originalTextFor
 ( 
expr
 , 
asString
 = True ) :

4705 
locMarker
 = 
Empty
 ( ) . 
setParseAction
 ( lambda 
s
 , 
loc
 , 
t
 : 
loc
 )

4706 
endlocMarker
 = 
locMarker
 . 
copy
 ( )

4707 
endlocMarker
 . 
callPreparse
 = False

4708 
matchExpr
 = 
locMarker
 ( "_original_start" ) + 
expr
 + 
endlocMarker
 ( "_original_end" )

4709 if 
asString
 :

4710 
extractText
 = lambda 
s
 , 
l
 , 
t
 : 
s
 [ 
t
 . 
_original_start
 : 
t
 . 
_original_end
 ]

4712 def 
extractText
 ( 
s
 , 
l
 , 
t
 ) :

4713 
t
 [ : ] = [ 
s
 [ 
t
 . 
pop
 ( '_original_start' ) : 
t
 . 
pop
 ( '_original_end' ) ] ]

4714 
matchExpr
 . 
setParseAction
 ( 
extractText
 )

4715 
matchExpr
 . 
ignoreExprs
 = 
expr
 . 
ignoreExprs

4716 return 
matchExpr
 
	}

4718 def 
	$ungroup
 ( 
expr
 ) :

4723 return 
TokenConverter
 ( 
expr
 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] ) 
	}

4725 def 
	$locatedExpr
 ( 
expr
 ) :

4745 
locator
 = 
Empty
 ( ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
l
 )

4746 return 
Group
 ( 
locator
 ( "locn_start" ) + 
expr
 ( "value" ) + 
locator
 . 
copy
 ( ) . 
leaveWhitespace
 ( ) ( "locn_end" ) ) 
	}

4750 
empty
 = 
Empty
 ( ) . 
setName
 ( "empty" )

4751 
lineStart
 = 
LineStart
 ( ) . 
setName
 ( "lineStart" )

4752 
lineEnd
 = 
LineEnd
 ( ) . 
setName
 ( "lineEnd" )

4753 
stringStart
 = 
StringStart
 ( ) . 
setName
 ( "stringStart" )

4754 
stringEnd
 = 
StringEnd
 ( ) . 
setName
 ( "stringEnd" )

4756 
_escapedPunc
 = 
Word
 ( 
_bslash
 , r"\[]-*.$+^?()~ " , 
exact
 = 2 ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] [ 1 ] )

4757 
_escapedHexChar
 = 
Regex
 ( r"\\0?[xX][0-9a-fA-F]+" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
unichr
 ( 
int
 ( 
t
 [ 0 ] . 
lstrip
 ( r'\0x' ) , 16 ) ) )

4758 
_escapedOctChar
 = 
Regex
 ( r"\\0[0-7]+" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
unichr
 ( 
int
 ( 
t
 [ 0 ] [ 1 : ] , 8 ) ) )

4759 
_singleChar
 = 
_escapedPunc
 | 
_escapedHexChar
 | 
_escapedOctChar
 | 
CharsNotIn
 ( r'\]' , 
exact
 = 1 )

4760 
_charRange
 = 
Group
 ( 
_singleChar
 + 
Suppress
 ( "-" ) + 
_singleChar
 )

4761 
_reBracketExpr
 = 
Literal
 ( "[" ) + 
Optional
 ( "^" ) . 
setResultsName
 ( "negate" ) + 
Group
 ( 
OneOrMore
 ( 
_charRange
 | 
_singleChar
 ) ) . 
setResultsName
 ( "body" ) + "]"

4763 def 
	$srange
 ( 
s
 ) :

4781 
_expanded
 = lambda 
p
 : 
p
 if not 
isinstance
 ( 
p
 , 
ParseResults
 ) else '' . 
join
 ( 
unichr
 ( 
c
 ) for 
c
 in 
range
 ( 
ord
 ( 
p
 [ 0 ] ) , 
ord
 ( 
p
 [ 1 ] ) + 1 ) )

4783 return "" . 
join
 ( 
_expanded
 ( 
part
 ) for 
part
 in 
_reBracketExpr
 . 
parseString
 ( 
s
 ) . 
body
 )

4784 except 
Exception
 :

4785 return "" 
	}

4787 def 
	$matchOnlyAtCol
 ( 
n
 ) :

4792 def 
verifyCol
 ( 
strg
 , 
locn
 , 
toks
 ) :

4793 if 
col
 ( 
locn
 , 
strg
 ) != 
n
 :

4794 raise 
ParseException
 ( 
strg
 , 
locn
 , "matched token not at column %d" % 
n
 )

4795 return 
verifyCol
 
	}

4797 def 
	$replaceWith
 ( 
replStr
 ) :

4809 return lambda 
s
 , 
l
 , 
t
 : [ 
replStr
 ] 
	}

4811 def 
	$removeQuotes
 ( 
s
 , 
l
 , 
t
 ) :

4823 return 
t
 [ 0 ] [ 1 : - 1 ] 
	}

4825 def 
	$tokenMap
 ( 
func
 , * 
args
 ) :

4857 def 
pa
 ( 
s
 , 
l
 , 
t
 ) :

4858 return [ 
func
 ( 
tokn
 , * 
args
 ) for 
tokn
 in 
t
 ]

4861 
func_name
 = 
getattr
 ( 
func
 , '__name__' ,

4862 
getattr
 ( 
func
 , '__class__' ) . 
__name__
 )

4863 except 
Exception
 :

4864 
func_name
 = 
str
 ( 
func
 )

4865 
pa
 . 
__name__
 = 
func_name

4867 return 
pa
 
	}

4869 
upcaseTokens
 = 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
upper
 ( ) ) """(Deprecated) Helper parse action to convert tokens to upper case. Deprecated in favor of L{pyparsing_common.upcaseTokens}"""

4872 
downcaseTokens
 = 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
lower
 ( ) ) """(Deprecated) Helper parse action to convert tokens to lower case. Deprecated in favor of L{pyparsing_common.downcaseTokens}"""

4875 def 
	$_makeTags
 ( 
tagStr
 , 
xml
 ) :

4877 if 
isinstance
 ( 
tagStr
 , 
basestring
 ) :

4878 
resname
 = 
tagStr

4879 
tagStr
 = 
Keyword
 ( 
tagStr
 , 
caseless
 = not 
xml
 )

4881 
resname
 = 
tagStr
 . 
name

4883 
tagAttrName
 = 
Word
 ( 
alphas
 , 
alphanums
 + "_-:" )

4884 if ( 
xml
 ) :

4885 
tagAttrValue
 = 
dblQuotedString
 . 
copy
 ( ) . 
setParseAction
 ( 
removeQuotes
 )

4886 
openTag
 = 
Suppress
 ( "<" ) + 
tagStr
 ( "tag" ) +

4887 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
tagAttrName
 + 
Suppress
 ( "=" ) + 
tagAttrValue
 ) ) ) +

4888 
Optional
 ( "/" , 
default
 = [ False ] ) . 
setResultsName
 ( "empty" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] == '/' ) + 
Suppress
 ( ">" )

4890 
printablesLessRAbrack
 = "" . 
join
 ( 
c
 for 
c
 in 
printables
 if 
c
 not in ">" )

4891 
tagAttrValue
 = 
quotedString
 . 
copy
 ( ) . 
setParseAction
 ( 
removeQuotes
 ) | 
Word
 ( 
printablesLessRAbrack
 )

4892 
openTag
 = 
Suppress
 ( "<" ) + 
tagStr
 ( "tag" ) +

4893 
Dict
 ( 
ZeroOrMore
 ( 
Group
 ( 
tagAttrName
 . 
setParseAction
 ( 
downcaseTokens
 ) +

4894 
Optional
 ( 
Suppress
 ( "=" ) + 
tagAttrValue
 ) ) ) ) +

4895 
Optional
 ( "/" , 
default
 = [ False ] ) . 
setResultsName
 ( "empty" ) . 
setParseAction
 ( lambda 
s
 , 
l
 , 
t
 : 
t
 [ 0 ] == '/' ) + 
Suppress
 ( ">" )

4896 
closeTag
 = 
Combine
 ( 
_L
 ( "</" ) + 
tagStr
 + ">" )

4898 
openTag
 = 
openTag
 . 
setResultsName
 ( "start" + "" . 
join
 ( 
resname
 . 
replace
 ( ":" , " " ) . 
title
 ( ) . 
split
 ( ) ) ) . 
setName
 ( "<%s>" % 
resname
 )

4899 
closeTag
 = 
closeTag
 . 
setResultsName
 ( "end" + "" . 
join
 ( 
resname
 . 
replace
 ( ":" , " " ) . 
title
 ( ) . 
split
 ( ) ) ) . 
setName
 ( "</%s>" % 
resname
 )

4900 
openTag
 . 
tag
 = 
resname

4901 
closeTag
 . 
tag
 = 
resname

4902 return 
openTag
 , 
closeTag
 
	}

4904 def 
	$makeHTMLTags
 ( 
tagStr
 ) :

4921 return 
_makeTags
 ( 
tagStr
 , False ) 
	}

4923 def 
	$makeXMLTags
 ( 
tagStr
 ) :

4930 return 
_makeTags
 ( 
tagStr
 , True ) 
	}

4932 def 
	$withAttribute
 ( * 
args
 , ** 
attrDict
 ) :

4982 if 
args
 :

4983 
attrs
 = 
args
 [ : ]

4985 
attrs
 = 
attrDict
 . 
items
 ( )

4986 
attrs
 = [ ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
attrs
 ]

4987 def 
pa
 ( 
s
 , 
l
 , 
tokens
 ) :

4988 for 
attrName
 , 
attrValue
 in 
attrs
 :

4989 if 
attrName
 not in 
tokens
 :

4990 raise 
ParseException
 ( 
s
 , 
l
 , "no matching attribute " + 
attrName
 )

4991 if 
attrValue
 != 
withAttribute
 . 
ANY_VALUE
 and 
tokens
 [ 
attrName
 ] != 
attrValue
 :

4992 raise 
ParseException
 ( 
s
 , 
l
 , "attribute '%s' has value '%s', must be '%s'" %

4993 ( 
attrName
 , 
tokens
 [ 
attrName
 ] , 
attrValue
 ) )

4994 return 
pa
 
	}

4995 
withAttribute
 . 
ANY_VALUE
 = 
object
 ( )

4997 def 
	$withClass
 ( 
classname
 , 
namespace
 = '' ) :

5029 
classattr
 = "%s:class" % 
namespace
 if 
namespace
 else "class"

5030 return 
withAttribute
 ( ** { 
classattr
 : 
classname
 } ) 
	}

5032 
opAssoc
 = 
_Constants
 ( )

5033 
opAssoc
 . 
LEFT
 = 
object
 ( )

5034 
opAssoc
 . 
RIGHT
 = 
object
 ( )

5036 def 
	$infixNotation
 ( 
baseExpr
 , 
opList
 , 
lpar
 = 
Suppress
 ( '(' ) , 
rpar
 = 
Suppress
 ( ')' ) ) :

5097 
ret
 = 
Forward
 ( )

5098 
lastExpr
 = 
baseExpr
 | ( 
lpar
 + 
ret
 + 
rpar
 )

5099 for 
i
 , 
operDef
 in 
enumerate
 ( 
opList
 ) :

5100 
opExpr
 , 
arity
 , 
rightLeftAssoc
 , 
pa
 = ( 
operDef
 + ( None , ) ) [ : 4 ]

5101 
termName
 = "%s term" % 
opExpr
 if 
arity
 < 3 else "%s%s term" % 
opExpr

5102 if 
arity
 == 3 :

5103 if 
opExpr
 is None or 
len
 ( 
opExpr
 ) != 2 :

5104 raise 
ValueError
 ( "if numterms=3, opExpr must be a tuple or list of two expressions" )

5105 
opExpr1
 , 
opExpr2
 = 
opExpr

5106 
thisExpr
 = 
Forward
 ( ) . 
setName
 ( 
termName
 )

5107 if 
rightLeftAssoc
 == 
opAssoc
 . 
LEFT
 :

5108 if 
arity
 == 1 :

5109 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 ) )

5110 elif 
arity
 == 2 :

5111 if 
opExpr
 is not None :

5112 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 + 
lastExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 + 
lastExpr
 ) )

5114 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
lastExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
lastExpr
 ) )

5115 elif 
arity
 == 3 :

5116 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr1
 + 
lastExpr
 + 
opExpr2
 + 
lastExpr
 ) +

5117 
Group
 ( 
lastExpr
 + 
opExpr1
 + 
lastExpr
 + 
opExpr2
 + 
lastExpr
 )

5119 raise 
ValueError
 ( "operator must be unary (1), binary (2), or ternary (3)" )

5120 elif 
rightLeftAssoc
 == 
opAssoc
 . 
RIGHT
 :

5121 if 
arity
 == 1 :

5123 if not 
isinstance
 ( 
opExpr
 , 
Optional
 ) :

5124 
opExpr
 = 
Optional
 ( 
opExpr
 )

5125 
matchExpr
 = 
FollowedBy
 ( 
opExpr
 . 
expr
 + 
thisExpr
 ) + 
Group
 ( 
opExpr
 + 
thisExpr
 )

5126 elif 
arity
 == 2 :

5127 if 
opExpr
 is not None :

5128 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr
 + 
thisExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
opExpr
 + 
thisExpr
 ) )

5130 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
thisExpr
 ) + 
Group
 ( 
lastExpr
 + 
OneOrMore
 ( 
thisExpr
 ) )

5131 elif 
arity
 == 3 :

5132 
matchExpr
 = 
FollowedBy
 ( 
lastExpr
 + 
opExpr1
 + 
thisExpr
 + 
opExpr2
 + 
thisExpr
 ) +

5133 
Group
 ( 
lastExpr
 + 
opExpr1
 + 
thisExpr
 + 
opExpr2
 + 
thisExpr
 )

5135 raise 
ValueError
 ( "operator must be unary (1), binary (2), or ternary (3)" )

5137 raise 
ValueError
 ( "operator must indicate right or left associativity" )

5138 if 
pa
 :

5139 if 
isinstance
 ( 
pa
 , ( 
tuple
 , 
list
 ) ) :

5140 
matchExpr
 . 
setParseAction
 ( * 
pa
 )

5142 
matchExpr
 . 
setParseAction
 ( 
pa
 )

5143 
thisExpr
 <<= ( 
matchExpr
 . 
setName
 ( 
termName
 ) | 
lastExpr
 )

5144 
lastExpr
 = 
thisExpr

5145 
ret
 <<= 
lastExpr

5146 return 
ret
 
	}

5148 
operatorPrecedence
 = 
infixNotation
 """(Deprecated) Former name of C{L{infixNotation}}, will be dropped in a future release."""

5151 
dblQuotedString
 = 
Combine
 ( 
Regex
 ( r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*' ) + '"' ) . 
setName
 ( "string enclosed in double quotes" )

5152 
sglQuotedString
 = 
Combine
 ( 
Regex
 ( r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*" ) + "'" ) . 
setName
 ( "string enclosed in single quotes" )

5153 
quotedString
 = 
Combine
 ( 
Regex
 ( r'"(?:[^"\n\r\\]|(?:"")|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*' ) + '"' |

5154 
Regex
 ( r"'(?:[^'\n\r\\]|(?:'')|(?:\\(?:[^x]|x[0-9a-fA-F]+)))*" ) + "'" ) . 
setName
 ( "quotedString using single or double quotes" )

5155 
unicodeString
 = 
Combine
 ( 
_L
 ( 'u' ) + 
quotedString
 . 
copy
 ( ) ) . 
setName
 ( "unicode string literal" )

5157 def 
	$nestedExpr
 ( 
opener
 = "(" , 
closer
 = ")" , 
content
 = None , 
ignoreExpr
 = 
quotedString
 . 
copy
 ( ) ) :

5215 if 
opener
 == 
closer
 :

5216 raise 
ValueError
 ( "opening and closing strings cannot be the same" )

5217 if 
content
 is None :

5218 if 
isinstance
 ( 
opener
 , 
basestring
 ) and 
isinstance
 ( 
closer
 , 
basestring
 ) :

5219 if 
len
 ( 
opener
 ) == 1 and 
len
 ( 
closer
 ) == 1 :

5220 if 
ignoreExpr
 is not None :

5221 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
ignoreExpr
 +

5222 
CharsNotIn
 ( 
opener
 + 
closer
 + 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5223 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5225 
content
 = ( 
empty
 . 
copy
 ( ) + 
CharsNotIn
 ( 
opener
 + 
closer
 + 
ParserElement
 . 
DEFAULT_WHITE_CHARS

5226 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5228 if 
ignoreExpr
 is not None :

5229 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
ignoreExpr
 +

5230 ~ 
Literal
 ( 
opener
 ) + ~ 
Literal
 ( 
closer
 ) +

5231 
CharsNotIn
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5232 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5234 
content
 = ( 
Combine
 ( 
OneOrMore
 ( ~ 
Literal
 ( 
opener
 ) + ~ 
Literal
 ( 
closer
 ) +

5235 
CharsNotIn
 ( 
ParserElement
 . 
DEFAULT_WHITE_CHARS
 , 
exact
 = 1 ) )

5236 ) . 
setParseAction
 ( lambda 
t
 : 
t
 [ 0 ] . 
strip
 ( ) ) )

5238 raise 
ValueError
 ( "opening and closing arguments must be strings if no content expression is given" )

5239 
ret
 = 
Forward
 ( )

5240 if 
ignoreExpr
 is not None :

5241 
ret
 <<= 
Group
 ( 
Suppress
 ( 
opener
 ) + 
ZeroOrMore
 ( 
ignoreExpr
 | 
ret
 | 
content
 ) + 
Suppress
 ( 
closer
 ) )

5243 
ret
 <<= 
Group
 ( 
Suppress
 ( 
opener
 ) + 
ZeroOrMore
 ( 
ret
 | 
content
 ) + 
Suppress
 ( 
closer
 ) )

5244 
ret
 . 
setName
 ( 'nested %s%s expression' % ( 
opener
 , 
closer
 ) )

5245 return 
ret
 
	}

5247 def 
	$indentedBlock
 ( 
blockStatementExpr
 , 
indentStack
 , 
indent
 = True ) :

5325 def 
checkPeerIndent
 ( 
s
 , 
l
 , 
t
 ) :

5326 if 
l
 >= 
len
 ( 
s
 ) : return

5327 
curCol
 = 
col
 ( 
l
 , 
s
 )

5328 if 
curCol
 != 
indentStack
 [ - 1 ] :

5329 if 
curCol
 > 
indentStack
 [ - 1 ] :

5330 raise 
ParseFatalException
 ( 
s
 , 
l
 , "illegal nesting" )

5331 raise 
ParseException
 ( 
s
 , 
l
 , "not a peer entry" )

5333 def 
checkSubIndent
 ( 
s
 , 
l
 , 
t
 ) :

5334 
curCol
 = 
col
 ( 
l
 , 
s
 )

5335 if 
curCol
 > 
indentStack
 [ - 1 ] :

5336 
indentStack
 . 
append
 ( 
curCol
 )

5338 raise 
ParseException
 ( 
s
 , 
l
 , "not a subentry" )

5340 def 
checkUnindent
 ( 
s
 , 
l
 , 
t
 ) :

5341 if 
l
 >= 
len
 ( 
s
 ) : return

5342 
curCol
 = 
col
 ( 
l
 , 
s
 )

5343 if not ( 
indentStack
 and 
curCol
 < 
indentStack
 [ - 1 ] and 
curCol
 <= 
indentStack
 [ - 2 ] ) :

5344 raise 
ParseException
 ( 
s
 , 
l
 , "not an unindent" )

5345 
indentStack
 . 
pop
 ( )

5347 
NL
 = 
OneOrMore
 ( 
LineEnd
 ( ) . 
setWhitespaceChars
 ( "\t " ) . 
suppress
 ( ) )

5348 
INDENT
 = ( 
Empty
 ( ) + 
Empty
 ( ) . 
setParseAction
 ( 
checkSubIndent
 ) ) . 
setName
 ( 'INDENT' )

5349 
PEER
 = 
Empty
 ( ) . 
setParseAction
 ( 
checkPeerIndent
 ) . 
setName
 ( '' )

5350 
UNDENT
 = 
Empty
 ( ) . 
setParseAction
 ( 
checkUnindent
 ) . 
setName
 ( 'UNINDENT' )

5351 if 
indent
 :

5352 
smExpr
 = 
Group
 ( 
Optional
 ( 
NL
 ) +

5354 
INDENT
 + ( 
OneOrMore
 ( 
PEER
 + 
Group
 ( 
blockStatementExpr
 ) + 
Optional
 ( 
NL
 ) ) ) + 
UNDENT
 )

5356 
smExpr
 = 
Group
 ( 
Optional
 ( 
NL
 ) +

5357 ( 
OneOrMore
 ( 
PEER
 + 
Group
 ( 
blockStatementExpr
 ) + 
Optional
 ( 
NL
 ) ) ) )

5358 
blockStatementExpr
 . 
ignore
 ( 
_bslash
 + 
LineEnd
 ( ) )

5359 return 
smExpr
 . 
setName
 ( 'indented block' ) 
	}

5361 
alphas8bit
 = 
srange
 ( r"[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]" )

5362 
punc8bit
 = 
srange
 ( r"[\0xa1-\0xbf\0xd7\0xf7]" )

5364 
anyOpenTag
 , 
anyCloseTag
 = 
makeHTMLTags
 ( 
Word
 ( 
alphas
 , 
alphanums
 + "_:" ) . 
setName
 ( 'any tag' ) )

5365 
_htmlEntityMap
 = 
dict
 ( 
zip
 ( "gt lt amp nbsp quot apos" . 
split
 ( ) , '><& "\'' ) )

5366 
commonHTMLEntity
 = 
Regex
 ( '&(?P<entity>' + '|' . 
join
 ( 
_htmlEntityMap
 . 
keys
 ( ) ) + ");" ) . 
setName
 ( "common HTML entity" )

5367 def 
	$replaceHTMLEntity
 ( 
t
 ) :

5369 return 
_htmlEntityMap
 . 
get
 ( 
t
 . 
entity
 ) 
	}

5372 
cStyleComment
 = 
Combine
 ( 
Regex
 ( r"/\*(?:[^*]|\*(?!/))*" ) + '*/' ) . 
setName
 ( "C style comment" ) "Comment of the form C{/* ... */}"

5375 
htmlComment
 = 
Regex
 ( r"<!--[\s\S]*?-->" ) . 
setName
 ( "HTML comment" ) "Comment of the form C{<!-- ... -->}"

5378 
restOfLine
 = 
Regex
 ( r".*" ) . 
leaveWhitespace
 ( ) . 
setName
 ( "rest of line" )

5379 
dblSlashComment
 = 
Regex
 ( r"//(?:\\\n|[^\n])*" ) . 
setName
 ( "// comment" ) "Comment of the form C{// ... (to end of line)}"

5382 
cppStyleComment
 = 
Combine
 ( 
Regex
 ( r"/\*(?:[^*]|\*(?!/))*" ) + '*/' | 
dblSlashComment
 ) . 
setName
 ( "C++ style comment" ) "Comment of either form C{L{cStyleComment}} or C{L{dblSlashComment}}"

5385 
javaStyleComment
 = 
cppStyleComment
 "Same as C{L{cppStyleComment}}"

5388 
pythonStyleComment
 = 
Regex
 ( r"#.*" ) . 
setName
 ( "Python style comment" ) "Comment of the form C{# ... (to end of line)}"

5391 
_commasepitem
 = 
Combine
 ( 
OneOrMore
 ( 
Word
 ( 
printables
 , 
excludeChars
 = ',' ) +

5392 
Optional
 ( 
Word
 ( " \t" ) +

5393 ~ 
Literal
 ( "," ) + ~ 
LineEnd
 ( ) ) ) ) . 
streamline
 ( ) . 
setName
 ( "commaItem" )

5394 
commaSeparatedList
 = 
delimitedList
 ( 
Optional
 ( 
quotedString
 . 
copy
 ( ) | 
_commasepitem
 , 
default
 = "" ) ) . 
setName
 ( "commaSeparatedList" ) """(Deprecated) Predefined expression of 1 or more printable words or quoted strings, separated by commas.\n   This expression is deprecated in favor of L{pyparsing_common.comma_separated_list}."""

5399 class 
	cpyparsing_common
 :

5535 
convertToInteger
 = 
tokenMap
 ( 
int
 ) """\n    Parse action for converting parsed integers to Python int\n    """

5540 
convertToFloat
 = 
tokenMap
 ( 
float
 ) """\n    Parse action for converting parsed numbers to Python float\n    """

5545 
integer
 = 
Word
 ( 
nums
 ) . 
setName
 ( "integer" ) . 
setParseAction
 ( 
convertToInteger
 ) """expression that parses an unsigned integer, returns an int"""

5548 
hex_integer
 = 
Word
 ( 
hexnums
 ) . 
setName
 ( "hex integer" ) . 
setParseAction
 ( 
tokenMap
 ( 
int
 , 16 ) ) """expression that parses a hexadecimal integer, returns an int"""

5551 
signed_integer
 = 
Regex
 ( r'[+-]?\d+' ) . 
setName
 ( "signed integer" ) . 
setParseAction
 ( 
convertToInteger
 ) """expression that parses an integer with optional leading sign, returns an int"""

5554 
fraction
 = ( 
signed_integer
 ( ) . 
setParseAction
 ( 
convertToFloat
 ) + '/' + 
signed_integer
 ( ) . 
setParseAction
 ( 
convertToFloat
 ) ) . 
setName
 ( "fraction" ) """fractional expression of an integer divided by an integer, returns a float"""

5556 
fraction
 . 
addParseAction
 ( lambda 
t
 : 
t
 [ 0 ] / 
t
 [ - 1 ] )

5558 
mixed_integer
 = ( 
fraction
 | 
signed_integer
 + 
Optional
 ( 
Optional
 ( '-' ) . 
suppress
 ( ) + 
fraction
 ) ) . 
setName
 ( "fraction or mixed integer-fraction" ) """mixed integer of the form 'integer - fraction', with optional leading integer, returns float"""

5560 
mixed_integer
 . 
addParseAction
 ( 
sum
 )

5562 
real
 = 
Regex
 ( r'[+-]?\d+\.\d*' ) . 
setName
 ( "real number" ) . 
setParseAction
 ( 
convertToFloat
 ) """expression that parses a floating point number and returns a float"""

5565 
sci_real
 = 
Regex
 ( r'[+-]?\d+([eE][+-]?\d+|\.\d*([eE][+-]?\d+)?)' ) . 
setName
 ( "real number with scientific notation" ) . 
setParseAction
 ( 
convertToFloat
 ) """expression that parses a floating point number with optional scientific notation and returns a float"""

5569 
number
 = ( 
sci_real
 | 
real
 | 
signed_integer
 ) . 
streamline
 ( ) """any numeric expression, returns the corresponding Python type"""

5572 
fnumber
 = 
Regex
 ( r'[+-]?\d+\.?\d*([eE][+-]?\d+)?' ) . 
setName
 ( "fnumber" ) . 
setParseAction
 ( 
convertToFloat
 ) """any int or real number, returned as float"""

5575 
identifier
 = 
Word
 ( 
alphas
 + '_' , 
alphanums
 + '_' ) . 
setName
 ( "identifier" ) """typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')"""

5578 
ipv4_address
 = 
Regex
 ( r'(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}' ) . 
setName
 ( "IPv4 address" ) "IPv4 address (C{0.0.0.0 - 255.255.255.255})"

5581 
_ipv6_part
 = 
Regex
 ( r'[0-9a-fA-F]{1,4}' ) . 
setName
 ( "hex_integer" )

5582 
_full_ipv6_address
 = ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * 7 ) . 
setName
 ( "full IPv6 address" )

5583 
_short_ipv6_address
 = ( 
Optional
 ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * ( 0 , 6 ) ) + "::" + 
Optional
 ( 
_ipv6_part
 + ( ':' + 
_ipv6_part
 ) * ( 0 , 6 ) ) ) . 
setName
 ( "short IPv6 address" )

5584 
_short_ipv6_address
 . 
addCondition
 ( lambda 
t
 : 
sum
 ( 1 for 
tt
 in 
t
 if 
pyparsing_common
 . 
_ipv6_part
 . 
matches
 ( 
tt
 ) ) < 8 )

5585 
_mixed_ipv6_address
 = ( "::ffff:" + 
ipv4_address
 ) . 
setName
 ( "mixed IPv6 address" )

5586 
ipv6_address
 = 
Combine
 ( ( 
_full_ipv6_address
 | 
_mixed_ipv6_address
 | 
_short_ipv6_address
 ) . 
setName
 ( "IPv6 address" ) ) . 
setName
 ( "IPv6 address" ) "IPv6 address (long, short, or mixed form)"

5589 
mac_address
 = 
Regex
 ( r'[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\1[0-9a-fA-F]{2}){4}' ) . 
setName
 ( "MAC address" ) "MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)"

5592 @ 
	`staticmethod

5593 def 
	$convertToDate
 ( 
fmt
 = "%Y-%m-%d" ) :

5607 def 
cvt_fn
 ( 
s
 , 
l
 , 
t
 ) :

5609 return 
datetime
 . 
strptime
 ( 
t
 [ 0 ] , 
fmt
 ) . 
date
 ( )

5610 except 
ValueError
 as 
ve
 :

5611 raise 
ParseException
 ( 
s
 , 
l
 , 
str
 ( 
ve
 ) )

5612 return 
cvt_fn
 
	}

5614 @ 
	`staticmethod

5615 def 
	$convertToDatetime
 ( 
fmt
 = "%Y-%m-%dT%H:%M:%S.%f" ) :

5629 def 
cvt_fn
 ( 
s
 , 
l
 , 
t
 ) :

5631 return 
datetime
 . 
strptime
 ( 
t
 [ 0 ] , 
fmt
 )

5632 except 
ValueError
 as 
ve
 :

5633 raise 
ParseException
 ( 
s
 , 
l
 , 
str
 ( 
ve
 ) )

5634 return 
cvt_fn
 
	}

5636 
iso8601_date
 = 
Regex
 ( r'(?P<year>\d{4})(?:-(?P<month>\d\d)(?:-(?P<day>\d\d))?)?' ) . 
setName
 ( "ISO8601 date" ) "ISO8601 date (C{yyyy-mm-dd})"

5639 
iso8601_datetime
 = 
Regex
 ( r'(?P<year>\d{4})-(?P<month>\d\d)-(?P<day>\d\d)[T ](?P<hour>\d\d):(?P<minute>\d\d)(:(?P<second>\d\d(\.\d*)?)?)?(?P<tz>Z|[+-]\d\d:?\d\d)?' ) . 
setName
 ( "ISO8601 datetime" ) "ISO8601 datetime (C{yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)}) - trailing seconds, milliseconds, and timezone optional; accepts separating C{'T'} or C{' '}"

5642 
uuid
 = 
Regex
 ( r'[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}' ) . 
setName
 ( "UUID" ) "UUID (C{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx})"

5645 
_html_stripper
 = 
anyOpenTag
 . 
suppress
 ( ) | 
anyCloseTag
 . 
suppress
 ( )

5646 @ 
	`staticmethod

5647 def 
	$stripHTMLTags
 ( 
s
 , 
l
 , 
tokens
 ) :

5659 return 
pyparsing_common
 . 
_html_stripper
 . 
transformString
 ( 
tokens
 [ 0 ] ) 
	}

5661 
_commasepitem
 = 
Combine
 ( 
OneOrMore
 ( ~ 
Literal
 ( "," ) + ~ 
LineEnd
 ( ) + 
Word
 ( 
printables
 , 
excludeChars
 = ',' )

5662 + 
Optional
 ( 
White
 ( " \t" ) ) ) ) . 
streamline
 ( ) . 
setName
 ( "commaItem" )

5663 
comma_separated_list
 = 
delimitedList
 ( 
Optional
 ( 
quotedString
 . 
copy
 ( ) | 
_commasepitem
 , 
default
 = "" ) ) . 
setName
 ( "comma separated list" ) """Predefined expression of 1 or more printable words or quoted strings, separated by commas."""

5666 
upcaseTokens
 = 
staticmethod
 ( 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
upper
 ( ) ) ) """Parse action to convert tokens to upper case."""

5669 
downcaseTokens
 = 
staticmethod
 ( 
tokenMap
 ( lambda 
t
 : 
_ustr
 ( 
t
 ) . 
lower
 ( ) ) ) """Parse action to convert tokens to lower case."""

5673 if 
__name__
 == "__main__" :

5675 
selectToken
 = 
CaselessLiteral
 ( "select" )

5676 
fromToken
 = 
CaselessLiteral
 ( "from" )

5678 
ident
 = 
Word
 ( 
alphas
 , 
alphanums
 + "_$" )

5680 
columnName
 = 
delimitedList
 ( 
ident
 , "." , 
combine
 = True ) . 
setParseAction
 ( 
upcaseTokens
 )

5681 
columnNameList
 = 
Group
 ( 
delimitedList
 ( 
columnName
 ) ) . 
setName
 ( "columns" )

5682 
columnSpec
 = ( '*' | 
columnNameList
 )

5684 
tableName
 = 
delimitedList
 ( 
ident
 , "." , 
combine
 = True ) . 
setParseAction
 ( 
upcaseTokens
 )

5685 
tableNameList
 = 
Group
 ( 
delimitedList
 ( 
tableName
 ) ) . 
setName
 ( "tables" )

5687 
simpleSQL
 = 
selectToken
 ( "command" ) + 
columnSpec
 ( "columns" ) + 
fromToken
 + 
tableNameList
 ( "tables" )

5690 
simpleSQL
 . 
runTests
 ( """\n        # '*' as column list and dotted table name\n        select * from SYS.XYZZY\n\n        # caseless match on "SELECT", and casts back to "select"\n        SELECT * from XYZZY, ABC\n\n        # list of column names, and mixed case SELECT keyword\n        Select AA,BB,CC from Sys.dual\n\n        # multiple tables\n        Select A, B, C from Sys.dual, Table2\n\n        # invalid SELECT keyword - should fail\n        Xelect A, B, C from Sys.dual\n\n        # incomplete command - should fail\n        Select\n\n        # invalid column name - should fail\n        Select ^^^ frox Sys.dual\n\n        """

5714 
pyparsing_common
 . 
number
 . 
runTests
 ( """\n        100\n        -100\n        +100\n        3.14159\n        6.02e23\n        1e-12\n        """

5724 
pyparsing_common
 . 
fnumber
 . 
runTests
 ( """\n        100\n        -100\n        +100\n        3.14159\n        6.02e23\n        1e-12\n        """

5733 
pyparsing_common
 . 
hex_integer
 . 
runTests
 ( """\n        100\n        FF\n        """

5738 import 
	~uuid

5739 
pyparsing_common
 . 
uuid
 . 
setParseAction
 ( 
tokenMap
 ( 
uuid
 . 
UUID
 ) )

5740 
pyparsing_common
 . 
uuid
 . 
runTests
 ( """\n        12345678-1234-5678-1234-567812345678\n        """


	@./env/lib/python3.7/site-packages/setuptools/config.py

1 from 
	~__future__
 import 
absolute_import
 , 
unicode_literals

2 import 
	~io

3 import 
	~os

4 import 
	~sys

6 import 
	~warnings

7 import 
	~functools

8 from 
	~collections
 import 
defaultdict

9 from 
	~functools
 import 
partial

10 from 
	~functools
 import 
wraps

11 from 
	~importlib
 import 
import_module

13 from 
	~distutils.errors
 import 
DistutilsOptionError
 , 
DistutilsFileError

14 from 
	~setuptools.extern.packaging.version
 import 
LegacyVersion
 , 
parse

15 from 
	~setuptools.extern.six
 import 
string_types
 , 
PY3

18 
__metaclass__
 = 
type

21 def 
	$read_configuration
 (

22 
filepath
 , 
find_others
 = False , 
ignore_option_errors
 = False ) :

38 from 
	~setuptools.dist
 import 
Distribution
 , 
_Distribution

40 
filepath
 = 
os
 . 
path
 . 
abspath
 ( 
filepath
 )

42 if not 
os
 . 
path
 . 
isfile
 ( 
filepath
 ) :

43 raise 
DistutilsFileError
 ( 'Configuration file %s does not exist.'

44 % 
filepath
 )

46 
current_directory
 = 
os
 . 
getcwd
 ( )

47 
os
 . 
chdir
 ( 
os
 . 
path
 . 
dirname
 ( 
filepath
 ) )

50 
dist
 = 
Distribution
 ( )

52 
filenames
 = 
dist
 . 
find_config_files
 ( ) if 
find_others
 else [ ]

53 if 
filepath
 not in 
filenames
 :

54 
filenames
 . 
append
 ( 
filepath
 )

56 
_Distribution
 . 
parse_config_files
 ( 
dist
 , 
filenames
 = 
filenames
 )

58 
handlers
 = 
parse_configuration
 (

59 
dist
 , 
dist
 . 
command_options
 ,

60 
ignore_option_errors
 = 
ignore_option_errors
 )

63 
os
 . 
chdir
 ( 
current_directory
 )

65 return 
configuration_to_dict
 ( 
handlers
 ) 
	}

68 def 
	$_get_option
 ( 
target_obj
 , 
key
 ) :

74 
getter_name
 = 'get_{key}' . 
format
 ( ** 
locals
 ( ) )

75 
by_attribute
 = 
functools
 . 
partial
 ( 
getattr
 , 
target_obj
 , 
key
 )

76 
getter
 = 
getattr
 ( 
target_obj
 , 
getter_name
 , 
by_attribute
 )

77 return 
getter
 ( ) 
	}

80 def 
	$configuration_to_dict
 ( 
handlers
 ) :

88 
config_dict
 = 
defaultdict
 ( 
dict
 )

90 for 
handler
 in 
handlers
 :

91 for 
option
 in 
handler
 . 
set_options
 :

92 
value
 = 
_get_option
 ( 
handler
 . 
target_obj
 , 
option
 )

93 
config_dict
 [ 
handler
 . 
section_prefix
 ] [ 
option
 ] = 
value

95 return 
config_dict
 
	}

98 def 
	$parse_configuration
 (

99 
distribution
 , 
command_options
 , 
ignore_option_errors
 = False ) :

113 
options
 = 
ConfigOptionsHandler
 (

114 
distribution
 , 
command_options
 , 
ignore_option_errors
 )

115 
options
 . 
parse
 ( )

117 
meta
 = 
ConfigMetadataHandler
 (

118 
distribution
 . 
metadata
 , 
command_options
 , 
ignore_option_errors
 ,

119 
distribution
 . 
package_dir
 )

120 
meta
 . 
parse
 ( )

122 return 
meta
 , 
options
 
	}

125 class 
	cConfigHandler
 :

128 
section_prefix
 = None """Prefix for config sections handled by this handler.\n    Must be provided by class heirs.\n\n    """

134 
aliases
 = { } """Options aliases.\n    For compatibility with various packages. E.g.: d2to1 and pbr.\n    Note: `-` in keys is replaced with `_` by config parser.\n\n    """

141 def 
	$__init__
 ( 
self
 , 
target_obj
 , 
options
 , 
ignore_option_errors
 = False ) :

142 
sections
 = { }

144 
section_prefix
 = 
self
 . 
section_prefix

145 for 
section_name
 , 
section_options
 in 
options
 . 
items
 ( ) :

146 if not 
section_name
 . 
startswith
 ( 
section_prefix
 ) :

149 
section_name
 = 
section_name
 . 
replace
 ( 
section_prefix
 , '' ) . 
strip
 ( '.' )

150 
sections
 [ 
section_name
 ] = 
section_options

152 
self
 . 
ignore_option_errors
 = 
ignore_option_errors

153 
self
 . 
target_obj
 = 
target_obj

154 
self
 . 
sections
 = 
sections

155 
self
 . 
set_options
 = [ ] 
	}

157 @ 
property

158 def 
	$parsers
 ( 
self
 ) :

160 raise 
NotImplementedError
 ( '%s must provide .parsers property'

161 % 
self
 . 
__class__
 . 
__name__
 ) 
	}

163 def 
	$__setitem__
 ( 
self
 , 
option_name
 , 
value
 ) :

164 
unknown
 = 
tuple
 ( )

165 
target_obj
 = 
self
 . 
target_obj

168 
option_name
 = 
self
 . 
aliases
 . 
get
 ( 
option_name
 , 
option_name
 )

170 
current_value
 = 
getattr
 ( 
target_obj
 , 
option_name
 , 
unknown
 )

172 if 
current_value
 is 
unknown
 :

173 raise 
KeyError
 ( 
option_name
 )

175 if 
current_value
 :

179 
skip_option
 = False

180 
parser
 = 
self
 . 
parsers
 . 
get
 ( 
option_name
 )

181 if 
parser
 :

183 
value
 = 
parser
 ( 
value
 )

185 except 
Exception
 :

186 
skip_option
 = True

187 if not 
self
 . 
ignore_option_errors
 :

190 if 
skip_option
 :

193 
setter
 = 
getattr
 ( 
target_obj
 , 'set_%s' % 
option_name
 , None )

194 if 
setter
 is None :

195 
setattr
 ( 
target_obj
 , 
option_name
 , 
value
 )

197 
setter
 ( 
value
 )

199 
self
 . 
set_options
 . 
append
 ( 
option_name
 ) 
	}

201 @ 
classmethod

202 def 
	$_parse_list
 ( 
cls
 , 
value
 , 
separator
 = ',' ) :

211 if 
isinstance
 ( 
value
 , 
list
 ) :

212 return 
value

214 if '\n' in 
value
 :

215 
value
 = 
value
 . 
splitlines
 ( )

217 
value
 = 
value
 . 
split
 ( 
separator
 )

219 return [ 
chunk
 . 
strip
 ( ) for 
chunk
 in 
value
 if 
chunk
 . 
strip
 ( ) ] 
	}

221 @ 
classmethod

222 def 
	$_parse_dict
 ( 
cls
 , 
value
 ) :

228 
separator
 = '='

229 
result
 = { }

230 for 
line
 in 
cls
 . 
_parse_list
 ( 
value
 ) :

231 
key
 , 
sep
 , 
val
 = 
line
 . 
partition
 ( 
separator
 )

232 if 
sep
 != 
separator
 :

233 raise 
DistutilsOptionError
 ( 'Unable to parse option value to dict: %s'

234 % 
value
 )

235 
result
 [ 
key
 . 
strip
 ( ) ] = 
val
 . 
strip
 ( )

237 return 
result
 
	}

239 @ 
classmethod

240 def 
	$_parse_bool
 ( 
cls
 , 
value
 ) :

246 
value
 = 
value
 . 
lower
 ( )

247 return 
value
 in ( '1' , 'true' , 'yes' ) 
	}

249 @ 
classmethod

250 def 
	$_exclude_files_parser
 ( 
cls
 , 
key
 ) :

260 def 
parser
 ( 
value
 ) :

261 
exclude_directive
 = 'file:'

262 if 
value
 . 
startswith
 ( 
exclude_directive
 ) :

263 raise 
ValueError
 ( 'Only strings are accepted for the {0} field, ' 'files are not accepted'

265 . 
format
 ( 
key
 ) )

266 return 
value

267 return 
parser
 
	}

269 @ 
classmethod

270 def 
	$_parse_file
 ( 
cls
 , 
value
 ) :

283 
include_directive
 = 'file:'

285 if not 
isinstance
 ( 
value
 , 
string_types
 ) :

286 return 
value

288 if not 
value
 . 
startswith
 ( 
include_directive
 ) :

289 return 
value

291 
spec
 = 
value
 [ 
len
 ( 
include_directive
 ) : ]

292 
filepaths
 = ( 
os
 . 
path
 . 
abspath
 ( 
path
 . 
strip
 ( ) ) for 
path
 in 
spec
 . 
split
 ( ',' ) )

293 return '\n' . 
join
 (

294 
cls
 . 
_read_file
 ( 
path
 )

295 for 
path
 in 
filepaths

296 if ( 
cls
 . 
_assert_local
 ( 
path
 ) or True )

297 and 
os
 . 
path
 . 
isfile
 ( 
path
 )

298 ) 
	}

300 @ 
	`staticmethod

301 def 
	$_assert_local
 ( 
filepath
 ) :

302 if not 
filepath
 . 
startswith
 ( 
os
 . 
getcwd
 ( ) ) :

303 raise 
DistutilsOptionError
 ( '`file:` directive can not access %s'

304 % 
filepath
 ) 
	}

306 @ 
	`staticmethod

307 def 
	$_read_file
 ( 
filepath
 ) :

308 with 
io
 . 
open
 ( 
filepath
 , 
encoding
 = 'utf-8' ) as 
f
 :

309 return 
f
 . 
read
 ( ) 
	}

311 @ 
classmethod

312 def 
	$_parse_attr
 ( 
cls
 , 
value
 , 
package_dir
 = None ) :

322 
attr_directive
 = 'attr:'

323 if not 
value
 . 
startswith
 ( 
attr_directive
 ) :

324 return 
value

326 
attrs_path
 = 
value
 . 
replace
 ( 
attr_directive
 , '' ) . 
strip
 ( ) . 
split
 ( '.' )

327 
attr_name
 = 
attrs_path
 . 
pop
 ( )

329 
module_name
 = '.' . 
join
 ( 
attrs_path
 )

330 
module_name
 = 
module_name
 or '__init__'

332 
parent_path
 = 
os
 . 
getcwd
 ( )

333 if 
package_dir
 :

334 if 
attrs_path
 [ 0 ] in 
package_dir
 :

336 
custom_path
 = 
package_dir
 [ 
attrs_path
 [ 0 ] ]

337 
parts
 = 
custom_path
 . 
rsplit
 ( '/' , 1 )

338 if 
len
 ( 
parts
 ) > 1 :

339 
parent_path
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
getcwd
 ( ) , 
parts
 [ 0 ] )

340 
module_name
 = 
parts
 [ 1 ]

342 
module_name
 = 
custom_path

343 elif '' in 
package_dir
 :

345 
parent_path
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
getcwd
 ( ) , 
package_dir
 [ '' ] )

346 
sys
 . 
path
 . 
insert
 ( 0 , 
parent_path
 )

348 
module
 = 
import_module
 ( 
module_name
 )

349 
value
 = 
getattr
 ( 
module
 , 
attr_name
 )

352 
sys
 . 
path
 = 
sys
 . 
path
 [ 1 : ]

354 return 
value
 
	}

356 @ 
classmethod

357 def 
	$_get_parser_compound
 ( 
cls
 , * 
parse_methods
 ) :

365 def 
parse
 ( 
value
 ) :

366 
parsed
 = 
value

368 for 
method
 in 
parse_methods
 :

369 
parsed
 = 
method
 ( 
parsed
 )

371 return 
parsed

373 return 
parse
 
	}

375 @ 
classmethod

376 def 
	$_parse_section_to_dict
 ( 
cls
 , 
section_options
 , 
values_parser
 = None ) :

385 
value
 = { }

386 
values_parser
 = 
values_parser
 or ( lambda 
val
 : 
val
 )

387 for 
key
 , ( 
_
 , 
val
 ) in 
section_options
 . 
items
 ( ) :

388 
value
 [ 
key
 ] = 
values_parser
 ( 
val
 )

389 return 
value
 
	}

391 def 
	$parse_section
 ( 
self
 , 
section_options
 ) :

396 for ( 
name
 , ( 
_
 , 
value
 ) ) in 
section_options
 . 
items
 ( ) :

398 
self
 [ 
name
 ] = 
value

400 except 
KeyError
 :

401 pass 
	}

403 def 
	$parse
 ( 
self
 ) :

408 for 
section_name
 , 
section_options
 in 
self
 . 
sections
 . 
items
 ( ) :

410 
method_postfix
 = ''

411 if 
section_name
 :

412 
method_postfix
 = '_%s' % 
section_name

414 
section_parser_method
 = 
getattr
 (

415 
self
 ,

417 ( 'parse_section%s' % 
method_postfix
 ) . 
replace
 ( '.' , '__' ) ,

420 if 
section_parser_method
 is None :

421 raise 
DistutilsOptionError
 ( 'Unsupported distribution option section: [%s.%s]'

423 
self
 . 
section_prefix
 , 
section_name
 ) )

425 
section_parser_method
 ( 
section_options
 ) 
	}

427 def 
	$_deprecated_config_handler
 ( 
self
 , 
func
 , 
msg
 , 
warning_class
 ) :

434 @ 
	`wraps
 ( 
func
 )

435 def 
config_handler
 ( * 
args
 , ** 
kwargs
 ) :

436 
warnings
 . 
warn
 ( 
msg
 , 
warning_class
 )

437 return 
func
 ( * 
args
 , ** 
kwargs
 )

439 return 
config_handler
 
	}

442 class 
	cConfigMetadataHandler
 ( 
ConfigHandler
 ) :

444 
section_prefix
 = 'metadata'

446 
aliases
 = { 'home_page'

453 
strict_mode
 = False """We need to keep it loose, to be partially compatible with\n    `pbr` and `d2to1` packages which also uses `metadata` section.\n\n    """

459 def 
	$__init__
 ( 
self
 , 
target_obj
 , 
options
 , 
ignore_option_errors
 = False ,

460 
package_dir
 = None ) :

461 
super
 ( 
ConfigMetadataHandler
 , 
self
 ) . 
__init__
 ( 
target_obj
 , 
options
 ,

462 
ignore_option_errors
 )

463 
self
 . 
package_dir
 = 
package_dir
 
	}

465 @ 
property

466 def 
	$parsers
 ( 
self
 ) :

468 
parse_list
 = 
self
 . 
_parse_list

469 
parse_file
 = 
self
 . 
_parse_file

470 
parse_dict
 = 
self
 . 
_parse_dict

471 
exclude_files_parser
 = 
self
 . 
_exclude_files_parser

474 : 
parse_list
 , 'keywords'

475 : 
parse_list
 , 'provides'

476 : 
parse_list
 , 'requires'

477 : 
self
 . 
_deprecated_config_handler
 (

478 
parse_list
 , "The requires parameter is deprecated, please use " "install_requires for runtime dependencies."

481 
DeprecationWarning
 ) , 'obsoletes'

482 : 
parse_list
 , 'classifiers'

483 : 
self
 . 
_get_parser_compound
 ( 
parse_file
 , 
parse_list
 ) , 'license'

484 : 
exclude_files_parser
 ( 'license' ) , 'description'

485 : 
parse_file
 , 'long_description'

486 : 
parse_file
 , 'version'

487 : 
self
 . 
_parse_version
 , 'project_urls'

488 : 
parse_dict
 ,

489 } 
	}

491 def 
	$_parse_version
 ( 
self
 , 
value
 ) :

498 
version
 = 
self
 . 
_parse_file
 ( 
value
 )

500 if 
version
 != 
value
 :

501 
version
 = 
version
 . 
strip
 ( )

504 if 
isinstance
 ( 
parse
 ( 
version
 ) , 
LegacyVersion
 ) :

505 
tmpl
 = ( 'Version loaded from {value} does not ' 'comply with PEP 440: {version}'

509 raise 
DistutilsOptionError
 ( 
tmpl
 . 
format
 ( ** 
locals
 ( ) ) )

511 return 
version

513 
version
 = 
self
 . 
_parse_attr
 ( 
value
 , 
self
 . 
package_dir
 )

515 if 
callable
 ( 
version
 ) :

516 
version
 = 
version
 ( )

518 if not 
isinstance
 ( 
version
 , 
string_types
 ) :

519 if 
hasattr
 ( 
version
 , '__iter__' ) :

520 
version
 = '.' . 
join
 ( 
map
 ( 
str
 , 
version
 ) )

522 
version
 = '%s' % 
version

524 return 
version
 
	}

527 class 
	cConfigOptionsHandler
 ( 
ConfigHandler
 ) :

529 
section_prefix
 = 'options'

531 @ 
property

532 def 
	$parsers
 ( 
self
 ) :

534 
parse_list
 = 
self
 . 
_parse_list

535 
parse_list_semicolon
 = 
partial
 ( 
self
 . 
_parse_list
 , 
separator
 = ';' )

536 
parse_bool
 = 
self
 . 
_parse_bool

537 
parse_dict
 = 
self
 . 
_parse_dict

540 : 
parse_bool
 , 'use_2to3'

541 : 
parse_bool
 , 'include_package_data'

542 : 
parse_bool
 , 'package_dir'

543 : 
parse_dict
 , 'use_2to3_fixers'

544 : 
parse_list
 , 'use_2to3_exclude_fixers'

545 : 
parse_list
 , 'convert_2to3_doctests'

546 : 
parse_list
 , 'scripts'

547 : 
parse_list
 , 'eager_resources'

548 : 
parse_list
 , 'dependency_links'

549 : 
parse_list
 , 'namespace_packages'

550 : 
parse_list
 , 'install_requires'

551 : 
parse_list_semicolon
 , 'setup_requires'

552 : 
parse_list_semicolon
 , 'tests_require'

553 : 
parse_list_semicolon
 , 'packages'

554 : 
self
 . 
_parse_packages
 , 'entry_points'

555 : 
self
 . 
_parse_file
 , 'py_modules'

556 : 
parse_list
 ,

557 } 
	}

559 def 
	$_parse_packages
 ( 
self
 , 
value
 ) :

565 
find_directives
 = [ 'find:' , 'find_namespace:' ]

566 
trimmed_value
 = 
value
 . 
strip
 ( )

568 if 
trimmed_value
 not in 
find_directives
 :

569 return 
self
 . 
_parse_list
 ( 
value
 )

571 
findns
 = 
trimmed_value
 == 
find_directives
 [ 1 ]

572 if 
findns
 and not 
PY3
 :

573 raise 
DistutilsOptionError
 ( 'find_namespace: directive is unsupported on Python < 3.3'

577 
find_kwargs
 = 
self
 . 
parse_section_packages__find
 (

578 
self
 . 
sections
 . 
get
 ( 'packages.find' , { } ) )

580 if 
findns
 :

581 from 
	~setuptools
 import 
find_namespace_packages
 as 
find_packages

583 from 
	~setuptools
 import 
find_packages

585 return 
find_packages
 ( ** 
find_kwargs
 ) 
	}

587 def 
	$parse_section_packages__find
 ( 
self
 , 
section_options
 ) :

594 
section_data
 = 
self
 . 
_parse_section_to_dict
 (

595 
section_options
 , 
self
 . 
_parse_list
 )

597 
valid_keys
 = [ 'where' , 'include' , 'exclude' ]

599 
find_kwargs
 = 
dict
 (

600 [ ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
section_data
 . 
items
 ( ) if 
k
 in 
valid_keys
 and 
v
 ] )

602 
where
 = 
find_kwargs
 . 
get
 ( 'where' )

603 if 
where
 is not None :

604 
find_kwargs
 [ 'where' ] = 
where
 [ 0 ]

606 return 
find_kwargs
 
	}

608 def 
	$parse_section_entry_points
 ( 
self
 , 
section_options
 ) :

613 
parsed
 = 
self
 . 
_parse_section_to_dict
 ( 
section_options
 , 
self
 . 
_parse_list
 )

614 
self
 [ 'entry_points' ] = 
parsed
 
	}

616 def 
	$_parse_package_data
 ( 
self
 , 
section_options
 ) :

617 
parsed
 = 
self
 . 
_parse_section_to_dict
 ( 
section_options
 , 
self
 . 
_parse_list
 )

619 
root
 = 
parsed
 . 
get
 ( '*' )

620 if 
root
 :

621 
parsed
 [ '' ] = 
root

622 del 
parsed
 [ '*' ]

624 return 
parsed
 
	}

626 def 
	$parse_section_package_data
 ( 
self
 , 
section_options
 ) :

631 
self
 [ 'package_data' ] = 
self
 . 
_parse_package_data
 ( 
section_options
 ) 
	}

633 def 
	$parse_section_exclude_package_data
 ( 
self
 , 
section_options
 ) :

638 
self
 [ 'exclude_package_data' ] = 
self
 . 
_parse_package_data
 (

639 
section_options
 ) 
	}

641 def 
	$parse_section_extras_require
 ( 
self
 , 
section_options
 ) :

646 
parse_list
 = 
partial
 ( 
self
 . 
_parse_list
 , 
separator
 = ';' )

647 
self
 [ 'extras_require' ] = 
self
 . 
_parse_section_to_dict
 (

648 
section_options
 , 
parse_list
 ) 
	}

650 def 
	$parse_section_data_files
 ( 
self
 , 
section_options
 ) :

655 
parsed
 = 
self
 . 
_parse_section_to_dict
 ( 
section_options
 , 
self
 . 
_parse_list
 )

656 
self
 [ 'data_files' ] = [ ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
parsed
 . 
items
 ( ) ] 
	}


	@./env/lib/python3.7/site-packages/setuptools/extern/__init__.py

1 import 
	~sys

4 class 
	cVendorImporter
 :

10 def 
	$__init__
 ( 
self
 , 
root_name
 , 
vendored_names
 = ( ) , 
vendor_pkg
 = None ) :

11 
self
 . 
root_name
 = 
root_name

12 
self
 . 
vendored_names
 = 
set
 ( 
vendored_names
 )

13 
self
 . 
vendor_pkg
 = 
vendor_pkg
 or 
root_name
 . 
replace
 ( 'extern' , '_vendor' ) 
	}

15 @ 
property

16 def 
	$search_path
 ( 
self
 ) :

20 yield 
self
 . 
vendor_pkg
 + '.'

21 yield '' 
	}

23 def 
	$find_module
 ( 
self
 , 
fullname
 , 
path
 = None ) :

28 
root
 , 
base
 , 
target
 = 
fullname
 . 
partition
 ( 
self
 . 
root_name
 + '.' )

29 if 
root
 :

31 if not 
any
 ( 
map
 ( 
target
 . 
startswith
 , 
self
 . 
vendored_names
 ) ) :

33 return 
self
 
	}

35 def 
	$load_module
 ( 
self
 , 
fullname
 ) :

39 
root
 , 
base
 , 
target
 = 
fullname
 . 
partition
 ( 
self
 . 
root_name
 + '.' )

40 for 
prefix
 in 
self
 . 
search_path
 :

42 
extant
 = 
prefix
 + 
target

43 
__import__
 ( 
extant
 )

44 
mod
 = 
sys
 . 
modules
 [ 
extant
 ]

45 
sys
 . 
modules
 [ 
fullname
 ] = 
mod

51 if 
sys
 . 
version_info
 >= ( 3 , ) :

52 del 
sys
 . 
modules
 [ 
extant
 ]

53 return 
mod

54 except 
ImportError
 :

57 raise 
ImportError
 ( "The '{target}' package is required; " "normally this is bundled with this package so if you get " "this warning, consult the packager of your " "distribution."

61 . 
format
 ( ** 
locals
 ( ) )

62 ) 
	}

64 def 
	$install
 ( 
self
 ) :

68 if 
self
 not in 
sys
 . 
meta_path
 :

69 
sys
 . 
meta_path
 . 
append
 ( 
self
 ) 
	}

72 
names
 = 'six' , 'packaging' , 'pyparsing' ,

73 
VendorImporter
 ( 
__name__
 , 
names
 , 'setuptools._vendor' ) . 
install
 ( )


	@./env/lib/python3.7/site-packages/setuptools/py27compat.py

5 import 
	~platform

7 from 
	~setuptools.extern
 import 
six

10 def 
	$get_all_headers
 ( 
message
 , 
key
 ) :

14 return 
message
 . 
get_all
 ( 
key
 ) 
	}

17 if 
six
 . 
PY2
 :

18 def 
	$get_all_headers
 ( 
message
 , 
key
 ) :

19 return 
message
 . 
getheaders
 ( 
key
 ) 
	}

22 
linux_py2_ascii
 = (

23 
platform
 . 
system
 ( ) == 'Linux' and

24 
six
 . 
PY2

27 
rmtree_safe
 = 
str
 if 
linux_py2_ascii
 else lambda 
x
 : 
x
 """Workaround for http://bugs.python.org/issue24672"""


	@./env/lib/python3.7/site-packages/setuptools/pep425tags.py

4 from 
	~__future__
 import 
absolute_import

6 import 
	~distutils.util

7 from 
	~distutils
 import 
log

8 import 
	~platform

9 import 
	~re

10 import 
	~sys

11 import 
	~sysconfig

12 import 
	~warnings

13 from 
	~collections
 import 
OrderedDict

15 from . 
	~extern
 import 
six

17 from . import 
glibc

19 
_osx_arch_pat
 = 
re
 . 
compile
 ( r'(.+)_(\d+)_(\d+)_(.+)' )

22 def 
	$get_config_var
 ( 
var
 ) :

24 return 
sysconfig
 . 
get_config_var
 ( 
var
 )

25 except 
IOError
 as 
e
 :

26 
warnings
 . 
warn
 ( "{}" . 
format
 ( 
e
 ) , 
RuntimeWarning
 )

27 return None 
	}

30 def 
	$get_abbr_impl
 ( ) :

32 if 
hasattr
 ( 
sys
 , 'pypy_version_info' ) :

33 
pyimpl
 = 'pp'

34 elif 
sys
 . 
platform
 . 
startswith
 ( 'java' ) :

35 
pyimpl
 = 'jy'

36 elif 
sys
 . 
platform
 == 'cli' :

37 
pyimpl
 = 'ip'

39 
pyimpl
 = 'cp'

40 return 
pyimpl
 
	}

43 def 
	$get_impl_ver
 ( ) :

45 
impl_ver
 = 
get_config_var
 ( "py_version_nodot" )

46 if not 
impl_ver
 or 
get_abbr_impl
 ( ) == 'pp' :

47 
impl_ver
 = '' . 
join
 ( 
map
 ( 
str
 , 
get_impl_version_info
 ( ) ) )

48 return 
impl_ver
 
	}

51 def 
	$get_impl_version_info
 ( ) :

54 if 
get_abbr_impl
 ( ) == 'pp' :

56 return ( 
sys
 . 
version_info
 [ 0 ] , 
sys
 . 
pypy_version_info
 . 
major
 ,

57 
sys
 . 
pypy_version_info
 . 
minor
 )

59 return 
sys
 . 
version_info
 [ 0 ] , 
sys
 . 
version_info
 [ 1 ] 
	}

62 def 
	$get_impl_tag
 ( ) :

66 return "{}{}" . 
format
 ( 
get_abbr_impl
 ( ) , 
get_impl_ver
 ( ) ) 
	}

69 def 
	$get_flag
 ( 
var
 , 
fallback
 , 
expected
 = True , 
warn
 = True ) :

72 
val
 = 
get_config_var
 ( 
var
 )

73 if 
val
 is None :

74 if 
warn
 :

75 
log
 . 
debug
 ( "Config variable '%s' is unset, Python ABI tag may " "be incorrect"

76 , 
var
 )

77 return 
fallback
 ( )

78 return 
val
 == 
expected
 
	}

81 def 
	$get_abi_tag
 ( ) :

84 
soabi
 = 
get_config_var
 ( 'SOABI' )

85 
impl
 = 
get_abbr_impl
 ( )

86 if not 
soabi
 and 
impl
 in { 'cp' , 'pp' } and 
hasattr
 ( 
sys
 , 'maxunicode' ) :

87 
d
 = ''

88 
m
 = ''

89 
u
 = ''

90 if 
get_flag
 ( 'Py_DEBUG' ,

91 lambda : 
hasattr
 ( 
sys
 , 'gettotalrefcount' ) ,

92 
warn
 = ( 
impl
 == 'cp' ) ) :

93 
d
 = 'd'

94 if 
get_flag
 ( 'WITH_PYMALLOC' ,

95 lambda : 
impl
 == 'cp' ,

96 
warn
 = ( 
impl
 == 'cp' ) ) :

97 
m
 = 'm'

98 if 
get_flag
 ( 'Py_UNICODE_SIZE' ,

99 lambda : 
sys
 . 
maxunicode
 == 0x10ffff ,

100 
expected
 = 4 ,

101 
warn
 = ( 
impl
 == 'cp' and

102 
six
 . 
PY2
 ) )

103 and 
six
 . 
PY2
 :

104 
u
 = 'u'

105 
abi
 = '%s%s%s%s%s' % ( 
impl
 , 
get_impl_ver
 ( ) , 
d
 , 
m
 , 
u
 )

106 elif 
soabi
 and 
soabi
 . 
startswith
 ( 'cpython-' ) :

107 
abi
 = 'cp' + 
soabi
 . 
split
 ( '-' ) [ 1 ]

108 elif 
soabi
 :

109 
abi
 = 
soabi
 . 
replace
 ( '.' , '_' ) . 
replace
 ( '-' , '_' )

111 
abi
 = None

112 return 
abi
 
	}

115 def 
	$_is_running_32bit
 ( ) :

116 return 
sys
 . 
maxsize
 == 2147483647 
	}

119 def 
	$get_platform
 ( ) :

121 if 
sys
 . 
platform
 == 'darwin' :

125 
release
 , 
_
 , 
machine
 = 
platform
 . 
mac_ver
 ( )

126 
split_ver
 = 
release
 . 
split
 ( '.' )

128 if 
machine
 == "x86_64" and 
_is_running_32bit
 ( ) :

129 
machine
 = "i386"

130 elif 
machine
 == "ppc64" and 
_is_running_32bit
 ( ) :

131 
machine
 = "ppc"

133 return 'macosx_{}_{}_{}' . 
format
 ( 
split_ver
 [ 0 ] , 
split_ver
 [ 1 ] , 
machine
 )

136 
result
 = 
distutils
 . 
util
 . 
get_platform
 ( ) . 
replace
 ( '.' , '_' ) . 
replace
 ( '-' , '_' )

137 if 
result
 == "linux_x86_64" and 
_is_running_32bit
 ( ) :

140 
result
 = "linux_i686"

142 return 
result
 
	}

145 def 
	$is_manylinux1_compatible
 ( ) :

147 if 
get_platform
 ( ) not in { "linux_x86_64" , "linux_i686" } :

152 import 
	~_manylinux

153 return 
bool
 ( 
_manylinux
 . 
manylinux1_compatible
 )

154 except ( 
ImportError
 , 
AttributeError
 ) :

159 return 
glibc
 . 
have_compatible_glibc
 ( 2 , 5 ) 
	}

162 def 
	$get_darwin_arches
 ( 
major
 , 
minor
 , 
machine
 ) :

166 
arches
 = [ ]

168 def 
_supports_arch
 ( 
major
 , 
minor
 , 
arch
 ) :

190 if 
arch
 == 'ppc' :

191 return ( 
major
 , 
minor
 ) <= ( 10 , 5 )

192 if 
arch
 == 'ppc64' :

193 return ( 
major
 , 
minor
 ) == ( 10 , 5 )

194 if 
arch
 == 'i386' :

195 return ( 
major
 , 
minor
 ) >= ( 10 , 4 )

196 if 
arch
 == 'x86_64' :

197 return ( 
major
 , 
minor
 ) >= ( 10 , 5 )

198 if 
arch
 in 
groups
 :

199 for 
garch
 in 
groups
 [ 
arch
 ] :

200 if 
_supports_arch
 ( 
major
 , 
minor
 , 
garch
 ) :

204 
groups
 = 
OrderedDict
 ( [

211 if 
_supports_arch
 ( 
major
 , 
minor
 , 
machine
 ) :

212 
arches
 . 
append
 ( 
machine
 )

214 for 
garch
 in 
groups
 :

215 if 
machine
 in 
groups
 [ 
garch
 ] and 
_supports_arch
 ( 
major
 , 
minor
 , 
garch
 ) :

216 
arches
 . 
append
 ( 
garch
 )

218 
arches
 . 
append
 ( 'universal' )

220 return 
arches
 
	}

223 def 
	$get_supported
 ( 
versions
 = None , 
noarch
 = False , 
platform
 = None ,

224 
impl
 = None , 
abi
 = None ) :

237 
supported
 = [ ]

240 if 
versions
 is None :

241 
versions
 = [ ]

242 
version_info
 = 
get_impl_version_info
 ( )

243 
major
 = 
version_info
 [ : - 1 ]

245 for 
minor
 in 
range
 ( 
version_info
 [ - 1 ] , - 1 , - 1 ) :

246 
versions
 . 
append
 ( '' . 
join
 ( 
map
 ( 
str
 , 
major
 + ( 
minor
 , ) ) ) )

248 
impl
 = 
impl
 or 
get_abbr_impl
 ( )

250 
abis
 = [ ]

252 
abi
 = 
abi
 or 
get_abi_tag
 ( )

253 if 
abi
 :

254 
abis
 [ 0 : 0 ] = [ 
abi
 ]

256 
abi3s
 = 
set
 ( )

257 import 
	~imp

258 for 
suffix
 in 
imp
 . 
get_suffixes
 ( ) :

259 if 
suffix
 [ 0 ] . 
startswith
 ( '.abi' ) :

260 
abi3s
 . 
add
 ( 
suffix
 [ 0 ] . 
split
 ( '.' , 2 ) [ 1 ] )

262 
abis
 . 
extend
 ( 
sorted
 ( 
list
 ( 
abi3s
 ) ) )

264 
abis
 . 
append
 ( 'none' )

266 if not 
noarch
 :

267 
arch
 = 
platform
 or 
get_platform
 ( )

268 if 
arch
 . 
startswith
 ( 'macosx' ) :

270 
match
 = 
_osx_arch_pat
 . 
match
 ( 
arch
 )

271 if 
match
 :

272 
name
 , 
major
 , 
minor
 , 
actual_arch
 = 
match
 . 
groups
 ( )

273 
tpl
 = '{}_{}_%i_%s' . 
format
 ( 
name
 , 
major
 )

274 
arches
 = [ ]

275 for 
m
 in 
reversed
 ( 
range
 ( 
int
 ( 
minor
 ) + 1 ) ) :

276 for 
a
 in 
get_darwin_arches
 ( 
int
 ( 
major
 ) , 
m
 , 
actual_arch
 ) :

277 
arches
 . 
append
 ( 
tpl
 % ( 
m
 , 
a
 ) )

280 
arches
 = [ 
arch
 ]

281 elif 
platform
 is None and 
is_manylinux1_compatible
 ( ) :

282 
arches
 = [ 
arch
 . 
replace
 ( 'linux' , 'manylinux1' ) , 
arch
 ]

284 
arches
 = [ 
arch
 ]

287 for 
abi
 in 
abis
 :

288 for 
arch
 in 
arches
 :

289 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] ) , 
abi
 , 
arch
 ) )

292 for 
version
 in 
versions
 [ 1 : ] :

294 if 
version
 in { '31' , '30' } :

296 for 
abi
 in 
abi3s
 :

297 for 
arch
 in 
arches
 :

298 
supported
 . 
append
 ( ( "%s%s" % ( 
impl
 , 
version
 ) , 
abi
 , 
arch
 ) )

301 for 
arch
 in 
arches
 :

302 
supported
 . 
append
 ( ( 'py%s' % ( 
versions
 [ 0 ] [ 0 ] ) , 'none' , 
arch
 ) )

305 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] ) , 'none' , 'any' ) )

308 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] [ 0 ] ) , 'none' , 'any' ) )

311 for 
i
 , 
version
 in 
enumerate
 ( 
versions
 ) :

312 
supported
 . 
append
 ( ( 'py%s' % ( 
version
 , ) , 'none' , 'any' ) )

313 if 
i
 == 0 :

314 
supported
 . 
append
 ( ( 'py%s' % ( 
version
 [ 0 ] ) , 'none' , 'any' ) )

316 return 
supported
 
	}

319 
implementation_tag
 = 
get_impl_tag
 ( )


	@./env/lib/python3.7/site-packages/yappi.py

7 import 
	~os

8 import 
	~sys

9 import 
	~_yappi

10 import 
	~pickle

11 import 
	~threading

13 from 
	~thread
 import 
get_ident

14 except 
ImportError
 :

15 from 
	~threading
 import 
get_ident

17 from 
	~contextlib
 import 
contextmanager

19 class 
	cYappiError
 ( 
Exception
 ) : pass

21 
__all__
 = [ 'start' , 'stop' , 'get_func_stats' , 'get_thread_stats' , 'clear_stats' , 'is_running' , 'get_clock_time'

24 
LINESEP
 = 
os
 . 
linesep

25 
COLUMN_GAP
 = 2

26 
YPICKLE_PROTOCOL
 = 2

28 
COLUMNS_FUNCSTATS
 = [ "name" , "ncall" , "ttot" , "tsub" , "tavg" ]

29 
COLUMNS_THREADSTATS
 = [ "name" , "id" , "tid" , "ttot" , "scnt" ]

30 
SORT_TYPES_FUNCSTATS
 = { "name" : 0 , "callcount" : 3 , "totaltime" : 6 , "subtime" : 7 , "avgtime" : 10 , "ncall"

32 
SORT_TYPES_CHILDFUNCSTATS
 = { "name" : 10 , "callcount" : 1 , "totaltime" : 3 , "subtime" : 4 , "avgtime" : 5 , "ncall"

34 
SORT_TYPES_THREADSTATS
 = { "name" : 0 , "id" : 1 , "tid" : 2 , "totaltime" : 3 , "schedcount" : 4 , "ttot"

36 
SORT_ORDERS
 = { "ascending" : 0 , "asc" : 0 , "descending" : 1 , "desc" : 1 }

37 
DEFAULT_SORT_TYPE
 = "totaltime"

38 
DEFAULT_SORT_ORDER
 = "desc"

40 
CLOCK_TYPES
 = { "WALL" : 0 , "CPU" : 1 }

42 def 
	$_validate_sorttype
 ( 
sort_type
 , 
list
 ) :

43 
sort_type
 = 
sort_type
 . 
lower
 ( )

44 if 
sort_type
 not in 
list
 :

45 raise 
YappiError
 ( "Invalid SortType parameter: '%s'" % ( 
sort_type
 ) )

46 return 
sort_type
 
	}

48 def 
	$_validate_sortorder
 ( 
sort_order
 ) :

49 
sort_order
 = 
sort_order
 . 
lower
 ( )

50 if 
sort_order
 not in 
SORT_ORDERS
 :

51 raise 
YappiError
 ( "Invalid SortOrder parameter: '%s'" % ( 
sort_order
 ) )

52 return 
sort_order
 
	}

54 def 
	$_validate_columns
 ( 
name
 , 
list
 ) :

55 
name
 = 
name
 . 
lower
 ( )

56 if 
name
 not in 
list
 :

57 raise 
YappiError
 ( "Invalid Column name: '%s'" % ( 
name
 ) ) 
	}

60 def 
	$_ctx_name_callback
 ( ) :

67 
current_thread
 = 
threading
 . 
_active
 [ 
get_ident
 ( ) ]

68 return 
current_thread
 . 
__class__
 . 
__name__

69 except 
KeyError
 :

71 return None 
	}

73 def 
	$_profile_thread_callback
 ( 
frame
 , 
event
 , 
arg
 ) :

79 
_yappi
 . 
_profile_event
 ( 
frame
 , 
event
 , 
arg
 ) 
	}

81 def 
	$_fft
 ( 
x
 , 
COL_SIZE
 = 8 ) :

85 
_rprecision
 = 6

86 while ( 
_rprecision
 > 0 ) :

87 
_fmt
 = "%0." + "%d" % ( 
_rprecision
 ) + "f"

88 
s
 = 
_fmt
 % ( 
x
 )

89 if 
len
 ( 
s
 ) <= 
COL_SIZE
 :

91 
_rprecision
 -= 1

92 return 
s
 
	}

94 def 
	$_func_fullname
 ( 
builtin
 , 
module
 , 
lineno
 , 
name
 ) :

95 if 
builtin
 :

96 return "%s.%s" % ( 
module
 , 
name
 )

98 return "%s:%d %s" % ( 
module
 , 
lineno
 , 
name
 ) 
	}
 """\nConverts our internal yappi's YFuncStats (YSTAT type) to PSTAT. So there are\nsome differences between the statistics parameters. The PSTAT format is as following:\n\nPSTAT expects a dict. entry as following:\n\nstats[("mod_name", line_no, "func_name")] = \\n    ( total_call_count, actual_call_count, total_time, cumulative_time,\n    {\n        ("mod_name", line_no, "func_name") :\n        (total_call_count, --> total count caller called the callee\n        actual_call_count, --> total count caller called the callee - (recursive calls)\n        total_time,        --> total time caller spent _only_ for this function (not further subcalls)\n        cumulative_time)   --> total time caller spent for this function\n    } --> callers dict\n    )\n\nNote that in PSTAT the total time spent in the function is called as cumulative_time and\nthe time spent _only_ in the function as total_time. From Yappi's perspective, this means:\n\ntotal_time (inline time) = tsub\ncumulative_time (total time) = ttot\n\nOther than that we hold called functions in a profile entry as named 'children'. On the\nother hand, PSTAT expects to have a dict of callers of the function. So we also need to\nconvert children to callers dict.\nFrom Python Docs:\n'''\nWith cProfile, each caller is preceded by three numbers:\nthe number of times this specific call was made, and the total\nand cumulative times spent in the current function while it was\ninvoked by this specific caller.\n'''\nThat means we only need to assign ChildFuncStat's ttot/tsub values to the caller\nproperly. Docs indicate that when b() is called by a() pstat holds the total time\nof b() when called by a, just like yappi.\n\nPSTAT only expects to have the above dict to be saved.\n"""

139 def 
	$convert2pstats
 ( 
stats
 ) :

140 from 
	~collections
 import 
defaultdict
 """\n    Converts the internal stat type of yappi(which is returned by a call to YFuncStats.get())\n    as pstats object.\n    """

145 if not 
isinstance
 ( 
stats
 , 
YFuncStats
 ) :

146 raise 
YappiError
 ( "Source stats must be derived from YFuncStats." )

147 import 
	~pstats

148 class 
	c_PStatHolder
 :

149 def 
__init__
 ( 
self
 , 
d
 ) :

150 
self
 . 
stats
 = 
d

151 def 
create_stats
 ( 
self
 ) :

153 def 
pstat_id
 ( 
fs
 ) :

154 return ( 
fs
 . 
module
 , 
fs
 . 
lineno
 , 
fs
 . 
name
 )

156 
_pdict
 = { }

159 
_callers
 = 
defaultdict
 ( 
dict
 )

160 for 
fs
 in 
stats
 :

161 for 
ct
 in 
fs
 . 
children
 :

162 
_callers
 [ 
ct
 ] [ 
pstat_id
 ( 
fs
 ) ] = ( 
ct
 . 
ncall
 , 
ct
 . 
nactualcall
 , 
ct
 . 
tsub
 , 
ct
 . 
ttot
 )

165 for 
fs
 in 
stats
 :

166 
_pdict
 [ 
pstat_id
 ( 
fs
 ) ] = ( 
fs
 . 
ncall
 , 
fs
 . 
nactualcall
 , 
fs
 . 
tsub
 , 
fs
 . 
ttot
 , 
_callers
 [ 
fs
 ] , )

168 return 
pstats
 . 
Stats
 ( 
_PStatHolder
 ( 
_pdict
 ) ) 
	}

170 def 
	$profile
 ( 
clock_type
 = "cpu" , 
profile_builtins
 = False , 
return_callback
 = None ) :

181 def 
_profile_dec
 ( 
func
 ) :

182 def 
wrapper
 ( * 
args
 , ** 
kwargs
 ) :

183 if 
func
 . 
_rec_level
 == 0 :

184 
clear_stats
 ( )

185 
set_clock_type
 ( 
clock_type
 )

186 
start
 ( 
profile_builtins
 , 
profile_threads
 = False )

187 
func
 . 
_rec_level
 += 1

189 return 
func
 ( * 
args
 , ** 
kwargs
 )

191 
func
 . 
_rec_level
 -= 1

195 if 
func
 . 
_rec_level
 == 0 :

197 
stop
 ( )

198 if 
return_callback
 is None :

199 
sys
 . 
stdout
 . 
write
 ( 
LINESEP
 )

200 
sys
 . 
stdout
 . 
write
 ( "Executed in %s %s clock seconds" %

201 ( 
_fft
 ( 
get_thread_stats
 ( ) [ 0 ] . 
ttot
 ) , 
clock_type
 . 
upper
 ( ) ) )

202 
sys
 . 
stdout
 . 
write
 ( 
LINESEP
 )

203 
get_func_stats
 ( ) . 
print_all
 ( )

205 
return_callback
 ( 
func
 , 
get_func_stats
 ( ) )

207 
clear_stats
 ( )

208 
func
 . 
_rec_level
 = 0

209 return 
wrapper

210 return 
_profile_dec
 
	}

212 class 
	cStatString
 ( 
object
 ) :

216 
_TRAIL_DOT
 = ".."

217 
_LEFT
 = 1

218 
_RIGHT
 = 2

220 def 
	$__init__
 ( 
self
 , 
s
 ) :

221 
self
 . 
_s
 = 
str
 ( 
s
 ) 
	}

223 def 
	$_trim
 ( 
self
 , 
length
 , 
direction
 ) :

224 if ( 
len
 ( 
self
 . 
_s
 ) > 
length
 ) :

225 if 
direction
 == 
self
 . 
_LEFT
 :

226 
self
 . 
_s
 = 
self
 . 
_s
 [ - 
length
 : ]

227 return 
self
 . 
_TRAIL_DOT
 + 
self
 . 
_s
 [ 
len
 ( 
self
 . 
_TRAIL_DOT
 ) : ]

228 elif 
direction
 == 
self
 . 
_RIGHT
 :

229 
self
 . 
_s
 = 
self
 . 
_s
 [ : 
length
 ]

230 return 
self
 . 
_s
 [ : - 
len
 ( 
self
 . 
_TRAIL_DOT
 ) ] + 
self
 . 
_TRAIL_DOT

231 return 
self
 . 
_s
 + ( " " * ( 
length
 - 
len
 ( 
self
 . 
_s
 ) ) ) 
	}

233 def 
	$ltrim
 ( 
self
 , 
length
 ) :

234 return 
self
 . 
_trim
 ( 
length
 , 
self
 . 
_LEFT
 ) 
	}

236 def 
	$rtrim
 ( 
self
 , 
length
 ) :

237 return 
self
 . 
_trim
 ( 
length
 , 
self
 . 
_RIGHT
 ) 
	}

239 class 
	cYStat
 ( 
dict
 ) :

244 
_KEYS
 = { }

246 def 
	$__init__
 ( 
self
 , 
values
 ) :

247 
super
 ( 
YStat
 , 
self
 ) . 
__init__
 ( )

249 for 
key
 , 
i
 in 
self
 . 
_KEYS
 . 
items
 ( ) :

250 
setattr
 ( 
self
 , 
key
 , 
values
 [ 
i
 ] ) 
	}

252 def 
	$__setattr__
 ( 
self
 , 
name
 , 
value
 ) :

253 
self
 [ 
self
 . 
_KEYS
 [ 
name
 ] ] = 
value

254 
super
 ( 
YStat
 , 
self
 ) . 
__setattr__
 ( 
name
 , 
value
 ) 
	}

256 class 
	cYFuncStat
 ( 
YStat
 ) :

260 
_KEYS
 = { 'name' : 0 , 'module' : 1 , 'lineno' : 2 , 'ncall' : 3 , 'nactualcall' : 4 , 'builtin' : 5 , 'ttot' : 6 , 'tsub' : 7 , 'index' : 8 , 'children' : 9 , 'ctx_id' : 10 , 'tavg' : 11 , 'full_name' : 12 }

262 def 
	$__eq__
 ( 
self
 , 
other
 ) :

263 if 
other
 is None :

265 return 
self
 . 
full_name
 == 
other
 . 
full_name
 
	}

267 def 
	$__ne__
 ( 
self
 , 
other
 ) :

268 return not 
self
 == 
other
 
	}

270 def 
	$__add__
 ( 
self
 , 
other
 ) :

273 if 
self
 is 
other
 :

274 return 
self

276 
self
 . 
ncall
 += 
other
 . 
ncall

277 
self
 . 
nactualcall
 += 
other
 . 
nactualcall

278 
self
 . 
ttot
 += 
other
 . 
ttot

279 
self
 . 
tsub
 += 
other
 . 
tsub

280 
self
 . 
tavg
 = 
self
 . 
ttot
 / 
self
 . 
ncall

281 for 
other_child_stat
 in 
other
 . 
children
 :

283 
self
 . 
children
 . 
append
 ( 
other_child_stat
 )

284 return 
self
 
	}

286 def 
	$__hash__
 ( 
self
 ) :

287 return 
hash
 ( 
self
 . 
full_name
 ) 
	}

289 def 
	$is_recursive
 ( 
self
 ) :

293 if 
self
 . 
nactualcall
 == 0 :

295 return 
self
 . 
ncall
 != 
self
 . 
nactualcall
 
	}

297 def 
	$strip_dirs
 ( 
self
 ) :

298 
self
 . 
module
 = 
os
 . 
path
 . 
basename
 ( 
self
 . 
module
 )

299 
self
 . 
full_name
 = 
_func_fullname
 ( 
self
 . 
builtin
 , 
self
 . 
module
 , 
self
 . 
lineno
 ,

300 
self
 . 
name
 )

301 return 
self
 
	}

303 def 
	$_print
 ( 
self
 , 
out
 , 
columns
 ) :

304 for 
x
 in 
sorted
 ( 
columns
 . 
keys
 ( ) ) :

305 
title
 , 
size
 = 
columns
 [ 
x
 ]

306 if 
title
 == "name" :

307 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
full_name
 ) . 
ltrim
 ( 
size
 ) )

308 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

309 elif 
title
 == "ncall" :

310 if 
self
 . 
is_recursive
 ( ) :

311 
out
 . 
write
 ( 
StatString
 ( "%d/%d" % ( 
self
 . 
ncall
 ,

312 
self
 . 
nactualcall
 ) ) . 
rtrim
 ( 
size
 ) )

314 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
ncall
 ) . 
rtrim
 ( 
size
 ) )

315 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

316 elif 
title
 == "tsub" :

317 
out
 . 
write
 ( 
StatString
 ( 
_fft
 ( 
self
 . 
tsub
 , 
size
 ) ) . 
rtrim
 ( 
size
 ) )

318 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

319 elif 
title
 == "ttot" :

320 
out
 . 
write
 ( 
StatString
 ( 
_fft
 ( 
self
 . 
ttot
 , 
size
 ) ) . 
rtrim
 ( 
size
 ) )

321 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

322 elif 
title
 == "tavg" :

323 
out
 . 
write
 ( 
StatString
 ( 
_fft
 ( 
self
 . 
tavg
 , 
size
 ) ) . 
rtrim
 ( 
size
 ) )

324 
out
 . 
write
 ( 
LINESEP
 ) 
	}

326 class 
	cYChildFuncStat
 ( 
YFuncStat
 ) :

330 
_KEYS
 = { 'index' : 0 , 'ncall' : 1 , 'nactualcall' : 2 , 'ttot' : 3 , 'tsub' : 4 , 'tavg' : 5 , 'builtin' : 6 , 'full_name' : 7 , 'module' : 8 , 'lineno' : 9 , 'name' : 10 }

332 def 
	$__add__
 ( 
self
 , 
other
 ) :

333 if 
other
 is None :

334 return 
self

335 
self
 . 
nactualcall
 += 
other
 . 
nactualcall

336 
self
 . 
ncall
 += 
other
 . 
ncall

337 
self
 . 
ttot
 += 
other
 . 
ttot

338 
self
 . 
tsub
 += 
other
 . 
tsub

339 
self
 . 
tavg
 = 
self
 . 
ttot
 / 
self
 . 
ncall

340 return 
self
 
	}

341 class 
	cYThreadStat
 ( 
YStat
 ) :

345 
_KEYS
 = { 'name' : 0 , 'id' : 1 , 'tid' : 2 , 'ttot' : 3 , 'sched_count' : 4 , }

347 def 
	$__eq__
 ( 
self
 , 
other
 ) :

348 if 
other
 is None :

350 return 
self
 . 
id
 == 
other
 . 
id
 
	}

352 def 
	$__ne__
 ( 
self
 , 
other
 ) :

353 return not 
self
 == 
other
 
	}

355 def 
	$__hash__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

356 return 
hash
 ( 
self
 . 
id
 ) 
	}

358 def 
	$_print
 ( 
self
 , 
out
 , 
columns
 ) :

359 for 
x
 in 
sorted
 ( 
columns
 . 
keys
 ( ) ) :

360 
title
 , 
size
 = 
columns
 [ 
x
 ]

361 if 
title
 == "name" :

362 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
name
 ) . 
ltrim
 ( 
size
 ) )

363 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

364 elif 
title
 == "id" :

365 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
id
 ) . 
rtrim
 ( 
size
 ) )

366 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

367 elif 
title
 == "tid" :

368 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
tid
 ) . 
rtrim
 ( 
size
 ) )

369 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

370 elif 
title
 == "ttot" :

371 
out
 . 
write
 ( 
StatString
 ( 
_fft
 ( 
self
 . 
ttot
 , 
size
 ) ) . 
rtrim
 ( 
size
 ) )

372 
out
 . 
write
 ( " " * 
COLUMN_GAP
 )

373 elif 
title
 == "scnt" :

374 
out
 . 
write
 ( 
StatString
 ( 
self
 . 
sched_count
 ) . 
rtrim
 ( 
size
 ) )

375 
out
 . 
write
 ( 
LINESEP
 ) 
	}

377 class 
	cYStats
 ( 
object
 ) :

381 def 
	$__init__
 ( 
self
 ) :

382 
self
 . 
_clock_type
 = None

383 
self
 . 
_as_dict
 = { }

384 
self
 . 
_as_list
 = [ ] 
	}

386 def 
	$get
 ( 
self
 ) :

387 
self
 . 
_clock_type
 = 
_yappi
 . 
get_clock_type
 ( )

388 
self
 . 
sort
 ( 
DEFAULT_SORT_TYPE
 , 
DEFAULT_SORT_ORDER
 )

389 return 
self
 
	}

391 def 
	$sort
 ( 
self
 , 
sort_type
 , 
sort_order
 ) :

392 
self
 . 
_as_list
 . 
sort
 ( 
key
 = lambda 
stat
 : 
stat
 [ 
sort_type
 ] ,

393 
reverse
 = ( 
sort_order
 == 
SORT_ORDERS
 [ "desc" ] ) )

394 return 
self
 
	}

396 def 
	$clear
 ( 
self
 ) :

397 del 
self
 . 
_as_list
 [ : ]

398 
self
 . 
_as_dict
 . 
clear
 ( ) 
	}

400 def 
	$empty
 ( 
self
 ) :

401 return ( 
len
 ( 
self
 . 
_as_list
 ) == 0 ) 
	}

403 def 
	$__getitem__
 ( 
self
 , 
key
 ) :

405 return 
self
 . 
_as_list
 [ 
key
 ]

406 except 
IndexError
 :

407 return None 
	}

409 def 
	$count
 ( 
self
 , 
item
 ) :

410 return 
self
 . 
_as_list
 . 
count
 ( 
item
 ) 
	}

412 def 
	$__iter__
 ( 
self
 ) :

413 return 
iter
 ( 
self
 . 
_as_list
 ) 
	}

415 def 
	$__len__
 ( 
self
 ) :

416 return 
len
 ( 
self
 . 
_as_list
 ) 
	}

418 def 
	$pop
 ( 
self
 ) :

419 
item
 = 
self
 . 
_as_list
 . 
pop
 ( )

420 del 
self
 . 
_as_dict
 [ 
item
 ]

421 return 
item
 
	}

423 def 
	$append
 ( 
self
 , 
item
 ) :

426 
existing
 = 
self
 . 
_as_dict
 . 
get
 ( 
item
 )

427 if 
existing
 :

428 
existing
 += 
item

430 
self
 . 
_as_list
 . 
append
 ( 
item
 )

431 
self
 . 
_as_dict
 [ 
item
 ] = 
item
 
	}

433 def 
	$_print_header
 ( 
self
 , 
out
 , 
columns
 ) :

434 for 
x
 in 
sorted
 ( 
columns
 . 
keys
 ( ) ) :

435 
title
 , 
size
 = 
columns
 [ 
x
 ]

436 if 
len
 ( 
title
 ) > 
size
 :

437 raise 
YappiError
 ( "Column title exceeds available length[%s:%d]" %

438 ( 
title
 , 
size
 ) )

439 
out
 . 
write
 ( 
title
 )

440 
out
 . 
write
 ( " " * ( 
COLUMN_GAP
 + 
size
 - 
len
 ( 
title
 ) ) )

441 
out
 . 
write
 ( 
LINESEP
 ) 
	}

443 def 
	$_debug_check_sanity
 ( 
self
 ) :

447 for 
x
 in 
self
 :

448 if 
self
 . 
count
 ( 
x
 ) > 1 :

450 return True 
	}

453 class 
	cYStatsIndexable
 ( 
YStats
 ) :

455 def 
	$__init__
 ( 
self
 ) :

456 
super
 ( 
YStatsIndexable
 , 
self
 ) . 
__init__
 ( )

457 
self
 . 
_additional_indexing
 = { } 
	}

459 def 
	$clear
 ( 
self
 ) :

460 
super
 ( 
YStatsIndexable
 , 
self
 ) . 
clear
 ( )

461 
self
 . 
_additional_indexing
 . 
clear
 ( ) 
	}

463 def 
	$pop
 ( 
self
 ) :

464 
item
 = 
super
 ( 
YStatsIndexable
 , 
self
 ) . 
pop
 ( )

465 
self
 . 
_additional_indexing
 . 
pop
 ( 
item
 . 
index
 , None )

466 
self
 . 
_additional_indexing
 . 
pop
 ( 
item
 . 
full_name
 , None )

467 return 
item
 
	}

469 def 
	$append
 ( 
self
 , 
item
 ) :

470 
super
 ( 
YStatsIndexable
 , 
self
 ) . 
append
 ( 
item
 )

472 
self
 . 
_additional_indexing
 . 
setdefault
 ( 
item
 . 
index
 , 
item
 )

473 
self
 . 
_additional_indexing
 . 
setdefault
 ( 
item
 . 
full_name
 , 
item
 ) 
	}

475 def 
	$__getitem__
 ( 
self
 , 
key
 ) :

476 if 
isinstance
 ( 
key
 , 
int
 ) :

478 return 
self
 . 
_additional_indexing
 . 
get
 ( 
key
 , None )

479 elif 
isinstance
 ( 
key
 , 
str
 ) :

481 return 
self
 . 
_additional_indexing
 . 
get
 ( 
key
 , None )

482 elif 
isinstance
 ( 
key
 , 
YFuncStat
 ) or 
isinstance
 ( 
key
 , 
YChildFuncStat
 ) :

483 return 
self
 . 
_additional_indexing
 . 
get
 ( 
key
 . 
index
 , None )

485 return 
super
 ( 
YStatsIndexable
 , 
self
 ) . 
__getitem__
 ( 
key
 ) 
	}

487 class 
	cYChildFuncStats
 ( 
YStatsIndexable
 ) :

489 def 
	$sort
 ( 
self
 , 
sort_type
 , 
sort_order
 = "desc" ) :

490 
sort_type
 = 
_validate_sorttype
 ( 
sort_type
 , 
SORT_TYPES_CHILDFUNCSTATS
 )

491 
sort_order
 = 
_validate_sortorder
 ( 
sort_order
 )

493 return 
super
 ( 
YChildFuncStats
 , 
self
 ) . 
sort
 ( 
SORT_TYPES_CHILDFUNCSTATS
 [ 
sort_type
 ] , 
SORT_ORDERS
 [ 
sort_order
 ] ) 
	}

495 def 
	$print_all
 ( 
self
 , 
out
 = 
sys
 . 
stdout
 , 
columns
 = { 0 : ( "name" , 36 ) , 1 : ( "ncall" , 5 ) ,

500 if 
self
 . 
empty
 ( ) or 
len
 ( 
columns
 ) == 0 :

503 for 
_
 , 
col
 in 
columns
 . 
items
 ( ) :

504 
_validate_columns
 ( 
col
 [ 0 ] , 
COLUMNS_FUNCSTATS
 )

506 
out
 . 
write
 ( 
LINESEP
 )

507 
self
 . 
_print_header
 ( 
out
 , 
columns
 )

508 for 
stat
 in 
self
 :

509 
stat
 . 
_print
 ( 
out
 , 
columns
 ) 
	}

511 def 
	$strip_dirs
 ( 
self
 ) :

512 for 
stat
 in 
self
 :

513 
stat
 . 
strip_dirs
 ( )

514 return 
self
 
	}

517 class 
	cYFuncStats
 ( 
YStatsIndexable
 ) :

519 
_idx_max
 = 0

520 
_sort_type
 = None

521 
_sort_order
 = None

522 
_SUPPORTED_LOAD_FORMATS
 = [ 'YSTAT' ]

523 
_SUPPORTED_SAVE_FORMATS
 = [ 'YSTAT' , 'CALLGRIND' , 'PSTAT' ]

524 def 
	$__init__
 ( 
self
 , 
files
 = [ ] ) :

525 
super
 ( 
YFuncStats
 , 
self
 ) . 
__init__
 ( )

526 
self
 . 
add
 ( 
files
 ) 
	}

528 def 
	$strip_dirs
 ( 
self
 ) :

529 for 
stat
 in 
self
 :

530 
stat
 . 
strip_dirs
 ( )

531 
stat
 . 
children
 . 
strip_dirs
 ( )

532 return 
self
 
	}

534 def 
	$get
 ( 
self
 , 
filter
 = None ) :

535 
_yappi
 . 
_pause
 ( )

536 
self
 . 
clear
 ( )

538 
self
 . 
_filter
 = 
filter

539 
_yappi
 . 
enum_func_stats
 ( 
self
 . 
_enumerator
 )

540 
self
 . 
_filter
 = None

543 for 
stat
 in 
self
 :

545 
_childs
 = 
YChildFuncStats
 ( )

546 for 
child_tpl
 in 
stat
 . 
children
 :

547 
rstat
 = 
self
 [ 
child_tpl
 [ 0 ] ]

552 if 
rstat
 is None :

555 
tavg
 = 
rstat
 . 
ttot
 / 
rstat
 . 
ncall

556 
cfstat
 = 
YChildFuncStat
 ( 
child_tpl
 + ( 
tavg
 , 
rstat
 . 
builtin
 , 
rstat
 . 
full_name
 , 
rstat
 . 
module
 ,

557 
rstat
 . 
lineno
 , 
rstat
 . 
name
 , ) )

558 
_childs
 . 
append
 ( 
cfstat
 )

559 
stat
 . 
children
 = 
_childs

560 
result
 = 
super
 ( 
YFuncStats
 , 
self
 ) . 
get
 ( )

562 
_yappi
 . 
_resume
 ( )

563 return 
result
 
	}

565 def 
	$_enumerator
 ( 
self
 , 
stat_entry
 ) :

567 
fname
 , 
fmodule
 , 
flineno
 , 
fncall
 , 
fnactualcall
 , 
fbuiltin
 , 
fttot
 , 
ftsub
 ,

568 
findex
 , 
fchildren
 , 
fctxid
 = 
stat_entry

571 
ffull_name
 = 
_func_fullname
 ( 
bool
 ( 
fbuiltin
 ) , 
fmodule
 , 
flineno
 , 
fname
 )

572 
ftavg
 = 
fttot
 / 
fncall

573 
fstat
 = 
YFuncStat
 ( 
stat_entry
 + ( 
ftavg
 , 
ffull_name
 ) )

576 if 
os
 . 
path
 . 
basename
 ( 
fstat
 . 
module
 ) == "yappi.py" or 
fstat
 . 
module
 == "_yappi" :

579 
fstat
 . 
builtin
 = 
bool
 ( 
fstat
 . 
builtin
 )

581 if 
self
 . 
_filter
 :

582 for 
k
 , 
v
 in 
self
 . 
_filter
 . 
items
 ( ) :

583 if 
getattr
 ( 
fstat
 , 
k
 ) != 
v
 :

586 
self
 . 
append
 ( 
fstat
 )

589 if 
self
 . 
_idx_max
 < 
fstat
 . 
index
 :

590 
self
 . 
_idx_max
 = 
fstat
 . 
index
 
	}

592 def 
	$_add_from_YSTAT
 ( 
self
 , 
file
 ) :

594 
saved_stats
 , 
saved_clock_type
 = 
pickle
 . 
load
 ( 
file
 )

596 raise 
YappiError
 ( "Unable to load the saved profile information from %s." % ( 
file
 . 
name
 ) )

598 if not 
self
 . 
empty
 ( ) :

599 if 
self
 . 
_clock_type
 != 
saved_clock_type
 and 
self
 . 
_clock_type
 is not None :

600 raise 
YappiError
 ( "Clock type mismatch between current and saved profiler sessions.[%s,%s]" %

601 ( 
self
 . 
_clock_type
 , 
saved_clock_type
 ) )

603 
self
 . 
_clock_type
 = 
saved_clock_type

606 for 
saved_stat
 in 
saved_stats
 :

607 if 
saved_stat
 not in 
self
 :

608 
self
 . 
_idx_max
 += 1

609 
saved_stat
 . 
index
 = 
self
 . 
_idx_max

610 
self
 . 
append
 ( 
saved_stat
 )

613 for 
saved_stat
 in 
saved_stats
 :

614 for 
saved_child_stat
 in 
saved_stat
 . 
children
 :

618 
saved_child_stat
 . 
index
 = 
self
 [ 
saved_child_stat
 . 
full_name
 ] . 
index

621 for 
saved_stat
 in 
saved_stats
 :

622 
saved_stat_in_curr
 = 
self
 [ 
saved_stat
 . 
full_name
 ]

623 
saved_stat_in_curr
 += 
saved_stat
 
	}

625 def 
	$_save_as_YSTAT
 ( 
self
 , 
path
 ) :

626 with 
open
 ( 
path
 , "wb" ) as 
f
 :

627 
pickle
 . 
dump
 ( ( 
self
 , 
self
 . 
_clock_type
 ) , 
f
 , 
YPICKLE_PROTOCOL
 ) 
	}

629 def 
	$_save_as_PSTAT
 ( 
self
 , 
path
 ) :

633 
_stats
 = 
convert2pstats
 ( 
self
 )

634 
_stats
 . 
dump_stats
 ( 
path
 ) 
	}

635 def 
	$_save_as_CALLGRIND
 ( 
self
 , 
path
 ) :

640 
header
 = """version: 1\ncreator: %s\npid: %d\ncmd:  %s\npart: 1\n\nevents: Ticks""" %

641 ( 'yappi' , 
os
 . 
getpid
 ( ) , ' ' . 
join
 ( 
sys
 . 
argv
 ) )

643 
lines
 = [ 
header
 ]

646 
file_ids
 = [ '' ]

647 
func_ids
 = [ '' ]

648 for 
func_stat
 in 
self
 :

649 
file_ids
 += [ 'fl=(%d) %s' % ( 
func_stat
 . 
index
 , 
func_stat
 . 
module
 ) ]

650 
func_ids
 += [ 'fn=(%d) %s %s:%s' % ( 
func_stat
 . 
index
 , 
func_stat
 . 
name
 , 
func_stat
 . 
module
 , 
func_stat
 . 
lineno
 ) ]

652 
lines
 += 
file_ids
 + 
func_ids

655 for 
func_stat
 in 
self
 :

656 
func_stats
 = [ '' , 'fl=(%d)'

657 % 
func_stat
 . 
index
 , 'fn=(%d)'

658 % 
func_stat
 . 
index
 ]

659 
func_stats
 += [ '%s %s' % ( 
func_stat
 . 
lineno
 , 
int
 ( 
func_stat
 . 
tsub
 * 1e6 ) ) ]

662 for 
child
 in 
func_stat
 . 
children
 :

663 
func_stats
 += [ 'cfl=(%d)' % 
child
 . 
index
 , 'cfn=(%d)'

664 % 
child
 . 
index
 , 'calls=%d 0'

665 % 
child
 . 
ncall
 , '0 %d'

666 % 
int
 ( 
child
 . 
ttot
 * 1e6 )

668 
lines
 += 
func_stats

670 with 
open
 ( 
path
 , "w" ) as 
f
 :

671 
f
 . 
write
 ( '\n' . 
join
 ( 
lines
 ) ) 
	}

673 def 
	$add
 ( 
self
 , 
files
 , 
type
 = "ystat" ) :

674 
type
 = 
type
 . 
upper
 ( )

675 if 
type
 not in 
self
 . 
_SUPPORTED_LOAD_FORMATS
 :

676 raise 
NotImplementedError
 ( 'Loading from (%s) format is not possible currently.' )

677 if 
isinstance
 ( 
files
 , 
str
 ) :

678 
files
 = [ 
files
 , ]

679 for 
fd
 in 
files
 :

680 with 
open
 ( 
fd
 , "rb" ) as 
f
 :

681 
add_func
 = 
getattr
 ( 
self
 , "_add_from_%s" % ( 
type
 ) )

682 
add_func
 ( 
file
 = 
f
 )

684 return 
self
 . 
sort
 ( 
DEFAULT_SORT_TYPE
 , 
DEFAULT_SORT_ORDER
 ) 
	}

686 def 
	$save
 ( 
self
 , 
path
 , 
type
 = "ystat" ) :

687 
type
 = 
type
 . 
upper
 ( )

688 if 
type
 not in 
self
 . 
_SUPPORTED_SAVE_FORMATS
 :

689 raise 
NotImplementedError
 ( 'Saving in "%s" format is not possible currently.' % ( 
type
 ) )

691 
save_func
 = 
getattr
 ( 
self
 , "_save_as_%s" % ( 
type
 ) )

692 
save_func
 ( 
path
 = 
path
 ) 
	}

694 def 
	$print_all
 ( 
self
 , 
out
 = 
sys
 . 
stdout
 , 
columns
 = { 0 : ( "name" , 36 ) , 1 : ( "ncall" , 5 ) ,

699 if 
self
 . 
empty
 ( ) :

702 for 
_
 , 
col
 in 
columns
 . 
items
 ( ) :

703 
_validate_columns
 ( 
col
 [ 0 ] , 
COLUMNS_FUNCSTATS
 )

705 
out
 . 
write
 ( 
LINESEP
 )

706 
out
 . 
write
 ( "Clock type: %s" % ( 
self
 . 
_clock_type
 . 
upper
 ( ) ) )

707 
out
 . 
write
 ( 
LINESEP
 )

708 
out
 . 
write
 ( "Ordered by: %s, %s" % ( 
self
 . 
_sort_type
 , 
self
 . 
_sort_order
 ) )

709 
out
 . 
write
 ( 
LINESEP
 )

710 
out
 . 
write
 ( 
LINESEP
 )

712 
self
 . 
_print_header
 ( 
out
 , 
columns
 )

713 for 
stat
 in 
self
 :

714 
stat
 . 
_print
 ( 
out
 , 
columns
 ) 
	}

716 def 
	$sort
 ( 
self
 , 
sort_type
 , 
sort_order
 = "desc" ) :

717 
sort_type
 = 
_validate_sorttype
 ( 
sort_type
 , 
SORT_TYPES_FUNCSTATS
 )

718 
sort_order
 = 
_validate_sortorder
 ( 
sort_order
 )

720 
self
 . 
_sort_type
 = 
sort_type

721 
self
 . 
_sort_order
 = 
sort_order

723 return 
super
 ( 
YFuncStats
 , 
self
 ) . 
sort
 ( 
SORT_TYPES_FUNCSTATS
 [ 
sort_type
 ] , 
SORT_ORDERS
 [ 
sort_order
 ] ) 
	}

725 def 
	$debug_print
 ( 
self
 ) :

726 if 
self
 . 
empty
 ( ) :

729 
console
 = 
sys
 . 
stdout

730 
CHILD_STATS_LEFT_MARGIN
 = 5

731 for 
stat
 in 
self
 :

732 
console
 . 
write
 ( "index: %d" % 
stat
 . 
index
 )

733 
console
 . 
write
 ( 
LINESEP
 )

734 
console
 . 
write
 ( "full_name: %s" % 
stat
 . 
full_name
 )

735 
console
 . 
write
 ( 
LINESEP
 )

736 
console
 . 
write
 ( "ncall: %d/%d" % ( 
stat
 . 
ncall
 , 
stat
 . 
nactualcall
 ) )

737 
console
 . 
write
 ( 
LINESEP
 )

738 
console
 . 
write
 ( "ttot: %s" % 
_fft
 ( 
stat
 . 
ttot
 ) )

739 
console
 . 
write
 ( 
LINESEP
 )

740 
console
 . 
write
 ( "tsub: %s" % 
_fft
 ( 
stat
 . 
tsub
 ) )

741 
console
 . 
write
 ( 
LINESEP
 )

742 
console
 . 
write
 ( "children: " )

743 
console
 . 
write
 ( 
LINESEP
 )

744 for 
child_stat
 in 
stat
 . 
children
 :

745 
console
 . 
write
 ( 
LINESEP
 )

746 
console
 . 
write
 ( " " * 
CHILD_STATS_LEFT_MARGIN
 )

747 
console
 . 
write
 ( "index: %d" % 
child_stat
 . 
index
 )

748 
console
 . 
write
 ( 
LINESEP
 )

749 
console
 . 
write
 ( " " * 
CHILD_STATS_LEFT_MARGIN
 )

750 
console
 . 
write
 ( "child_full_name: %s" % 
child_stat
 . 
full_name
 )

751 
console
 . 
write
 ( 
LINESEP
 )

752 
console
 . 
write
 ( " " * 
CHILD_STATS_LEFT_MARGIN
 )

753 
console
 . 
write
 ( "ncall: %d/%d" % ( 
child_stat
 . 
ncall
 , 
child_stat
 . 
nactualcall
 ) )

754 
console
 . 
write
 ( 
LINESEP
 )

755 
console
 . 
write
 ( " " * 
CHILD_STATS_LEFT_MARGIN
 )

756 
console
 . 
write
 ( "ttot: %s" % 
_fft
 ( 
child_stat
 . 
ttot
 ) )

757 
console
 . 
write
 ( 
LINESEP
 )

758 
console
 . 
write
 ( " " * 
CHILD_STATS_LEFT_MARGIN
 )

759 
console
 . 
write
 ( "tsub: %s" % 
_fft
 ( 
child_stat
 . 
tsub
 ) )

760 
console
 . 
write
 ( 
LINESEP
 )

761 
console
 . 
write
 ( 
LINESEP
 ) 
	}

763 class 
	cYThreadStats
 ( 
YStats
 ) :

765 def 
	$get
 ( 
self
 ) :

766 
_yappi
 . 
_pause
 ( )

767 
self
 . 
clear
 ( )

769 
_yappi
 . 
enum_thread_stats
 ( 
self
 . 
_enumerator
 )

770 
result
 = 
super
 ( 
YThreadStats
 , 
self
 ) . 
get
 ( )

772 
_yappi
 . 
_resume
 ( )

773 return 
result
 
	}

775 def 
	$_enumerator
 ( 
self
 , 
stat_entry
 ) :

776 
tstat
 = 
YThreadStat
 ( 
stat_entry
 )

777 
self
 . 
append
 ( 
tstat
 ) 
	}

779 def 
	$sort
 ( 
self
 , 
sort_type
 , 
sort_order
 = "desc" ) :

780 
sort_type
 = 
_validate_sorttype
 ( 
sort_type
 , 
SORT_TYPES_THREADSTATS
 )

781 
sort_order
 = 
_validate_sortorder
 ( 
sort_order
 )

783 return 
super
 ( 
YThreadStats
 , 
self
 ) . 
sort
 ( 
SORT_TYPES_THREADSTATS
 [ 
sort_type
 ] , 
SORT_ORDERS
 [ 
sort_order
 ] ) 
	}

785 def 
	$print_all
 ( 
self
 , 
out
 = 
sys
 . 
stdout
 , 
columns
 = { 0 : ( "name" , 13 ) , 1 : ( "id" , 5 ) ,

791 if 
self
 . 
empty
 ( ) :

794 for 
_
 , 
col
 in 
columns
 . 
items
 ( ) :

795 
_validate_columns
 ( 
col
 [ 0 ] , 
COLUMNS_THREADSTATS
 )

797 
out
 . 
write
 ( 
LINESEP
 )

798 
self
 . 
_print_header
 ( 
out
 , 
columns
 )

799 for 
stat
 in 
self
 :

800 
stat
 . 
_print
 ( 
out
 , 
columns
 ) 
	}

802 def 
	$strip_dirs
 ( 
self
 ) :

803 pass 
	}

805 def 
	$is_running
 ( ) :

809 return 
bool
 ( 
_yappi
 . 
is_running
 ( ) ) 
	}

811 def 
	$start
 ( 
builtins
 = False , 
profile_threads
 = True ) :

815 if 
profile_threads
 :

816 
threading
 . 
setprofile
 ( 
_profile_thread_callback
 )

817 
_yappi
 . 
start
 ( 
builtins
 , 
profile_threads
 ) 
	}

819 def 
	$get_func_stats
 ( 
filter
 = None ) :

825 
_yappi
 . 
_pause
 ( )

827 
stats
 = 
YFuncStats
 ( ) . 
get
 ( 
filter
 = 
filter
 )

829 
_yappi
 . 
_resume
 ( )

830 return 
stats
 
	}

832 def 
	$get_thread_stats
 ( ) :

836 
_yappi
 . 
_pause
 ( )

838 
stats
 = 
YThreadStats
 ( ) . 
get
 ( )

840 
_yappi
 . 
_resume
 ( )

841 return 
stats
 
	}

843 def 
	$stop
 ( ) :

847 
_yappi
 . 
stop
 ( )

848 
threading
 . 
setprofile
 ( None ) 
	}

850 @ 
	`contextmanager

851 def 
	$run
 ( 
builtins
 = False , 
profile_threads
 = True ) :

871 
start
 ( 
builtins
 = 
builtins
 , 
profile_threads
 = 
profile_threads
 )

875 
stop
 ( ) 
	}

877 def 
	$clear_stats
 ( ) :

881 
_yappi
 . 
_pause
 ( )

883 
_yappi
 . 
clear_stats
 ( )

885 
_yappi
 . 
_resume
 ( ) 
	}

887 def 
	$get_clock_time
 ( ) :

891 return 
_yappi
 . 
get_clock_time
 ( ) 
	}

893 def 
	$get_clock_type
 ( ) :

897 return 
_yappi
 . 
get_clock_type
 ( ) 
	}

899 def 
	$get_clock_info
 ( ) :

904 return 
_yappi
 . 
get_clock_info
 ( ) 
	}

906 def 
	$set_clock_type
 ( 
type
 ) :

911 
type
 = 
type
 . 
upper
 ( )

912 if 
type
 not in 
CLOCK_TYPES
 :

913 raise 
YappiError
 ( "Invalid clock type:%s" % ( 
type
 ) )

915 
_yappi
 . 
set_clock_type
 ( 
CLOCK_TYPES
 [ 
type
 ] ) 
	}

917 def 
	$shift_context_time
 ( 
context_id
 , 
amount
 ) :

924 
_yappi
 . 
shift_context_time
 ( 
context_id
 , 
amount
 ) 
	}

926 def 
	$get_mem_usage
 ( ) :

930 return 
_yappi
 . 
get_mem_usage
 ( ) 
	}

932 def 
	$set_context_id_callback
 ( 
callback
 ) :

941 return 
_yappi
 . 
set_context_id_callback
 ( 
callback
 ) 
	}

943 def 
	$set_context_name_callback
 ( 
callback
 ) :

956 if 
callback
 is None :

957 return 
_yappi
 . 
set_context_name_callback
 ( 
_ctx_name_callback
 )

958 return 
_yappi
 . 
set_context_name_callback
 ( 
callback
 ) 
	}

961 
set_context_name_callback
 ( None )

963 def 
	$main
 ( ) :

964 from 
	~optparse
 import 
OptionParser

965 
usage
 = "%s [-b] [-c clock_type] [-o output_file] [-f output_format] [-s] [scriptfile] args ..." % 
os
 . 
path
 . 
basename
 ( 
sys
 . 
argv
 [ 0 ] )

966 
parser
 = 
OptionParser
 ( 
usage
 = 
usage
 )

967 
parser
 . 
allow_interspersed_args
 = False

968 
parser
 . 
add_option
 ( "-c" , "--clock-type" , 
default
 = "cpu" ,

969 
choices
 = 
sorted
 ( 
c
 . 
lower
 ( ) for 
c
 in 
CLOCK_TYPES
 ) ,

970 
metavar
 = "clock_type" , 
help
 = "Clock type to use during profiling" "(\"cpu\" or \"wall\", default is \"cpu\")."

972 
parser
 . 
add_option
 ( "-b" , "--builtins" ,

973 
action
 = "store_true" , 
dest
 = "profile_builtins" , 
default
 = False ,

974 
help
 = "Profiles builtin functions when set. [default: False]" )

975 
parser
 . 
add_option
 ( "-o" , "--output-file" , 
metavar
 = "output_file" ,

976 
help
 = "Write stats to output_file." )

977 
parser
 . 
add_option
 ( "-f" , "--output-format" , 
default
 = "pstat" ,

978 
choices
 = ( "pstat" , "callgrind" , "ystat" ) ,

979 
metavar
 = "output_format" , 
help
 = "Write stats in the specified" "format (\"pstat\", \"callgrind\" or \"ystat\", default is " "\"pstat\")."

982 
parser
 . 
add_option
 ( "-s" , "--single_thread" ,

983 
action
 = "store_true" , 
dest
 = "profile_single_thread" , 
default
 = False ,

984 
help
 = "Profiles only the thread that calls start(). [default: False]" )

985 if not 
sys
 . 
argv
 [ 1 : ] :

986 
parser
 . 
print_usage
 ( )

987 
sys
 . 
exit
 ( 2 )

989 ( 
options
 , 
args
 ) = 
parser
 . 
parse_args
 ( )

990 
sys
 . 
argv
 [ : ] = 
args

992 if ( 
len
 ( 
sys
 . 
argv
 ) > 0 ) :

993 
sys
 . 
path
 . 
insert
 ( 0 , 
os
 . 
path
 . 
dirname
 ( 
sys
 . 
argv
 [ 0 ] ) )

994 
set_clock_type
 ( 
options
 . 
clock_type
 )

995 
start
 ( 
options
 . 
profile_builtins
 , not 
options
 . 
profile_single_thread
 )

997 if 
sys
 . 
version_info
 >= ( 3 , 0 ) :

998 
exec
 ( 
compile
 ( 
open
 ( 
sys
 . 
argv
 [ 0 ] ) . 
read
 ( ) , 
sys
 . 
argv
 [ 0 ] , 'exec' ) ,

999 
sys
 . 
_getframe
 ( 1 ) . 
f_globals
 , 
sys
 . 
_getframe
 ( 1 ) . 
f_locals
 )

1001 
execfile
 ( 
sys
 . 
argv
 [ 0 ] , 
sys
 . 
_getframe
 ( 1 ) . 
f_globals
 , 
sys
 . 
_getframe
 ( 1 ) . 
f_locals
 )

1003 
stop
 ( )

1004 if 
options
 . 
output_file
 :

1005 
stats
 = 
get_func_stats
 ( )

1006 
stats
 . 
save
 ( 
options
 . 
output_file
 , 
options
 . 
output_format
 )

1009 
get_func_stats
 ( ) . 
print_all
 ( )

1010 
get_thread_stats
 ( ) . 
print_all
 ( )

1012 
parser
 . 
print_usage
 ( ) 
	}

1014 if 
__name__
 == "__main__" :

1015 
main
 ( )


	@./env/lib/python3.7/site-packages/pip/_internal/operations/prepare.py

4 import 
	~logging

5 import 
	~os

7 from 
	~pip._vendor
 import 
pkg_resources
 , 
requests

9 from 
	~pip._internal.build_env
 import 
BuildEnvironment

10 from 
	~pip._internal.download
 import (

11 
is_dir_url
 , 
is_file_url
 , 
is_vcs_url
 , 
unpack_url
 , 
url_to_path
 ,

13 from 
	~pip._internal.exceptions
 import (

14 
DirectoryUrlHashUnsupported
 , 
HashUnpinned
 , 
InstallationError
 ,

15 
PreviousBuildDirError
 , 
VcsHashUnsupported
 ,

17 from 
	~pip._internal.utils.compat
 import 
expanduser

18 from 
	~pip._internal.utils.hashes
 import 
MissingHashes

19 from 
	~pip._internal.utils.logging
 import 
indent_log

20 from 
	~pip._internal.utils.misc
 import 
display_path
 , 
normalize_path

21 from 
	~pip._internal.vcs
 import 
vcs

23 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

26 def 
	$make_abstract_dist
 ( 
req
 ) :

34 if 
req
 . 
editable
 :

35 return 
IsSDist
 ( 
req
 )

36 elif 
req
 . 
link
 and 
req
 . 
link
 . 
is_wheel
 :

37 return 
IsWheel
 ( 
req
 )

39 return 
IsSDist
 ( 
req
 ) 
	}

42 class 
	cDistAbstraction
 ( 
object
 ) :

61 def 
	$__init__
 ( 
self
 , 
req
 ) :

62 
self
 . 
req
 = 
req
 
	}

64 def 
	$dist
 ( 
self
 , 
finder
 ) :

66 raise 
NotImplementedError
 ( 
self
 . 
dist
 ) 
	}

68 def 
	$prep_for_dist
 ( 
self
 , 
finder
 , 
build_isolation
 ) :

70 raise 
NotImplementedError
 ( 
self
 . 
dist
 ) 
	}

73 class 
	cIsWheel
 ( 
DistAbstraction
 ) :

75 def 
	$dist
 ( 
self
 , 
finder
 ) :

76 return 
list
 ( 
pkg_resources
 . 
find_distributions
 (

77 
self
 . 
req
 . 
source_dir
 ) ) [ 0 ] 
	}

79 def 
	$prep_for_dist
 ( 
self
 , 
finder
 , 
build_isolation
 ) :

81 pass 
	}

84 class 
	cIsSDist
 ( 
DistAbstraction
 ) :

86 def 
	$dist
 ( 
self
 , 
finder
 ) :

87 
dist
 = 
self
 . 
req
 . 
get_dist
 ( )

89 if 
finder
 and 
dist
 . 
has_metadata
 ( 'dependency_links.txt' ) :

90 
finder
 . 
add_dependency_links
 (

91 
dist
 . 
get_metadata_lines
 ( 'dependency_links.txt' )

93 return 
dist
 
	}

95 def 
	$prep_for_dist
 ( 
self
 , 
finder
 , 
build_isolation
 ) :

100 
self
 . 
req
 . 
load_pyproject_toml
 ( )

101 
should_isolate
 = 
self
 . 
req
 . 
use_pep517
 and 
build_isolation

103 if 
should_isolate
 :

106 
self
 . 
req
 . 
build_env
 = 
BuildEnvironment
 ( )

107 
self
 . 
req
 . 
build_env
 . 
install_requirements
 (

108 
finder
 , 
self
 . 
req
 . 
pyproject_requires
 , "Installing build dependencies"

111 
missing
 = [ ]

112 if 
self
 . 
req
 . 
requirements_to_check
 :

113 
check
 = 
self
 . 
req
 . 
requirements_to_check

114 
missing
 = 
self
 . 
req
 . 
build_env
 . 
missing_requirements
 ( 
check
 )

115 if 
missing
 :

116 
logger
 . 
warning
 ( "Missing build requirements in pyproject.toml for %s."

118 
self
 . 
req
 ,

120 
logger
 . 
warning
 ( "The project does not specify a build backend, and pip " "cannot fall back to setuptools without %s."

123 . 
join
 ( 
map
 ( 
repr
 , 
sorted
 ( 
missing
 ) ) )

126 
self
 . 
req
 . 
run_egg_info
 ( )

127 
self
 . 
req
 . 
assert_source_matches_version
 ( ) 
	}

130 class 
	cInstalled
 ( 
DistAbstraction
 ) :

132 def 
	$dist
 ( 
self
 , 
finder
 ) :

133 return 
self
 . 
req
 . 
satisfied_by
 
	}

135 def 
	$prep_for_dist
 ( 
self
 , 
finder
 , 
build_isolation
 ) :

136 pass 
	}

139 class 
	cRequirementPreparer
 ( 
object
 ) :

143 def 
	$__init__
 ( 
self
 , 
build_dir
 , 
download_dir
 , 
src_dir
 , 
wheel_download_dir
 ,

144 
progress_bar
 , 
build_isolation
 , 
req_tracker
 ) :

145 
super
 ( 
RequirementPreparer
 , 
self
 ) . 
__init__
 ( )

147 
self
 . 
src_dir
 = 
src_dir

148 
self
 . 
build_dir
 = 
build_dir

149 
self
 . 
req_tracker
 = 
req_tracker

153 
self
 . 
download_dir
 = 
download_dir

158 if 
wheel_download_dir
 :

159 
wheel_download_dir
 = 
normalize_path
 ( 
wheel_download_dir
 )

160 
self
 . 
wheel_download_dir
 = 
wheel_download_dir

167 
self
 . 
progress_bar
 = 
progress_bar

170 
self
 . 
build_isolation
 = 
build_isolation
 
	}

172 @ 
property

173 def 
	$_download_should_save
 ( 
self
 ) :

175 if 
self
 . 
download_dir
 :

176 
self
 . 
download_dir
 = 
expanduser
 ( 
self
 . 
download_dir
 )

177 if 
os
 . 
path
 . 
exists
 ( 
self
 . 
download_dir
 ) :

180 
logger
 . 
critical
 ( 'Could not find download directory' )

181 raise 
InstallationError
 ( "Could not find or access download directory '%s'"

183 % 
display_path
 ( 
self
 . 
download_dir
 ) )

184 return False 
	}

186 def 
	$prepare_linked_requirement
 ( 
self
 , 
req
 , 
session
 , 
finder
 ,

187 
upgrade_allowed
 , 
require_hashes
 ) :

191 if 
req
 . 
link
 and 
req
 . 
link
 . 
scheme
 == 'file' :

192 
path
 = 
url_to_path
 ( 
req
 . 
link
 . 
url
 )

193 
logger
 . 
info
 ( 'Processing %s' , 
display_path
 ( 
path
 ) )

195 
logger
 . 
info
 ( 'Collecting %s' , 
req
 )

197 with 
indent_log
 ( ) :

202 
req
 . 
ensure_has_source_dir
 ( 
self
 . 
build_dir
 )

209 if 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
req
 . 
source_dir
 , 'setup.py' ) ) :

210 raise 
PreviousBuildDirError
 ( "pip can't proceed with requirements '%s' due to a" " pre-existing build directory (%s). This is " "likely due to a previous installation that failed" ". pip is being responsible and not assuming it " "can delete this. Please delete it and try again."

216 % ( 
req
 , 
req
 . 
source_dir
 )

218 
req
 . 
populate_link
 ( 
finder
 , 
upgrade_allowed
 , 
require_hashes
 )

227 assert 
req
 . 
link

228 
link
 = 
req
 . 
link

234 if 
require_hashes
 :

240 if 
is_vcs_url
 ( 
link
 ) :

241 raise 
VcsHashUnsupported
 ( )

242 elif 
is_file_url
 ( 
link
 ) and 
is_dir_url
 ( 
link
 ) :

243 raise 
DirectoryUrlHashUnsupported
 ( )

244 if not 
req
 . 
original_link
 and not 
req
 . 
is_pinned
 :

252 raise 
HashUnpinned
 ( )

254 
hashes
 = 
req
 . 
hashes
 ( 
trust_internet
 = not 
require_hashes
 )

255 if 
require_hashes
 and not 
hashes
 :

260 
hashes
 = 
MissingHashes
 ( )

263 
download_dir
 = 
self
 . 
download_dir

265 
autodelete_unpacked
 = True

266 if 
req
 . 
link
 . 
is_wheel
 and 
self
 . 
wheel_download_dir
 :

269 
download_dir
 = 
self
 . 
wheel_download_dir

270 if 
req
 . 
link
 . 
is_wheel
 :

271 if 
download_dir
 :

274 
autodelete_unpacked
 = True

278 
autodelete_unpacked
 = False

279 
unpack_url
 (

280 
req
 . 
link
 , 
req
 . 
source_dir
 ,

281 
download_dir
 , 
autodelete_unpacked
 ,

282 
session
 = 
session
 , 
hashes
 = 
hashes
 ,

283 
progress_bar
 = 
self
 . 
progress_bar

285 except 
requests
 . 
HTTPError
 as 
exc
 :

286 
logger
 . 
critical
 ( 'Could not install requirement %s because of error %s'

288 
req
 ,

289 
exc
 ,

291 raise 
InstallationError
 ( 'Could not install requirement %s because of HTTP ' 'error %s for URL %s'

294 ( 
req
 , 
exc
 , 
req
 . 
link
 )

296 
abstract_dist
 = 
make_abstract_dist
 ( 
req
 )

297 with 
self
 . 
req_tracker
 . 
track
 ( 
req
 ) :

298 
abstract_dist
 . 
prep_for_dist
 ( 
finder
 , 
self
 . 
build_isolation
 )

299 if 
self
 . 
_download_should_save
 :

301 if 
req
 . 
link
 . 
scheme
 in 
vcs
 . 
all_schemes
 :

302 
req
 . 
archive
 ( 
self
 . 
download_dir
 )

303 return 
abstract_dist
 
	}

305 def 
	$prepare_editable_requirement
 ( 
self
 , 
req
 , 
require_hashes
 , 
use_user_site
 ,

306 
finder
 ) :

309 assert 
req
 . 
editable
 , "cannot prepare a non-editable req as editable"

311 
logger
 . 
info
 ( 'Obtaining %s' , 
req
 )

313 with 
indent_log
 ( ) :

314 if 
require_hashes
 :

315 raise 
InstallationError
 ( 'The editable requirement %s cannot be installed when ' 'requiring hashes, because there is no single file to ' 'hash.'

318 % 
req

320 
req
 . 
ensure_has_source_dir
 ( 
self
 . 
src_dir
 )

321 
req
 . 
update_editable
 ( not 
self
 . 
_download_should_save
 )

323 
abstract_dist
 = 
make_abstract_dist
 ( 
req
 )

324 with 
self
 . 
req_tracker
 . 
track
 ( 
req
 ) :

325 
abstract_dist
 . 
prep_for_dist
 ( 
finder
 , 
self
 . 
build_isolation
 )

327 if 
self
 . 
_download_should_save
 :

328 
req
 . 
archive
 ( 
self
 . 
download_dir
 )

329 
req
 . 
check_if_exists
 ( 
use_user_site
 )

331 return 
abstract_dist
 
	}

333 def 
	$prepare_installed_requirement
 ( 
self
 , 
req
 , 
require_hashes
 , 
skip_reason
 ) :

336 assert 
req
 . 
satisfied_by
 , "req should have been satisfied but isn't"

337 assert 
skip_reason
 is not None , ( "did not get skip reason skipped but req.satisfied_by " "is set to %r"

339 % ( 
req
 . 
satisfied_by
 , )

341 
logger
 . 
info
 ( 'Requirement %s: %s (%s)'

343 
skip_reason
 , 
req
 , 
req
 . 
satisfied_by
 . 
version

345 with 
indent_log
 ( ) :

346 if 
require_hashes
 :

347 
logger
 . 
debug
 ( 'Since it is already installed, we are trusting this ' 'package without checking its hash. To ensure a ' 'completely repeatable environment, install into an ' 'empty virtualenv.'

353 
abstract_dist
 = 
Installed
 ( 
req
 )

355 return 
abstract_dist
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/operations/check.py

4 from 
	~collections
 import 
namedtuple

6 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

8 from 
	~pip._internal.operations.prepare
 import 
make_abstract_dist

9 from 
	~pip._internal.utils.misc
 import 
get_installed_distributions

10 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

12 if 
MYPY_CHECK_RUNNING
 :

13 from 
	~pip._internal.req.req_install
 import 
InstallRequirement

14 from 
	~typing
 import (

15 
Any
 , 
Callable
 , 
Dict
 , 
Iterator
 , 
Optional
 , 
Set
 , 
Tuple
 , 
List

19 
PackageSet
 = 
Dict
 [ 
str
 , 'PackageDetails' ]

20 
Missing
 = 
Tuple
 [ 
str
 , 
Any
 ]

21 
Conflicting
 = 
Tuple
 [ 
str
 , 
str
 , 
Any
 ]

23 
MissingDict
 = 
Dict
 [ 
str
 , 
List
 [ 
Missing
 ] ]

24 
ConflictingDict
 = 
Dict
 [ 
str
 , 
List
 [ 
Conflicting
 ] ]

25 
CheckResult
 = 
Tuple
 [ 
MissingDict
 , 
ConflictingDict
 ]

27 
PackageDetails
 = 
namedtuple
 ( 'PackageDetails' , [ 'version' , 'requires' ] )

30 def 
	$create_package_set_from_installed
 ( ** 
kwargs
 ) :

35 if 
kwargs
 == { } :

36 
kwargs
 = { "local_only" : False , "skip" : ( ) }

38 
package_set
 = { }

39 for 
dist
 in 
get_installed_distributions
 ( ** 
kwargs
 ) :

40 
name
 = 
canonicalize_name
 ( 
dist
 . 
project_name
 )

41 
package_set
 [ 
name
 ] = 
PackageDetails
 ( 
dist
 . 
version
 , 
dist
 . 
requires
 ( ) )

42 return 
package_set
 
	}

45 def 
	$check_package_set
 ( 
package_set
 , 
should_ignore
 = None ) :

52 if 
should_ignore
 is None :

53 def 
should_ignore
 ( 
name
 ) :

56 
missing
 = 
dict
 ( )

57 
conflicting
 = 
dict
 ( )

59 for 
package_name
 in 
package_set
 :

61 
missing_deps
 = 
set
 ( )

62 
conflicting_deps
 = 
set
 ( )

64 if 
should_ignore
 ( 
package_name
 ) :

67 for 
req
 in 
package_set
 [ 
package_name
 ] . 
requires
 :

68 
name
 = 
canonicalize_name
 ( 
req
 . 
project_name
 )

71 if 
name
 not in 
package_set
 :

72 
missed
 = True

73 if 
req
 . 
marker
 is not None :

74 
missed
 = 
req
 . 
marker
 . 
evaluate
 ( )

75 if 
missed
 :

76 
missing_deps
 . 
add
 ( ( 
name
 , 
req
 ) )

80 
version
 = 
package_set
 [ 
name
 ] . 
version

81 if not 
req
 . 
specifier
 . 
contains
 ( 
version
 , 
prereleases
 = True ) :

82 
conflicting_deps
 . 
add
 ( ( 
name
 , 
version
 , 
req
 ) )

84 if 
missing_deps
 :

85 
missing
 [ 
package_name
 ] = 
sorted
 ( 
missing_deps
 , 
key
 = 
str
 )

86 if 
conflicting_deps
 :

87 
conflicting
 [ 
package_name
 ] = 
sorted
 ( 
conflicting_deps
 , 
key
 = 
str
 )

89 return 
missing
 , 
conflicting
 
	}

92 def 
	$check_install_conflicts
 ( 
to_install
 ) :

98 
package_set
 = 
create_package_set_from_installed
 ( )

100 
would_be_installed
 = 
_simulate_installation_of
 ( 
to_install
 , 
package_set
 )

103 
whitelist
 = 
_create_whitelist
 ( 
would_be_installed
 , 
package_set
 )

106 
package_set
 ,

107 
check_package_set
 (

108 
package_set
 , 
should_ignore
 = lambda 
name
 : 
name
 not in 
whitelist

110 ) 
	}

116 def 
	$_simulate_installation_of
 ( 
to_install
 , 
package_set
 ) :

122 
installed
 = 
set
 ( )

125 for 
inst_req
 in 
to_install
 :

126 
dist
 = 
make_abstract_dist
 ( 
inst_req
 ) . 
dist
 ( 
finder
 = None )

127 
name
 = 
canonicalize_name
 ( 
dist
 . 
key
 )

128 
package_set
 [ 
name
 ] = 
PackageDetails
 ( 
dist
 . 
version
 , 
dist
 . 
requires
 ( ) )

130 
installed
 . 
add
 ( 
name
 )

132 return 
installed
 
	}

135 def 
	$_create_whitelist
 ( 
would_be_installed
 , 
package_set
 ) :

137 
packages_affected
 = 
set
 ( 
would_be_installed
 )

139 for 
package_name
 in 
package_set
 :

140 if 
package_name
 in 
packages_affected
 :

143 for 
req
 in 
package_set
 [ 
package_name
 ] . 
requires
 :

144 if 
canonicalize_name
 ( 
req
 . 
name
 ) in 
packages_affected
 :

145 
packages_affected
 . 
add
 ( 
package_name
 )

148 return 
packages_affected
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/operations/__init__.py


	@./env/lib/python3.7/site-packages/pip/_internal/operations/freeze.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~collections

4 import 
	~logging

5 import 
	~os

6 import 
	~re

8 from 
	~pip._vendor
 import 
pkg_resources
 , 
six

9 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

10 from 
	~pip._vendor.pkg_resources
 import 
RequirementParseError

12 from 
	~pip._internal.exceptions
 import 
InstallationError

13 from 
	~pip._internal.req.constructors
 import (

14 
install_req_from_editable
 , 
install_req_from_line
 ,

16 from 
	~pip._internal.req.req_file
 import 
COMMENT_RE

17 from 
	~pip._internal.utils.deprecation
 import 
deprecated

18 from 
	~pip._internal.utils.misc
 import (

19 
dist_is_editable
 , 
get_installed_distributions
 , 
make_vcs_requirement_url
 ,

22 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

25 def 
	$freeze
 (

26 
requirement
 = None ,

27 
find_links
 = None , 
local_only
 = None , 
user_only
 = None , 
skip_regex
 = None ,

28 
isolated
 = False ,

29 
wheel_cache
 = None ,

30 
exclude_editable
 = False ,

31 
skip
 = ( ) ) :

32 
find_links
 = 
find_links
 or [ ]

33 
skip_match
 = None

35 if 
skip_regex
 :

36 
skip_match
 = 
re
 . 
compile
 ( 
skip_regex
 ) . 
search

38 
dependency_links
 = [ ]

40 for 
dist
 in 
pkg_resources
 . 
working_set
 :

41 if 
dist
 . 
has_metadata
 ( 'dependency_links.txt' ) :

42 
dependency_links
 . 
extend
 (

43 
dist
 . 
get_metadata_lines
 ( 'dependency_links.txt' )

45 for 
link
 in 
find_links
 :

46 if '#egg=' in 
link
 :

47 
dependency_links
 . 
append
 ( 
link
 )

48 for 
link
 in 
find_links
 :

49 yield '-f %s' % 
link

50 
installations
 = { }

51 for 
dist
 in 
get_installed_distributions
 ( 
local_only
 = 
local_only
 ,

52 
skip
 = ( ) ,

53 
user_only
 = 
user_only
 ) :

55 
req
 = 
FrozenRequirement
 . 
from_dist
 (

56 
dist
 ,

57 
dependency_links

59 except 
RequirementParseError
 :

60 
logger
 . 
warning
 ( "Could not parse requirement: %s"

62 
dist
 . 
project_name

65 if 
exclude_editable
 and 
req
 . 
editable
 :

67 
installations
 [ 
req
 . 
name
 ] = 
req

69 if 
requirement
 :

74 
emitted_options
 = 
set
 ( )

77 
req_files
 = 
collections
 . 
defaultdict
 ( 
list
 )

78 for 
req_file_path
 in 
requirement
 :

79 with 
open
 ( 
req_file_path
 ) as 
req_file
 :

80 for 
line
 in 
req_file
 :

81 if ( not 
line
 . 
strip
 ( ) or

82 
line
 . 
strip
 ( ) . 
startswith
 ( '#' ) or

83 ( 
skip_match
 and 
skip_match
 ( 
line
 ) ) or

84 
line
 . 
startswith
 ( ( '-r'

93 
line
 = 
line
 . 
rstrip
 ( )

94 if 
line
 not in 
emitted_options
 :

95 
emitted_options
 . 
add
 ( 
line
 )

96 yield 
line

99 if 
line
 . 
startswith
 ( '-e' ) or 
line
 . 
startswith
 ( '--editable' ) :

100 if 
line
 . 
startswith
 ( '-e' ) :

101 
line
 = 
line
 [ 2 : ] . 
strip
 ( )

103 
line
 = 
line
 [ 
len
 ( '--editable' ) : ] . 
strip
 ( ) . 
lstrip
 ( '=' )

104 
line_req
 = 
install_req_from_editable
 (

105 
line
 ,

106 
isolated
 = 
isolated
 ,

107 
wheel_cache
 = 
wheel_cache
 ,

110 
line_req
 = 
install_req_from_line
 (

111 
COMMENT_RE
 . 
sub
 ( '' , 
line
 ) . 
strip
 ( ) ,

112 
isolated
 = 
isolated
 ,

113 
wheel_cache
 = 
wheel_cache
 ,

116 if not 
line_req
 . 
name
 :

117 
logger
 . 
info
 ( "Skipping line in requirement file [%s] because " "it's not clear what it would install: %s"

120 
req_file_path
 , 
line
 . 
strip
 ( ) ,

122 
logger
 . 
info
 ( "  (add #egg=PackageName to the URL to avoid" " this warning)"

126 elif 
line_req
 . 
name
 not in 
installations
 :

129 if not 
req_files
 [ 
line_req
 . 
name
 ] :

130 
logger
 . 
warning
 ( "Requirement file [%s] contains %s, but that " "package is not installed"

133 
req_file_path
 ,

134 
COMMENT_RE
 . 
sub
 ( '' , 
line
 ) . 
strip
 ( ) ,

137 
req_files
 [ 
line_req
 . 
name
 ] . 
append
 ( 
req_file_path
 )

139 yield 
str
 ( 
installations
 [ 
line_req
 . 
name
 ] ) . 
rstrip
 ( )

140 del 
installations
 [ 
line_req
 . 
name
 ]

141 
req_files
 [ 
line_req
 . 
name
 ] . 
append
 ( 
req_file_path
 )

145 for 
name
 , 
files
 in 
six
 . 
iteritems
 ( 
req_files
 ) :

146 if 
len
 ( 
files
 ) > 1 :

147 
logger
 . 
warning
 ( "Requirement %s included multiple times [%s]" ,

148 
name
 , ', ' . 
join
 ( 
sorted
 ( 
set
 ( 
files
 ) ) ) )

154 for 
installation
 in 
sorted
 (

155 
installations
 . 
values
 ( ) , 
key
 = lambda 
x
 : 
x
 . 
name
 . 
lower
 ( ) ) :

156 if 
canonicalize_name
 ( 
installation
 . 
name
 ) not in 
skip
 :

157 yield 
str
 ( 
installation
 ) . 
rstrip
 ( ) 
	}

160 class 
	cFrozenRequirement
 ( 
object
 ) :

161 def 
	$__init__
 ( 
self
 , 
name
 , 
req
 , 
editable
 , 
comments
 = ( ) ) :

162 
self
 . 
name
 = 
name

163 
self
 . 
req
 = 
req

164 
self
 . 
editable
 = 
editable

165 
self
 . 
comments
 = 
comments
 
	}

167 
_rev_re
 = 
re
 . 
compile
 ( r'-r(\d+)$' )

168 
_date_re
 = 
re
 . 
compile
 ( r'-(20\d\d\d\d\d\d)$' )

170 @ 
classmethod

171 def 
	$_init_args_from_dist
 ( 
cls
 , 
dist
 , 
dependency_links
 ) :

178 
location
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
abspath
 ( 
dist
 . 
location
 ) )

179 
comments
 = [ ]

180 from 
	~pip._internal.vcs
 import 
vcs
 , 
get_src_requirement

181 if 
dist_is_editable
 ( 
dist
 ) and 
vcs
 . 
get_backend_name
 ( 
location
 ) :

182 
editable
 = True

184 
req
 = 
get_src_requirement
 ( 
dist
 , 
location
 )

185 except 
InstallationError
 as 
exc
 :

186 
logger
 . 
warning
 ( "Error when trying to get requirement for VCS system %s, " "falling back to uneditable format"

188 , 
exc

190 
req
 = None

191 if 
req
 is None :

192 
logger
 . 
warning
 ( 'Could not determine repository location of %s'

193 , 
location

195 
comments
 . 
append
 ( '## !! Could not determine repository location'

198 
req
 = 
dist
 . 
as_requirement
 ( )

199 
editable
 = False

201 
editable
 = False

202 
req
 = 
dist
 . 
as_requirement
 ( )

203 
specs
 = 
req
 . 
specs

204 assert 
len
 ( 
specs
 ) == 1 and 
specs
 [ 0 ] [ 0 ] in [ "==" , "===" ] , 'Expected 1 spec with == or ===; specs = %r; dist = %r'

206 ( 
specs
 , 
dist
 )

207 
version
 = 
specs
 [ 0 ] [ 1 ]

208 
ver_match
 = 
cls
 . 
_rev_re
 . 
search
 ( 
version
 )

209 
date_match
 = 
cls
 . 
_date_re
 . 
search
 ( 
version
 )

210 if 
ver_match
 or 
date_match
 :

211 
svn_backend
 = 
vcs
 . 
get_backend
 ( 'svn' )

212 if 
svn_backend
 :

213 
svn_location
 = 
svn_backend
 ( ) . 
get_location
 (

214 
dist
 ,

215 
dependency_links
 ,

217 if not 
svn_location
 :

218 
logger
 . 
warning
 ( 'Warning: cannot find svn location for %s'

219 , 
req
 ,

221 
comments
 . 
append
 ( '## FIXME: could not find svn URL in dependency_links ' 'for this package:'

226 
deprecated
 ( "SVN editable detection based on dependency links " "will be dropped in the future."

229 
replacement
 = None ,

230 
gone_in
 = "18.2" ,

231 
issue
 = 4187 ,

233 
comments
 . 
append
 ( '# Installing as editable to satisfy requirement %s:'

235 
req

237 if 
ver_match
 :

238 
rev
 = 
ver_match
 . 
group
 ( 1 )

240 
rev
 = '{%s}' % 
date_match
 . 
group
 ( 1 )

241 
editable
 = True

242 
egg_name
 = 
cls
 . 
egg_name
 ( 
dist
 )

243 
req
 = 
make_vcs_requirement_url
 ( 
svn_location
 , 
rev
 , 
egg_name
 )

245 return ( 
req
 , 
editable
 , 
comments
 ) 
	}

247 @ 
classmethod

248 def 
	$from_dist
 ( 
cls
 , 
dist
 , 
dependency_links
 ) :

249 
args
 = 
cls
 . 
_init_args_from_dist
 ( 
dist
 , 
dependency_links
 )

250 return 
cls
 ( 
dist
 . 
project_name
 , * 
args
 ) 
	}

252 @ 
	`staticmethod

253 def 
	$egg_name
 ( 
dist
 ) :

254 
name
 = 
dist
 . 
egg_name
 ( )

255 
match
 = 
re
 . 
search
 ( r'-py\d\.\d$' , 
name
 )

256 if 
match
 :

257 
name
 = 
name
 [ : 
match
 . 
start
 ( ) ]

258 return 
name
 
	}

260 def 
	$__str__
 ( 
self
 ) :

261 
req
 = 
self
 . 
req

262 if 
self
 . 
editable
 :

263 
req
 = '-e %s' % 
req

264 return '\n' . 
join
 ( 
list
 ( 
self
 . 
comments
 ) + [ 
str
 ( 
req
 ) ] ) + '\n' 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/constructors.py

11 import 
	~logging

12 import 
	~os

13 import 
	~re

14 import 
	~traceback

16 from 
	~pip._vendor.packaging.markers
 import 
Marker

17 from 
	~pip._vendor.packaging.requirements
 import 
InvalidRequirement
 , 
Requirement

18 from 
	~pip._vendor.packaging.specifiers
 import 
Specifier

19 from 
	~pip._vendor.pkg_resources
 import 
RequirementParseError
 , 
parse_requirements

21 from 
	~pip._internal.download
 import (

22 
is_archive_file
 , 
is_url
 , 
path_to_url
 , 
url_to_path
 ,

24 from 
	~pip._internal.exceptions
 import 
InstallationError

25 from 
	~pip._internal.models.index
 import 
PyPI
 , 
TestPyPI

26 from 
	~pip._internal.models.link
 import 
Link

27 from 
	~pip._internal.req.req_install
 import 
InstallRequirement

28 from 
	~pip._internal.utils.misc
 import 
is_installable_dir

29 from 
	~pip._internal.vcs
 import 
vcs

30 from 
	~pip._internal.wheel
 import 
Wheel

32 
__all__
 = [ "install_req_from_editable"

37 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

38 
operators
 = 
Specifier
 . 
_operators
 . 
keys
 ( )

41 def 
	$_strip_extras
 ( 
path
 ) :

42 
m
 = 
re
 . 
match
 ( r'^(.+)(\[[^\]]+\])$' , 
path
 )

43 
extras
 = None

44 if 
m
 :

45 
path_no_extras
 = 
m
 . 
group
 ( 1 )

46 
extras
 = 
m
 . 
group
 ( 2 )

48 
path_no_extras
 = 
path

50 return 
path_no_extras
 , 
extras
 
	}

53 def 
	$parse_editable
 ( 
editable_req
 ) :

64 
url
 = 
editable_req

67 
url_no_extras
 , 
extras
 = 
_strip_extras
 ( 
url
 )

69 if 
os
 . 
path
 . 
isdir
 ( 
url_no_extras
 ) :

70 if not 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
url_no_extras
 , 'setup.py' ) ) :

71 raise 
InstallationError
 ( "Directory %r is not installable. File 'setup.py' not found."

73 
url_no_extras

76 
url_no_extras
 = 
path_to_url
 ( 
url_no_extras
 )

78 if 
url_no_extras
 . 
lower
 ( ) . 
startswith
 ( 'file:' ) :

79 
package_name
 = 
Link
 ( 
url_no_extras
 ) . 
egg_fragment

80 if 
extras
 :

82 
package_name
 ,

83 
url_no_extras
 ,

84 
Requirement
 ( "placeholder" + 
extras
 . 
lower
 ( ) ) . 
extras
 ,

87 return 
package_name
 , 
url_no_extras
 , None

89 for 
version_control
 in 
vcs
 :

90 if 
url
 . 
lower
 ( ) . 
startswith
 ( '%s:' % 
version_control
 ) :

91 
url
 = '%s+%s' % ( 
version_control
 , 
url
 )

94 if '+' not in 
url
 :

95 raise 
InstallationError
 ( '%s should either be a path to a local project or a VCS url ' 'beginning with svn+, git+, hg+, or bzr+'

98 
editable_req

101 
vc_type
 = 
url
 . 
split
 ( '+' , 1 ) [ 0 ] . 
lower
 ( )

103 if not 
vcs
 . 
get_backend
 ( 
vc_type
 ) :

104 
error_message
 = 'For --editable=%s only ' % 
editable_req
 + ', '

105 . 
join
 ( [ 
backend
 . 
name
 + '+URL' for 
backend
 in 
vcs
 . 
backends
 ] ) + ' is currently supported'

107 raise 
InstallationError
 ( 
error_message
 )

109 
package_name
 = 
Link
 ( 
url
 ) . 
egg_fragment

110 if not 
package_name
 :

111 raise 
InstallationError
 ( "Could not detect requirement name for '%s', please specify one " "with #egg=your_package_name"

113 % 
editable_req

115 return 
package_name
 , 
url
 , None 
	}

118 def 
	$deduce_helpful_msg
 ( 
req
 ) :

124 
msg
 = ""

125 if 
os
 . 
path
 . 
exists
 ( 
req
 ) :

126 
msg
 = " It does exist."

129 with 
open
 ( 
req
 , 'r' ) as 
fp
 :

131 
next
 ( 
parse_requirements
 ( 
fp
 . 
read
 ( ) ) )

132 
msg
 += " The argument you provided " + "(%s) appears to be a"

133 % ( 
req
 ) + " requirements file. If that is the"

137 except 
RequirementParseError
 :

138 
logger
 . 
debug
 ( "Cannot parse '%s' as requirements \\n            file"

139 % ( 
req
 ) , 
exc_info
 = 1 )

141 
msg
 += " File '%s' does not exist." % ( 
req
 )

142 return 
msg
 
	}

148 def 
	$install_req_from_editable
 (

149 
editable_req
 , 
comes_from
 = None , 
isolated
 = False , 
options
 = None ,

150 
wheel_cache
 = None , 
constraint
 = False

152 
name
 , 
url
 , 
extras_override
 = 
parse_editable
 ( 
editable_req
 )

153 if 
url
 . 
startswith
 ( 'file:' ) :

154 
source_dir
 = 
url_to_path
 ( 
url
 )

156 
source_dir
 = None

158 if 
name
 is not None :

160 
req
 = 
Requirement
 ( 
name
 )

161 except 
InvalidRequirement
 :

162 raise 
InstallationError
 ( "Invalid requirement: '%s'" % 
name
 )

164 
req
 = None

165 return 
InstallRequirement
 (

166 
req
 , 
comes_from
 , 
source_dir
 = 
source_dir
 ,

167 
editable
 = True ,

168 
link
 = 
Link
 ( 
url
 ) ,

169 
constraint
 = 
constraint
 ,

170 
isolated
 = 
isolated
 ,

171 
options
 = 
options
 if 
options
 else { } ,

172 
wheel_cache
 = 
wheel_cache
 ,

173 
extras
 = 
extras_override
 or ( ) ,

174 ) 
	}

177 def 
	$install_req_from_line
 (

178 
name
 , 
comes_from
 = None , 
isolated
 = False , 
options
 = None , 
wheel_cache
 = None ,

179 
constraint
 = False

184 if 
is_url
 ( 
name
 ) :

185 
marker_sep
 = '; '

187 
marker_sep
 = ';'

188 if 
marker_sep
 in 
name
 :

189 
name
 , 
markers
 = 
name
 . 
split
 ( 
marker_sep
 , 1 )

190 
markers
 = 
markers
 . 
strip
 ( )

191 if not 
markers
 :

192 
markers
 = None

194 
markers
 = 
Marker
 ( 
markers
 )

196 
markers
 = None

197 
name
 = 
name
 . 
strip
 ( )

198 
req
 = None

199 
path
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
abspath
 ( 
name
 ) )

200 
link
 = None

201 
extras
 = None

203 if 
is_url
 ( 
name
 ) :

204 
link
 = 
Link
 ( 
name
 )

206 
p
 , 
extras
 = 
_strip_extras
 ( 
path
 )

207 
looks_like_dir
 = 
os
 . 
path
 . 
isdir
 ( 
p
 ) and (

208 
os
 . 
path
 . 
sep
 in 
name
 or

209 ( 
os
 . 
path
 . 
altsep
 is not None and 
os
 . 
path
 . 
altsep
 in 
name
 ) or

210 
name
 . 
startswith
 ( '.' )

212 if 
looks_like_dir
 :

213 if not 
is_installable_dir
 ( 
p
 ) :

214 raise 
InstallationError
 ( "Directory %r is not installable. Neither 'setup.py' " "nor 'pyproject.toml' found."

216 % 
name

218 
link
 = 
Link
 ( 
path_to_url
 ( 
p
 ) )

219 elif 
is_archive_file
 ( 
p
 ) :

220 if not 
os
 . 
path
 . 
isfile
 ( 
p
 ) :

221 
logger
 . 
warning
 ( 'Requirement %r looks like a filename, but the ' 'file does not exist'

224 
name

226 
link
 = 
Link
 ( 
path_to_url
 ( 
p
 ) )

229 if 
link
 :

231 if 
link
 . 
scheme
 == 'file' and 
re
 . 
search
 ( r'\.\./' , 
link
 . 
url
 ) :

232 
link
 = 
Link
 (

233 
path_to_url
 ( 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
abspath
 ( 
link
 . 
path
 ) ) ) )

235 if 
link
 . 
is_wheel
 :

236 
wheel
 = 
Wheel
 ( 
link
 . 
filename
 )

237 
req
 = "%s==%s" % ( 
wheel
 . 
name
 , 
wheel
 . 
version
 )

241 
req
 = 
link
 . 
egg_fragment

245 
req
 = 
name

247 if 
extras
 :

248 
extras
 = 
Requirement
 ( "placeholder" + 
extras
 . 
lower
 ( ) ) . 
extras

250 
extras
 = ( )

251 if 
req
 is not None :

253 
req
 = 
Requirement
 ( 
req
 )

254 except 
InvalidRequirement
 :

255 if 
os
 . 
path
 . 
sep
 in 
req
 :

256 
add_msg
 = "It looks like a path."

257 
add_msg
 += 
deduce_helpful_msg
 ( 
req
 )

258 elif '=' in 
req
 and not 
any
 ( 
op
 in 
req
 for 
op
 in 
operators
 ) :

259 
add_msg
 = "= is not a valid operator. Did you mean == ?"

261 
add_msg
 = 
traceback
 . 
format_exc
 ( )

262 raise 
InstallationError
 ( "Invalid requirement: '%s'\n%s"

263 % ( 
req
 , 
add_msg
 )

266 return 
InstallRequirement
 (

267 
req
 , 
comes_from
 , 
link
 = 
link
 , 
markers
 = 
markers
 ,

268 
isolated
 = 
isolated
 ,

269 
options
 = 
options
 if 
options
 else { } ,

270 
wheel_cache
 = 
wheel_cache
 ,

271 
constraint
 = 
constraint
 ,

272 
extras
 = 
extras
 ,

273 ) 
	}

276 def 
	$install_req_from_req
 (

277 
req
 , 
comes_from
 = None , 
isolated
 = False , 
wheel_cache
 = None

280 
req
 = 
Requirement
 ( 
req
 )

281 except 
InvalidRequirement
 :

282 raise 
InstallationError
 ( "Invalid requirement: '%s'" % 
req
 )

284 
domains_not_allowed
 = [

285 
PyPI
 . 
file_storage_domain
 ,

286 
TestPyPI
 . 
file_storage_domain
 ,

288 if 
req
 . 
url
 and 
comes_from
 . 
link
 . 
netloc
 in 
domains_not_allowed
 :

290 raise 
InstallationError
 ( "Packages installed from PyPI cannot depend on packages " "which are not also hosted on PyPI.\n" "%s depends on %s "

293 % ( 
comes_from
 . 
name
 , 
req
 )

296 return 
InstallRequirement
 (

297 
req
 , 
comes_from
 , 
isolated
 = 
isolated
 , 
wheel_cache
 = 
wheel_cache

298 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/req_install.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

5 import 
	~shutil

6 import 
	~sys

7 import 
	~sysconfig

8 import 
	~zipfile

9 from 
	~distutils.util
 import 
change_root

11 from 
	~pip._vendor
 import 
pkg_resources
 , 
six

12 from 
	~pip._vendor.packaging.requirements
 import 
Requirement

13 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

14 from 
	~pip._vendor.packaging.version
 import 
Version

15 from 
	~pip._vendor.packaging.version
 import 
parse
 as 
parse_version

16 from 
	~pip._vendor.pep517.wrappers
 import 
Pep517HookCaller

18 from 
	~pip._internal
 import 
wheel

19 from 
	~pip._internal.build_env
 import 
NoOpBuildEnvironment

20 from 
	~pip._internal.exceptions
 import 
InstallationError

21 from 
	~pip._internal.locations
 import (

22 
PIP_DELETE_MARKER_FILENAME
 , 
running_under_virtualenv
 ,

24 from 
	~pip._internal.models.link
 import 
Link

25 from 
	~pip._internal.pyproject
 import 
load_pyproject_toml

26 from 
	~pip._internal.req.req_uninstall
 import 
UninstallPathSet

27 from 
	~pip._internal.utils.compat
 import 
native_str

28 from 
	~pip._internal.utils.hashes
 import 
Hashes

29 from 
	~pip._internal.utils.logging
 import 
indent_log

30 from 
	~pip._internal.utils.misc
 import (

31 
_make_build_dir
 , 
ask_path_exists
 , 
backup_dir
 , 
call_subprocess
 ,

32 
display_path
 , 
dist_in_site_packages
 , 
dist_in_usersite
 , 
ensure_dir
 ,

33 
get_installed_version
 , 
rmtree
 ,

35 from 
	~pip._internal.utils.packaging
 import 
get_metadata

36 from 
	~pip._internal.utils.setuptools_build
 import 
SETUPTOOLS_SHIM

37 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

38 from 
	~pip._internal.utils.ui
 import 
open_spinner

39 from 
	~pip._internal.vcs
 import 
vcs

40 from 
	~pip._internal.wheel
 import 
move_wheel_files

42 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

45 class 
	cInstallRequirement
 ( 
object
 ) :

52 def 
	$__init__
 ( 
self
 , 
req
 , 
comes_from
 , 
source_dir
 = None , 
editable
 = False ,

53 
link
 = None , 
update
 = True , 
markers
 = None ,

54 
isolated
 = False , 
options
 = None , 
wheel_cache
 = None ,

55 
constraint
 = False , 
extras
 = ( ) ) :

56 assert 
req
 is None or 
isinstance
 ( 
req
 , 
Requirement
 ) , 
req

57 
self
 . 
req
 = 
req

58 
self
 . 
comes_from
 = 
comes_from

59 
self
 . 
constraint
 = 
constraint

60 if 
source_dir
 is not None :

61 
self
 . 
source_dir
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
abspath
 ( 
source_dir
 ) )

63 
self
 . 
source_dir
 = None

64 
self
 . 
editable
 = 
editable

66 
self
 . 
_wheel_cache
 = 
wheel_cache

67 if 
link
 is not None :

68 
self
 . 
link
 = 
self
 . 
original_link
 = 
link

70 
self
 . 
link
 = 
self
 . 
original_link
 = 
req
 and 
req
 . 
url
 and 
Link
 ( 
req
 . 
url
 )

72 if 
extras
 :

73 
self
 . 
extras
 = 
extras

74 elif 
req
 :

75 
self
 . 
extras
 = {

76 
pkg_resources
 . 
safe_extra
 ( 
extra
 ) for 
extra
 in 
req
 . 
extras

79 
self
 . 
extras
 = 
set
 ( )

80 if 
markers
 is not None :

81 
self
 . 
markers
 = 
markers

83 
self
 . 
markers
 = 
req
 and 
req
 . 
marker

84 
self
 . 
_egg_info_path
 = None

87 
self
 . 
satisfied_by
 = None

90 
self
 . 
conflicts_with
 = None

92 
self
 . 
_temp_build_dir
 = 
TempDirectory
 ( 
kind
 = "req-build" )

95 
self
 . 
_ideal_build_dir
 = None

97 
self
 . 
update
 = 
update

99 
self
 . 
install_succeeded
 = None

101 
self
 . 
uninstalled_pathset
 = None

102 
self
 . 
options
 = 
options
 if 
options
 else { }

104 
self
 . 
prepared
 = False

105 
self
 . 
is_direct
 = False

107 
self
 . 
isolated
 = 
isolated

108 
self
 . 
build_env
 = 
NoOpBuildEnvironment
 ( )

111 
self
 . 
pyproject_requires
 = None

115 
self
 . 
requirements_to_check
 = [ ]

118 
self
 . 
pep517_backend
 = None

125 
self
 . 
use_pep517
 = None 
	}

127 def 
	$__str__
 ( 
self
 ) :

128 if 
self
 . 
req
 :

129 
s
 = 
str
 ( 
self
 . 
req
 )

130 if 
self
 . 
link
 :

131 
s
 += ' from %s' % 
self
 . 
link
 . 
url

132 elif 
self
 . 
link
 :

133 
s
 = 
self
 . 
link
 . 
url

135 
s
 = '<InstallRequirement>'

136 if 
self
 . 
satisfied_by
 is not None :

137 
s
 += ' in %s' % 
display_path
 ( 
self
 . 
satisfied_by
 . 
location
 )

138 if 
self
 . 
comes_from
 :

139 if 
isinstance
 ( 
self
 . 
comes_from
 , 
six
 . 
string_types
 ) :

140 
comes_from
 = 
self
 . 
comes_from

142 
comes_from
 = 
self
 . 
comes_from
 . 
from_path
 ( )

143 if 
comes_from
 :

144 
s
 += ' (from %s)' % 
comes_from

145 return 
s
 
	}

147 def 
	$__repr__
 ( 
self
 ) :

149 
self
 . 
__class__
 . 
__name__
 , 
str
 ( 
self
 ) , 
self
 . 
editable
 ) 
	}

151 def 
	$populate_link
 ( 
self
 , 
finder
 , 
upgrade
 , 
require_hashes
 ) :

163 if 
self
 . 
link
 is None :

164 
self
 . 
link
 = 
finder
 . 
find_requirement
 ( 
self
 , 
upgrade
 )

165 if 
self
 . 
_wheel_cache
 is not None and not 
require_hashes
 :

166 
old_link
 = 
self
 . 
link

167 
self
 . 
link
 = 
self
 . 
_wheel_cache
 . 
get
 ( 
self
 . 
link
 , 
self
 . 
name
 )

168 if 
old_link
 != 
self
 . 
link
 :

169 
logger
 . 
debug
 ( 'Using cached wheel link: %s' , 
self
 . 
link
 ) 
	}

172 @ 
property

173 def 
	$name
 ( 
self
 ) :

174 if 
self
 . 
req
 is None :

176 return 
native_str
 ( 
pkg_resources
 . 
safe_name
 ( 
self
 . 
req
 . 
name
 ) ) 
	}

178 @ 
property

179 def 
	$specifier
 ( 
self
 ) :

180 return 
self
 . 
req
 . 
specifier
 
	}

182 @ 
property

183 def 
	$is_pinned
 ( 
self
 ) :

188 
specifiers
 = 
self
 . 
specifier

189 return ( 
len
 ( 
specifiers
 ) == 1 and

190 
next
 ( 
iter
 ( 
specifiers
 ) ) . 
operator
 in { '==' , '===' } ) 
	}

192 @ 
property

193 def 
	$installed_version
 ( 
self
 ) :

194 return 
get_installed_version
 ( 
self
 . 
name
 ) 
	}

196 def 
	$match_markers
 ( 
self
 , 
extras_requested
 = None ) :

197 if not 
extras_requested
 :

200 
extras_requested
 = ( '' , )

201 if 
self
 . 
markers
 is not None :

202 return 
any
 (

203 
self
 . 
markers
 . 
evaluate
 ( { 'extra' : 
extra
 } )

204 for 
extra
 in 
extras_requested
 )

206 return True 
	}

208 @ 
property

209 def 
	$has_hash_options
 ( 
self
 ) :

216 return 
bool
 ( 
self
 . 
options
 . 
get
 ( 'hashes' , { } ) ) 
	}

218 def 
	$hashes
 ( 
self
 , 
trust_internet
 = True ) :

233 
good_hashes
 = 
self
 . 
options
 . 
get
 ( 'hashes' , { } ) . 
copy
 ( )

234 
link
 = 
self
 . 
link
 if 
trust_internet
 else 
self
 . 
original_link

235 if 
link
 and 
link
 . 
hash
 :

236 
good_hashes
 . 
setdefault
 ( 
link
 . 
hash_name
 , [ ] ) . 
append
 ( 
link
 . 
hash
 )

237 return 
Hashes
 ( 
good_hashes
 ) 
	}

239 def 
	$from_path
 ( 
self
 ) :

242 if 
self
 . 
req
 is None :

244 
s
 = 
str
 ( 
self
 . 
req
 )

245 if 
self
 . 
comes_from
 :

246 if 
isinstance
 ( 
self
 . 
comes_from
 , 
six
 . 
string_types
 ) :

247 
comes_from
 = 
self
 . 
comes_from

249 
comes_from
 = 
self
 . 
comes_from
 . 
from_path
 ( )

250 if 
comes_from
 :

251 
s
 += '->' + 
comes_from

252 return 
s
 
	}

254 def 
	$build_location
 ( 
self
 , 
build_dir
 ) :

255 assert 
build_dir
 is not None

256 if 
self
 . 
_temp_build_dir
 . 
path
 is not None :

257 return 
self
 . 
_temp_build_dir
 . 
path

258 if 
self
 . 
req
 is None :

266 
self
 . 
_temp_build_dir
 . 
create
 ( )

267 
self
 . 
_ideal_build_dir
 = 
build_dir

269 return 
self
 . 
_temp_build_dir
 . 
path

270 if 
self
 . 
editable
 :

271 
name
 = 
self
 . 
name
 . 
lower
 ( )

273 
name
 = 
self
 . 
name

276 if not 
os
 . 
path
 . 
exists
 ( 
build_dir
 ) :

277 
logger
 . 
debug
 ( 'Creating directory %s' , 
build_dir
 )

278 
_make_build_dir
 ( 
build_dir
 )

279 return 
os
 . 
path
 . 
join
 ( 
build_dir
 , 
name
 ) 
	}

281 def 
	$_correct_build_location
 ( 
self
 ) :

291 if 
self
 . 
source_dir
 is not None :

293 assert 
self
 . 
req
 is not None

294 assert 
self
 . 
_temp_build_dir
 . 
path

295 assert 
self
 . 
_ideal_build_dir
 . 
path

296 
old_location
 = 
self
 . 
_temp_build_dir
 . 
path

297 
self
 . 
_temp_build_dir
 . 
path
 = None

299 
new_location
 = 
self
 . 
build_location
 ( 
self
 . 
_ideal_build_dir
 )

300 if 
os
 . 
path
 . 
exists
 ( 
new_location
 ) :

301 raise 
InstallationError
 ( 'A package already exists in %s; please remove it to continue'

303 % 
display_path
 ( 
new_location
 ) )

304 
logger
 . 
debug
 ( 'Moving package %s from %s to new location %s'

306 
self
 , 
display_path
 ( 
old_location
 ) , 
display_path
 ( 
new_location
 ) ,

308 
shutil
 . 
move
 ( 
old_location
 , 
new_location
 )

309 
self
 . 
_temp_build_dir
 . 
path
 = 
new_location

310 
self
 . 
_ideal_build_dir
 = None

311 
self
 . 
source_dir
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
abspath
 ( 
new_location
 ) )

312 
self
 . 
_egg_info_path
 = None 
	}

314 def 
	$remove_temporary_source
 ( 
self
 ) :

317 if 
self
 . 
source_dir
 and 
os
 . 
path
 . 
exists
 (

318 
os
 . 
path
 . 
join
 ( 
self
 . 
source_dir
 , 
PIP_DELETE_MARKER_FILENAME
 ) ) :

319 
logger
 . 
debug
 ( 'Removing source in %s' , 
self
 . 
source_dir
 )

320 
rmtree
 ( 
self
 . 
source_dir
 )

321 
self
 . 
source_dir
 = None

322 
self
 . 
_temp_build_dir
 . 
cleanup
 ( )

323 
self
 . 
build_env
 . 
cleanup
 ( ) 
	}

325 def 
	$check_if_exists
 ( 
self
 , 
use_user_site
 ) :

330 if 
self
 . 
req
 is None :

337 
no_marker
 = 
Requirement
 ( 
str
 ( 
self
 . 
req
 ) )

338 
no_marker
 . 
marker
 = None

339 
self
 . 
satisfied_by
 = 
pkg_resources
 . 
get_distribution
 ( 
str
 ( 
no_marker
 ) )

340 if 
self
 . 
editable
 and 
self
 . 
satisfied_by
 :

341 
self
 . 
conflicts_with
 = 
self
 . 
satisfied_by

344 
self
 . 
satisfied_by
 = None

346 except 
pkg_resources
 . 
DistributionNotFound
 :

348 except 
pkg_resources
 . 
VersionConflict
 :

349 
existing_dist
 = 
pkg_resources
 . 
get_distribution
 (

350 
self
 . 
req
 . 
name

352 if 
use_user_site
 :

353 if 
dist_in_usersite
 ( 
existing_dist
 ) :

354 
self
 . 
conflicts_with
 = 
existing_dist

355 elif ( 
running_under_virtualenv
 ( ) and

356 
dist_in_site_packages
 ( 
existing_dist
 ) ) :

357 raise 
InstallationError
 ( "Will not install to the user site because it will " "lack sys.path precedence to %s in %s"

360 ( 
existing_dist
 . 
project_name
 , 
existing_dist
 . 
location
 )

363 
self
 . 
conflicts_with
 = 
existing_dist

364 return True 
	}

367 @ 
property

368 def 
	$is_wheel
 ( 
self
 ) :

369 return 
self
 . 
link
 and 
self
 . 
link
 . 
is_wheel
 
	}

371 def 
	$move_wheel_files
 ( 
self
 , 
wheeldir
 , 
root
 = None , 
home
 = None , 
prefix
 = None ,

372 
warn_script_location
 = True , 
use_user_site
 = False ,

373 
pycompile
 = True ) :

374 
move_wheel_files
 (

375 
self
 . 
name
 , 
self
 . 
req
 , 
wheeldir
 ,

376 
user
 = 
use_user_site
 ,

377 
home
 = 
home
 ,

378 
root
 = 
root
 ,

379 
prefix
 = 
prefix
 ,

380 
pycompile
 = 
pycompile
 ,

381 
isolated
 = 
self
 . 
isolated
 ,

382 
warn_script_location
 = 
warn_script_location
 ,

383 ) 
	}

386 @ 
property

387 def 
	$setup_py_dir
 ( 
self
 ) :

388 return 
os
 . 
path
 . 
join
 (

389 
self
 . 
source_dir
 ,

390 
self
 . 
link
 and 
self
 . 
link
 . 
subdirectory_fragment
 or '' ) 
	}

392 @ 
property

393 def 
	$setup_py
 ( 
self
 ) :

394 assert 
self
 . 
source_dir
 , "No source dir for %s" % 
self

396 
setup_py
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
setup_py_dir
 , 'setup.py' )

399 if 
six
 . 
PY2
 and 
isinstance
 ( 
setup_py
 , 
six
 . 
text_type
 ) :

400 
setup_py
 = 
setup_py
 . 
encode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

402 return 
setup_py
 
	}

404 @ 
property

405 def 
	$pyproject_toml
 ( 
self
 ) :

406 assert 
self
 . 
source_dir
 , "No source dir for %s" % 
self

408 
pp_toml
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
setup_py_dir
 , 'pyproject.toml' )

411 if 
six
 . 
PY2
 and 
isinstance
 ( 
pp_toml
 , 
six
 . 
text_type
 ) :

412 
pp_toml
 = 
pp_toml
 . 
encode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

414 return 
pp_toml
 
	}

416 def 
	$load_pyproject_toml
 ( 
self
 ) :

424 
pep517_data
 = 
load_pyproject_toml
 (

425 
self
 . 
use_pep517
 ,

426 
self
 . 
pyproject_toml
 ,

427 
self
 . 
setup_py
 ,

428 
str
 ( 
self
 )

431 if 
pep517_data
 is None :

432 
self
 . 
use_pep517
 = False

434 
self
 . 
use_pep517
 = True

435 
requires
 , 
backend
 , 
check
 = 
pep517_data

436 
self
 . 
requirements_to_check
 = 
check

437 
self
 . 
pyproject_requires
 = 
requires

438 
self
 . 
pep517_backend
 = 
Pep517HookCaller
 ( 
self
 . 
setup_py_dir
 , 
backend
 ) 
	}

440 def 
	$run_egg_info
 ( 
self
 ) :

441 assert 
self
 . 
source_dir

442 if 
self
 . 
name
 :

443 
logger
 . 
debug
 ( 'Running setup.py (path:%s) egg_info for package %s'

445 
self
 . 
setup_py
 , 
self
 . 
name
 ,

448 
logger
 . 
debug
 ( 'Running setup.py (path:%s) egg_info for package from %s'

450 
self
 . 
setup_py
 , 
self
 . 
link
 ,

453 with 
indent_log
 ( ) :

454 
script
 = 
SETUPTOOLS_SHIM
 % 
self
 . 
setup_py

455 
base_cmd
 = [ 
sys
 . 
executable
 , '-c' , 
script
 ]

456 if 
self
 . 
isolated
 :

457 
base_cmd
 += [ "--no-user-cfg" ]

458 
egg_info_cmd
 = 
base_cmd
 + [ 'egg_info' ]

462 if 
self
 . 
editable
 :

463 
egg_base_option
 = [ ]

465 
egg_info_dir
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
setup_py_dir
 , 'pip-egg-info' )

466 
ensure_dir
 ( 
egg_info_dir
 )

467 
egg_base_option
 = [ '--egg-base' , 'pip-egg-info' ]

468 with 
self
 . 
build_env
 :

469 
call_subprocess
 (

470 
egg_info_cmd
 + 
egg_base_option
 ,

471 
cwd
 = 
self
 . 
setup_py_dir
 ,

472 
show_stdout
 = False ,

473 
command_desc
 = 'python setup.py egg_info' )

475 if not 
self
 . 
req
 :

476 if 
isinstance
 ( 
parse_version
 ( 
self
 . 
metadata
 [ "Version" ] ) , 
Version
 ) :

477 
op
 = "=="

479 
op
 = "==="

480 
self
 . 
req
 = 
Requirement
 ( ""

481 . 
join
 ( [

482 
self
 . 
metadata
 [ "Name" ] ,

483 
op
 ,

484 
self
 . 
metadata
 [ "Version" ] ,

487 
self
 . 
_correct_build_location
 ( )

489 
metadata_name
 = 
canonicalize_name
 ( 
self
 . 
metadata
 [ "Name" ] )

490 if 
canonicalize_name
 ( 
self
 . 
req
 . 
name
 ) != 
metadata_name
 :

491 
logger
 . 
warning
 ( 'Running setup.py (path:%s) egg_info for package %s ' 'produced metadata for project name %s. Fix your ' '#egg=%s fragments.'

495 
self
 . 
setup_py
 , 
self
 . 
name
 , 
metadata_name
 , 
self
 . 
name

497 
self
 . 
req
 = 
Requirement
 ( 
metadata_name
 ) 
	}

499 @ 
property

500 def 
	$egg_info_path
 ( 
self
 ) :

501 if 
self
 . 
_egg_info_path
 is None :

502 if 
self
 . 
editable
 :

503 
base
 = 
self
 . 
source_dir

505 
base
 = 
os
 . 
path
 . 
join
 ( 
self
 . 
setup_py_dir
 , 'pip-egg-info' )

506 
filenames
 = 
os
 . 
listdir
 ( 
base
 )

507 if 
self
 . 
editable
 :

508 
filenames
 = [ ]

509 for 
root
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
base
 ) :

510 for 
dir
 in 
vcs
 . 
dirnames
 :

511 if 
dir
 in 
dirs
 :

512 
dirs
 . 
remove
 ( 
dir
 )

516 for 
dir
 in 
list
 ( 
dirs
 ) :

520 
os
 . 
path
 . 
lexists
 (

521 
os
 . 
path
 . 
join
 ( 
root
 , 
dir
 , 'bin' , 'python' )

523 
os
 . 
path
 . 
exists
 (

524 
os
 . 
path
 . 
join
 (

525 
root
 , 
dir
 , 'Scripts' , 'Python.exe'

528 
dirs
 . 
remove
 ( 
dir
 )

530 elif 
dir
 == 'test' or 
dir
 == 'tests' :

531 
dirs
 . 
remove
 ( 
dir
 )

532 
filenames
 . 
extend
 ( [ 
os
 . 
path
 . 
join
 ( 
root
 , 
dir
 )

533 for 
dir
 in 
dirs
 ] )

534 
filenames
 = [ 
f
 for 
f
 in 
filenames
 if 
f
 . 
endswith
 ( '.egg-info' ) ]

536 if not 
filenames
 :

537 raise 
InstallationError
 ( "Files/directories not found in %s"

538 % 
base

543 if 
len
 ( 
filenames
 ) > 1 :

544 
filenames
 . 
sort
 (

545 
key
 = lambda 
x
 : 
x
 . 
count
 ( 
os
 . 
path
 . 
sep
 ) +

546 ( 
os
 . 
path
 . 
altsep
 and 
x
 . 
count
 ( 
os
 . 
path
 . 
altsep
 ) or 0 )

548 
self
 . 
_egg_info_path
 = 
os
 . 
path
 . 
join
 ( 
base
 , 
filenames
 [ 0 ] )

549 return 
self
 . 
_egg_info_path
 
	}

551 @ 
property

552 def 
	$metadata
 ( 
self
 ) :

553 if not 
hasattr
 ( 
self
 , '_metadata' ) :

554 
self
 . 
_metadata
 = 
get_metadata
 ( 
self
 . 
get_dist
 ( ) )

556 return 
self
 . 
_metadata
 
	}

558 def 
	$get_dist
 ( 
self
 ) :

560 
egg_info
 = 
self
 . 
egg_info_path
 . 
rstrip
 ( 
os
 . 
path
 . 
sep
 )

561 
base_dir
 = 
os
 . 
path
 . 
dirname
 ( 
egg_info
 )

562 
metadata
 = 
pkg_resources
 . 
PathMetadata
 ( 
base_dir
 , 
egg_info
 )

563 
dist_name
 = 
os
 . 
path
 . 
splitext
 ( 
os
 . 
path
 . 
basename
 ( 
egg_info
 ) ) [ 0 ]

564 return 
pkg_resources
 . 
Distribution
 (

565 
os
 . 
path
 . 
dirname
 ( 
egg_info
 ) ,

566 
project_name
 = 
dist_name
 ,

567 
metadata
 = 
metadata
 ,

568 ) 
	}

570 def 
	$assert_source_matches_version
 ( 
self
 ) :

571 assert 
self
 . 
source_dir

572 
version
 = 
self
 . 
metadata
 [ 'version' ]

573 if 
self
 . 
req
 . 
specifier
 and 
version
 not in 
self
 . 
req
 . 
specifier
 :

574 
logger
 . 
warning
 ( 'Requested %s, but installing version %s'

576 
self
 ,

577 
version
 ,

580 
logger
 . 
debug
 ( 'Source in %s has version %s, which satisfies requirement %s'

582 
display_path
 ( 
self
 . 
source_dir
 ) ,

583 
version
 ,

584 
self
 ,

585 ) 
	}

588 def 
	$ensure_has_source_dir
 ( 
self
 , 
parent_dir
 ) :

598 if 
self
 . 
source_dir
 is None :

599 
self
 . 
source_dir
 = 
self
 . 
build_location
 ( 
parent_dir
 )

600 return 
self
 . 
source_dir
 
	}

603 def 
	$install_editable
 ( 
self
 , 
install_options
 ,

604 
global_options
 = ( ) , 
prefix
 = None ) :

605 
logger
 . 
info
 ( 'Running setup.py develop for %s' , 
self
 . 
name
 )

607 if 
self
 . 
isolated
 :

608 
global_options
 = 
list
 ( 
global_options
 ) + [ "--no-user-cfg" ]

610 if 
prefix
 :

611 
prefix_param
 = [ '--prefix={}' . 
format
 ( 
prefix
 ) ]

612 
install_options
 = 
list
 ( 
install_options
 ) + 
prefix_param

614 with 
indent_log
 ( ) :

616 with 
self
 . 
build_env
 :

617 
call_subprocess
 (

619 
sys
 . 
executable
 , '-c'

621 
SETUPTOOLS_SHIM
 % 
self
 . 
setup_py

623 
list
 ( 
global_options
 ) +

625 
list
 ( 
install_options
 ) ,

627 
cwd
 = 
self
 . 
setup_py_dir
 ,

628 
show_stdout
 = False ,

631 
self
 . 
install_succeeded
 = True 
	}

633 def 
	$update_editable
 ( 
self
 , 
obtain
 = True ) :

634 if not 
self
 . 
link
 :

635 
logger
 . 
debug
 ( "Cannot update repository at %s; repository location is " "unknown"

638 
self
 . 
source_dir
 ,

641 assert 
self
 . 
editable

642 assert 
self
 . 
source_dir

643 if 
self
 . 
link
 . 
scheme
 == 'file' :

646 assert '+' in 
self
 . 
link
 . 
url
 , "bad url: %r" % 
self
 . 
link
 . 
url

647 if not 
self
 . 
update
 :

649 
vc_type
 , 
url
 = 
self
 . 
link
 . 
url
 . 
split
 ( '+' , 1 )

650 
backend
 = 
vcs
 . 
get_backend
 ( 
vc_type
 )

651 if 
backend
 :

652 
vcs_backend
 = 
backend
 ( 
self
 . 
link
 . 
url
 )

653 if 
obtain
 :

654 
vcs_backend
 . 
obtain
 ( 
self
 . 
source_dir
 )

656 
vcs_backend
 . 
export
 ( 
self
 . 
source_dir
 )

660 % ( 
self
 . 
link
 , 
vc_type
 ) ) 
	}

663 def 
	$uninstall
 ( 
self
 , 
auto_confirm
 = False , 
verbose
 = False ,

664 
use_user_site
 = False ) :

677 if not 
self
 . 
check_if_exists
 ( 
use_user_site
 ) :

678 
logger
 . 
warning
 ( "Skipping %s as it is not installed." , 
self
 . 
name
 )

680 
dist
 = 
self
 . 
satisfied_by
 or 
self
 . 
conflicts_with

682 
uninstalled_pathset
 = 
UninstallPathSet
 . 
from_dist
 ( 
dist
 )

683 
uninstalled_pathset
 . 
remove
 ( 
auto_confirm
 , 
verbose
 )

684 return 
uninstalled_pathset
 
	}

686 def 
	$_clean_zip_name
 ( 
self
 , 
name
 , 
prefix
 ) :

687 assert 
name
 . 
startswith
 ( 
prefix
 + 
os
 . 
path
 . 
sep
 ) , ( "name %r doesn't start with prefix %r"

688 % ( 
name
 , 
prefix
 )

690 
name
 = 
name
 [ 
len
 ( 
prefix
 ) + 1 : ]

691 
name
 = 
name
 . 
replace
 ( 
os
 . 
path
 . 
sep
 , '/' )

692 return 
name
 
	}

696 def 
	$archive
 ( 
self
 , 
build_dir
 ) :

697 assert 
self
 . 
source_dir

698 
create_archive
 = True

699 
archive_name
 = '%s-%s.zip' % ( 
self
 . 
name
 , 
self
 . 
metadata
 [ "version" ] )

700 
archive_path
 = 
os
 . 
path
 . 
join
 ( 
build_dir
 , 
archive_name
 )

701 if 
os
 . 
path
 . 
exists
 ( 
archive_path
 ) :

702 
response
 = 
ask_path_exists
 ( 'The file %s exists. (i)gnore, (w)ipe, (b)ackup, (a)bort '

704 
display_path
 ( 
archive_path
 ) , ( 'i' , 'w' , 'b' , 'a' ) )

705 if 
response
 == 'i' :

706 
create_archive
 = False

707 elif 
response
 == 'w' :

708 
logger
 . 
warning
 ( 'Deleting %s' , 
display_path
 ( 
archive_path
 ) )

709 
os
 . 
remove
 ( 
archive_path
 )

710 elif 
response
 == 'b' :

711 
dest_file
 = 
backup_dir
 ( 
archive_path
 )

712 
logger
 . 
warning
 ( 'Backing up %s to %s'

714 
display_path
 ( 
archive_path
 ) ,

715 
display_path
 ( 
dest_file
 ) ,

717 
shutil
 . 
move
 ( 
archive_path
 , 
dest_file
 )

718 elif 
response
 == 'a' :

719 
sys
 . 
exit
 ( - 1 )

720 if 
create_archive
 :

721 
zip
 = 
zipfile
 . 
ZipFile
 (

722 
archive_path
 , 'w' , 
zipfile
 . 
ZIP_DEFLATED
 ,

723 
allowZip64
 = True

725 
dir
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
abspath
 ( 
self
 . 
setup_py_dir
 ) )

726 for 
dirpath
 , 
dirnames
 , 
filenames
 in 
os
 . 
walk
 ( 
dir
 ) :

727 if 'pip-egg-info' in 
dirnames
 :

728 
dirnames
 . 
remove
 ( 'pip-egg-info' )

729 for 
dirname
 in 
dirnames
 :

730 
dirname
 = 
os
 . 
path
 . 
join
 ( 
dirpath
 , 
dirname
 )

731 
name
 = 
self
 . 
_clean_zip_name
 ( 
dirname
 , 
dir
 )

732 
zipdir
 = 
zipfile
 . 
ZipInfo
 ( 
self
 . 
name
 + '/' + 
name
 + '/' )

733 
zipdir
 . 
external_attr
 = 0x1ED << 16

734 
zip
 . 
writestr
 ( 
zipdir
 , '' )

735 for 
filename
 in 
filenames
 :

736 if 
filename
 == 
PIP_DELETE_MARKER_FILENAME
 :

738 
filename
 = 
os
 . 
path
 . 
join
 ( 
dirpath
 , 
filename
 )

739 
name
 = 
self
 . 
_clean_zip_name
 ( 
filename
 , 
dir
 )

740 
zip
 . 
write
 ( 
filename
 , 
self
 . 
name
 + '/' + 
name
 )

741 
zip
 . 
close
 ( )

742 
logger
 . 
info
 ( 'Saved %s' , 
display_path
 ( 
archive_path
 ) ) 
	}

744 def 
	$install
 ( 
self
 , 
install_options
 , 
global_options
 = None , 
root
 = None ,

745 
home
 = None , 
prefix
 = None , 
warn_script_location
 = True ,

746 
use_user_site
 = False , 
pycompile
 = True ) :

747 
global_options
 = 
global_options
 if 
global_options
 is not None else [ ]

748 if 
self
 . 
editable
 :

749 
self
 . 
install_editable
 (

750 
install_options
 , 
global_options
 , 
prefix
 = 
prefix
 ,

753 if 
self
 . 
is_wheel
 :

754 
version
 = 
wheel
 . 
wheel_version
 ( 
self
 . 
source_dir
 )

755 
wheel
 . 
check_compatibility
 ( 
version
 , 
self
 . 
name
 )

757 
self
 . 
move_wheel_files
 (

758 
self
 . 
source_dir
 , 
root
 = 
root
 , 
prefix
 = 
prefix
 , 
home
 = 
home
 ,

759 
warn_script_location
 = 
warn_script_location
 ,

760 
use_user_site
 = 
use_user_site
 , 
pycompile
 = 
pycompile
 ,

762 
self
 . 
install_succeeded
 = True

770 
global_options
 = 
list
 ( 
global_options
 ) +

771 
self
 . 
options
 . 
get
 ( 'global_options' , [ ] )

772 
install_options
 = 
list
 ( 
install_options
 ) +

773 
self
 . 
options
 . 
get
 ( 'install_options' , [ ] )

775 if 
self
 . 
isolated
 :

776 
global_options
 = 
global_options
 + [ "--no-user-cfg" ]

778 with 
TempDirectory
 ( 
kind
 = "record" ) as 
temp_dir
 :

779 
record_filename
 = 
os
 . 
path
 . 
join
 ( 
temp_dir
 . 
path
 , 'install-record.txt' )

780 
install_args
 = 
self
 . 
get_install_args
 (

781 
global_options
 , 
record_filename
 , 
root
 , 
prefix
 , 
pycompile
 ,

783 
msg
 = 'Running setup.py install for %s' % ( 
self
 . 
name
 , )

784 with 
open_spinner
 ( 
msg
 ) as 
spinner
 :

785 with 
indent_log
 ( ) :

786 with 
self
 . 
build_env
 :

787 
call_subprocess
 (

788 
install_args
 + 
install_options
 ,

789 
cwd
 = 
self
 . 
setup_py_dir
 ,

790 
show_stdout
 = False ,

791 
spinner
 = 
spinner
 ,

794 if not 
os
 . 
path
 . 
exists
 ( 
record_filename
 ) :

795 
logger
 . 
debug
 ( 'Record file %s not found' , 
record_filename
 )

797 
self
 . 
install_succeeded
 = True

799 def 
prepend_root
 ( 
path
 ) :

800 if 
root
 is None or not 
os
 . 
path
 . 
isabs
 ( 
path
 ) :

801 return 
path

803 return 
change_root
 ( 
root
 , 
path
 )

805 with 
open
 ( 
record_filename
 ) as 
f
 :

806 for 
line
 in 
f
 :

807 
directory
 = 
os
 . 
path
 . 
dirname
 ( 
line
 )

808 if 
directory
 . 
endswith
 ( '.egg-info' ) :

809 
egg_info_dir
 = 
prepend_root
 ( 
directory
 )

812 
logger
 . 
warning
 ( 'Could not find .egg-info directory in install record' ' for %s'

815 
self
 ,

820 
new_lines
 = [ ]

821 with 
open
 ( 
record_filename
 ) as 
f
 :

822 for 
line
 in 
f
 :

823 
filename
 = 
line
 . 
strip
 ( )

824 if 
os
 . 
path
 . 
isdir
 ( 
filename
 ) :

825 
filename
 += 
os
 . 
path
 . 
sep

826 
new_lines
 . 
append
 (

827 
os
 . 
path
 . 
relpath
 ( 
prepend_root
 ( 
filename
 ) , 
egg_info_dir
 )

829 
new_lines
 . 
sort
 ( )

830 
ensure_dir
 ( 
egg_info_dir
 )

831 
inst_files_path
 = 
os
 . 
path
 . 
join
 ( 
egg_info_dir
 , 'installed-files.txt' )

832 with 
open
 ( 
inst_files_path
 , 'w' ) as 
f
 :

833 
f
 . 
write
 ( '\n' . 
join
 ( 
new_lines
 ) + '\n' ) 
	}

835 def 
	$get_install_args
 ( 
self
 , 
global_options
 , 
record_filename
 , 
root
 , 
prefix
 ,

836 
pycompile
 ) :

837 
install_args
 = [ 
sys
 . 
executable
 , "-u" ]

838 
install_args
 . 
append
 ( '-c' )

839 
install_args
 . 
append
 ( 
SETUPTOOLS_SHIM
 % 
self
 . 
setup_py
 )

840 
install_args
 += 
list
 ( 
global_options
 ) +

841 [ 'install' , '--record' , 
record_filename
 ]

842 
install_args
 += [ '--single-version-externally-managed' ]

844 if 
root
 is not None :

845 
install_args
 += [ '--root' , 
root
 ]

846 if 
prefix
 is not None :

847 
install_args
 += [ '--prefix' , 
prefix
 ]

849 if 
pycompile
 :

850 
install_args
 += [ "--compile" ]

852 
install_args
 += [ "--no-compile" ]

854 if 
running_under_virtualenv
 ( ) :

855 
py_ver_str
 = 'python' + 
sysconfig
 . 
get_python_version
 ( )

856 
install_args
 += [ '--install-headers' ,

857 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'include' , 'site' ,

858 
py_ver_str
 , 
self
 . 
name
 ) ]

860 return 
install_args
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/req_set.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 from 
	~collections
 import 
OrderedDict

6 from 
	~pip._internal.exceptions
 import 
InstallationError

7 from 
	~pip._internal.utils.logging
 import 
indent_log

8 from 
	~pip._internal.wheel
 import 
Wheel

10 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

13 class 
	cRequirementSet
 ( 
object
 ) :

15 def 
	$__init__
 ( 
self
 , 
require_hashes
 = False , 
check_supported_wheels
 = True ) :

19 
self
 . 
requirements
 = 
OrderedDict
 ( )

20 
self
 . 
require_hashes
 = 
require_hashes

21 
self
 . 
check_supported_wheels
 = 
check_supported_wheels

24 
self
 . 
requirement_aliases
 = { }

25 
self
 . 
unnamed_requirements
 = [ ]

26 
self
 . 
successfully_downloaded
 = [ ]

27 
self
 . 
reqs_to_cleanup
 = [ ] 
	}

29 def 
	$__str__
 ( 
self
 ) :

30 
reqs
 = [ 
req
 for 
req
 in 
self
 . 
requirements
 . 
values
 ( )

31 if not 
req
 . 
comes_from
 ]

32 
reqs
 . 
sort
 ( 
key
 = lambda 
req
 : 
req
 . 
name
 . 
lower
 ( ) )

33 return ' ' . 
join
 ( [ 
str
 ( 
req
 . 
req
 ) for 
req
 in 
reqs
 ] ) 
	}

35 def 
	$__repr__
 ( 
self
 ) :

36 
reqs
 = [ 
req
 for 
req
 in 
self
 . 
requirements
 . 
values
 ( ) ]

37 
reqs
 . 
sort
 ( 
key
 = lambda 
req
 : 
req
 . 
name
 . 
lower
 ( ) )

38 
reqs_str
 = ', ' . 
join
 ( [ 
str
 ( 
req
 . 
req
 ) for 
req
 in 
reqs
 ] )

40 % ( 
self
 . 
__class__
 . 
__name__
 , 
len
 ( 
reqs
 ) , 
reqs_str
 ) ) 
	}

42 def 
	$add_requirement
 ( 
self
 , 
install_req
 , 
parent_req_name
 = None ,

43 
extras_requested
 = None ) :

58 
name
 = 
install_req
 . 
name

61 if not 
install_req
 . 
match_markers
 ( 
extras_requested
 ) :

62 
logger
 . 
info
 ( "Ignoring %s: markers '%s' don't match your environment"

64 
name
 , 
install_req
 . 
markers
 ,

72 if 
install_req
 . 
link
 and 
install_req
 . 
link
 . 
is_wheel
 :

73 
wheel
 = 
Wheel
 ( 
install_req
 . 
link
 . 
filename
 )

74 if 
self
 . 
check_supported_wheels
 and not 
wheel
 . 
supported
 ( ) :

75 raise 
InstallationError
 ( "%s is not a supported wheel on this platform."

77 
wheel
 . 
filename

81 assert 
install_req
 . 
is_direct
 == ( 
parent_req_name
 is None ) , ( "a direct req shouldn't have a parent and also, " "a non direct req should have a parent"

88 if not 
name
 :

90 
self
 . 
unnamed_requirements
 . 
append
 ( 
install_req
 )

91 return [ 
install_req
 ] , None

94 
existing_req
 = 
self
 . 
get_requirement
 ( 
name
 )

95 except 
KeyError
 :

96 
existing_req
 = None

98 
has_conflicting_requirement
 = (

99 
parent_req_name
 is None and

100 
existing_req
 and

101 not 
existing_req
 . 
constraint
 and

102 
existing_req
 . 
extras
 == 
install_req
 . 
extras
 and

103 
existing_req
 . 
req
 . 
specifier
 != 
install_req
 . 
req
 . 
specifier

105 if 
has_conflicting_requirement
 :

106 raise 
InstallationError
 ( "Double requirement given: %s (already in %s, name=%r)"

108 % ( 
install_req
 , 
existing_req
 , 
name
 )

113 if not 
existing_req
 :

114 
self
 . 
requirements
 [ 
name
 ] = 
install_req

116 if 
name
 . 
lower
 ( ) != 
name
 :

117 
self
 . 
requirement_aliases
 [ 
name
 . 
lower
 ( ) ] = 
name

119 return [ 
install_req
 ] , 
install_req

123 if 
install_req
 . 
constraint
 or not 
existing_req
 . 
constraint
 :

124 return [ ] , 
existing_req

126 
does_not_satisfy_constraint
 = (

127 
install_req
 . 
link
 and

129 
existing_req
 . 
link
 and

130 
install_req
 . 
link
 . 
path
 == 
existing_req
 . 
link
 . 
path

133 if 
does_not_satisfy_constraint
 :

134 
self
 . 
reqs_to_cleanup
 . 
append
 ( 
install_req
 )

135 raise 
InstallationError
 ( "Could not satisfy constraints for '%s': " "installation from path or url cannot be " "constrained to a version"

138 % 
name
 ,

142 
existing_req
 . 
constraint
 = False

143 
existing_req
 . 
extras
 = 
tuple
 ( 
sorted
 (

144 
set
 ( 
existing_req
 . 
extras
 ) | 
set
 ( 
install_req
 . 
extras
 )

146 
logger
 . 
debug
 ( "Setting %s extras to: %s"

148 
existing_req
 , 
existing_req
 . 
extras
 ,

152 return [ 
existing_req
 ] , 
existing_req
 
	}

154 def 
	$has_requirement
 ( 
self
 , 
project_name
 ) :

155 
name
 = 
project_name
 . 
lower
 ( )

156 if ( 
name
 in 
self
 . 
requirements
 and

157 not 
self
 . 
requirements
 [ 
name
 ] . 
constraint
 or

158 
name
 in 
self
 . 
requirement_aliases
 and

159 not 
self
 . 
requirements
 [ 
self
 . 
requirement_aliases
 [ 
name
 ] ] . 
constraint
 ) :

161 return False 
	}

163 @ 
property

164 def 
	$has_requirements
 ( 
self
 ) :

165 return 
list
 ( 
req
 for 
req
 in 
self
 . 
requirements
 . 
values
 ( ) if not

166 
req
 . 
constraint
 ) or 
self
 . 
unnamed_requirements
 
	}

168 def 
	$get_requirement
 ( 
self
 , 
project_name
 ) :

169 for 
name
 in 
project_name
 , 
project_name
 . 
lower
 ( ) :

170 if 
name
 in 
self
 . 
requirements
 :

171 return 
self
 . 
requirements
 [ 
name
 ]

172 if 
name
 in 
self
 . 
requirement_aliases
 :

173 return 
self
 . 
requirements
 [ 
self
 . 
requirement_aliases
 [ 
name
 ] ]

174 raise 
KeyError
 ( "No project with the name %r" % 
project_name
 ) 
	}

176 def 
	$cleanup_files
 ( 
self
 ) :

178 
logger
 . 
debug
 ( 'Cleaning up...' )

179 with 
indent_log
 ( ) :

180 for 
req
 in 
self
 . 
reqs_to_cleanup
 :

181 
req
 . 
remove_temporary_source
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/req_file.py

5 from 
	~__future__
 import 
absolute_import

7 import 
	~optparse

8 import 
	~os

9 import 
	~re

10 import 
	~shlex

11 import 
	~sys

13 from 
	~pip._vendor.six.moves
 import 
filterfalse

14 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

16 from 
	~pip._internal.cli
 import 
cmdoptions

17 from 
	~pip._internal.download
 import 
get_file_content

18 from 
	~pip._internal.exceptions
 import 
RequirementsFileParseError

19 from 
	~pip._internal.req.constructors
 import (

20 
install_req_from_editable
 , 
install_req_from_line
 ,

23 
__all__
 = [ 'parse_requirements' ]

25 
SCHEME_RE
 = 
re
 . 
compile
 ( r'^(http|https|file):' , 
re
 . 
I
 )

26 
COMMENT_RE
 = 
re
 . 
compile
 ( r'(^|\s)+#.*$' )

32 
ENV_VAR_RE
 = 
re
 . 
compile
 ( r'(?P<var>\$\{(?P<name>[A-Z0-9_]+)\})' )

34 
SUPPORTED_OPTIONS
 = [

35 
cmdoptions
 . 
constraints
 ,

36 
cmdoptions
 . 
editable
 ,

37 
cmdoptions
 . 
requirements
 ,

38 
cmdoptions
 . 
no_index
 ,

39 
cmdoptions
 . 
index_url
 ,

40 
cmdoptions
 . 
find_links
 ,

41 
cmdoptions
 . 
extra_index_url
 ,

42 
cmdoptions
 . 
always_unzip
 ,

43 
cmdoptions
 . 
no_binary
 ,

44 
cmdoptions
 . 
only_binary
 ,

45 
cmdoptions
 . 
pre
 ,

46 
cmdoptions
 . 
process_dependency_links
 ,

47 
cmdoptions
 . 
trusted_host
 ,

48 
cmdoptions
 . 
require_hashes
 ,

52 
SUPPORTED_OPTIONS_REQ
 = [

53 
cmdoptions
 . 
install_options
 ,

54 
cmdoptions
 . 
global_options
 ,

55 
cmdoptions
 . 
hash
 ,

59 
SUPPORTED_OPTIONS_REQ_DEST
 = [ 
o
 ( ) . 
dest
 for 
o
 in 
SUPPORTED_OPTIONS_REQ
 ]

62 def 
	$parse_requirements
 ( 
filename
 , 
finder
 = None , 
comes_from
 = None , 
options
 = None ,

63 
session
 = None , 
constraint
 = False , 
wheel_cache
 = None ) :

75 if 
session
 is None :

76 raise 
TypeError
 ( "parse_requirements() missing 1 required keyword argument: " "'session'"

81 
_
 , 
content
 = 
get_file_content
 (

82 
filename
 , 
comes_from
 = 
comes_from
 , 
session
 = 
session

85 
lines_enum
 = 
preprocess
 ( 
content
 , 
options
 )

87 for 
line_number
 , 
line
 in 
lines_enum
 :

88 
req_iter
 = 
process_line
 ( 
line
 , 
filename
 , 
line_number
 , 
finder
 ,

89 
comes_from
 , 
options
 , 
session
 , 
wheel_cache
 ,

90 
constraint
 = 
constraint
 )

91 for 
req
 in 
req_iter
 :

92 yield 
req
 
	}

95 def 
	$preprocess
 ( 
content
 , 
options
 ) :

101 
lines_enum
 = 
enumerate
 ( 
content
 . 
splitlines
 ( ) , 
start
 = 1 )

102 
lines_enum
 = 
join_lines
 ( 
lines_enum
 )

103 
lines_enum
 = 
ignore_comments
 ( 
lines_enum
 )

104 
lines_enum
 = 
skip_regex
 ( 
lines_enum
 , 
options
 )

105 
lines_enum
 = 
expand_env_variables
 ( 
lines_enum
 )

106 return 
lines_enum
 
	}

109 def 
	$process_line
 ( 
line
 , 
filename
 , 
line_number
 , 
finder
 = None , 
comes_from
 = None ,

110 
options
 = None , 
session
 = None , 
wheel_cache
 = None ,

111 
constraint
 = False ) :

129 
parser
 = 
build_parser
 ( 
line
 )

130 
defaults
 = 
parser
 . 
get_default_values
 ( )

131 
defaults
 . 
index_url
 = None

132 if 
finder
 :

134 
defaults
 . 
format_control
 = 
finder
 . 
format_control

135 
args_str
 , 
options_str
 = 
break_args_options
 ( 
line
 )

136 if 
sys
 . 
version_info
 < ( 2 , 7 , 3 ) :

138 
options_str
 = 
options_str
 . 
encode
 ( 'utf8' )

139 
opts
 , 
_
 = 
parser
 . 
parse_args
 ( 
shlex
 . 
split
 ( 
options_str
 ) , 
defaults
 )

142 
line_comes_from
 = '%s %s (line %s)' % ( '-c'

143 if 
constraint
 else '-r' , 
filename
 , 
line_number
 ,

147 if 
args_str
 :

148 
isolated
 = 
options
 . 
isolated_mode
 if 
options
 else False

149 if 
options
 :

150 
cmdoptions
 . 
check_install_build_global
 ( 
options
 , 
opts
 )

152 
req_options
 = { }

153 for 
dest
 in 
SUPPORTED_OPTIONS_REQ_DEST
 :

154 if 
dest
 in 
opts
 . 
__dict__
 and 
opts
 . 
__dict__
 [ 
dest
 ] :

155 
req_options
 [ 
dest
 ] = 
opts
 . 
__dict__
 [ 
dest
 ]

156 yield 
install_req_from_line
 (

157 
args_str
 , 
line_comes_from
 , 
constraint
 = 
constraint
 ,

158 
isolated
 = 
isolated
 , 
options
 = 
req_options
 , 
wheel_cache
 = 
wheel_cache

162 elif 
opts
 . 
editables
 :

163 
isolated
 = 
options
 . 
isolated_mode
 if 
options
 else False

164 yield 
install_req_from_editable
 (

165 
opts
 . 
editables
 [ 0 ] , 
comes_from
 = 
line_comes_from
 ,

166 
constraint
 = 
constraint
 , 
isolated
 = 
isolated
 , 
wheel_cache
 = 
wheel_cache

170 elif 
opts
 . 
requirements
 or 
opts
 . 
constraints
 :

171 if 
opts
 . 
requirements
 :

172 
req_path
 = 
opts
 . 
requirements
 [ 0 ]

173 
nested_constraint
 = False

175 
req_path
 = 
opts
 . 
constraints
 [ 0 ]

176 
nested_constraint
 = True

178 if 
SCHEME_RE
 . 
search
 ( 
filename
 ) :

180 
req_path
 = 
urllib_parse
 . 
urljoin
 ( 
filename
 , 
req_path
 )

182 elif not 
SCHEME_RE
 . 
search
 ( 
req_path
 ) :

184 
req_path
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
dirname
 ( 
filename
 ) , 
req_path
 )

186 
parser
 = 
parse_requirements
 (

187 
req_path
 , 
finder
 , 
comes_from
 , 
options
 , 
session
 ,

188 
constraint
 = 
nested_constraint
 , 
wheel_cache
 = 
wheel_cache

190 for 
req
 in 
parser
 :

191 yield 
req

194 elif 
opts
 . 
require_hashes
 :

195 
options
 . 
require_hashes
 = 
opts
 . 
require_hashes

198 elif 
finder
 :

199 if 
opts
 . 
index_url
 :

200 
finder
 . 
index_urls
 = [ 
opts
 . 
index_url
 ]

201 if 
opts
 . 
no_index
 is True :

202 
finder
 . 
index_urls
 = [ ]

203 if 
opts
 . 
extra_index_urls
 :

204 
finder
 . 
index_urls
 . 
extend
 ( 
opts
 . 
extra_index_urls
 )

205 if 
opts
 . 
find_links
 :

209 
value
 = 
opts
 . 
find_links
 [ 0 ]

210 
req_dir
 = 
os
 . 
path
 . 
dirname
 ( 
os
 . 
path
 . 
abspath
 ( 
filename
 ) )

211 
relative_to_reqs_file
 = 
os
 . 
path
 . 
join
 ( 
req_dir
 , 
value
 )

212 if 
os
 . 
path
 . 
exists
 ( 
relative_to_reqs_file
 ) :

213 
value
 = 
relative_to_reqs_file

214 
finder
 . 
find_links
 . 
append
 ( 
value
 )

215 if 
opts
 . 
pre
 :

216 
finder
 . 
allow_all_prereleases
 = True

217 if 
opts
 . 
process_dependency_links
 :

218 
finder
 . 
process_dependency_links
 = True

219 if 
opts
 . 
trusted_hosts
 :

220 
finder
 . 
secure_origins
 . 
extend
 (

221 ( "*" , 
host
 , "*" ) for 
host
 in 
opts
 . 
trusted_hosts
 ) 
	}

224 def 
	$break_args_options
 ( 
line
 ) :

229 
tokens
 = 
line
 . 
split
 ( ' ' )

230 
args
 = [ ]

231 
options
 = 
tokens
 [ : ]

232 for 
token
 in 
tokens
 :

233 if 
token
 . 
startswith
 ( '-' ) or 
token
 . 
startswith
 ( '--' ) :

236 
args
 . 
append
 ( 
token
 )

237 
options
 . 
pop
 ( 0 )

238 return ' ' . 
join
 ( 
args
 ) , ' ' . 
join
 ( 
options
 ) 
	}

241 def 
	$build_parser
 ( 
line
 ) :

245 
parser
 = 
optparse
 . 
OptionParser
 ( 
add_help_option
 = False )

247 
option_factories
 = 
SUPPORTED_OPTIONS
 + 
SUPPORTED_OPTIONS_REQ

248 for 
option_factory
 in 
option_factories
 :

249 
option
 = 
option_factory
 ( )

250 
parser
 . 
add_option
 ( 
option
 )

254 def 
parser_exit
 ( 
self
 , 
msg
 ) :

256 
msg
 = 'Invalid requirement: %s\n%s' % ( 
line
 , 
msg
 )

257 raise 
RequirementsFileParseError
 ( 
msg
 )

258 
parser
 . 
exit
 = 
parser_exit

260 return 
parser
 
	}

263 def 
	$join_lines
 ( 
lines_enum
 ) :

267 
primary_line_number
 = None

268 
new_line
 = [ ]

269 for 
line_number
 , 
line
 in 
lines_enum
 :

270 if not 
line
 . 
endswith
 ( '\\' ) or 
COMMENT_RE
 . 
match
 ( 
line
 ) :

271 if 
COMMENT_RE
 . 
match
 ( 
line
 ) :

273 
line
 = ' ' + 
line

274 if 
new_line
 :

275 
new_line
 . 
append
 ( 
line
 )

276 yield 
primary_line_number
 , '' . 
join
 ( 
new_line
 )

277 
new_line
 = [ ]

279 yield 
line_number
 , 
line

281 if not 
new_line
 :

282 
primary_line_number
 = 
line_number

283 
new_line
 . 
append
 ( 
line
 . 
strip
 ( '\\' ) )

286 if 
new_line
 :

287 yield 
primary_line_number
 , '' . 
join
 ( 
new_line
 ) 
	}

292 def 
	$ignore_comments
 ( 
lines_enum
 ) :

296 for 
line_number
 , 
line
 in 
lines_enum
 :

297 
line
 = 
COMMENT_RE
 . 
sub
 ( '' , 
line
 )

298 
line
 = 
line
 . 
strip
 ( )

299 if 
line
 :

300 yield 
line_number
 , 
line
 
	}

303 def 
	$skip_regex
 ( 
lines_enum
 , 
options
 ) :

309 
skip_regex
 = 
options
 . 
skip_requirements_regex
 if 
options
 else None

310 if 
skip_regex
 :

311 
pattern
 = 
re
 . 
compile
 ( 
skip_regex
 )

312 
lines_enum
 = 
filterfalse
 ( lambda 
e
 : 
pattern
 . 
search
 ( 
e
 [ 1 ] ) , 
lines_enum
 )

313 return 
lines_enum
 
	}

316 def 
	$expand_env_variables
 ( 
lines_enum
 ) :

332 for 
line_number
 , 
line
 in 
lines_enum
 :

333 for 
env_var
 , 
var_name
 in 
ENV_VAR_RE
 . 
findall
 ( 
line
 ) :

334 
value
 = 
os
 . 
getenv
 ( 
var_name
 )

335 if not 
value
 :

338 
line
 = 
line
 . 
replace
 ( 
env_var
 , 
value
 )

340 yield 
line_number
 , 
line
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/req_tracker.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~contextlib

4 import 
	~errno

5 import 
	~hashlib

6 import 
	~logging

7 import 
	~os

9 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

11 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

14 class 
	cRequirementTracker
 ( 
object
 ) :

16 def 
	$__init__
 ( 
self
 ) :

17 
self
 . 
_root
 = 
os
 . 
environ
 . 
get
 ( 'PIP_REQ_TRACKER' )

18 if 
self
 . 
_root
 is None :

19 
self
 . 
_temp_dir
 = 
TempDirectory
 ( 
delete
 = False , 
kind
 = 'req-tracker' )

20 
self
 . 
_temp_dir
 . 
create
 ( )

21 
self
 . 
_root
 = 
os
 . 
environ
 [ 'PIP_REQ_TRACKER' ] = 
self
 . 
_temp_dir
 . 
path

22 
logger
 . 
debug
 ( 'Created requirements tracker %r' , 
self
 . 
_root
 )

24 
self
 . 
_temp_dir
 = None

25 
logger
 . 
debug
 ( 'Re-using requirements tracker %r' , 
self
 . 
_root
 )

26 
self
 . 
_entries
 = 
set
 ( ) 
	}

28 def 
	$__enter__
 ( 
self
 ) :

29 return 
self
 
	}

31 def 
	$__exit__
 ( 
self
 , 
exc_type
 , 
exc_val
 , 
exc_tb
 ) :

32 
self
 . 
cleanup
 ( ) 
	}

34 def 
	$_entry_path
 ( 
self
 , 
link
 ) :

35 
hashed
 = 
hashlib
 . 
sha224
 ( 
link
 . 
url_without_fragment
 . 
encode
 ( ) ) . 
hexdigest
 ( )

36 return 
os
 . 
path
 . 
join
 ( 
self
 . 
_root
 , 
hashed
 ) 
	}

38 def 
	$add
 ( 
self
 , 
req
 ) :

39 
link
 = 
req
 . 
link

40 
info
 = 
str
 ( 
req
 )

41 
entry_path
 = 
self
 . 
_entry_path
 ( 
link
 )

43 with 
open
 ( 
entry_path
 ) as 
fp
 :

45 raise 
LookupError
 ( '%s is already being built: %s'

46 % ( 
link
 , 
fp
 . 
read
 ( ) ) )

47 except 
IOError
 as 
e
 :

48 if 
e
 . 
errno
 != 
errno
 . 
ENOENT
 :

50 assert 
req
 not in 
self
 . 
_entries

51 with 
open
 ( 
entry_path
 , 'w' ) as 
fp
 :

52 
fp
 . 
write
 ( 
info
 )

53 
self
 . 
_entries
 . 
add
 ( 
req
 )

54 
logger
 . 
debug
 ( 'Added %s to build tracker %r' , 
req
 , 
self
 . 
_root
 ) 
	}

56 def 
	$remove
 ( 
self
 , 
req
 ) :

57 
link
 = 
req
 . 
link

58 
self
 . 
_entries
 . 
remove
 ( 
req
 )

59 
os
 . 
unlink
 ( 
self
 . 
_entry_path
 ( 
link
 ) )

60 
logger
 . 
debug
 ( 'Removed %s from build tracker %r' , 
req
 , 
self
 . 
_root
 ) 
	}

62 def 
	$cleanup
 ( 
self
 ) :

63 for 
req
 in 
set
 ( 
self
 . 
_entries
 ) :

64 
self
 . 
remove
 ( 
req
 )

65 
remove
 = 
self
 . 
_temp_dir
 is not None

66 if 
remove
 :

67 
self
 . 
_temp_dir
 . 
cleanup
 ( )

68 
logger
 . 
debug
 ( '%s build tracker %r' , 'Removed'

69 if 
remove
 else 'Cleaned' ,

70 
self
 . 
_root
 ) 
	}

72 @ 
contextlib
 . 
	`contextmanager

73 def 
	$track
 ( 
self
 , 
req
 ) :

74 
self
 . 
add
 ( 
req
 )

76 
self
 . 
remove
 ( 
req
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/req_uninstall.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~csv

4 import 
	~functools

5 import 
	~logging

6 import 
	~os

7 import 
	~sys

8 import 
	~sysconfig

10 from 
	~pip._vendor
 import 
pkg_resources

12 from 
	~pip._internal.exceptions
 import 
UninstallationError

13 from 
	~pip._internal.locations
 import 
bin_py
 , 
bin_user

14 from 
	~pip._internal.utils.compat
 import 
WINDOWS
 , 
cache_from_source
 , 
uses_pycache

15 from 
	~pip._internal.utils.logging
 import 
indent_log

16 from 
	~pip._internal.utils.misc
 import (

17 
FakeFile
 , 
ask
 , 
dist_in_usersite
 , 
dist_is_local
 , 
egg_link_path
 , 
is_local
 ,

18 
normalize_path
 , 
renames
 ,

20 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

22 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

25 def 
	$_script_names
 ( 
dist
 , 
script_name
 , 
is_gui
 ) :

30 if 
dist_in_usersite
 ( 
dist
 ) :

31 
bin_dir
 = 
bin_user

33 
bin_dir
 = 
bin_py

34 
exe_name
 = 
os
 . 
path
 . 
join
 ( 
bin_dir
 , 
script_name
 )

35 
paths_to_remove
 = [ 
exe_name
 ]

36 if 
WINDOWS
 :

37 
paths_to_remove
 . 
append
 ( 
exe_name
 + '.exe' )

38 
paths_to_remove
 . 
append
 ( 
exe_name
 + '.exe.manifest' )

39 if 
is_gui
 :

40 
paths_to_remove
 . 
append
 ( 
exe_name
 + '-script.pyw' )

42 
paths_to_remove
 . 
append
 ( 
exe_name
 + '-script.py' )

43 return 
paths_to_remove
 
	}

46 def 
	$_unique
 ( 
fn
 ) :

47 @ 
functools
 . 
	`wraps
 ( 
fn
 )

48 def 
unique
 ( * 
args
 , ** 
kw
 ) :

49 
seen
 = 
set
 ( )

50 for 
item
 in 
fn
 ( * 
args
 , ** 
kw
 ) :

51 if 
item
 not in 
seen
 :

52 
seen
 . 
add
 ( 
item
 )

53 yield 
item

54 return 
unique
 
	}

57 @ 
	`_unique

58 def 
	$uninstallation_paths
 ( 
dist
 ) :

67 
r
 = 
csv
 . 
reader
 ( 
FakeFile
 ( 
dist
 . 
get_metadata_lines
 ( 'RECORD' ) ) )

68 for 
row
 in 
r
 :

69 
path
 = 
os
 . 
path
 . 
join
 ( 
dist
 . 
location
 , 
row
 [ 0 ] )

70 yield 
path

71 if 
path
 . 
endswith
 ( '.py' ) :

72 
dn
 , 
fn
 = 
os
 . 
path
 . 
split
 ( 
path
 )

73 
base
 = 
fn
 [ : - 3 ]

74 
path
 = 
os
 . 
path
 . 
join
 ( 
dn
 , 
base
 + '.pyc' )

75 yield 
path

76 
path
 = 
os
 . 
path
 . 
join
 ( 
dn
 , 
base
 + '.pyo' )

77 yield 
path
 
	}

80 def 
	$compact
 ( 
paths
 ) :

86 
sep
 = 
os
 . 
path
 . 
sep

87 
short_paths
 = 
set
 ( )

88 for 
path
 in 
sorted
 ( 
paths
 , 
key
 = 
len
 ) :

89 
should_add
 = 
any
 (

90 
path
 . 
startswith
 ( 
shortpath
 . 
rstrip
 ( "*" ) ) and

91 
path
 [ 
len
 ( 
shortpath
 . 
rstrip
 ( "*" ) . 
rstrip
 ( 
sep
 ) ) ] == 
sep

92 for 
shortpath
 in 
short_paths

94 if not 
should_add
 :

95 
short_paths
 . 
add
 ( 
path
 )

96 return 
short_paths
 
	}

99 def 
	$compress_for_output_listing
 ( 
paths
 ) :

110 
will_remove
 = 
list
 ( 
paths
 )

111 
will_skip
 = 
set
 ( )

114 
folders
 = 
set
 ( )

115 
files
 = 
set
 ( )

116 for 
path
 in 
will_remove
 :

117 if 
path
 . 
endswith
 ( ".pyc" ) :

119 if 
path
 . 
endswith
 ( "__init__.py" ) or ".dist-info" in 
path
 :

120 
folders
 . 
add
 ( 
os
 . 
path
 . 
dirname
 ( 
path
 ) )

121 
files
 . 
add
 ( 
path
 )

123 
_normcased_files
 = 
set
 ( 
map
 ( 
os
 . 
path
 . 
normcase
 , 
files
 ) )

125 
folders
 = 
compact
 ( 
folders
 )

129 for 
folder
 in 
folders
 :

130 for 
dirpath
 , 
_
 , 
dirfiles
 in 
os
 . 
walk
 ( 
folder
 ) :

131 for 
fname
 in 
dirfiles
 :

132 if 
fname
 . 
endswith
 ( ".pyc" ) :

135 
file_
 = 
os
 . 
path
 . 
join
 ( 
dirpath
 , 
fname
 )

136 if ( 
os
 . 
path
 . 
isfile
 ( 
file_
 ) and

137 
os
 . 
path
 . 
normcase
 ( 
file_
 ) not in 
_normcased_files
 ) :

139 
will_skip
 . 
add
 ( 
file_
 )

141 
will_remove
 = 
files
 | {

142 
os
 . 
path
 . 
join
 ( 
folder
 , "*" ) for 
folder
 in 
folders

145 return 
will_remove
 , 
will_skip
 
	}

148 class 
	cUninstallPathSet
 ( 
object
 ) :

151 def 
	$__init__
 ( 
self
 , 
dist
 ) :

152 
self
 . 
paths
 = 
set
 ( )

153 
self
 . 
_refuse
 = 
set
 ( )

154 
self
 . 
pth
 = { }

155 
self
 . 
dist
 = 
dist

156 
self
 . 
save_dir
 = 
TempDirectory
 ( 
kind
 = "uninstall" )

157 
self
 . 
_moved_paths
 = [ ] 
	}

159 def 
	$_permitted
 ( 
self
 , 
path
 ) :

165 return 
is_local
 ( 
path
 ) 
	}

167 def 
	$add
 ( 
self
 , 
path
 ) :

168 
head
 , 
tail
 = 
os
 . 
path
 . 
split
 ( 
path
 )

172 
path
 = 
os
 . 
path
 . 
join
 ( 
normalize_path
 ( 
head
 ) , 
os
 . 
path
 . 
normcase
 ( 
tail
 ) )

174 if not 
os
 . 
path
 . 
exists
 ( 
path
 ) :

176 if 
self
 . 
_permitted
 ( 
path
 ) :

177 
self
 . 
paths
 . 
add
 ( 
path
 )

179 
self
 . 
_refuse
 . 
add
 ( 
path
 )

183 if 
os
 . 
path
 . 
splitext
 ( 
path
 ) [ 1 ] == '.py' and 
uses_pycache
 :

184 
self
 . 
add
 ( 
cache_from_source
 ( 
path
 ) ) 
	}

186 def 
	$add_pth
 ( 
self
 , 
pth_file
 , 
entry
 ) :

187 
pth_file
 = 
normalize_path
 ( 
pth_file
 )

188 if 
self
 . 
_permitted
 ( 
pth_file
 ) :

189 if 
pth_file
 not in 
self
 . 
pth
 :

190 
self
 . 
pth
 [ 
pth_file
 ] = 
UninstallPthEntries
 ( 
pth_file
 )

191 
self
 . 
pth
 [ 
pth_file
 ] . 
add
 ( 
entry
 )

193 
self
 . 
_refuse
 . 
add
 ( 
pth_file
 ) 
	}

195 def 
	$_stash
 ( 
self
 , 
path
 ) :

196 return 
os
 . 
path
 . 
join
 (

197 
self
 . 
save_dir
 . 
path
 , 
os
 . 
path
 . 
splitdrive
 ( 
path
 ) [ 1 ] . 
lstrip
 ( 
os
 . 
path
 . 
sep
 )

198 ) 
	}

200 def 
	$remove
 ( 
self
 , 
auto_confirm
 = False , 
verbose
 = False ) :

204 if not 
self
 . 
paths
 :

205 
logger
 . 
info
 ( "Can't uninstall '%s'. No files were found to uninstall."

207 
self
 . 
dist
 . 
project_name
 ,

211 
dist_name_version
 = (

212 
self
 . 
dist
 . 
project_name
 + "-" + 
self
 . 
dist
 . 
version

214 
logger
 . 
info
 ( 'Uninstalling %s:' , 
dist_name_version
 )

216 with 
indent_log
 ( ) :

217 if 
auto_confirm
 or 
self
 . 
_allowed_to_proceed
 ( 
verbose
 ) :

218 
self
 . 
save_dir
 . 
create
 ( )

220 for 
path
 in 
sorted
 ( 
compact
 ( 
self
 . 
paths
 ) ) :

221 
new_path
 = 
self
 . 
_stash
 ( 
path
 )

222 
logger
 . 
debug
 ( 'Removing file or directory %s' , 
path
 )

223 
self
 . 
_moved_paths
 . 
append
 ( 
path
 )

224 
renames
 ( 
path
 , 
new_path
 )

225 for 
pth
 in 
self
 . 
pth
 . 
values
 ( ) :

226 
pth
 . 
remove
 ( )

228 
logger
 . 
info
 ( 'Successfully uninstalled %s' , 
dist_name_version
 ) 
	}

230 def 
	$_allowed_to_proceed
 ( 
self
 , 
verbose
 ) :

234 def 
_display
 ( 
msg
 , 
paths
 ) :

235 if not 
paths
 :

238 
logger
 . 
info
 ( 
msg
 )

239 with 
indent_log
 ( ) :

240 for 
path
 in 
sorted
 ( 
compact
 ( 
paths
 ) ) :

241 
logger
 . 
info
 ( 
path
 )

243 if not 
verbose
 :

244 
will_remove
 , 
will_skip
 = 
compress_for_output_listing
 ( 
self
 . 
paths
 )

248 
will_remove
 = 
list
 ( 
self
 . 
paths
 )

249 
will_skip
 = 
set
 ( )

251 
_display
 ( 'Would remove:' , 
will_remove
 )

252 
_display
 ( 'Would not remove (might be manually added):' , 
will_skip
 )

253 
_display
 ( 'Would not remove (outside of prefix):' , 
self
 . 
_refuse
 )

255 return 
ask
 ( 'Proceed (y/n)? ' , ( 'y' , 'n' ) ) == 'y' 
	}

257 def 
	$rollback
 ( 
self
 ) :

259 if 
self
 . 
save_dir
 . 
path
 is None :

260 
logger
 . 
error
 ( "Can't roll back %s; was not uninstalled"

262 
self
 . 
dist
 . 
project_name
 ,

265 
logger
 . 
info
 ( 'Rolling back uninstall of %s' , 
self
 . 
dist
 . 
project_name
 )

266 for 
path
 in 
self
 . 
_moved_paths
 :

267 
tmp_path
 = 
self
 . 
_stash
 ( 
path
 )

268 
logger
 . 
debug
 ( 'Replacing %s' , 
path
 )

269 
renames
 ( 
tmp_path
 , 
path
 )

270 for 
pth
 in 
self
 . 
pth
 . 
values
 ( ) :

271 
pth
 . 
rollback
 ( ) 
	}

273 def 
	$commit
 ( 
self
 ) :

275 
self
 . 
save_dir
 . 
cleanup
 ( )

276 
self
 . 
_moved_paths
 = [ ] 
	}

278 @ 
classmethod

279 def 
	$from_dist
 ( 
cls
 , 
dist
 ) :

280 
dist_path
 = 
normalize_path
 ( 
dist
 . 
location
 )

281 if not 
dist_is_local
 ( 
dist
 ) :

282 
logger
 . 
info
 ( "Not uninstalling %s at %s, outside environment %s"

284 
dist
 . 
key
 ,

285 
dist_path
 ,

286 
sys
 . 
prefix
 ,

288 return 
cls
 ( 
dist
 )

290 if 
dist_path
 in { 
p
 for 
p
 in { 
sysconfig
 . 
get_path
 ( "stdlib" ) ,

291 
sysconfig
 . 
get_path
 ( "platstdlib" ) }

292 if 
p
 } :

293 
logger
 . 
info
 ( "Not uninstalling %s at %s, as it is in the standard library."

295 
dist
 . 
key
 ,

296 
dist_path
 ,

298 return 
cls
 ( 
dist
 )

300 
paths_to_remove
 = 
cls
 ( 
dist
 )

301 
develop_egg_link
 = 
egg_link_path
 ( 
dist
 )

302 
develop_egg_link_egg_info
 = '{}.egg-info' . 
format
 (

303 
pkg_resources
 . 
to_filename
 ( 
dist
 . 
project_name
 ) )

304 
egg_info_exists
 = 
dist
 . 
egg_info
 and 
os
 . 
path
 . 
exists
 ( 
dist
 . 
egg_info
 )

306 
distutils_egg_info
 = 
getattr
 ( 
dist
 . 
_provider
 , 'path' , None )

310 if ( 
egg_info_exists
 and 
dist
 . 
egg_info
 . 
endswith
 ( '.egg-info' ) and

311 not 
dist
 . 
egg_info
 . 
endswith
 ( 
develop_egg_link_egg_info
 ) ) :

314 
paths_to_remove
 . 
add
 ( 
dist
 . 
egg_info
 )

315 if 
dist
 . 
has_metadata
 ( 'installed-files.txt' ) :

316 for 
installed_file
 in 
dist
 . 
get_metadata
 ( 'installed-files.txt'

317 ) . 
splitlines
 ( ) :

318 
path
 = 
os
 . 
path
 . 
normpath
 (

319 
os
 . 
path
 . 
join
 ( 
dist
 . 
egg_info
 , 
installed_file
 )

321 
paths_to_remove
 . 
add
 ( 
path
 )

325 elif 
dist
 . 
has_metadata
 ( 'top_level.txt' ) :

326 if 
dist
 . 
has_metadata
 ( 'namespace_packages.txt' ) :

327 
namespaces
 = 
dist
 . 
get_metadata
 ( 'namespace_packages.txt' )

329 
namespaces
 = [ ]

330 for 
top_level_pkg
 in [

331 
p
 for 
p

332 in 
dist
 . 
get_metadata
 ( 'top_level.txt' ) . 
splitlines
 ( )

333 if 
p
 and 
p
 not in 
namespaces
 ] :

334 
path
 = 
os
 . 
path
 . 
join
 ( 
dist
 . 
location
 , 
top_level_pkg
 )

335 
paths_to_remove
 . 
add
 ( 
path
 )

336 
paths_to_remove
 . 
add
 ( 
path
 + '.py' )

337 
paths_to_remove
 . 
add
 ( 
path
 + '.pyc' )

338 
paths_to_remove
 . 
add
 ( 
path
 + '.pyo' )

340 elif 
distutils_egg_info
 :

341 raise 
UninstallationError
 ( "Cannot uninstall {!r}. It is a distutils installed project " "and thus we cannot accurately determine which files belong " "to it which would lead to only a partial uninstall."

344 . 
format
 (

345 
dist
 . 
project_name
 ,

349 elif 
dist
 . 
location
 . 
endswith
 ( '.egg' ) :

353 
paths_to_remove
 . 
add
 ( 
dist
 . 
location
 )

354 
easy_install_egg
 = 
os
 . 
path
 . 
split
 ( 
dist
 . 
location
 ) [ 1 ]

355 
easy_install_pth
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
dirname
 ( 
dist
 . 
location
 ) , 'easy-install.pth'

357 
paths_to_remove
 . 
add_pth
 ( 
easy_install_pth
 , './' + 
easy_install_egg
 )

359 elif 
egg_info_exists
 and 
dist
 . 
egg_info
 . 
endswith
 ( '.dist-info' ) :

360 for 
path
 in 
uninstallation_paths
 ( 
dist
 ) :

361 
paths_to_remove
 . 
add
 ( 
path
 )

363 elif 
develop_egg_link
 :

365 with 
open
 ( 
develop_egg_link
 , 'r' ) as 
fh
 :

366 
link_pointer
 = 
os
 . 
path
 . 
normcase
 ( 
fh
 . 
readline
 ( ) . 
strip
 ( ) )

367 assert ( 
link_pointer
 == 
dist
 . 
location
 ) , ( 'Egg-link %s does not match installed location of %s ' '(at %s)'

369 % ( 
link_pointer
 , 
dist
 . 
project_name
 , 
dist
 . 
location
 )

371 
paths_to_remove
 . 
add
 ( 
develop_egg_link
 )

372 
easy_install_pth
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
dirname
 ( 
develop_egg_link
 ) , 'easy-install.pth'

374 
paths_to_remove
 . 
add_pth
 ( 
easy_install_pth
 , 
dist
 . 
location
 )

377 
logger
 . 
debug
 ( 'Not sure how to uninstall: %s - Check: %s'

379 
dist
 , 
dist
 . 
location
 ,

383 if 
dist
 . 
has_metadata
 ( 'scripts' ) and 
dist
 . 
metadata_isdir
 ( 'scripts' ) :

384 for 
script
 in 
dist
 . 
metadata_listdir
 ( 'scripts' ) :

385 if 
dist_in_usersite
 ( 
dist
 ) :

386 
bin_dir
 = 
bin_user

388 
bin_dir
 = 
bin_py

389 
paths_to_remove
 . 
add
 ( 
os
 . 
path
 . 
join
 ( 
bin_dir
 , 
script
 ) )

390 if 
WINDOWS
 :

391 
paths_to_remove
 . 
add
 ( 
os
 . 
path
 . 
join
 ( 
bin_dir
 , 
script
 ) + '.bat' )

394 
_scripts_to_remove
 = [ ]

395 
console_scripts
 = 
dist
 . 
get_entry_map
 ( 
group
 = 'console_scripts' )

396 for 
name
 in 
console_scripts
 . 
keys
 ( ) :

397 
_scripts_to_remove
 . 
extend
 ( 
_script_names
 ( 
dist
 , 
name
 , False ) )

399 
gui_scripts
 = 
dist
 . 
get_entry_map
 ( 
group
 = 'gui_scripts' )

400 for 
name
 in 
gui_scripts
 . 
keys
 ( ) :

401 
_scripts_to_remove
 . 
extend
 ( 
_script_names
 ( 
dist
 , 
name
 , True ) )

403 for 
s
 in 
_scripts_to_remove
 :

404 
paths_to_remove
 . 
add
 ( 
s
 )

406 return 
paths_to_remove
 
	}

409 class 
	cUninstallPthEntries
 ( 
object
 ) :

410 def 
	$__init__
 ( 
self
 , 
pth_file
 ) :

411 if not 
os
 . 
path
 . 
isfile
 ( 
pth_file
 ) :

412 raise 
UninstallationError
 ( "Cannot remove entries from nonexistent file %s"

413 % 
pth_file

415 
self
 . 
file
 = 
pth_file

416 
self
 . 
entries
 = 
set
 ( )

417 
self
 . 
_saved_lines
 = None 
	}

419 def 
	$add
 ( 
self
 , 
entry
 ) :

420 
entry
 = 
os
 . 
path
 . 
normcase
 ( 
entry
 )

425 if 
WINDOWS
 and not 
os
 . 
path
 . 
splitdrive
 ( 
entry
 ) [ 0 ] :

426 
entry
 = 
entry
 . 
replace
 ( '\\' , '/' )

427 
self
 . 
entries
 . 
add
 ( 
entry
 ) 
	}

429 def 
	$remove
 ( 
self
 ) :

430 
logger
 . 
debug
 ( 'Removing pth entries from %s:' , 
self
 . 
file
 )

431 with 
open
 ( 
self
 . 
file
 , 'rb' ) as 
fh
 :

433 
lines
 = 
fh
 . 
readlines
 ( )

434 
self
 . 
_saved_lines
 = 
lines

435 if 
any
 ( b'\r\n' in 
line
 for 
line
 in 
lines
 ) :

436 
endline
 = '\r\n'

438 
endline
 = '\n'

440 if 
lines
 and not 
lines
 [ - 1 ] . 
endswith
 ( 
endline
 . 
encode
 ( "utf-8" ) ) :

441 
lines
 [ - 1 ] = 
lines
 [ - 1 ] + 
endline
 . 
encode
 ( "utf-8" )

442 for 
entry
 in 
self
 . 
entries
 :

444 
logger
 . 
debug
 ( 'Removing entry: %s' , 
entry
 )

445 
lines
 . 
remove
 ( ( 
entry
 + 
endline
 ) . 
encode
 ( "utf-8" ) )

446 except 
ValueError
 :

448 with 
open
 ( 
self
 . 
file
 , 'wb' ) as 
fh
 :

449 
fh
 . 
writelines
 ( 
lines
 ) 
	}

451 def 
	$rollback
 ( 
self
 ) :

452 if 
self
 . 
_saved_lines
 is None :

453 
logger
 . 
error
 ( 'Cannot roll back changes to %s, none were made'

454 , 
self
 . 
file

457 
logger
 . 
debug
 ( 'Rolling %s back to previous state' , 
self
 . 
file
 )

458 with 
open
 ( 
self
 . 
file
 , 'wb' ) as 
fh
 :

459 
fh
 . 
writelines
 ( 
self
 . 
_saved_lines
 )

460 return True 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/req/__init__.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

5 from . 
	~req_install
 import 
InstallRequirement

6 from . 
	~req_set
 import 
RequirementSet

7 from . 
	~req_file
 import 
parse_requirements

8 from 
	~pip._internal.utils.logging
 import 
indent_log

11 
__all__
 = [ "RequirementSet"

16 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

19 def 
	$install_given_reqs
 ( 
to_install
 , 
install_options
 , 
global_options
 = ( ) ,

20 * 
args
 , ** 
kwargs
 ) :

27 if 
to_install
 :

28 
logger
 . 
info
 ( 'Installing collected packages: %s'

30 . 
join
 ( [ 
req
 . 
name
 for 
req
 in 
to_install
 ] ) ,

33 with 
indent_log
 ( ) :

34 for 
requirement
 in 
to_install
 :

35 if 
requirement
 . 
conflicts_with
 :

36 
logger
 . 
info
 ( 'Found existing installation: %s'

38 
requirement
 . 
conflicts_with
 ,

40 with 
indent_log
 ( ) :

41 
uninstalled_pathset
 = 
requirement
 . 
uninstall
 (

42 
auto_confirm
 = True

45 
requirement
 . 
install
 (

46 
install_options
 ,

47 
global_options
 ,

48 * 
args
 ,

49 ** 
kwargs

51 except 
Exception
 :

52 
should_rollback
 = (

53 
requirement
 . 
conflicts_with
 and

54 not 
requirement
 . 
install_succeeded

57 if 
should_rollback
 :

58 
uninstalled_pathset
 . 
rollback
 ( )

61 
should_commit
 = (

62 
requirement
 . 
conflicts_with
 and

63 
requirement
 . 
install_succeeded

65 if 
should_commit
 :

66 
uninstalled_pathset
 . 
commit
 ( )

67 
requirement
 . 
remove_temporary_source
 ( )

69 return 
to_install
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/locations.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~os

5 import 
	~os.path

6 import 
	~platform

7 import 
	~site

8 import 
	~sys

9 import 
	~sysconfig

10 from 
	~distutils
 import 
sysconfig
 as 
distutils_sysconfig

11 from 
	~distutils.command.install
 import 
SCHEME_KEYS

13 from 
	~pip._internal.utils
 import 
appdirs

14 from 
	~pip._internal.utils.compat
 import 
WINDOWS
 , 
expanduser

17 
USER_CACHE_DIR
 = 
appdirs
 . 
user_cache_dir
 ( "pip" )

20 
DELETE_MARKER_MESSAGE
 = '''\\nThis file is placed here by pip to indicate the source was put\nhere by pip.\n\nOnce this package is successfully installed this source code will be\ndeleted (unless you remove this file).\n'''

27 
PIP_DELETE_MARKER_FILENAME
 = 'pip-delete-this-directory.txt'

30 def 
	$write_delete_marker_file
 ( 
directory
 ) :

34 
filepath
 = 
os
 . 
path
 . 
join
 ( 
directory
 , 
PIP_DELETE_MARKER_FILENAME
 )

35 with 
open
 ( 
filepath
 , 'w' ) as 
marker_fp
 :

36 
marker_fp
 . 
write
 ( 
DELETE_MARKER_MESSAGE
 ) 
	}

39 def 
	$running_under_virtualenv
 ( ) :

44 if 
hasattr
 ( 
sys
 , 'real_prefix' ) :

46 elif 
sys
 . 
prefix
 != 
getattr
 ( 
sys
 , "base_prefix" , 
sys
 . 
prefix
 ) :

49 return False 
	}

52 def 
	$virtualenv_no_global
 ( ) :

58 
site_mod_dir
 = 
os
 . 
path
 . 
dirname
 ( 
os
 . 
path
 . 
abspath
 ( 
site
 . 
__file__
 ) )

59 
no_global_file
 = 
os
 . 
path
 . 
join
 ( 
site_mod_dir
 , 'no-global-site-packages.txt' )

60 if 
running_under_virtualenv
 ( ) and 
os
 . 
path
 . 
isfile
 ( 
no_global_file
 ) :

61 return True 
	}

64 if 
running_under_virtualenv
 ( ) :

65 
src_prefix
 = 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'src' )

69 
src_prefix
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
getcwd
 ( ) , 'src' )

70 except 
OSError
 :

72 
sys
 . 
exit
 ( "The folder you are executing pip from can no longer be found."

79 
src_prefix
 = 
os
 . 
path
 . 
abspath
 ( 
src_prefix
 )

83 
site_packages
 = 
sysconfig
 . 
get_path
 ( "purelib" )

87 if 
platform
 . 
python_implementation
 ( ) . 
lower
 ( ) == "pypy" :

88 
site_packages
 = 
distutils_sysconfig
 . 
get_python_lib
 ( )

92 
user_site
 = 
site
 . 
getusersitepackages
 ( )

93 except 
AttributeError
 :

94 
user_site
 = 
site
 . 
USER_SITE

95 
user_dir
 = 
expanduser
 ( '~' )

96 if 
WINDOWS
 :

97 
bin_py
 = 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'Scripts' )

98 
bin_user
 = 
os
 . 
path
 . 
join
 ( 
user_site
 , 'Scripts' )

100 if not 
os
 . 
path
 . 
exists
 ( 
bin_py
 ) :

101 
bin_py
 = 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'bin' )

102 
bin_user
 = 
os
 . 
path
 . 
join
 ( 
user_site
 , 'bin' )

104 
config_basename
 = 'pip.ini'

106 
legacy_storage_dir
 = 
os
 . 
path
 . 
join
 ( 
user_dir
 , 'pip' )

107 
legacy_config_file
 = 
os
 . 
path
 . 
join
 (

108 
legacy_storage_dir
 ,

109 
config_basename
 ,

112 
bin_py
 = 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'bin' )

113 
bin_user
 = 
os
 . 
path
 . 
join
 ( 
user_site
 , 'bin' )

115 
config_basename
 = 'pip.conf'

117 
legacy_storage_dir
 = 
os
 . 
path
 . 
join
 ( 
user_dir
 , '.pip' )

118 
legacy_config_file
 = 
os
 . 
path
 . 
join
 (

119 
legacy_storage_dir
 ,

120 
config_basename
 ,

124 if 
sys
 . 
platform
 [ : 6 ] == 'darwin' and 
sys
 . 
prefix
 [ : 16 ] == '/System/Library/' :

125 
bin_py
 = '/usr/local/bin'

127 
site_config_files
 = [

128 
os
 . 
path
 . 
join
 ( 
path
 , 
config_basename
 )

129 for 
path
 in 
appdirs
 . 
site_config_dirs
 ( 'pip' )

132 
venv_config_file
 = 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 
config_basename
 )

133 
new_config_file
 = 
os
 . 
path
 . 
join
 ( 
appdirs
 . 
user_config_dir
 ( "pip" ) , 
config_basename
 )

136 def 
	$distutils_scheme
 ( 
dist_name
 , 
user
 = False , 
home
 = None , 
root
 = None ,

137 
isolated
 = False , 
prefix
 = None ) :

141 from 
	~distutils.dist
 import 
Distribution

143 
scheme
 = { }

145 if 
isolated
 :

146 
extra_dist_args
 = { "script_args" : [ "--no-user-cfg" ] }

148 
extra_dist_args
 = { }

149 
dist_args
 = { 'name' : 
dist_name
 }

150 
dist_args
 . 
update
 ( 
extra_dist_args
 )

152 
d
 = 
Distribution
 ( 
dist_args
 )

153 
d
 . 
parse_config_files
 ( )

154 
i
 = 
d
 . 
get_command_obj
 ( 'install' , 
create
 = True )

158 assert not ( 
user
 and 
prefix
 ) , "user={} prefix={}" . 
format
 ( 
user
 , 
prefix
 )

159 
i
 . 
user
 = 
user
 or 
i
 . 
user

160 if 
user
 :

161 
i
 . 
prefix
 = ""

162 
i
 . 
prefix
 = 
prefix
 or 
i
 . 
prefix

163 
i
 . 
home
 = 
home
 or 
i
 . 
home

164 
i
 . 
root
 = 
root
 or 
i
 . 
root

165 
i
 . 
finalize_options
 ( )

166 for 
key
 in 
SCHEME_KEYS
 :

167 
scheme
 [ 
key
 ] = 
getattr
 ( 
i
 , 'install_' + 
key
 )

174 if 'install_lib' in 
d
 . 
get_option_dict
 ( 'install' ) :

175 
scheme
 . 
update
 ( 
dict
 ( 
purelib
 = 
i
 . 
install_lib
 , 
platlib
 = 
i
 . 
install_lib
 ) )

177 if 
running_under_virtualenv
 ( ) :

178 
scheme
 [ 'headers' ] = 
os
 . 
path
 . 
join
 (

179 
sys
 . 
prefix
 , 'include'

182 + 
sys
 . 
version
 [ : 3 ] ,

183 
dist_name
 ,

186 if 
root
 is not None :

187 
path_no_drive
 = 
os
 . 
path
 . 
splitdrive
 (

188 
os
 . 
path
 . 
abspath
 ( 
scheme
 [ "headers" ] ) ) [ 1 ]

189 
scheme
 [ "headers" ] = 
os
 . 
path
 . 
join
 (

190 
root
 ,

191 
path_no_drive
 [ 1 : ] ,

194 return 
scheme
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/pyproject.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~io

4 import 
	~os

6 from 
	~pip._vendor
 import 
pytoml
 , 
six

8 from 
	~pip._internal.exceptions
 import 
InstallationError

11 def 
	$_is_list_of_str
 ( 
obj
 ) :

13 
isinstance
 ( 
obj
 , 
list
 ) and

14 
all
 ( 
isinstance
 ( 
item
 , 
six
 . 
string_types
 ) for 
item
 in 
obj
 )

15 ) 
	}

18 def 
	$load_pyproject_toml
 ( 
use_pep517
 , 
pyproject_toml
 , 
setup_py
 , 
req_name
 ) :

38 
has_pyproject
 = 
os
 . 
path
 . 
isfile
 ( 
pyproject_toml
 )

39 
has_setup
 = 
os
 . 
path
 . 
isfile
 ( 
setup_py
 )

41 if 
has_pyproject
 :

42 with 
io
 . 
open
 ( 
pyproject_toml
 , 
encoding
 = "utf-8" ) as 
f
 :

43 
pp_toml
 = 
pytoml
 . 
load
 ( 
f
 )

44 
build_system
 = 
pp_toml
 . 
get
 ( "build-system" )

46 
build_system
 = None

51 if 
has_pyproject
 and not 
has_setup
 :

52 if 
use_pep517
 is False :

53 raise 
InstallationError
 ( "Disabling PEP 517 processing is invalid: " "project does not have a setup.py"

57 
use_pep517
 = True

58 elif 
build_system
 and "build-backend" in 
build_system
 :

59 if 
use_pep517
 is False :

60 raise 
InstallationError
 ( "Disabling PEP 517 processing is invalid: " "project specifies a build backend of {} " "in pyproject.toml"

63 . 
format
 (

64 
build_system
 [ "build-backend" ]

67 
use_pep517
 = True

72 elif 
use_pep517
 is None :

73 
use_pep517
 = 
has_pyproject

76 assert 
use_pep517
 is not None

80 if not 
use_pep517
 :

83 if 
build_system
 is None :

90 
build_system
 = { "requires"

99 assert 
build_system
 is not None

103 
error_template
 = ( "{package} has a pyproject.toml file that does not comply " "with PEP 518: {reason}"

109 if "requires" not in 
build_system
 :

110 raise 
InstallationError
 (

111 
error_template
 . 
format
 ( 
package
 = 
req_name
 , 
reason
 = ( "it has a 'build-system' table but not " "'build-system.requires' which is mandatory in the table"

118 
requires
 = 
build_system
 [ "requires" ]

119 if not 
_is_list_of_str
 ( 
requires
 ) :

120 raise 
InstallationError
 ( 
error_template
 . 
format
 (

121 
package
 = 
req_name
 ,

122 
reason
 = "'build-system.requires' is not a list of strings." ,

125 
backend
 = 
build_system
 . 
get
 ( "build-backend" )

126 
check
 = [ ]

127 if 
backend
 is None :

141 
backend
 = "setuptools.build_meta"

142 
check
 = [ "setuptools>=38.2.5" , "wheel" ]

144 return ( 
requires
 , 
backend
 , 
check
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/cli/parser.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~logging

5 import 
	~optparse

6 import 
	~sys

7 import 
	~textwrap

8 from 
	~distutils.util
 import 
strtobool

10 from 
	~pip._vendor.six
 import 
string_types

12 from 
	~pip._internal.cli.status_codes
 import 
UNKNOWN_ERROR

13 from 
	~pip._internal.configuration
 import 
Configuration
 , 
ConfigurationError

14 from 
	~pip._internal.utils.compat
 import 
get_terminal_size

16 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

19 class 
	cPrettyHelpFormatter
 ( 
optparse
 . 
IndentedHelpFormatter
 ) :

22 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

24 
kwargs
 [ 'max_help_position' ] = 30

25 
kwargs
 [ 'indent_increment' ] = 1

26 
kwargs
 [ 'width' ] = 
get_terminal_size
 ( ) [ 0 ] - 2

27 
optparse
 . 
IndentedHelpFormatter
 . 
__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) 
	}

29 def 
	$format_option_strings
 ( 
self
 , 
option
 ) :

30 return 
self
 . 
_format_option_strings
 ( 
option
 , ' <%s>' , ', ' ) 
	}

32 def 
	$_format_option_strings
 ( 
self
 , 
option
 , 
mvarfmt
 = ' <%s>' , 
optsep
 = ', ' ) :

40 
opts
 = [ ]

42 if 
option
 . 
_short_opts
 :

43 
opts
 . 
append
 ( 
option
 . 
_short_opts
 [ 0 ] )

44 if 
option
 . 
_long_opts
 :

45 
opts
 . 
append
 ( 
option
 . 
_long_opts
 [ 0 ] )

46 if 
len
 ( 
opts
 ) > 1 :

47 
opts
 . 
insert
 ( 1 , 
optsep
 )

49 if 
option
 . 
takes_value
 ( ) :

50 
metavar
 = 
option
 . 
metavar
 or 
option
 . 
dest
 . 
lower
 ( )

51 
opts
 . 
append
 ( 
mvarfmt
 % 
metavar
 . 
lower
 ( ) )

53 return '' . 
join
 ( 
opts
 ) 
	}

55 def 
	$format_heading
 ( 
self
 , 
heading
 ) :

56 if 
heading
 == 'Options' :

58 return 
heading
 + ':\n' 
	}

60 def 
	$format_usage
 ( 
self
 , 
usage
 ) :

65 
msg
 = '\nUsage: %s\n' % 
self
 . 
indent_lines
 ( 
textwrap
 . 
dedent
 ( 
usage
 ) , "  " )

66 return 
msg
 
	}

68 def 
	$format_description
 ( 
self
 , 
description
 ) :

70 if 
description
 :

71 if 
hasattr
 ( 
self
 . 
parser
 , 'main' ) :

72 
label
 = 'Commands'

74 
label
 = 'Description'

76 
description
 = 
description
 . 
lstrip
 ( '\n' )

78 
description
 = 
description
 . 
rstrip
 ( )

80 
description
 = 
self
 . 
indent_lines
 ( 
textwrap
 . 
dedent
 ( 
description
 ) , "  " )

81 
description
 = '%s:\n%s\n' % ( 
label
 , 
description
 )

82 return 
description

84 return '' 
	}

86 def 
	$format_epilog
 ( 
self
 , 
epilog
 ) :

88 if 
epilog
 :

89 return 
epilog

91 return '' 
	}

93 def 
	$indent_lines
 ( 
self
 , 
text
 , 
indent
 ) :

94 
new_lines
 = [ 
indent
 + 
line
 for 
line
 in 
text
 . 
split
 ( '\n' ) ]

95 return "\n" . 
join
 ( 
new_lines
 ) 
	}

98 class 
	cUpdatingDefaultsHelpFormatter
 ( 
PrettyHelpFormatter
 ) :

105 def 
	$expand_default
 ( 
self
 , 
option
 ) :

106 if 
self
 . 
parser
 is not None :

107 
self
 . 
parser
 . 
_update_defaults
 ( 
self
 . 
parser
 . 
defaults
 )

108 return 
optparse
 . 
IndentedHelpFormatter
 . 
expand_default
 ( 
self
 , 
option
 ) 
	}

111 class 
	cCustomOptionParser
 ( 
optparse
 . 
OptionParser
 ) :

113 def 
	$insert_option_group
 ( 
self
 , 
idx
 , * 
args
 , ** 
kwargs
 ) :

115 
group
 = 
self
 . 
add_option_group
 ( * 
args
 , ** 
kwargs
 )

117 
self
 . 
option_groups
 . 
pop
 ( )

118 
self
 . 
option_groups
 . 
insert
 ( 
idx
 , 
group
 )

120 return 
group
 
	}

122 @ 
property

123 def 
	$option_list_all
 ( 
self
 ) :

125 
res
 = 
self
 . 
option_list
 [ : ]

126 for 
i
 in 
self
 . 
option_groups
 :

127 
res
 . 
extend
 ( 
i
 . 
option_list
 )

129 return 
res
 
	}

132 class 
	cConfigOptionParser
 ( 
CustomOptionParser
 ) :

136 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

137 
self
 . 
name
 = 
kwargs
 . 
pop
 ( 'name' )

139 
isolated
 = 
kwargs
 . 
pop
 ( "isolated" , False )

140 
self
 . 
config
 = 
Configuration
 ( 
isolated
 )

142 assert 
self
 . 
name

143 
optparse
 . 
OptionParser
 . 
__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) 
	}

145 def 
	$check_default
 ( 
self
 , 
option
 , 
key
 , 
val
 ) :

147 return 
option
 . 
check_value
 ( 
key
 , 
val
 )

148 except 
optparse
 . 
OptionValueError
 as 
exc
 :

149 
print
 ( "An error occurred during configuration: %s" % 
exc
 )

150 
sys
 . 
exit
 ( 3 ) 
	}

152 def 
	$_get_ordered_configuration_items
 ( 
self
 ) :

154 
override_order
 = [ "global" , 
self
 . 
name
 , ":env:" ]

157 
section_items
 = { 
name
 : [ ] for 
name
 in 
override_order
 }

158 for 
section_key
 , 
val
 in 
self
 . 
config
 . 
items
 ( ) :

160 if not 
val
 :

161 
logger
 . 
debug
 ( "Ignoring configuration key '%s' as it's value is empty."

163 
section_key

167 
section
 , 
key
 = 
section_key
 . 
split
 ( "." , 1 )

168 if 
section
 in 
override_order
 :

169 
section_items
 [ 
section
 ] . 
append
 ( ( 
key
 , 
val
 ) )

172 for 
section
 in 
override_order
 :

173 for 
key
 , 
val
 in 
section_items
 [ 
section
 ] :

174 yield 
key
 , 
val
 
	}

176 def 
	$_update_defaults
 ( 
self
 , 
defaults
 ) :

182 
self
 . 
values
 = 
optparse
 . 
Values
 ( 
self
 . 
defaults
 )

183 
late_eval
 = 
set
 ( )

185 for 
key
 , 
val
 in 
self
 . 
_get_ordered_configuration_items
 ( ) :

187 
option
 = 
self
 . 
get_option
 ( '--' + 
key
 )

192 if 
option
 is None :

195 if 
option
 . 
action
 in ( 'store_true' , 'store_false' , 'count' ) :

197 
val
 = 
strtobool
 ( 
val
 )

198 except 
ValueError
 :

199 
error_msg
 = 
invalid_config_error_message
 (

200 
option
 . 
action
 , 
key
 , 
val

202 
self
 . 
error
 ( 
error_msg
 )

204 elif 
option
 . 
action
 == 'append' :

205 
val
 = 
val
 . 
split
 ( )

206 
val
 = [ 
self
 . 
check_default
 ( 
option
 , 
key
 , 
v
 ) for 
v
 in 
val
 ]

207 elif 
option
 . 
action
 == 'callback' :

208 
late_eval
 . 
add
 ( 
option
 . 
dest
 )

209 
opt_str
 = 
option
 . 
get_opt_string
 ( )

210 
val
 = 
option
 . 
convert_value
 ( 
opt_str
 , 
val
 )

212 
args
 = 
option
 . 
callback_args
 or ( )

213 
kwargs
 = 
option
 . 
callback_kwargs
 or { }

214 
option
 . 
callback
 ( 
option
 , 
opt_str
 , 
val
 , 
self
 , * 
args
 , ** 
kwargs
 )

216 
val
 = 
self
 . 
check_default
 ( 
option
 , 
key
 , 
val
 )

218 
defaults
 [ 
option
 . 
dest
 ] = 
val

220 for 
key
 in 
late_eval
 :

221 
defaults
 [ 
key
 ] = 
getattr
 ( 
self
 . 
values
 , 
key
 )

222 
self
 . 
values
 = None

223 return 
defaults
 
	}

225 def 
	$get_default_values
 ( 
self
 ) :

228 if not 
self
 . 
process_default_values
 :

230 return 
optparse
 . 
Values
 ( 
self
 . 
defaults
 )

234 
self
 . 
config
 . 
load
 ( )

235 except 
ConfigurationError
 as 
err
 :

236 
self
 . 
exit
 ( 
UNKNOWN_ERROR
 , 
str
 ( 
err
 ) )

238 
defaults
 = 
self
 . 
_update_defaults
 ( 
self
 . 
defaults
 . 
copy
 ( ) )

239 for 
option
 in 
self
 . 
_get_all_options
 ( ) :

240 
default
 = 
defaults
 . 
get
 ( 
option
 . 
dest
 )

241 if 
isinstance
 ( 
default
 , 
string_types
 ) :

242 
opt_str
 = 
option
 . 
get_opt_string
 ( )

243 
defaults
 [ 
option
 . 
dest
 ] = 
option
 . 
check_value
 ( 
opt_str
 , 
default
 )

244 return 
optparse
 . 
Values
 ( 
defaults
 ) 
	}

246 def 
	$error
 ( 
self
 , 
msg
 ) :

247 
self
 . 
print_usage
 ( 
sys
 . 
stderr
 )

248 
self
 . 
exit
 ( 
UNKNOWN_ERROR
 , "%s\n" % 
msg
 ) 
	}

251 def 
	$invalid_config_error_message
 ( 
action
 , 
key
 , 
val
 ) :

254 if 
action
 in ( 'store_true' , 'store_false' ) :

257 ) . 
format
 ( 
val
 , 
key
 )

261 ) . 
format
 ( 
val
 , 
key
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/cli/base_command.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~logging

5 import 
	~logging.config

6 import 
	~optparse

7 import 
	~os

8 import 
	~sys

10 from 
	~pip._internal.cli
 import 
cmdoptions

11 from 
	~pip._internal.cli.parser
 import (

12 
ConfigOptionParser
 , 
UpdatingDefaultsHelpFormatter
 ,

14 from 
	~pip._internal.cli.status_codes
 import (

15 
ERROR
 , 
PREVIOUS_BUILD_DIR_ERROR
 , 
SUCCESS
 , 
UNKNOWN_ERROR
 ,

16 
VIRTUALENV_NOT_FOUND
 ,

18 from 
	~pip._internal.download
 import 
PipSession

19 from 
	~pip._internal.exceptions
 import (

20 
BadCommand
 , 
CommandError
 , 
InstallationError
 , 
PreviousBuildDirError
 ,

21 
UninstallationError
 ,

23 from 
	~pip._internal.index
 import 
PackageFinder

24 from 
	~pip._internal.locations
 import 
running_under_virtualenv

25 from 
	~pip._internal.req.constructors
 import (

26 
install_req_from_editable
 , 
install_req_from_line
 ,

28 from 
	~pip._internal.req.req_file
 import 
parse_requirements

29 from 
	~pip._internal.utils.logging
 import 
setup_logging

30 from 
	~pip._internal.utils.misc
 import 
get_prog
 , 
normalize_path

31 from 
	~pip._internal.utils.outdated
 import 
pip_version_check

32 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

34 if 
MYPY_CHECK_RUNNING
 :

35 from 
	~typing
 import 
Optional

37 
__all__
 = [ 'Command' ]

39 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

42 class 
	cCommand
 ( 
object
 ) :

43 
name
 = None

44 
usage
 = None

45 
hidden
 = False

46 
ignore_require_venv
 = False

48 def 
	$__init__
 ( 
self
 , 
isolated
 = False ) :

49 
parser_kw
 = { 'usage'

50 : 
self
 . 
usage
 , 'prog'

51 : '%s %s' % ( 
get_prog
 ( ) , 
self
 . 
name
 ) , 'formatter'

52 : 
UpdatingDefaultsHelpFormatter
 ( ) , 'add_help_option'

54 : 
self
 . 
name
 , 'description'

55 : 
self
 . 
__doc__
 , 'isolated'

56 : 
isolated
 ,

59 
self
 . 
parser
 = 
ConfigOptionParser
 ( ** 
parser_kw
 )

62 
optgroup_name
 = '%s Options' % 
self
 . 
name
 . 
capitalize
 ( )

63 
self
 . 
cmd_opts
 = 
optparse
 . 
OptionGroup
 ( 
self
 . 
parser
 , 
optgroup_name
 )

66 
gen_opts
 = 
cmdoptions
 . 
make_option_group
 (

67 
cmdoptions
 . 
general_group
 ,

68 
self
 . 
parser
 ,

70 
self
 . 
parser
 . 
add_option_group
 ( 
gen_opts
 ) 
	}

72 def 
	$_build_session
 ( 
self
 , 
options
 , 
retries
 = None , 
timeout
 = None ) :

73 
session
 = 
PipSession
 (

74 
cache
 = (

75 
normalize_path
 ( 
os
 . 
path
 . 
join
 ( 
options
 . 
cache_dir
 , "http" ) )

76 if 
options
 . 
cache_dir
 else None

78 
retries
 = 
retries
 if 
retries
 is not None else 
options
 . 
retries
 ,

79 
insecure_hosts
 = 
options
 . 
trusted_hosts
 ,

83 if 
options
 . 
cert
 :

84 
session
 . 
verify
 = 
options
 . 
cert

87 if 
options
 . 
client_cert
 :

88 
session
 . 
cert
 = 
options
 . 
client_cert

91 if 
options
 . 
timeout
 or 
timeout
 :

92 
session
 . 
timeout
 = (

93 
timeout
 if 
timeout
 is not None else 
options
 . 
timeout

97 if 
options
 . 
proxy
 :

98 
session
 . 
proxies
 = { "http"

99 : 
options
 . 
proxy
 , "https"

100 : 
options
 . 
proxy
 ,

104 
session
 . 
auth
 . 
prompting
 = not 
options
 . 
no_input

106 return 
session
 
	}

108 def 
	$parse_args
 ( 
self
 , 
args
 ) :

110 return 
self
 . 
parser
 . 
parse_args
 ( 
args
 ) 
	}

112 def 
	$main
 ( 
self
 , 
args
 ) :

113 
options
 , 
args
 = 
self
 . 
parse_args
 ( 
args
 )

116 
self
 . 
verbosity
 = 
options
 . 
verbose
 - 
options
 . 
quiet

118 
setup_logging
 (

119 
verbosity
 = 
self
 . 
verbosity
 ,

120 
no_color
 = 
options
 . 
no_color
 ,

121 
user_log_file
 = 
options
 . 
log
 ,

128 if 
options
 . 
no_input
 :

129 
os
 . 
environ
 [ 'PIP_NO_INPUT' ] = '1'

131 if 
options
 . 
exists_action
 :

132 
os
 . 
environ
 [ 'PIP_EXISTS_ACTION' ] = ' ' . 
join
 ( 
options
 . 
exists_action
 )

134 if 
options
 . 
require_venv
 and not 
self
 . 
ignore_require_venv
 :

136 if not 
running_under_virtualenv
 ( ) :

137 
logger
 . 
critical
 ( 'Could not find an activated virtualenv (required).'

140 
sys
 . 
exit
 ( 
VIRTUALENV_NOT_FOUND
 )

143 
status
 = 
self
 . 
run
 ( 
options
 , 
args
 )

146 if 
isinstance
 ( 
status
 , 
int
 ) :

147 return 
status

148 except 
PreviousBuildDirError
 as 
exc
 :

149 
logger
 . 
critical
 ( 
str
 ( 
exc
 ) )

150 
logger
 . 
debug
 ( 'Exception information:' , 
exc_info
 = True )

152 return 
PREVIOUS_BUILD_DIR_ERROR

153 except ( 
InstallationError
 , 
UninstallationError
 , 
BadCommand
 ) as 
exc
 :

154 
logger
 . 
critical
 ( 
str
 ( 
exc
 ) )

155 
logger
 . 
debug
 ( 'Exception information:' , 
exc_info
 = True )

157 return 
ERROR

158 except 
CommandError
 as 
exc
 :

159 
logger
 . 
critical
 ( 'ERROR: %s' , 
exc
 )

160 
logger
 . 
debug
 ( 'Exception information:' , 
exc_info
 = True )

162 return 
ERROR

163 except 
KeyboardInterrupt
 :

164 
logger
 . 
critical
 ( 'Operation cancelled by user' )

165 
logger
 . 
debug
 ( 'Exception information:' , 
exc_info
 = True )

167 return 
ERROR

168 except 
BaseException
 :

169 
logger
 . 
critical
 ( 'Exception:' , 
exc_info
 = True )

171 return 
UNKNOWN_ERROR

173 
allow_version_check
 = (

175 
hasattr
 ( 
options
 , "no_index" ) and

177 not ( 
options
 . 
disable_pip_version_check
 or 
options
 . 
no_index
 )

180 if 
allow_version_check
 :

181 
session
 = 
self
 . 
_build_session
 (

182 
options
 ,

183 
retries
 = 0 ,

184 
timeout
 = 
min
 ( 5 , 
options
 . 
timeout
 )

186 with 
session
 :

187 
pip_version_check
 ( 
session
 , 
options
 )

190 
logging
 . 
shutdown
 ( )

192 return 
SUCCESS
 
	}

195 class 
	cRequirementCommand
 ( 
Command
 ) :

197 @ 
	`staticmethod

198 def 
	$populate_requirement_set
 ( 
requirement_set
 , 
args
 , 
options
 , 
finder
 ,

199 
session
 , 
name
 , 
wheel_cache
 ) :

206 for 
filename
 in 
options
 . 
constraints
 :

207 for 
req_to_add
 in 
parse_requirements
 (

208 
filename
 ,

209 
constraint
 = True , 
finder
 = 
finder
 , 
options
 = 
options
 ,

210 
session
 = 
session
 , 
wheel_cache
 = 
wheel_cache
 ) :

211 
req_to_add
 . 
is_direct
 = True

212 
requirement_set
 . 
add_requirement
 ( 
req_to_add
 )

214 for 
req
 in 
args
 :

215 
req_to_add
 = 
install_req_from_line
 (

216 
req
 , None , 
isolated
 = 
options
 . 
isolated_mode
 ,

217 
wheel_cache
 = 
wheel_cache

219 
req_to_add
 . 
is_direct
 = True

220 
requirement_set
 . 
add_requirement
 ( 
req_to_add
 )

222 for 
req
 in 
options
 . 
editables
 :

223 
req_to_add
 = 
install_req_from_editable
 (

224 
req
 ,

225 
isolated
 = 
options
 . 
isolated_mode
 ,

226 
wheel_cache
 = 
wheel_cache

228 
req_to_add
 . 
is_direct
 = True

229 
requirement_set
 . 
add_requirement
 ( 
req_to_add
 )

231 for 
filename
 in 
options
 . 
requirements
 :

232 for 
req_to_add
 in 
parse_requirements
 (

233 
filename
 ,

234 
finder
 = 
finder
 , 
options
 = 
options
 , 
session
 = 
session
 ,

235 
wheel_cache
 = 
wheel_cache
 ) :

236 
req_to_add
 . 
is_direct
 = True

237 
requirement_set
 . 
add_requirement
 ( 
req_to_add
 )

240 
requirement_set
 . 
require_hashes
 = 
options
 . 
require_hashes

242 if not ( 
args
 or 
options
 . 
editables
 or 
options
 . 
requirements
 ) :

243 
opts
 = { 'name' : 
name
 }

244 if 
options
 . 
find_links
 :

245 raise 
CommandError
 ( 'You must give at least one requirement to %(name)s ' '(maybe you meant "pip %(name)s %(links)s"?)'

248 
dict
 ( 
opts
 , 
links
 = ' ' . 
join
 ( 
options
 . 
find_links
 ) ) )

250 raise 
CommandError
 ( 'You must give at least one requirement to %(name)s ' '(see "pip help %(name)s")'

252 % 
opts
 ) 
	}

254 def 
	$_build_package_finder
 ( 
self
 , 
options
 , 
session
 ,

255 
platform
 = None , 
python_versions
 = None ,

256 
abi
 = None , 
implementation
 = None ) :

260 
index_urls
 = [ 
options
 . 
index_url
 ] + 
options
 . 
extra_index_urls

261 if 
options
 . 
no_index
 :

262 
logger
 . 
debug
 ( 'Ignoring indexes: %s' , ',' . 
join
 ( 
index_urls
 ) )

263 
index_urls
 = [ ]

265 return 
PackageFinder
 (

266 
find_links
 = 
options
 . 
find_links
 ,

267 
format_control
 = 
options
 . 
format_control
 ,

268 
index_urls
 = 
index_urls
 ,

269 
trusted_hosts
 = 
options
 . 
trusted_hosts
 ,

270 
allow_all_prereleases
 = 
options
 . 
pre
 ,

271 
process_dependency_links
 = 
options
 . 
process_dependency_links
 ,

272 
session
 = 
session
 ,

273 
platform
 = 
platform
 ,

274 
versions
 = 
python_versions
 ,

275 
abi
 = 
abi
 ,

276 
implementation
 = 
implementation
 ,

277 
prefer_binary
 = 
options
 . 
prefer_binary
 ,

278 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/cli/__init__.py


	@./env/lib/python3.7/site-packages/pip/_internal/cli/autocompletion.py

4 import 
	~optparse

5 import 
	~os

6 import 
	~sys

8 from 
	~pip._internal.cli.main_parser
 import 
create_main_parser

9 from 
	~pip._internal.commands
 import 
commands_dict
 , 
get_summaries

10 from 
	~pip._internal.utils.misc
 import 
get_installed_distributions

13 def 
	$autocomplete
 ( ) :

17 if 'PIP_AUTO_COMPLETE' not in 
os
 . 
environ
 :

19 
cwords
 = 
os
 . 
environ
 [ 'COMP_WORDS' ] . 
split
 ( ) [ 1 : ]

20 
cword
 = 
int
 ( 
os
 . 
environ
 [ 'COMP_CWORD' ] )

22 
current
 = 
cwords
 [ 
cword
 - 1 ]

23 except 
IndexError
 :

24 
current
 = ''

26 
subcommands
 = [ 
cmd
 for 
cmd
 , 
summary
 in 
get_summaries
 ( ) ]

27 
options
 = [ ]

30 
subcommand_name
 = [ 
w
 for 
w
 in 
cwords
 if 
w
 in 
subcommands
 ] [ 0 ]

31 except 
IndexError
 :

32 
subcommand_name
 = None

34 
parser
 = 
create_main_parser
 ( )

36 if 
subcommand_name
 :

38 if 
subcommand_name
 == 'help' :

39 
sys
 . 
exit
 ( 1 )

41 
should_list_installed
 = (

42 
subcommand_name
 in [ 'show' , 'uninstall' ] and

43 not 
current
 . 
startswith
 ( '-' )

45 if 
should_list_installed
 :

46 
installed
 = [ ]

47 
lc
 = 
current
 . 
lower
 ( )

48 for 
dist
 in 
get_installed_distributions
 ( 
local_only
 = True ) :

49 if 
dist
 . 
key
 . 
startswith
 ( 
lc
 ) and 
dist
 . 
key
 not in 
cwords
 [ 1 : ] :

50 
installed
 . 
append
 ( 
dist
 . 
key
 )

52 if 
installed
 :

53 for 
dist
 in 
installed
 :

54 
print
 ( 
dist
 )

55 
sys
 . 
exit
 ( 1 )

57 
subcommand
 = 
commands_dict
 [ 
subcommand_name
 ] ( )

59 for 
opt
 in 
subcommand
 . 
parser
 . 
option_list_all
 :

60 if 
opt
 . 
help
 != 
optparse
 . 
SUPPRESS_HELP
 :

61 for 
opt_str
 in 
opt
 . 
_long_opts
 + 
opt
 . 
_short_opts
 :

62 
options
 . 
append
 ( ( 
opt_str
 , 
opt
 . 
nargs
 ) )

65 
prev_opts
 = [ 
x
 . 
split
 ( '=' ) [ 0 ] for 
x
 in 
cwords
 [ 1 : 
cword
 - 1 ] ]

66 
options
 = [ ( 
x
 , 
v
 ) for ( 
x
 , 
v
 ) in 
options
 if 
x
 not in 
prev_opts
 ]

68 
options
 = [ ( 
k
 , 
v
 ) for 
k
 , 
v
 in 
options
 if 
k
 . 
startswith
 ( 
current
 ) ]

70 
completion_type
 = 
get_path_completion_type
 (

71 
cwords
 , 
cword
 , 
subcommand
 . 
parser
 . 
option_list_all
 ,

75 if 
completion_type
 :

76 
options
 = 
auto_complete_paths
 ( 
current
 , 
completion_type
 )

77 
options
 = ( ( 
opt
 , 0 ) for 
opt
 in 
options
 )

78 for 
option
 in 
options
 :

79 
opt_label
 = 
option
 [ 0 ]

81 if 
option
 [ 1 ] and 
option
 [ 0 ] [ : 2 ] == "--" :

82 
opt_label
 += '='

83 
print
 ( 
opt_label
 )

87 
opts
 = [ 
i
 . 
option_list
 for 
i
 in 
parser
 . 
option_groups
 ]

88 
opts
 . 
append
 ( 
parser
 . 
option_list
 )

89 
opts
 = ( 
o
 for 
it
 in 
opts
 for 
o
 in 
it
 )

90 if 
current
 . 
startswith
 ( '-' ) :

91 for 
opt
 in 
opts
 :

92 if 
opt
 . 
help
 != 
optparse
 . 
SUPPRESS_HELP
 :

93 
subcommands
 += 
opt
 . 
_long_opts
 + 
opt
 . 
_short_opts

96 
completion_type
 = 
get_path_completion_type
 ( 
cwords
 , 
cword
 , 
opts
 )

97 if 
completion_type
 :

98 
subcommands
 = 
auto_complete_paths
 ( 
current
 , 
completion_type
 )

100 
print
 ( ' ' . 
join
 ( [ 
x
 for 
x
 in 
subcommands
 if 
x
 . 
startswith
 ( 
current
 ) ] ) )

101 
sys
 . 
exit
 ( 1 ) 
	}

104 def 
	$get_path_completion_type
 ( 
cwords
 , 
cword
 , 
opts
 ) :

112 if 
cword
 < 2 or not 
cwords
 [ 
cword
 - 2 ] . 
startswith
 ( '-' ) :

114 for 
opt
 in 
opts
 :

115 if 
opt
 . 
help
 == 
optparse
 . 
SUPPRESS_HELP
 :

117 for 
o
 in 
str
 ( 
opt
 ) . 
split
 ( '/' ) :

118 if 
cwords
 [ 
cword
 - 2 ] . 
split
 ( '=' ) [ 0 ] == 
o
 :

119 if not 
opt
 . 
metavar
 or 
any
 (

120 
x
 in ( 'path' , 'file' , 'dir' )

121 for 
x
 in 
opt
 . 
metavar
 . 
split
 ( '/' ) ) :

122 return 
opt
 . 
metavar
 
	}

125 def 
	$auto_complete_paths
 ( 
current
 , 
completion_type
 ) :

134 
directory
 , 
filename
 = 
os
 . 
path
 . 
split
 ( 
current
 )

135 
current_path
 = 
os
 . 
path
 . 
abspath
 ( 
directory
 )

137 if not 
os
 . 
access
 ( 
current_path
 , 
os
 . 
R_OK
 ) :

139 
filename
 = 
os
 . 
path
 . 
normcase
 ( 
filename
 )

141 
file_list
 = ( 
x
 for 
x
 in 
os
 . 
listdir
 ( 
current_path
 )

142 if 
os
 . 
path
 . 
normcase
 ( 
x
 ) . 
startswith
 ( 
filename
 ) )

143 for 
f
 in 
file_list
 :

144 
opt
 = 
os
 . 
path
 . 
join
 ( 
current_path
 , 
f
 )

145 
comp_file
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
join
 ( 
directory
 , 
f
 ) )

149 if 
completion_type
 != 'dir' and 
os
 . 
path
 . 
isfile
 ( 
opt
 ) :

150 yield 
comp_file

151 elif 
os
 . 
path
 . 
isdir
 ( 
opt
 ) :

152 yield 
os
 . 
path
 . 
join
 ( 
comp_file
 , '' ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/cli/cmdoptions.py

10 from 
	~__future__
 import 
absolute_import

12 import 
	~warnings

13 from 
	~functools
 import 
partial

14 from 
	~optparse
 import 
SUPPRESS_HELP
 , 
Option
 , 
OptionGroup

16 from 
	~pip._internal.exceptions
 import 
CommandError

17 from 
	~pip._internal.locations
 import 
USER_CACHE_DIR
 , 
src_prefix

18 from 
	~pip._internal.models.format_control
 import 
FormatControl

19 from 
	~pip._internal.models.index
 import 
PyPI

20 from 
	~pip._internal.utils.hashes
 import 
STRONG_HASHES

21 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

22 from 
	~pip._internal.utils.ui
 import 
BAR_TYPES

24 if 
MYPY_CHECK_RUNNING
 :

25 from 
	~typing
 import 
Any

28 def 
	$make_option_group
 ( 
group
 , 
parser
 ) :

34 
option_group
 = 
OptionGroup
 ( 
parser
 , 
group
 [ 'name' ] )

35 for 
option
 in 
group
 [ 'options' ] :

36 
option_group
 . 
add_option
 ( 
option
 ( ) )

37 return 
option_group
 
	}

40 def 
	$check_install_build_global
 ( 
options
 , 
check_options
 = None ) :

47 if 
check_options
 is None :

48 
check_options
 = 
options

50 def 
getname
 ( 
n
 ) :

51 return 
getattr
 ( 
check_options
 , 
n
 , None )

52 
names
 = [ "build_options" , "global_options" , "install_options" ]

53 if 
any
 ( 
map
 ( 
getname
 , 
names
 ) ) :

54 
control
 = 
options
 . 
format_control

55 
control
 . 
disallow_binaries
 ( )

56 
warnings
 . 
warn
 ( 'Disabling all use of wheels due to the use of --build-options ' '/ --global-options / --install-options.'

58 , 
stacklevel
 = 2 ,

59 ) 
	}

62 def 
	$check_dist_restriction
 ( 
options
 , 
check_target
 = False ) :

68 
dist_restriction_set
 = 
any
 ( [

69 
options
 . 
python_version
 ,

70 
options
 . 
platform
 ,

71 
options
 . 
abi
 ,

72 
options
 . 
implementation
 ,

75 
binary_only
 = 
FormatControl
 ( 
set
 ( ) , { ':all:' } )

76 
sdist_dependencies_allowed
 = (

77 
options
 . 
format_control
 != 
binary_only
 and

78 not 
options
 . 
ignore_dependencies

84 if 
dist_restriction_set
 and 
sdist_dependencies_allowed
 :

85 raise 
CommandError
 ( "When restricting platform and interpreter constraints using " "--python-version, --platform, --abi, or --implementation, " "either --no-deps must be set, or --only-binary=:all: must be " "set and --no-binary must not be set (or must be set to " ":none:)."

93 if 
check_target
 :

94 if 
dist_restriction_set
 and not 
options
 . 
target_dir
 :

95 raise 
CommandError
 ( "Can not use any platform or abi specific options unless " "installing via '--target'"

98 ) 
	}

105 
help_
 = 
partial
 (

106 
Option
 , '-h'

108 
dest
 = 'help' ,

109 
action
 = 'help' ,

110 
help
 = 'Show help.' ,

113 
isolated_mode
 = 
partial
 (

114 
Option
 , "--isolated"

116 
dest
 = "isolated_mode" ,

117 
action
 = "store_true" ,

118 
default
 = False ,

119 
help
 = ( "Run pip in an isolated mode, ignoring environment variables and user " "configuration."

125 
require_virtualenv
 = 
partial
 (

126 
Option
 , '--require-virtualenv'

129 
dest
 = 'require_venv' ,

130 
action
 = 'store_true' ,

131 
default
 = False ,

132 
help
 = 
SUPPRESS_HELP

135 
verbose
 = 
partial
 (

136 
Option
 , '-v'

138 
dest
 = 'verbose' ,

139 
action
 = 'count' ,

140 
default
 = 0 ,

141 
help
 = 'Give more output. Option is additive, and can be used up to 3 times.'

144 
no_color
 = 
partial
 (

145 
Option
 , '--no-color'

147 
dest
 = 'no_color' ,

148 
action
 = 'store_true' ,

149 
default
 = False ,

150 
help
 = "Suppress colored output" ,

153 
version
 = 
partial
 (

154 
Option
 , '-V'

156 
dest
 = 'version' ,

157 
action
 = 'store_true' ,

158 
help
 = 'Show version and exit.' ,

161 
quiet
 = 
partial
 (

162 
Option
 , '-q'

164 
dest
 = 'quiet' ,

165 
action
 = 'count' ,

166 
default
 = 0 ,

167 
help
 = ( 'Give less output. Option is additive, and can be used up to 3' ' times (corresponding to WARNING, ERROR, and CRITICAL logging' ' levels).'

174 
progress_bar
 = 
partial
 (

175 
Option
 , '--progress-bar'

177 
dest
 = 'progress_bar' ,

178 
type
 = 'choice' ,

179 
choices
 = 
list
 ( 
BAR_TYPES
 . 
keys
 ( ) ) ,

180 
default
 = 'on' ,

181 
help
 = ( 'Specify type of progress to be displayed ['

183 . 
join
 ( 
BAR_TYPES
 . 
keys
 ( ) ) + '] (default: %default)'

187 
log
 = 
partial
 (

188 
Option
 , "--log"

190 
dest
 = "log" ,

191 
metavar
 = "path" ,

192 
help
 = "Path to a verbose appending log."

195 
no_input
 = 
partial
 (

196 
Option
 , '--no-input'

199 
dest
 = 'no_input' ,

200 
action
 = 'store_true' ,

201 
default
 = False ,

202 
help
 = 
SUPPRESS_HELP

205 
proxy
 = 
partial
 (

206 
Option
 , '--proxy'

208 
dest
 = 'proxy' ,

209 
type
 = 'str' ,

210 
default
 = '' ,

211 
help
 = "Specify a proxy in the form [user:passwd@]proxy.server:port."

214 
retries
 = 
partial
 (

215 
Option
 , '--retries'

217 
dest
 = 'retries' ,

218 
type
 = 'int' ,

219 
default
 = 5 ,

220 
help
 = "Maximum number of retries each connection should attempt " "(default %default times)."

224 
timeout
 = 
partial
 (

225 
Option
 , '--timeout'

227 
metavar
 = 'sec' ,

228 
dest
 = 'timeout' ,

229 
type
 = 'float' ,

230 
default
 = 15 ,

231 
help
 = 'Set the socket timeout (default %default seconds).' ,

234 
skip_requirements_regex
 = 
partial
 (

235 
Option
 , '--skip-requirements-regex'

238 
dest
 = 'skip_requirements_regex' ,

239 
type
 = 'str' ,

240 
default
 = '' ,

241 
help
 = 
SUPPRESS_HELP
 ,

245 def 
	$exists_action
 ( ) :

246 return 
Option
 ( '--exists-action'

249 
dest
 = 'exists_action' ,

250 
type
 = 'choice' ,

251 
choices
 = [ 's' , 'i' , 'w' , 'b' , 'a' ] ,

252 
default
 = [ ] ,

253 
action
 = 'append' ,

254 
metavar
 = 'action' ,

255 
help
 = "Default action when a path already exists: " "(s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort)."

257 ) 
	}

260 
cert
 = 
partial
 (

261 
Option
 , '--cert'

263 
dest
 = 'cert' ,

264 
type
 = 'str' ,

265 
metavar
 = 'path' ,

266 
help
 = "Path to alternate CA bundle." ,

269 
client_cert
 = 
partial
 (

270 
Option
 , '--client-cert'

272 
dest
 = 'client_cert' ,

273 
type
 = 'str' ,

274 
default
 = None ,

275 
metavar
 = 'path' ,

276 
help
 = "Path to SSL client certificate, a single file containing the " "private key and the certificate in PEM format."

280 
index_url
 = 
partial
 (

281 
Option
 , '-i'

283 
dest
 = 'index_url' ,

284 
metavar
 = 'URL' ,

285 
default
 = 
PyPI
 . 
simple_url
 ,

286 
help
 = "Base URL of Python Package Index (default %default). " "This should point to a repository compliant with PEP 503 " "(the simple repository API) or a local directory laid out " "in the same format."

293 def 
	$extra_index_url
 ( ) :

294 return 
Option
 ( '--extra-index-url'

296 
dest
 = 'extra_index_urls' ,

297 
metavar
 = 'URL' ,

298 
action
 = 'append' ,

299 
default
 = [ ] ,

300 
help
 = "Extra URLs of package indexes to use in addition to " "--index-url. Should follow the same rules as " "--index-url."

303 ) 
	}

306 
no_index
 = 
partial
 (

307 
Option
 , '--no-index'

309 
dest
 = 'no_index' ,

310 
action
 = 'store_true' ,

311 
default
 = False ,

312 
help
 = 'Ignore package index (only looking at --find-links URLs instead).' ,

316 def 
	$find_links
 ( ) :

317 return 
Option
 ( '-f'

319 
dest
 = 'find_links' ,

320 
action
 = 'append' ,

321 
default
 = [ ] ,

322 
metavar
 = 'url' ,

323 
help
 = "If a url or path to an html file, then parse for links to " "archives. If a local path or file:// url that's a directory, " "then look for archives in the directory listing."

326 ) 
	}

329 def 
	$trusted_host
 ( ) :

330 return 
Option
 ( "--trusted-host"

332 
dest
 = "trusted_hosts" ,

333 
action
 = "append" ,

334 
metavar
 = "HOSTNAME" ,

335 
default
 = [ ] ,

336 
help
 = "Mark this host as trusted, even though it does not have valid " "or any HTTPS."

338 ) 
	}

342 
process_dependency_links
 = 
partial
 (

343 
Option
 , "--process-dependency-links"

345 
dest
 = "process_dependency_links" ,

346 
action
 = "store_true" ,

347 
default
 = False ,

348 
help
 = "Enable the processing of dependency links." ,

352 def 
	$constraints
 ( ) :

353 return 
Option
 ( '-c'

355 
dest
 = 'constraints' ,

356 
action
 = 'append' ,

357 
default
 = [ ] ,

358 
metavar
 = 'file' ,

359 
help
 = 'Constrain versions using the given constraints file. ' 'This option can be used multiple times.'

361 ) 
	}

364 def 
	$requirements
 ( ) :

365 return 
Option
 ( '-r'

367 
dest
 = 'requirements' ,

368 
action
 = 'append' ,

369 
default
 = [ ] ,

370 
metavar
 = 'file' ,

371 
help
 = 'Install from the given requirements file. ' 'This option can be used multiple times.'

373 ) 
	}

376 def 
	$editable
 ( ) :

377 return 
Option
 ( '-e'

379 
dest
 = 'editables' ,

380 
action
 = 'append' ,

381 
default
 = [ ] ,

382 
metavar
 = 'path/url' ,

383 
help
 = ( 'Install a project in editable mode (i.e. setuptools ' '"develop mode") from a local project path or a VCS url.'

385 ) 
	}

388 
src
 = 
partial
 (

389 
Option
 , '--src'

391 
dest
 = 'src_dir' ,

392 
metavar
 = 'dir' ,

393 
default
 = 
src_prefix
 ,

394 
help
 = 'Directory to check out editable projects into. ' 'The default in a virtualenv is "<venv path>/src". ' 'The default for global installs is "<current dir>/src".'

400 def 
	$_get_format_control
 ( 
values
 , 
option
 ) :

402 return 
getattr
 ( 
values
 , 
option
 . 
dest
 ) 
	}

405 def 
	$_handle_no_binary
 ( 
option
 , 
opt_str
 , 
value
 , 
parser
 ) :

406 
existing
 = 
_get_format_control
 ( 
parser
 . 
values
 , 
option
 )

407 
FormatControl
 . 
handle_mutual_excludes
 (

408 
value
 , 
existing
 . 
no_binary
 , 
existing
 . 
only_binary
 ,

409 ) 
	}

412 def 
	$_handle_only_binary
 ( 
option
 , 
opt_str
 , 
value
 , 
parser
 ) :

413 
existing
 = 
_get_format_control
 ( 
parser
 . 
values
 , 
option
 )

414 
FormatControl
 . 
handle_mutual_excludes
 (

415 
value
 , 
existing
 . 
only_binary
 , 
existing
 . 
no_binary
 ,

416 ) 
	}

419 def 
	$no_binary
 ( ) :

420 
format_control
 = 
FormatControl
 ( 
set
 ( ) , 
set
 ( ) )

421 return 
Option
 ( "--no-binary"

422 , 
dest
 = "format_control" , 
action
 = "callback" ,

423 
callback
 = 
_handle_no_binary
 , 
type
 = "str" ,

424 
default
 = 
format_control
 ,

425 
help
 = "Do not use binary packages. Can be supplied multiple times, and " "each time adds to the existing value. Accepts either :all: to " "disable all binary packages, :none: to empty the set, or one or " "more package names with commas between them. Note that some " "packages are tricky to compile and may fail to install when " "this option is used on them."

431 ) 
	}

434 def 
	$only_binary
 ( ) :

435 
format_control
 = 
FormatControl
 ( 
set
 ( ) , 
set
 ( ) )

436 return 
Option
 ( "--only-binary"

437 , 
dest
 = "format_control" , 
action
 = "callback" ,

438 
callback
 = 
_handle_only_binary
 , 
type
 = "str" ,

439 
default
 = 
format_control
 ,

440 
help
 = "Do not use source packages. Can be supplied multiple times, and " "each time adds to the existing value. Accepts either :all: to " "disable all source packages, :none: to empty the set, or one or " "more package names with commas between them. Packages without " "binary distributions will fail to install when this option is " "used on them."

446 ) 
	}

449 
platform
 = 
partial
 (

450 
Option
 , '--platform'

452 
dest
 = 'platform' ,

453 
metavar
 = 'platform' ,

454 
default
 = None ,

455 
help
 = ( "Only use wheels compatible with <platform>. " "Defaults to the platform of the running system."

460 
python_version
 = 
partial
 (

461 
Option
 , '--python-version'

463 
dest
 = 'python_version' ,

464 
metavar
 = 'python_version' ,

465 
default
 = None ,

466 
help
 = ( "Only use wheels compatible with Python " "interpreter version <version>. If not specified, then the " "current system interpreter minor version is used. A major " "version (e.g. '2') can be specified to match all " "minor revs of that major version.  A minor version " "(e.g. '34') can also be specified."

475 
implementation
 = 
partial
 (

476 
Option
 , '--implementation'

478 
dest
 = 'implementation' ,

479 
metavar
 = 'implementation' ,

480 
default
 = None ,

481 
help
 = ( "Only use wheels compatible with Python " "implementation <implementation>, e.g. 'pp', 'jy', 'cp', " " or 'ip'. If not specified, then the current " "interpreter implementation is used.  Use 'py' to force " "implementation-agnostic wheels."

489 
abi
 = 
partial
 (

490 
Option
 , '--abi'

492 
dest
 = 'abi' ,

493 
metavar
 = 'abi' ,

494 
default
 = None ,

495 
help
 = ( "Only use wheels compatible with Python " "abi <abi>, e.g. 'pypy_41'.  If not specified, then the " "current interpreter abi tag is used.  Generally " "you will need to specify --implementation, " "--platform, and --python-version when using " "this option."

504 def 
	$prefer_binary
 ( ) :

505 return 
Option
 ( "--prefer-binary"

507 
dest
 = "prefer_binary" ,

508 
action
 = "store_true" ,

509 
default
 = False ,

510 
help
 = "Prefer older binary packages over newer source packages."

511 ) 
	}

514 
cache_dir
 = 
partial
 (

515 
Option
 , "--cache-dir"

517 
dest
 = "cache_dir" ,

518 
default
 = 
USER_CACHE_DIR
 ,

519 
metavar
 = "dir" ,

520 
help
 = "Store the cache data in <dir>."

523 
no_cache
 = 
partial
 (

524 
Option
 , "--no-cache-dir"

526 
dest
 = "cache_dir" ,

527 
action
 = "store_false" ,

528 
help
 = "Disable the cache." ,

531 
no_deps
 = 
partial
 (

532 
Option
 , '--no-deps'

534 
dest
 = 'ignore_dependencies' ,

535 
action
 = 'store_true' ,

536 
default
 = False ,

537 
help
 = "Don't install package dependencies." ,

540 
build_dir
 = 
partial
 (

541 
Option
 , '-b'

543 
dest
 = 'build_dir' ,

544 
metavar
 = 'dir' ,

545 
help
 = 'Directory to unpack packages into and build in. Note that ' 'an initial build still takes place in a temporary directory. ' 'The location of temporary directories can be controlled by setting ' 'the TMPDIR environment variable (TEMP on Windows) appropriately. ' 'When passed, build directories are not cleaned in case of failures.'

552 
ignore_requires_python
 = 
partial
 (

553 
Option
 , '--ignore-requires-python'

555 
dest
 = 'ignore_requires_python' ,

556 
action
 = 'store_true' ,

557 
help
 = 'Ignore the Requires-Python information.'

560 
no_build_isolation
 = 
partial
 (

561 
Option
 , '--no-build-isolation'

563 
dest
 = 'build_isolation' ,

564 
action
 = 'store_false' ,

565 
default
 = True ,

566 
help
 = 'Disable isolation when building a modern source distribution. ' 'Build dependencies specified by PEP 518 must be already installed ' 'if this option is used.'

571 
install_options
 = 
partial
 (

572 
Option
 , '--install-option'

574 
dest
 = 'install_options' ,

575 
action
 = 'append' ,

576 
metavar
 = 'options' ,

577 
help
 = "Extra arguments to be supplied to the setup.py install " "command (use like --install-option=\"--install-scripts=/usr/local/" "bin\"). Use multiple --install-option options to pass multiple " "options to setup.py install. If you are using an option with a " "directory path, be sure to use absolute path."

584 
global_options
 = 
partial
 (

585 
Option
 , '--global-option'

587 
dest
 = 'global_options' ,

588 
action
 = 'append' ,

589 
metavar
 = 'options' ,

590 
help
 = "Extra global options to be supplied to the setup.py " "call before the install command."

594 
no_clean
 = 
partial
 (

595 
Option
 , '--no-clean'

597 
action
 = 'store_true' ,

598 
default
 = False ,

599 
help
 = "Don't clean up build directories."

602 
pre
 = 
partial
 (

603 
Option
 , '--pre'

605 
action
 = 'store_true' ,

606 
default
 = False ,

607 
help
 = "Include pre-release and development versions. By default, " "pip only finds stable versions."

611 
disable_pip_version_check
 = 
partial
 (

612 
Option
 , "--disable-pip-version-check"

614 
dest
 = "disable_pip_version_check" ,

615 
action
 = "store_true" ,

616 
default
 = True ,

617 
help
 = "Don't periodically check PyPI to determine whether a new version " "of pip is available for download. Implied with --no-index."

623 
always_unzip
 = 
partial
 (

624 
Option
 , '-Z'

626 
dest
 = 'always_unzip' ,

627 
action
 = 'store_true' ,

628 
help
 = 
SUPPRESS_HELP
 ,

632 def 
	$_merge_hash
 ( 
option
 , 
opt_str
 , 
value
 , 
parser
 ) :

635 if not 
parser
 . 
values
 . 
hashes
 :

636 
parser
 . 
values
 . 
hashes
 = { }

638 
algo
 , 
digest
 = 
value
 . 
split
 ( ':' , 1 )

639 except 
ValueError
 :

640 
parser
 . 
error
 ( 'Arguments to %s must be a hash name ' 'followed by a value, like --hash=sha256:abcde...'

642 
opt_str
 )

643 if 
algo
 not in 
STRONG_HASHES
 :

644 
parser
 . 
error
 ( 'Allowed hash algorithms for %s are %s.' %

645 ( 
opt_str
 , ', ' . 
join
 ( 
STRONG_HASHES
 ) ) )

646 
parser
 . 
values
 . 
hashes
 . 
setdefault
 ( 
algo
 , [ ] ) . 
append
 ( 
digest
 ) 
	}

649 
hash
 = 
partial
 (

650 
Option
 , '--hash'

654 
dest
 = 'hashes' ,

655 
action
 = 'callback' ,

656 
callback
 = 
_merge_hash
 ,

657 
type
 = 'string' ,

658 
help
 = "Verify that the package's archive matches this " 'hash before installing. Example: --hash=sha256:abcdef...'

663 
require_hashes
 = 
partial
 (

664 
Option
 , '--require-hashes'

666 
dest
 = 'require_hashes' ,

667 
action
 = 'store_true' ,

668 
default
 = False ,

669 
help
 = 'Require a hash to check each requirement against, for ' 'repeatable installs. This option is implied when any package in a ' 'requirements file has a --hash option.'

679 
general_group
 = { 'name'

682 
help_
 ,

683 
isolated_mode
 ,

684 
require_virtualenv
 ,

685 
verbose
 ,

686 
version
 ,

687 
quiet
 ,

688 
log
 ,

689 
no_input
 ,

690 
proxy
 ,

691 
retries
 ,

692 
timeout
 ,

693 
skip_requirements_regex
 ,

694 
exists_action
 ,

695 
trusted_host
 ,

696 
cert
 ,

697 
client_cert
 ,

698 
cache_dir
 ,

699 
no_cache
 ,

700 
disable_pip_version_check
 ,

701 
no_color
 ,

705 
index_group
 = { 'name'

708 
index_url
 ,

709 
extra_index_url
 ,

710 
no_index
 ,

711 
find_links
 ,

712 
process_dependency_links
 ,


	@./env/lib/python3.7/site-packages/pip/_internal/cli/main_parser.py

4 import 
	~os

5 import 
	~sys

7 from 
	~pip
 import 
__version__

8 from 
	~pip._internal.cli
 import 
cmdoptions

9 from 
	~pip._internal.cli.parser
 import (

10 
ConfigOptionParser
 , 
UpdatingDefaultsHelpFormatter
 ,

12 from 
	~pip._internal.commands
 import (

13 
commands_dict
 , 
get_similar_commands
 , 
get_summaries
 ,

15 from 
	~pip._internal.exceptions
 import 
CommandError

16 from 
	~pip._internal.utils.misc
 import 
get_prog

18 
__all__
 = [ "create_main_parser" , "parse_command" ]

21 def 
	$create_main_parser
 ( ) :

25 
parser_kw
 = { 'usage'

28 : 
UpdatingDefaultsHelpFormatter
 ( ) , 'name'

30 : 
get_prog
 ( ) ,

33 
parser
 = 
ConfigOptionParser
 ( ** 
parser_kw
 )

34 
parser
 . 
disable_interspersed_args
 ( )

36 
pip_pkg_dir
 = 
os
 . 
path
 . 
abspath
 ( 
os
 . 
path
 . 
join
 (

37 
os
 . 
path
 . 
dirname
 ( 
__file__
 ) , ".." , ".." ,

39 
parser
 . 
version
 = 'pip %s from %s (python %s)' % (

40 
__version__
 , 
pip_pkg_dir
 , 
sys
 . 
version
 [ : 3 ] ,

44 
gen_opts
 = 
cmdoptions
 . 
make_option_group
 ( 
cmdoptions
 . 
general_group
 , 
parser
 )

45 
parser
 . 
add_option_group
 ( 
gen_opts
 )

47 
parser
 . 
main
 = True

50 
command_summaries
 = 
get_summaries
 ( )

51 
description
 = [ '' ] + [ '%-27s %s' % ( 
i
 , 
j
 ) for 
i
 , 
j
 in 
command_summaries
 ]

52 
parser
 . 
description
 = '\n' . 
join
 ( 
description
 )

54 return 
parser
 
	}

57 def 
	$parse_command
 ( 
args
 ) :

58 
parser
 = 
create_main_parser
 ( )

67 
general_options
 , 
args_else
 = 
parser
 . 
parse_args
 ( 
args
 )

70 if 
general_options
 . 
version
 :

71 
sys
 . 
stdout
 . 
write
 ( 
parser
 . 
version
 )

72 
sys
 . 
stdout
 . 
write
 ( 
os
 . 
linesep
 )

73 
sys
 . 
exit
 ( )

76 if not 
args_else
 or ( 
args_else
 [ 0 ] == 'help' and 
len
 ( 
args_else
 ) == 1 ) :

77 
parser
 . 
print_help
 ( )

78 
sys
 . 
exit
 ( )

81 
cmd_name
 = 
args_else
 [ 0 ]

83 if 
cmd_name
 not in 
commands_dict
 :

84 
guess
 = 
get_similar_commands
 ( 
cmd_name
 )

86 
msg
 = [ 'unknown command "%s"' % 
cmd_name
 ]

87 if 
guess
 :

88 
msg
 . 
append
 ( 'maybe you meant "%s"' % 
guess
 )

90 raise 
CommandError
 ( ' - ' . 
join
 ( 
msg
 ) )

93 
cmd_args
 = 
args
 [ : ]

94 
cmd_args
 . 
remove
 ( 
cmd_name
 )

96 return 
cmd_name
 , 
cmd_args
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/cli/status_codes.py

1 from 
	~__future__
 import 
absolute_import

3 
SUCCESS
 = 0

4 
ERROR
 = 1

5 
UNKNOWN_ERROR
 = 2

6 
VIRTUALENV_NOT_FOUND
 = 3

7 
PREVIOUS_BUILD_DIR_ERROR
 = 4

8 
NO_MATCHES_FOUND
 = 23


	@./env/lib/python3.7/site-packages/pip/_internal/cache.py

4 import 
	~errno

5 import 
	~hashlib

6 import 
	~logging

7 import 
	~os

9 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

11 from 
	~pip._internal.download
 import 
path_to_url

12 from 
	~pip._internal.models.link
 import 
Link

13 from 
	~pip._internal.utils.compat
 import 
expanduser

14 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

15 from 
	~pip._internal.wheel
 import 
InvalidWheelFilename
 , 
Wheel

17 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

20 class 
	cCache
 ( 
object
 ) :

31 def 
	$__init__
 ( 
self
 , 
cache_dir
 , 
format_control
 , 
allowed_formats
 ) :

32 
super
 ( 
Cache
 , 
self
 ) . 
__init__
 ( )

33 
self
 . 
cache_dir
 = 
expanduser
 ( 
cache_dir
 ) if 
cache_dir
 else None

34 
self
 . 
format_control
 = 
format_control

35 
self
 . 
allowed_formats
 = 
allowed_formats

37 
_valid_formats
 = { "source" , "binary" }

38 assert 
self
 . 
allowed_formats
 . 
union
 ( 
_valid_formats
 ) == 
_valid_formats
 
	}

40 def 
	$_get_cache_path_parts
 ( 
self
 , 
link
 ) :

47 
key_parts
 = [ 
link
 . 
url_without_fragment
 ]

48 if 
link
 . 
hash_name
 is not None and 
link
 . 
hash
 is not None :

49 
key_parts
 . 
append
 ( "=" . 
join
 ( [ 
link
 . 
hash_name
 , 
link
 . 
hash
 ] ) )

50 
key_url
 = "#" . 
join
 ( 
key_parts
 )

56 
hashed
 = 
hashlib
 . 
sha224
 ( 
key_url
 . 
encode
 ( ) ) . 
hexdigest
 ( )

61 
parts
 = [ 
hashed
 [ : 2 ] , 
hashed
 [ 2 : 4 ] , 
hashed
 [ 4 : 6 ] , 
hashed
 [ 6 : ] ]

63 return 
parts
 
	}

65 def 
	$_get_candidates
 ( 
self
 , 
link
 , 
package_name
 ) :

66 
can_not_cache
 = (

67 not 
self
 . 
cache_dir
 or

68 not 
package_name
 or

69 not 
link

71 if 
can_not_cache
 :

74 
canonical_name
 = 
canonicalize_name
 ( 
package_name
 )

75 
formats
 = 
self
 . 
format_control
 . 
get_allowed_formats
 (

76 
canonical_name

78 if not 
self
 . 
allowed_formats
 . 
intersection
 ( 
formats
 ) :

81 
root
 = 
self
 . 
get_path_for_link
 ( 
link
 )

83 return 
os
 . 
listdir
 ( 
root
 )

84 except 
OSError
 as 
err
 :

85 if 
err
 . 
errno
 in { 
errno
 . 
ENOENT
 , 
errno
 . 
ENOTDIR
 } :

87 raise 
	}

89 def 
	$get_path_for_link
 ( 
self
 , 
link
 ) :

92 raise 
NotImplementedError
 ( ) 
	}

94 def 
	$get
 ( 
self
 , 
link
 , 
package_name
 ) :

98 raise 
NotImplementedError
 ( ) 
	}

100 def 
	$_link_for_candidate
 ( 
self
 , 
link
 , 
candidate
 ) :

101 
root
 = 
self
 . 
get_path_for_link
 ( 
link
 )

102 
path
 = 
os
 . 
path
 . 
join
 ( 
root
 , 
candidate
 )

104 return 
Link
 ( 
path_to_url
 ( 
path
 ) ) 
	}

106 def 
	$cleanup
 ( 
self
 ) :

107 pass 
	}

110 class 
	cSimpleWheelCache
 ( 
Cache
 ) :

114 def 
	$__init__
 ( 
self
 , 
cache_dir
 , 
format_control
 ) :

115 
super
 ( 
SimpleWheelCache
 , 
self
 ) . 
__init__
 (

116 
cache_dir
 , 
format_control
 , { "binary" }

117 ) 
	}

119 def 
	$get_path_for_link
 ( 
self
 , 
link
 ) :

134 
parts
 = 
self
 . 
_get_cache_path_parts
 ( 
link
 )

137 return 
os
 . 
path
 . 
join
 ( 
self
 . 
cache_dir
 , "wheels" , * 
parts
 ) 
	}

139 def 
	$get
 ( 
self
 , 
link
 , 
package_name
 ) :

140 
candidates
 = [ ]

142 for 
wheel_name
 in 
self
 . 
_get_candidates
 ( 
link
 , 
package_name
 ) :

144 
wheel
 = 
Wheel
 ( 
wheel_name
 )

145 except 
InvalidWheelFilename
 :

147 if not 
wheel
 . 
supported
 ( ) :

150 
candidates
 . 
append
 ( ( 
wheel
 . 
support_index_min
 ( ) , 
wheel_name
 ) )

152 if not 
candidates
 :

153 return 
link

155 return 
self
 . 
_link_for_candidate
 ( 
link
 , 
min
 ( 
candidates
 ) [ 1 ] ) 
	}

158 class 
	cEphemWheelCache
 ( 
SimpleWheelCache
 ) :

162 def 
	$__init__
 ( 
self
 , 
format_control
 ) :

163 
self
 . 
_temp_dir
 = 
TempDirectory
 ( 
kind
 = "ephem-wheel-cache" )

164 
self
 . 
_temp_dir
 . 
create
 ( )

166 
super
 ( 
EphemWheelCache
 , 
self
 ) . 
__init__
 (

167 
self
 . 
_temp_dir
 . 
path
 , 
format_control

168 ) 
	}

170 def 
	$cleanup
 ( 
self
 ) :

171 
self
 . 
_temp_dir
 . 
cleanup
 ( ) 
	}

174 class 
	cWheelCache
 ( 
Cache
 ) :

181 def 
	$__init__
 ( 
self
 , 
cache_dir
 , 
format_control
 ) :

182 
super
 ( 
WheelCache
 , 
self
 ) . 
__init__
 (

183 
cache_dir
 , 
format_control
 , { 'binary' }

185 
self
 . 
_wheel_cache
 = 
SimpleWheelCache
 ( 
cache_dir
 , 
format_control
 )

186 
self
 . 
_ephem_cache
 = 
EphemWheelCache
 ( 
format_control
 ) 
	}

188 def 
	$get_path_for_link
 ( 
self
 , 
link
 ) :

189 return 
self
 . 
_wheel_cache
 . 
get_path_for_link
 ( 
link
 ) 
	}

191 def 
	$get_ephem_path_for_link
 ( 
self
 , 
link
 ) :

192 return 
self
 . 
_ephem_cache
 . 
get_path_for_link
 ( 
link
 ) 
	}

194 def 
	$get
 ( 
self
 , 
link
 , 
package_name
 ) :

195 
retval
 = 
self
 . 
_wheel_cache
 . 
get
 ( 
link
 , 
package_name
 )

196 if 
retval
 is 
link
 :

197 
retval
 = 
self
 . 
_ephem_cache
 . 
get
 ( 
link
 , 
package_name
 )

198 return 
retval
 
	}

200 def 
	$cleanup
 ( 
self
 ) :

201 
self
 . 
_wheel_cache
 . 
cleanup
 ( )

202 
self
 . 
_ephem_cache
 . 
cleanup
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/build_env.py

4 import 
	~logging

5 import 
	~os

6 import 
	~sys

7 from 
	~distutils.sysconfig
 import 
get_python_lib

8 from 
	~sysconfig
 import 
get_paths

10 from 
	~pip._vendor.pkg_resources
 import 
Requirement
 , 
VersionConflict
 , 
WorkingSet

12 from 
	~pip._internal.utils.misc
 import 
call_subprocess

13 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

14 from 
	~pip._internal.utils.ui
 import 
open_spinner

16 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

19 class 
	cBuildEnvironment
 ( 
object
 ) :

23 def 
	$__init__
 ( 
self
 ) :

24 
self
 . 
_temp_dir
 = 
TempDirectory
 ( 
kind
 = "build-env" )

25 
self
 . 
_temp_dir
 . 
create
 ( ) 
	}

27 @ 
property

28 def 
	$path
 ( 
self
 ) :

29 return 
self
 . 
_temp_dir
 . 
path
 
	}

31 def 
	$__enter__
 ( 
self
 ) :

32 
self
 . 
save_path
 = 
os
 . 
environ
 . 
get
 ( 'PATH' , None )

33 
self
 . 
save_pythonpath
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , None )

34 
self
 . 
save_nousersite
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONNOUSERSITE' , None )

36 
install_scheme
 = 'nt' if ( 
os
 . 
name
 == 'nt' ) else 'posix_prefix'

37 
install_dirs
 = 
get_paths
 ( 
install_scheme
 , 
vars
 = { 'base'

38 : 
self
 . 
path
 , 'platbase'

39 : 
self
 . 
path
 ,

42 
scripts
 = 
install_dirs
 [ 'scripts' ]

43 if 
self
 . 
save_path
 :

44 
os
 . 
environ
 [ 'PATH' ] = 
scripts
 + 
os
 . 
pathsep
 + 
self
 . 
save_path

46 
os
 . 
environ
 [ 'PATH' ] = 
scripts
 + 
os
 . 
pathsep
 + 
os
 . 
defpath

50 
purelib
 = 
get_python_lib
 ( 
plat_specific
 = 0 , 
prefix
 = 
self
 . 
path
 )

51 
platlib
 = 
get_python_lib
 ( 
plat_specific
 = 1 , 
prefix
 = 
self
 . 
path
 )

52 if 
purelib
 == 
platlib
 :

53 
lib_dirs
 = 
purelib

55 
lib_dirs
 = 
purelib
 + 
os
 . 
pathsep
 + 
platlib

56 if 
self
 . 
save_pythonpath
 :

57 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
lib_dirs
 + 
os
 . 
pathsep
 +

58 
self
 . 
save_pythonpath

60 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
lib_dirs

62 
os
 . 
environ
 [ 'PYTHONNOUSERSITE' ] = '1'

64 return 
self
 . 
path
 
	}

66 def 
	$__exit__
 ( 
self
 , 
exc_type
 , 
exc_val
 , 
exc_tb
 ) :

67 def 
restore_var
 ( 
varname
 , 
old_value
 ) :

68 if 
old_value
 is None :

69 
os
 . 
environ
 . 
pop
 ( 
varname
 , None )

71 
os
 . 
environ
 [ 
varname
 ] = 
old_value

73 
restore_var
 ( 'PATH' , 
self
 . 
save_path
 )

74 
restore_var
 ( 'PYTHONPATH' , 
self
 . 
save_pythonpath
 )

75 
restore_var
 ( 'PYTHONNOUSERSITE' , 
self
 . 
save_nousersite
 ) 
	}

77 def 
	$cleanup
 ( 
self
 ) :

78 
self
 . 
_temp_dir
 . 
cleanup
 ( ) 
	}

80 def 
	$missing_requirements
 ( 
self
 , 
reqs
 ) :

83 
missing
 = [ ]

84 with 
self
 :

85 
ws
 = 
WorkingSet
 ( 
os
 . 
environ
 [ "PYTHONPATH" ] . 
split
 ( 
os
 . 
pathsep
 ) )

86 for 
req
 in 
reqs
 :

88 if 
ws
 . 
find
 ( 
Requirement
 . 
parse
 ( 
req
 ) ) is None :

89 
missing
 . 
append
 ( 
req
 )

90 except 
VersionConflict
 :

91 
missing
 . 
append
 ( 
req
 )

92 return 
missing
 
	}

94 def 
	$install_requirements
 ( 
self
 , 
finder
 , 
requirements
 , 
message
 ) :

95 
args
 = [

96 
sys
 . 
executable
 , '-m' , 'pip' , 'install' , '--ignore-installed' , '--no-user'

97 , '--prefix' , 
self
 . 
path
 , '--no-warn-script-location' ,

99 if 
logger
 . 
getEffectiveLevel
 ( ) <= 
logging
 . 
DEBUG
 :

100 
args
 . 
append
 ( '-v' )

101 for 
format_control
 in ( 'no_binary' , 'only_binary' ) :

102 
formats
 = 
getattr
 ( 
finder
 . 
format_control
 , 
format_control
 )

103 
args
 . 
extend
 ( ( '--' + 
format_control
 . 
replace
 ( '_' , '-' ) , ','

104 . 
join
 ( 
sorted
 ( 
formats
 or { ':none:' } ) ) ) )

105 if 
finder
 . 
index_urls
 :

106 
args
 . 
extend
 ( [ '-i' , 
finder
 . 
index_urls
 [ 0 ] ] )

107 for 
extra_index
 in 
finder
 . 
index_urls
 [ 1 : ] :

108 
args
 . 
extend
 ( [ '--extra-index-url' , 
extra_index
 ] )

110 
args
 . 
append
 ( '--no-index' )

111 for 
link
 in 
finder
 . 
find_links
 :

112 
args
 . 
extend
 ( [ '--find-links' , 
link
 ] )

113 for 
_
 , 
host
 , 
_
 in 
finder
 . 
secure_origins
 :

114 
args
 . 
extend
 ( [ '--trusted-host' , 
host
 ] )

115 if 
finder
 . 
allow_all_prereleases
 :

116 
args
 . 
append
 ( '--pre' )

117 if 
finder
 . 
process_dependency_links
 :

118 
args
 . 
append
 ( '--process-dependency-links' )

119 
args
 . 
append
 ( '--' )

120 
args
 . 
extend
 ( 
requirements
 )

121 with 
open_spinner
 ( 
message
 ) as 
spinner
 :

122 
call_subprocess
 ( 
args
 , 
show_stdout
 = False , 
spinner
 = 
spinner
 ) 
	}

125 class 
	cNoOpBuildEnvironment
 ( 
BuildEnvironment
 ) :

129 def 
	$__init__
 ( 
self
 ) :

130 pass 
	}

132 def 
	$__enter__
 ( 
self
 ) :

133 pass 
	}

135 def 
	$__exit__
 ( 
self
 , 
exc_type
 , 
exc_val
 , 
exc_tb
 ) :

136 pass 
	}

138 def 
	$cleanup
 ( 
self
 ) :

139 pass 
	}

141 def 
	$install_requirements
 ( 
self
 , 
finder
 , 
requirements
 , 
message
 ) :

142 raise 
NotImplementedError
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/wheel.py

4 from 
	~__future__
 import 
absolute_import

6 import 
	~collections

7 import 
	~compileall

8 import 
	~csv

9 import 
	~hashlib

10 import 
	~logging

11 import 
	~os.path

12 import 
	~re

13 import 
	~shutil

14 import 
	~stat

15 import 
	~sys

16 import 
	~warnings

17 from 
	~base64
 import 
urlsafe_b64encode

18 from 
	~email.parser
 import 
Parser

20 from 
	~pip._vendor
 import 
pkg_resources

21 from 
	~pip._vendor.distlib.scripts
 import 
ScriptMaker

22 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

23 from 
	~pip._vendor.six
 import 
StringIO

25 from 
	~pip._internal
 import 
pep425tags

26 from 
	~pip._internal.download
 import 
path_to_url
 , 
unpack_url

27 from 
	~pip._internal.exceptions
 import (

28 
InstallationError
 , 
InvalidWheelFilename
 , 
UnsupportedWheel
 ,

30 from 
	~pip._internal.locations
 import (

31 
PIP_DELETE_MARKER_FILENAME
 , 
distutils_scheme
 ,

33 from 
	~pip._internal.utils.logging
 import 
indent_log

34 from 
	~pip._internal.utils.misc
 import (

35 
call_subprocess
 , 
captured_stdout
 , 
ensure_dir
 , 
read_chunks
 ,

37 from 
	~pip._internal.utils.setuptools_build
 import 
SETUPTOOLS_SHIM

38 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

39 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

40 from 
	~pip._internal.utils.ui
 import 
open_spinner

42 if 
MYPY_CHECK_RUNNING
 :

43 from 
	~typing
 import 
Dict
 , 
List
 , 
Optional

45 
wheel_ext
 = '.whl'

47 
VERSION_COMPATIBLE
 = ( 1 , 0 )

50 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

53 def 
	$rehash
 ( 
path
 , 
blocksize
 = 1 << 20 ) :

55 
h
 = 
hashlib
 . 
sha256
 ( )

56 
length
 = 0

57 with 
open
 ( 
path
 , 'rb' ) as 
f
 :

58 for 
block
 in 
read_chunks
 ( 
f
 , 
size
 = 
blocksize
 ) :

59 
length
 += 
len
 ( 
block
 )

60 
h
 . 
update
 ( 
block
 )

61 
digest
 = 'sha256=' + 
urlsafe_b64encode
 (

62 
h
 . 
digest
 ( )

63 ) . 
decode
 ( 'latin1' ) . 
rstrip
 ( '=' )

64 return ( 
digest
 , 
length
 ) 
	}

67 def 
	$open_for_csv
 ( 
name
 , 
mode
 ) :

68 if 
sys
 . 
version_info
 [ 0 ] < 3 :

69 
nl
 = { }

70 
bin
 = 'b'

72 
nl
 = { 'newline' : '' }

73 
bin
 = ''

74 return 
open
 ( 
name
 , 
mode
 + 
bin
 , ** 
nl
 ) 
	}

77 def 
	$fix_script
 ( 
path
 ) :

81 if 
os
 . 
path
 . 
isfile
 ( 
path
 ) :

82 with 
open
 ( 
path
 , 'rb' ) as 
script
 :

83 
firstline
 = 
script
 . 
readline
 ( )

84 if not 
firstline
 . 
startswith
 ( b'#!python' ) :

86 
exename
 = 
sys
 . 
executable
 . 
encode
 ( 
sys
 . 
getfilesystemencoding
 ( ) )

87 
firstline
 = b'#!' + 
exename
 + 
os
 . 
linesep
 . 
encode
 ( "ascii" )

88 
rest
 = 
script
 . 
read
 ( )

89 with 
open
 ( 
path
 , 'wb' ) as 
script
 :

90 
script
 . 
write
 ( 
firstline
 )

91 
script
 . 
write
 ( 
rest
 )

92 return True 
	}

95 
dist_info_re
 = 
re
 . 
compile
 ( r"""^(?P<namever>(?P<name>.+?)(-(?P<ver>.+?))?)\n                                \.dist-info$"""

96 , 
re
 . 
VERBOSE
 )

99 def 
	$root_is_purelib
 ( 
name
 , 
wheeldir
 ) :

103 
name_folded
 = 
name
 . 
replace
 ( "-" , "_" )

104 for 
item
 in 
os
 . 
listdir
 ( 
wheeldir
 ) :

105 
match
 = 
dist_info_re
 . 
match
 ( 
item
 )

106 if 
match
 and 
match
 . 
group
 ( 'name' ) == 
name_folded
 :

107 with 
open
 ( 
os
 . 
path
 . 
join
 ( 
wheeldir
 , 
item
 , 'WHEEL' ) ) as 
wheel
 :

108 for 
line
 in 
wheel
 :

109 
line
 = 
line
 . 
lower
 ( ) . 
rstrip
 ( )

110 if 
line
 == "root-is-purelib: true" :

112 return False 
	}

115 def 
	$get_entrypoints
 ( 
filename
 ) :

116 if not 
os
 . 
path
 . 
exists
 ( 
filename
 ) :

123 with 
open
 ( 
filename
 ) as 
fp
 :

124 
data
 = 
StringIO
 ( )

125 for 
line
 in 
fp
 :

126 
data
 . 
write
 ( 
line
 . 
strip
 ( ) )

127 
data
 . 
write
 ( "\n" )

128 
data
 . 
seek
 ( 0 )

131 
entry_points
 = 
pkg_resources
 . 
EntryPoint
 . 
parse_map
 ( 
data
 )

132 
console
 = 
entry_points
 . 
get
 ( 'console_scripts' , { } )

133 
gui
 = 
entry_points
 . 
get
 ( 'gui_scripts' , { } )

135 def 
_split_ep
 ( 
s
 ) :

138 return 
str
 ( 
s
 ) . 
replace
 ( " " , "" ) . 
split
 ( "=" )

141 
console
 = 
dict
 ( 
_split_ep
 ( 
v
 ) for 
v
 in 
console
 . 
values
 ( ) )

142 
gui
 = 
dict
 ( 
_split_ep
 ( 
v
 ) for 
v
 in 
gui
 . 
values
 ( ) )

143 return 
console
 , 
gui
 
	}

146 def 
	$message_about_scripts_not_on_PATH
 ( 
scripts
 ) :

153 if not 
scripts
 :

157 
grouped_by_dir
 = 
collections
 . 
defaultdict
 ( 
set
 )

158 for 
destfile
 in 
scripts
 :

159 
parent_dir
 = 
os
 . 
path
 . 
dirname
 ( 
destfile
 )

160 
script_name
 = 
os
 . 
path
 . 
basename
 ( 
destfile
 )

161 
grouped_by_dir
 [ 
parent_dir
 ] . 
add
 ( 
script_name
 )

164 
not_warn_dirs
 = [

165 
os
 . 
path
 . 
normcase
 ( 
i
 ) . 
rstrip
 ( 
os
 . 
sep
 ) for 
i
 in

166 
os
 . 
environ
 . 
get
 ( "PATH" , "" ) . 
split
 ( 
os
 . 
pathsep
 )

170 
not_warn_dirs
 . 
append
 ( 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
dirname
 ( 
sys
 . 
executable
 ) ) )

171 
warn_for
 = {

172 
parent_dir
 : 
scripts
 for 
parent_dir
 , 
scripts
 in 
grouped_by_dir
 . 
items
 ( )

173 if 
os
 . 
path
 . 
normcase
 ( 
parent_dir
 ) not in 
not_warn_dirs

175 if not 
warn_for
 :

179 
msg_lines
 = [ ]

180 for 
parent_dir
 , 
scripts
 in 
warn_for
 . 
items
 ( ) :

181 
scripts
 = 
sorted
 ( 
scripts
 )

182 if 
len
 ( 
scripts
 ) == 1 :

183 
start_text
 = "script {} is" . 
format
 ( 
scripts
 [ 0 ] )

185 
start_text
 = "scripts {} are" . 
format
 ( ", "

186 . 
join
 ( 
scripts
 [ : - 1 ] ) + " and " + 
scripts
 [ - 1 ]

189 
msg_lines
 . 
append
 ( "The {} installed in '{}' which is not on PATH."

191 . 
format
 ( 
start_text
 , 
parent_dir
 )

194 
last_line_fmt
 = ( "Consider adding {} to PATH or, if you prefer " "to suppress this warning, use --no-warn-script-location."

198 if 
len
 ( 
msg_lines
 ) == 1 :

199 
msg_lines
 . 
append
 ( 
last_line_fmt
 . 
format
 ( "this directory" ) )

201 
msg_lines
 . 
append
 ( 
last_line_fmt
 . 
format
 ( "these directories" ) )

204 return "\n" . 
join
 ( 
msg_lines
 ) 
	}

207 def 
	$move_wheel_files
 ( 
name
 , 
req
 , 
wheeldir
 , 
user
 = False , 
home
 = None , 
root
 = None ,

208 
pycompile
 = True , 
scheme
 = None , 
isolated
 = False , 
prefix
 = None ,

209 
warn_script_location
 = True ) :

212 if not 
scheme
 :

213 
scheme
 = 
distutils_scheme
 (

214 
name
 , 
user
 = 
user
 , 
home
 = 
home
 , 
root
 = 
root
 , 
isolated
 = 
isolated
 ,

215 
prefix
 = 
prefix
 ,

218 if 
root_is_purelib
 ( 
name
 , 
wheeldir
 ) :

219 
lib_dir
 = 
scheme
 [ 'purelib' ]

221 
lib_dir
 = 
scheme
 [ 'platlib' ]

223 
info_dir
 = [ ]

224 
data_dirs
 = [ ]

225 
source
 = 
wheeldir
 . 
rstrip
 ( 
os
 . 
path
 . 
sep
 ) + 
os
 . 
path
 . 
sep

231 
installed
 = { }

232 
changed
 = 
set
 ( )

233 
generated
 = [ ]

236 if 
pycompile
 :

237 with 
captured_stdout
 ( ) as 
stdout
 :

238 with 
warnings
 . 
catch_warnings
 ( ) :

239 
warnings
 . 
filterwarnings
 ( 'ignore' )

240 
compileall
 . 
compile_dir
 ( 
source
 , 
force
 = True , 
quiet
 = True )

241 
logger
 . 
debug
 ( 
stdout
 . 
getvalue
 ( ) )

243 def 
normpath
 ( 
src
 , 
p
 ) :

244 return 
os
 . 
path
 . 
relpath
 ( 
src
 , 
p
 ) . 
replace
 ( 
os
 . 
path
 . 
sep
 , '/' )

246 def 
record_installed
 ( 
srcfile
 , 
destfile
 , 
modified
 = False ) :

248 
oldpath
 = 
normpath
 ( 
srcfile
 , 
wheeldir
 )

249 
newpath
 = 
normpath
 ( 
destfile
 , 
lib_dir
 )

250 
installed
 [ 
oldpath
 ] = 
newpath

251 if 
modified
 :

252 
changed
 . 
add
 ( 
destfile
 )

254 def 
clobber
 ( 
source
 , 
dest
 , 
is_base
 , 
fixer
 = None , 
filter
 = None ) :

255 
ensure_dir
 ( 
dest
 )

257 for 
dir
 , 
subdirs
 , 
files
 in 
os
 . 
walk
 ( 
source
 ) :

258 
basedir
 = 
dir
 [ 
len
 ( 
source
 ) : ] . 
lstrip
 ( 
os
 . 
path
 . 
sep
 )

259 
destdir
 = 
os
 . 
path
 . 
join
 ( 
dest
 , 
basedir
 )

260 if 
is_base
 and 
basedir
 . 
split
 ( 
os
 . 
path
 . 
sep
 , 1 ) [ 0 ] . 
endswith
 ( '.data' ) :

262 for 
s
 in 
subdirs
 :

263 
destsubdir
 = 
os
 . 
path
 . 
join
 ( 
dest
 , 
basedir
 , 
s
 )

264 if 
is_base
 and 
basedir
 == '' and 
destsubdir
 . 
endswith
 ( '.data' ) :

265 
data_dirs
 . 
append
 ( 
s
 )

267 elif ( 
is_base
 and

268 
s
 . 
endswith
 ( '.dist-info' ) and

269 
canonicalize_name
 ( 
s
 ) . 
startswith
 (

270 
canonicalize_name
 ( 
req
 . 
name
 ) ) ) :

271 assert not 
info_dir
 , ( 'Multiple .dist-info directories: ' +

272 
destsubdir
 + ', ' + ', '

273 . 
join
 ( 
info_dir
 ) )

274 
info_dir
 . 
append
 ( 
destsubdir
 )

275 for 
f
 in 
files
 :

277 if 
filter
 and 
filter
 ( 
f
 ) :

279 
srcfile
 = 
os
 . 
path
 . 
join
 ( 
dir
 , 
f
 )

280 
destfile
 = 
os
 . 
path
 . 
join
 ( 
dest
 , 
basedir
 , 
f
 )

284 
ensure_dir
 ( 
destdir
 )

294 if 
os
 . 
path
 . 
exists
 ( 
destfile
 ) :

295 
os
 . 
unlink
 ( 
destfile
 )

302 
shutil
 . 
copyfile
 ( 
srcfile
 , 
destfile
 )

306 
st
 = 
os
 . 
stat
 ( 
srcfile
 )

307 if 
hasattr
 ( 
os
 , "utime" ) :

308 
os
 . 
utime
 ( 
destfile
 , ( 
st
 . 
st_atime
 , 
st
 . 
st_mtime
 ) )

312 if 
os
 . 
access
 ( 
srcfile
 , 
os
 . 
X_OK
 ) :

313 
st
 = 
os
 . 
stat
 ( 
srcfile
 )

314 
permissions
 = (

315 
st
 . 
st_mode
 | 
stat
 . 
S_IXUSR
 | 
stat
 . 
S_IXGRP
 | 
stat
 . 
S_IXOTH

317 
os
 . 
chmod
 ( 
destfile
 , 
permissions
 )

319 
changed
 = False

320 if 
fixer
 :

321 
changed
 = 
fixer
 ( 
destfile
 )

322 
record_installed
 ( 
srcfile
 , 
destfile
 , 
changed
 )

324 
clobber
 ( 
source
 , 
lib_dir
 , True )

326 assert 
info_dir
 , "%s .dist-info directory not found" % 
req

329 
ep_file
 = 
os
 . 
path
 . 
join
 ( 
info_dir
 [ 0 ] , 'entry_points.txt' )

330 
console
 , 
gui
 = 
get_entrypoints
 ( 
ep_file
 )

332 def 
is_entrypoint_wrapper
 ( 
name
 ) :

335 if 
name
 . 
lower
 ( ) . 
endswith
 ( '.exe' ) :

336 
matchname
 = 
name
 [ : - 4 ]

337 elif 
name
 . 
lower
 ( ) . 
endswith
 ( '-script.py' ) :

338 
matchname
 = 
name
 [ : - 10 ]

339 elif 
name
 . 
lower
 ( ) . 
endswith
 ( ".pya" ) :

340 
matchname
 = 
name
 [ : - 4 ]

342 
matchname
 = 
name

344 return ( 
matchname
 in 
console
 or 
matchname
 in 
gui
 )

346 for 
datadir
 in 
data_dirs
 :

347 
fixer
 = None

348 
filter
 = None

349 for 
subdir
 in 
os
 . 
listdir
 ( 
os
 . 
path
 . 
join
 ( 
wheeldir
 , 
datadir
 ) ) :

350 
fixer
 = None

351 if 
subdir
 == 'scripts' :

352 
fixer
 = 
fix_script

353 
filter
 = 
is_entrypoint_wrapper

354 
source
 = 
os
 . 
path
 . 
join
 ( 
wheeldir
 , 
datadir
 , 
subdir
 )

355 
dest
 = 
scheme
 [ 
subdir
 ]

356 
clobber
 ( 
source
 , 
dest
 , False , 
fixer
 = 
fixer
 , 
filter
 = 
filter
 )

358 
maker
 = 
ScriptMaker
 ( None , 
scheme
 [ 'scripts' ] )

362 
maker
 . 
clobber
 = True

367 
maker
 . 
variants
 = { '' }

372 
maker
 . 
set_mode
 = True

378 def 
_get_script_text
 ( 
entry
 ) :

379 if 
entry
 . 
suffix
 is None :

380 raise 
InstallationError
 ( "Invalid script entry point: %s for req: %s - A callable " "suffix is required. Cf https://packaging.python.org/en/" "latest/distributing.html#console-scripts for more " "information."

384 % ( 
entry
 , 
req
 )

386 return 
maker
 . 
script_template
 % { "module"

387 : 
entry
 . 
prefix
 , "import_name"

388 : 
entry
 . 
suffix
 . 
split
 ( "." ) [ 0 ] , "func"

389 : 
entry
 . 
suffix
 ,

392 
maker
 . 
_get_script_text
 = 
_get_script_text

393 
maker
 . 
script_template
 = r"""# -*- coding: utf-8 -*-\nimport re\nimport sys\n\nfrom %(module)s import %(import_name)s\n\nif __name__ == '__main__':\n    sys.argv[0] = re.sub(r'(-script\.pyw?|\.exe)?$', '', sys.argv[0])\n    sys.exit(%(func)s())\n"""

437 
pip_script
 = 
console
 . 
pop
 ( 'pip' , None )

438 if 
pip_script
 :

439 if "ENSUREPIP_OPTIONS" not in 
os
 . 
environ
 :

440 
spec
 = 'pip = ' + 
pip_script

441 
generated
 . 
extend
 ( 
maker
 . 
make
 ( 
spec
 ) )

443 if 
os
 . 
environ
 . 
get
 ( "ENSUREPIP_OPTIONS" , "" ) != "altinstall" :

444 
spec
 = 'pip%s = %s' % ( 
sys
 . 
version
 [ : 1 ] , 
pip_script
 )

445 
generated
 . 
extend
 ( 
maker
 . 
make
 ( 
spec
 ) )

447 
spec
 = 'pip%s = %s' % ( 
sys
 . 
version
 [ : 3 ] , 
pip_script
 )

448 
generated
 . 
extend
 ( 
maker
 . 
make
 ( 
spec
 ) )

450 
pip_ep
 = [ 
k
 for 
k
 in 
console
 if 
re
 . 
match
 ( r'pip(\d(\.\d)?)?$' , 
k
 ) ]

451 for 
k
 in 
pip_ep
 :

452 del 
console
 [ 
k
 ]

453 
easy_install_script
 = 
console
 . 
pop
 ( 'easy_install' , None )

454 if 
easy_install_script
 :

455 if "ENSUREPIP_OPTIONS" not in 
os
 . 
environ
 :

456 
spec
 = 'easy_install = ' + 
easy_install_script

457 
generated
 . 
extend
 ( 
maker
 . 
make
 ( 
spec
 ) )

459 
spec
 = 'easy_install-%s = %s' % ( 
sys
 . 
version
 [ : 3 ] , 
easy_install_script
 )

460 
generated
 . 
extend
 ( 
maker
 . 
make
 ( 
spec
 ) )

462 
easy_install_ep
 = [

463 
k
 for 
k
 in 
console
 if 
re
 . 
match
 ( r'easy_install(-\d\.\d)?$' , 
k
 )

465 for 
k
 in 
easy_install_ep
 :

466 del 
console
 [ 
k
 ]

469 if 
len
 ( 
console
 ) > 0 :

470 
generated_console_scripts
 = 
maker
 . 
make_multiple
 (

471 [ '%s = %s' % 
kv
 for 
kv
 in 
console
 . 
items
 ( ) ]

473 
generated
 . 
extend
 ( 
generated_console_scripts
 )

475 if 
warn_script_location
 :

476 
msg
 = 
message_about_scripts_not_on_PATH
 ( 
generated_console_scripts
 )

477 if 
msg
 is not None :

478 
logger
 . 
warning
 ( 
msg
 )

480 if 
len
 ( 
gui
 ) > 0 :

481 
generated
 . 
extend
 (

482 
maker
 . 
make_multiple
 (

483 [ '%s = %s' % 
kv
 for 
kv
 in 
gui
 . 
items
 ( ) ] ,

489 
installer
 = 
os
 . 
path
 . 
join
 ( 
info_dir
 [ 0 ] , 'INSTALLER' )

490 
temp_installer
 = 
os
 . 
path
 . 
join
 ( 
info_dir
 [ 0 ] , 'INSTALLER.pip' )

491 with 
open
 ( 
temp_installer
 , 'wb' ) as 
installer_file
 :

492 
installer_file
 . 
write
 ( b'pip\n' )

493 
shutil
 . 
move
 ( 
temp_installer
 , 
installer
 )

494 
generated
 . 
append
 ( 
installer
 )

497 
record
 = 
os
 . 
path
 . 
join
 ( 
info_dir
 [ 0 ] , 'RECORD' )

498 
temp_record
 = 
os
 . 
path
 . 
join
 ( 
info_dir
 [ 0 ] , 'RECORD.pip' )

499 with 
open_for_csv
 ( 
record
 , 'r' ) as 
record_in
 :

500 with 
open_for_csv
 ( 
temp_record
 , 'w+' ) as 
record_out
 :

501 
reader
 = 
csv
 . 
reader
 ( 
record_in
 )

502 
writer
 = 
csv
 . 
writer
 ( 
record_out
 )

503 
outrows
 = [ ]

504 for 
row
 in 
reader
 :

505 
row
 [ 0 ] = 
installed
 . 
pop
 ( 
row
 [ 0 ] , 
row
 [ 0 ] )

506 if 
row
 [ 0 ] in 
changed
 :

507 
row
 [ 1 ] , 
row
 [ 2 ] = 
rehash
 ( 
row
 [ 0 ] )

508 
outrows
 . 
append
 ( 
tuple
 ( 
row
 ) )

509 for 
f
 in 
generated
 :

510 
digest
 , 
length
 = 
rehash
 ( 
f
 )

511 
outrows
 . 
append
 ( ( 
normpath
 ( 
f
 , 
lib_dir
 ) , 
digest
 , 
length
 ) )

512 for 
f
 in 
installed
 :

513 
outrows
 . 
append
 ( ( 
installed
 [ 
f
 ] , '' , '' ) )

514 for 
row
 in 
sorted
 ( 
outrows
 ) :

515 
writer
 . 
writerow
 ( 
row
 )

516 
shutil
 . 
move
 ( 
temp_record
 , 
record
 ) 
	}

519 def 
	$wheel_version
 ( 
source_dir
 ) :

526 
dist
 = [ 
d
 for 
d
 in 
pkg_resources
 . 
find_on_path
 ( None , 
source_dir
 ) ] [ 0 ]

528 
wheel_data
 = 
dist
 . 
get_metadata
 ( 'WHEEL' )

529 
wheel_data
 = 
Parser
 ( ) . 
parsestr
 ( 
wheel_data
 )

531 
version
 = 
wheel_data
 [ 'Wheel-Version' ] . 
strip
 ( )

532 
version
 = 
tuple
 ( 
map
 ( 
int
 , 
version
 . 
split
 ( '.' ) ) )

533 return 
version

534 except 
Exception
 :

535 return False 
	}

538 def 
	$check_compatibility
 ( 
version
 , 
name
 ) :

551 if not 
version
 :

552 raise 
UnsupportedWheel
 ( "%s is in an unsupported or invalid wheel"

553 % 
name

555 if 
version
 [ 0 ] > 
VERSION_COMPATIBLE
 [ 0 ] :

556 raise 
UnsupportedWheel
 ( "%s's Wheel-Version (%s) is not compatible with this version " "of pip"

558 % ( 
name
 , '.' . 
join
 ( 
map
 ( 
str
 , 
version
 ) ) )

560 elif 
version
 > 
VERSION_COMPATIBLE
 :

561 
logger
 . 
warning
 ( 'Installing from a newer Wheel-Version (%s)'

563 . 
join
 ( 
map
 ( 
str
 , 
version
 ) ) ,

564 ) 
	}

567 class 
	cWheel
 ( 
object
 ) :

572 
wheel_file_re
 = 
re
 . 
compile
 ( r"""^(?P<namever>(?P<name>.+?)-(?P<ver>.*?))\n        ((-(?P<build>\d[^-]*?))?-(?P<pyver>.+?)-(?P<abi>.+?)-(?P<plat>.+?)\n        \.whl|\.dist-info)$"""

576 
re
 . 
VERBOSE

579 def 
	$__init__
 ( 
self
 , 
filename
 ) :

583 
wheel_info
 = 
self
 . 
wheel_file_re
 . 
match
 ( 
filename
 )

584 if not 
wheel_info
 :

585 raise 
InvalidWheelFilename
 ( "%s is not a valid wheel filename."

586 % 
filename

588 
self
 . 
filename
 = 
filename

589 
self
 . 
name
 = 
wheel_info
 . 
group
 ( 'name' ) . 
replace
 ( '_' , '-' )

592 
self
 . 
version
 = 
wheel_info
 . 
group
 ( 'ver' ) . 
replace
 ( '_' , '-' )

593 
self
 . 
build_tag
 = 
wheel_info
 . 
group
 ( 'build' )

594 
self
 . 
pyversions
 = 
wheel_info
 . 
group
 ( 'pyver' ) . 
split
 ( '.' )

595 
self
 . 
abis
 = 
wheel_info
 . 
group
 ( 'abi' ) . 
split
 ( '.' )

596 
self
 . 
plats
 = 
wheel_info
 . 
group
 ( 'plat' ) . 
split
 ( '.' )

599 
self
 . 
file_tags
 = {

600 ( 
x
 , 
y
 , 
z
 ) for 
x
 in 
self
 . 
pyversions

601 for 
y
 in 
self
 . 
abis
 for 
z
 in 
self
 . 
plats

602 } 
	}

604 def 
	$support_index_min
 ( 
self
 , 
tags
 = None ) :

611 if 
tags
 is None :

612 
tags
 = 
pep425tags
 . 
get_supported
 ( )

613 
indexes
 = [ 
tags
 . 
index
 ( 
c
 ) for 
c
 in 
self
 . 
file_tags
 if 
c
 in 
tags
 ]

614 return 
min
 ( 
indexes
 ) if 
indexes
 else None 
	}

616 def 
	$supported
 ( 
self
 , 
tags
 = None ) :

618 if 
tags
 is None :

619 
tags
 = 
pep425tags
 . 
get_supported
 ( )

620 return 
bool
 ( 
set
 ( 
tags
 ) . 
intersection
 ( 
self
 . 
file_tags
 ) ) 
	}

623 class 
	cWheelBuilder
 ( 
object
 ) :

626 def 
	$__init__
 ( 
self
 , 
finder
 , 
preparer
 , 
wheel_cache
 ,

627 
build_options
 = None , 
global_options
 = None , 
no_clean
 = False ) :

628 
self
 . 
finder
 = 
finder

629 
self
 . 
preparer
 = 
preparer

630 
self
 . 
wheel_cache
 = 
wheel_cache

632 
self
 . 
_wheel_dir
 = 
preparer
 . 
wheel_download_dir

634 
self
 . 
build_options
 = 
build_options
 or [ ]

635 
self
 . 
global_options
 = 
global_options
 or [ ]

636 
self
 . 
no_clean
 = 
no_clean
 
	}

638 def 
	$_build_one
 ( 
self
 , 
req
 , 
output_dir
 , 
python_tag
 = None ) :

644 with 
req
 . 
build_env
 :

645 return 
self
 . 
_build_one_inside_env
 ( 
req
 , 
output_dir
 ,

646 
python_tag
 = 
python_tag
 ) 
	}

648 def 
	$_build_one_inside_env
 ( 
self
 , 
req
 , 
output_dir
 , 
python_tag
 = None ) :

649 with 
TempDirectory
 ( 
kind
 = "wheel" ) as 
temp_dir
 :

650 if 
self
 . 
__build_one
 ( 
req
 , 
temp_dir
 . 
path
 , 
python_tag
 = 
python_tag
 ) :

652 
wheel_name
 = 
os
 . 
listdir
 ( 
temp_dir
 . 
path
 ) [ 0 ]

653 
wheel_path
 = 
os
 . 
path
 . 
join
 ( 
output_dir
 , 
wheel_name
 )

654 
shutil
 . 
move
 (

655 
os
 . 
path
 . 
join
 ( 
temp_dir
 . 
path
 , 
wheel_name
 ) , 
wheel_path

657 
logger
 . 
info
 ( 'Stored in directory: %s' , 
output_dir
 )

658 return 
wheel_path

659 except 
Exception
 :

662 
self
 . 
_clean_one
 ( 
req
 )

663 return None 
	}

665 def 
	$_base_setup_args
 ( 
self
 , 
req
 ) :

671 
sys
 . 
executable
 , '-u' , '-c' ,

672 
SETUPTOOLS_SHIM
 % 
req
 . 
setup_py

673 ] + 
list
 ( 
self
 . 
global_options
 ) 
	}

675 def 
	$__build_one
 ( 
self
 , 
req
 , 
tempd
 , 
python_tag
 = None ) :

676 
base_args
 = 
self
 . 
_base_setup_args
 ( 
req
 )

678 
spin_message
 = 'Running setup.py bdist_wheel for %s' % ( 
req
 . 
name
 , )

679 with 
open_spinner
 ( 
spin_message
 ) as 
spinner
 :

680 
logger
 . 
debug
 ( 'Destination directory: %s' , 
tempd
 )

681 
wheel_args
 = 
base_args
 + [ 'bdist_wheel' , '-d' , 
tempd
 ]

682 + 
self
 . 
build_options

684 if 
python_tag
 is not None :

685 
wheel_args
 += [ "--python-tag" , 
python_tag
 ]

688 
call_subprocess
 ( 
wheel_args
 , 
cwd
 = 
req
 . 
setup_py_dir
 ,

689 
show_stdout
 = False , 
spinner
 = 
spinner
 )

691 except 
Exception
 :

692 
spinner
 . 
finish
 ( "error" )

693 
logger
 . 
error
 ( 'Failed building wheel for %s' , 
req
 . 
name
 )

694 return False 
	}

696 def 
	$_clean_one
 ( 
self
 , 
req
 ) :

697 
base_args
 = 
self
 . 
_base_setup_args
 ( 
req
 )

699 
logger
 . 
info
 ( 'Running setup.py clean for %s' , 
req
 . 
name
 )

700 
clean_args
 = 
base_args
 + [ 'clean' , '--all' ]

702 
call_subprocess
 ( 
clean_args
 , 
cwd
 = 
req
 . 
source_dir
 , 
show_stdout
 = False )

704 except 
Exception
 :

705 
logger
 . 
error
 ( 'Failed cleaning build dir for %s' , 
req
 . 
name
 )

706 return False 
	}

708 def 
	$build
 ( 
self
 , 
requirements
 , 
session
 , 
autobuilding
 = False ) :

715 from 
	~pip._internal
 import 
index

716 from 
	~pip._internal.models.link
 import 
Link

718 
building_is_possible
 = 
self
 . 
_wheel_dir
 or (

719 
autobuilding
 and 
self
 . 
wheel_cache
 . 
cache_dir

721 assert 
building_is_possible

723 
buildset
 = [ ]

724 
format_control
 = 
self
 . 
finder
 . 
format_control

725 for 
req
 in 
requirements
 :

726 if 
req
 . 
constraint
 :

728 if 
req
 . 
is_wheel
 :

729 if not 
autobuilding
 :

730 
logger
 . 
info
 ( 'Skipping %s, due to already being wheel.'

731 , 
req
 . 
name
 ,

733 elif 
autobuilding
 and 
req
 . 
editable
 :

735 elif 
autobuilding
 and not 
req
 . 
source_dir
 :

737 elif 
autobuilding
 and 
req
 . 
link
 and not 
req
 . 
link
 . 
is_artifact
 :

739 
buildset
 . 
append
 ( ( 
req
 , True ) )

741 
ephem_cache
 = False

742 if 
autobuilding
 :

743 
link
 = 
req
 . 
link

744 
base
 , 
ext
 = 
link
 . 
splitext
 ( )

745 if 
index
 . 
egg_info_matches
 ( 
base
 , None , 
link
 ) is None :

747 
ephem_cache
 = True

748 if "binary" not in 
format_control
 . 
get_allowed_formats
 (

749 
canonicalize_name
 ( 
req
 . 
name
 ) ) :

750 
logger
 . 
info
 ( "Skipping bdist_wheel for %s, due to binaries " "being disabled for it."

752 , 
req
 . 
name
 ,

755 
buildset
 . 
append
 ( ( 
req
 , 
ephem_cache
 ) )

757 if not 
buildset
 :

761 
logger
 . 
info
 ( 'Building wheels for collected packages: %s'

763 . 
join
 ( [ 
req
 . 
name
 for ( 
req
 , 
_
 ) in 
buildset
 ] ) ,

765 
_cache
 = 
self
 . 
wheel_cache

766 with 
indent_log
 ( ) :

767 
build_success
 , 
build_failure
 = [ ] , [ ]

768 for 
req
 , 
ephem
 in 
buildset
 :

769 
python_tag
 = None

770 if 
autobuilding
 :

771 
python_tag
 = 
pep425tags
 . 
implementation_tag

772 if 
ephem
 :

773 
output_dir
 = 
_cache
 . 
get_ephem_path_for_link
 ( 
req
 . 
link
 )

775 
output_dir
 = 
_cache
 . 
get_path_for_link
 ( 
req
 . 
link
 )

777 
ensure_dir
 ( 
output_dir
 )

778 except 
OSError
 as 
e
 :

779 
logger
 . 
warning
 ( "Building wheel for %s failed: %s" ,

780 
req
 . 
name
 , 
e
 )

781 
build_failure
 . 
append
 ( 
req
 )

784 
output_dir
 = 
self
 . 
_wheel_dir

785 
wheel_file
 = 
self
 . 
_build_one
 (

786 
req
 , 
output_dir
 ,

787 
python_tag
 = 
python_tag
 ,

789 if 
wheel_file
 :

790 
build_success
 . 
append
 ( 
req
 )

791 if 
autobuilding
 :

797 if 
req
 . 
source_dir
 and not 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 (

798 
req
 . 
source_dir
 , 
PIP_DELETE_MARKER_FILENAME
 ) ) :

799 raise 
AssertionError
 ( "bad source dir - missing marker"

802 
req
 . 
remove_temporary_source
 ( )

805 
req
 . 
source_dir
 = 
req
 . 
build_location
 (

806 
self
 . 
preparer
 . 
build_dir

809 
req
 . 
link
 = 
Link
 ( 
path_to_url
 ( 
wheel_file
 ) )

810 assert 
req
 . 
link
 . 
is_wheel

812 
unpack_url
 (

813 
req
 . 
link
 , 
req
 . 
source_dir
 , None , False ,

814 
session
 = 
session
 ,

817 
build_failure
 . 
append
 ( 
req
 )

820 if 
build_success
 :

821 
logger
 . 
info
 ( 'Successfully built %s'

823 . 
join
 ( [ 
req
 . 
name
 for 
req
 in 
build_success
 ] ) ,

825 if 
build_failure
 :

826 
logger
 . 
info
 ( 'Failed to build %s'

828 . 
join
 ( [ 
req
 . 
name
 for 
req
 in 
build_failure
 ] ) ,

831 return 
len
 ( 
build_failure
 ) == 0 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/completion.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~sys

4 import 
	~textwrap

6 from 
	~pip._internal.cli.base_command
 import 
Command

7 from 
	~pip._internal.utils.misc
 import 
get_prog

9 
BASE_COMPLETION
 = """\n# pip %(shell)s completion start%(script)s# pip %(shell)s completion end\n"""

13 
COMPLETION_SCRIPTS
 = { 'bash'

48 class 
	cCompletionCommand
 ( 
Command
 ) :

50 
name
 = 'completion'

51 
summary
 = 'A helper command used for command completion.'

52 
ignore_require_venv
 = True

54 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

55 
super
 ( 
CompletionCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

57 
cmd_opts
 = 
self
 . 
cmd_opts

59 
cmd_opts
 . 
add_option
 ( '--bash'

61 
action
 = 'store_const' ,

62 
const
 = 'bash' ,

63 
dest
 = 'shell' ,

64 
help
 = 'Emit completion code for bash' )

65 
cmd_opts
 . 
add_option
 ( '--zsh'

67 
action
 = 'store_const' ,

68 
const
 = 'zsh' ,

69 
dest
 = 'shell' ,

70 
help
 = 'Emit completion code for zsh' )

71 
cmd_opts
 . 
add_option
 ( '--fish'

73 
action
 = 'store_const' ,

74 
const
 = 'fish' ,

75 
dest
 = 'shell' ,

76 
help
 = 'Emit completion code for fish' )

78 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
cmd_opts
 ) 
	}

80 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

82 
shells
 = 
COMPLETION_SCRIPTS
 . 
keys
 ( )

83 
shell_options
 = [ '--' + 
shell
 for 
shell
 in 
sorted
 ( 
shells
 ) ]

84 if 
options
 . 
shell
 in 
shells
 :

85 
script
 = 
textwrap
 . 
dedent
 (

86 
COMPLETION_SCRIPTS
 . 
get
 ( 
options
 . 
shell
 , '' ) % { 'prog'

87 : 
get_prog
 ( ) ,

90 
print
 ( 
BASE_COMPLETION
 % { 'script' : 
script
 , 'shell' : 
options
 . 
shell
 } )

92 
sys
 . 
stderr
 . 
write
 ( 'ERROR: You must pass %s\n'

93 % ' or ' . 
join
 ( 
shell_options
 )

94 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/help.py

1 from 
	~__future__
 import 
absolute_import

3 from 
	~pip._internal.cli.base_command
 import 
Command

4 from 
	~pip._internal.cli.status_codes
 import 
SUCCESS

5 from 
	~pip._internal.exceptions
 import 
CommandError

8 class 
	cHelpCommand
 ( 
Command
 ) :

10 
name
 = 'help'

11 
usage
 = """\n      %prog <command>"""

13 
summary
 = 'Show help for commands.'

14 
ignore_require_venv
 = True

16 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

17 from 
	~pip._internal.commands
 import 
commands_dict
 , 
get_similar_commands

21 
cmd_name
 = 
args
 [ 0 ]

22 except 
IndexError
 :

23 return 
SUCCESS

25 if 
cmd_name
 not in 
commands_dict
 :

26 
guess
 = 
get_similar_commands
 ( 
cmd_name
 )

28 
msg
 = [ 'unknown command "%s"' % 
cmd_name
 ]

29 if 
guess
 :

30 
msg
 . 
append
 ( 'maybe you meant "%s"' % 
guess
 )

32 raise 
CommandError
 ( ' - ' . 
join
 ( 
msg
 ) )

34 
command
 = 
commands_dict
 [ 
cmd_name
 ] ( )

35 
command
 . 
parser
 . 
print_help
 ( )

37 return 
SUCCESS
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/show.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

5 from 
	~email.parser
 import 
FeedParser

7 from 
	~pip._vendor
 import 
pkg_resources

8 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

10 from 
	~pip._internal.cli.base_command
 import 
Command

11 from 
	~pip._internal.cli.status_codes
 import 
ERROR
 , 
SUCCESS

13 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

16 class 
	cShowCommand
 ( 
Command
 ) :

22 
name
 = 'show'

23 
usage
 = """\n      %prog [options] <package> ..."""

25 
summary
 = 'Show information about installed packages.'

26 
ignore_require_venv
 = True

28 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

29 
super
 ( 
ShowCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

30 
self
 . 
cmd_opts
 . 
add_option
 ( '-f'

32 
dest
 = 'files' ,

33 
action
 = 'store_true' ,

34 
default
 = False ,

35 
help
 = 'Show the full list of installed files for each package.' )

37 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

39 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

40 if not 
args
 :

41 
logger
 . 
warning
 ( 'ERROR: Please provide a package name or names.' )

42 return 
ERROR

43 
query
 = 
args

45 
results
 = 
search_packages_info
 ( 
query
 )

46 if not 
print_results
 (

47 
results
 , 
list_files
 = 
options
 . 
files
 , 
verbose
 = 
options
 . 
verbose
 ) :

48 return 
ERROR

49 return 
SUCCESS
 
	}

52 def 
	$search_packages_info
 ( 
query
 ) :

59 
installed
 = { }

60 for 
p
 in 
pkg_resources
 . 
working_set
 :

61 
installed
 [ 
canonicalize_name
 ( 
p
 . 
project_name
 ) ] = 
p

63 
query_names
 = [ 
canonicalize_name
 ( 
name
 ) for 
name
 in 
query
 ]

65 for 
dist
 in [ 
installed
 [ 
pkg
 ] for 
pkg
 in 
query_names
 if 
pkg
 in 
installed
 ] :

66 
package
 = { 'name'

67 : 
dist
 . 
project_name
 , 'version'

68 : 
dist
 . 
version
 , 'location'

69 : 
dist
 . 
location
 , 'requires'

70 : [ 
dep
 . 
project_name
 for 
dep
 in 
dist
 . 
requires
 ( ) ] ,

72 
file_list
 = None

73 
metadata
 = None

74 if 
isinstance
 ( 
dist
 , 
pkg_resources
 . 
DistInfoDistribution
 ) :

76 if 
dist
 . 
has_metadata
 ( 'RECORD' ) :

77 
lines
 = 
dist
 . 
get_metadata_lines
 ( 'RECORD' )

78 
paths
 = [ 
l
 . 
split
 ( ',' ) [ 0 ] for 
l
 in 
lines
 ]

79 
paths
 = [ 
os
 . 
path
 . 
join
 ( 
dist
 . 
location
 , 
p
 ) for 
p
 in 
paths
 ]

80 
file_list
 = [ 
os
 . 
path
 . 
relpath
 ( 
p
 , 
dist
 . 
location
 ) for 
p
 in 
paths
 ]

82 if 
dist
 . 
has_metadata
 ( 'METADATA' ) :

83 
metadata
 = 
dist
 . 
get_metadata
 ( 'METADATA' )

86 if 
dist
 . 
has_metadata
 ( 'installed-files.txt' ) :

87 
paths
 = 
dist
 . 
get_metadata_lines
 ( 'installed-files.txt' )

88 
paths
 = [ 
os
 . 
path
 . 
join
 ( 
dist
 . 
egg_info
 , 
p
 ) for 
p
 in 
paths
 ]

89 
file_list
 = [ 
os
 . 
path
 . 
relpath
 ( 
p
 , 
dist
 . 
location
 ) for 
p
 in 
paths
 ]

91 if 
dist
 . 
has_metadata
 ( 'PKG-INFO' ) :

92 
metadata
 = 
dist
 . 
get_metadata
 ( 'PKG-INFO' )

94 if 
dist
 . 
has_metadata
 ( 'entry_points.txt' ) :

95 
entry_points
 = 
dist
 . 
get_metadata_lines
 ( 'entry_points.txt' )

96 
package
 [ 'entry_points' ] = 
entry_points

98 if 
dist
 . 
has_metadata
 ( 'INSTALLER' ) :

99 for 
line
 in 
dist
 . 
get_metadata_lines
 ( 'INSTALLER' ) :

100 if 
line
 . 
strip
 ( ) :

101 
package
 [ 'installer' ] = 
line
 . 
strip
 ( )

106 
feed_parser
 = 
FeedParser
 ( )

107 
feed_parser
 . 
feed
 ( 
metadata
 )

108 
pkg_info_dict
 = 
feed_parser
 . 
close
 ( )

109 for 
key
 in ( 'metadata-version' , 'summary' , 'home-page'

111 
package
 [ 
key
 ] = 
pkg_info_dict
 . 
get
 ( 
key
 )

114 
classifiers
 = [ ]

115 for 
line
 in 
metadata
 . 
splitlines
 ( ) :

116 if 
line
 . 
startswith
 ( 'Classifier: ' ) :

117 
classifiers
 . 
append
 ( 
line
 [ 
len
 ( 'Classifier: ' ) : ] )

118 
package
 [ 'classifiers' ] = 
classifiers

120 if 
file_list
 :

121 
package
 [ 'files' ] = 
sorted
 ( 
file_list
 )

122 yield 
package
 
	}

125 def 
	$print_results
 ( 
distributions
 , 
list_files
 = False , 
verbose
 = False ) :

129 
results_printed
 = False

130 for 
i
 , 
dist
 in 
enumerate
 ( 
distributions
 ) :

131 
results_printed
 = True

132 if 
i
 > 0 :

133 
logger
 . 
info
 ( "---" )

135 
name
 = 
dist
 . 
get
 ( 'name' , '' )

136 
required_by
 = [

137 
pkg
 . 
project_name
 for 
pkg
 in 
pkg_resources
 . 
working_set

138 if 
name
 in [ 
required
 . 
name
 for 
required
 in 
pkg
 . 
requires
 ( ) ]

141 
logger
 . 
info
 ( "Name: %s" , 
name
 )

142 
logger
 . 
info
 ( "Version: %s" , 
dist
 . 
get
 ( 'version' , '' ) )

143 
logger
 . 
info
 ( "Summary: %s" , 
dist
 . 
get
 ( 'summary' , '' ) )

144 
logger
 . 
info
 ( "Home-page: %s" , 
dist
 . 
get
 ( 'home-page' , '' ) )

145 
logger
 . 
info
 ( "Author: %s" , 
dist
 . 
get
 ( 'author' , '' ) )

146 
logger
 . 
info
 ( "Author-email: %s" , 
dist
 . 
get
 ( 'author-email' , '' ) )

147 
logger
 . 
info
 ( "License: %s" , 
dist
 . 
get
 ( 'license' , '' ) )

148 
logger
 . 
info
 ( "Location: %s" , 
dist
 . 
get
 ( 'location' , '' ) )

149 
logger
 . 
info
 ( "Requires: %s" , ', ' . 
join
 ( 
dist
 . 
get
 ( 'requires' , [ ] ) ) )

150 
logger
 . 
info
 ( "Required-by: %s" , ', ' . 
join
 ( 
required_by
 ) )

152 if 
verbose
 :

153 
logger
 . 
info
 ( "Metadata-Version: %s" ,

154 
dist
 . 
get
 ( 'metadata-version' , '' ) )

155 
logger
 . 
info
 ( "Installer: %s" , 
dist
 . 
get
 ( 'installer' , '' ) )

156 
logger
 . 
info
 ( "Classifiers:" )

157 for 
classifier
 in 
dist
 . 
get
 ( 'classifiers' , [ ] ) :

158 
logger
 . 
info
 ( "  %s" , 
classifier
 )

159 
logger
 . 
info
 ( "Entry-points:" )

160 for 
entry
 in 
dist
 . 
get
 ( 'entry_points' , [ ] ) :

161 
logger
 . 
info
 ( "  %s" , 
entry
 . 
strip
 ( ) )

162 if 
list_files
 :

163 
logger
 . 
info
 ( "Files:" )

164 for 
line
 in 
dist
 . 
get
 ( 'files' , [ ] ) :

165 
logger
 . 
info
 ( "  %s" , 
line
 . 
strip
 ( ) )

166 if "files" not in 
dist
 :

167 
logger
 . 
info
 ( "Cannot locate installed-files.txt" )

168 return 
results_printed
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/wheel.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~logging

5 import 
	~os

7 from 
	~pip._internal.cache
 import 
WheelCache

8 from 
	~pip._internal.cli
 import 
cmdoptions

9 from 
	~pip._internal.cli.base_command
 import 
RequirementCommand

10 from 
	~pip._internal.exceptions
 import 
CommandError
 , 
PreviousBuildDirError

11 from 
	~pip._internal.operations.prepare
 import 
RequirementPreparer

12 from 
	~pip._internal.req
 import 
RequirementSet

13 from 
	~pip._internal.req.req_tracker
 import 
RequirementTracker

14 from 
	~pip._internal.resolve
 import 
Resolver

15 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

16 from 
	~pip._internal.wheel
 import 
WheelBuilder

18 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

21 class 
	cWheelCommand
 ( 
RequirementCommand
 ) :

36 
name
 = 'wheel'

37 
usage
 = """\n      %prog [options] <requirement specifier> ...\n      %prog [options] -r <requirements file> ...\n      %prog [options] [-e] <vcs project url> ...\n      %prog [options] [-e] <local project path> ...\n      %prog [options] <archive url/path> ..."""

44 
summary
 = 'Build wheels from your requirements.'

46 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

47 
super
 ( 
WheelCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

49 
cmd_opts
 = 
self
 . 
cmd_opts

51 
cmd_opts
 . 
add_option
 ( '-w'

53 
dest
 = 'wheel_dir' ,

54 
metavar
 = 'dir' ,

55 
default
 = 
os
 . 
curdir
 ,

56 
help
 = ( "Build wheels into <dir>, where the default is the " "current working directory."

59 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_binary
 ( ) )

60 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
only_binary
 ( ) )

61 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
prefer_binary
 ( ) )

62 
cmd_opts
 . 
add_option
 ( '--build-option'

64 
dest
 = 'build_options' ,

65 
metavar
 = 'options' ,

66 
action
 = 'append' ,

67 
help
 = "Extra arguments to be supplied to 'setup.py bdist_wheel'." ,

69 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_build_isolation
 ( ) )

70 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
constraints
 ( ) )

71 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
editable
 ( ) )

72 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
requirements
 ( ) )

73 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
src
 ( ) )

74 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
ignore_requires_python
 ( ) )

75 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_deps
 ( ) )

76 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
build_dir
 ( ) )

77 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
progress_bar
 ( ) )

79 
cmd_opts
 . 
add_option
 ( '--global-option'

81 
dest
 = 'global_options' ,

82 
action
 = 'append' ,

83 
metavar
 = 'options' ,

84 
help
 = "Extra global options to be supplied to the setup.py " "call before the 'bdist_wheel' command."

87 
cmd_opts
 . 
add_option
 ( '--pre'

89 
action
 = 'store_true' ,

90 
default
 = False ,

91 
help
 = ( "Include pre-release and development versions. By default, " "pip only finds stable versions."

95 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_clean
 ( ) )

96 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
require_hashes
 ( ) )

98 
index_opts
 = 
cmdoptions
 . 
make_option_group
 (

99 
cmdoptions
 . 
index_group
 ,

100 
self
 . 
parser
 ,

103 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
index_opts
 )

104 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
cmd_opts
 ) 
	}

106 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

107 
cmdoptions
 . 
check_install_build_global
 ( 
options
 )

109 
index_urls
 = [ 
options
 . 
index_url
 ] + 
options
 . 
extra_index_urls

110 if 
options
 . 
no_index
 :

111 
logger
 . 
debug
 ( 'Ignoring indexes: %s' , ',' . 
join
 ( 
index_urls
 ) )

112 
index_urls
 = [ ]

114 if 
options
 . 
build_dir
 :

115 
options
 . 
build_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
build_dir
 )

117 
options
 . 
src_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
src_dir
 )

119 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

120 
finder
 = 
self
 . 
_build_package_finder
 ( 
options
 , 
session
 )

121 
build_delete
 = ( not ( 
options
 . 
no_clean
 or 
options
 . 
build_dir
 ) )

122 
wheel_cache
 = 
WheelCache
 ( 
options
 . 
cache_dir
 , 
options
 . 
format_control
 )

124 with 
RequirementTracker
 ( ) as 
req_tracker
 , 
TempDirectory
 (

125 
options
 . 
build_dir
 , 
delete
 = 
build_delete
 , 
kind
 = "wheel"

126 ) as 
directory
 :

128 
requirement_set
 = 
RequirementSet
 (

129 
require_hashes
 = 
options
 . 
require_hashes
 ,

133 
self
 . 
populate_requirement_set
 (

134 
requirement_set
 , 
args
 , 
options
 , 
finder
 , 
session
 ,

135 
self
 . 
name
 , 
wheel_cache

138 
preparer
 = 
RequirementPreparer
 (

139 
build_dir
 = 
directory
 . 
path
 ,

140 
src_dir
 = 
options
 . 
src_dir
 ,

141 
download_dir
 = None ,

142 
wheel_download_dir
 = 
options
 . 
wheel_dir
 ,

143 
progress_bar
 = 
options
 . 
progress_bar
 ,

144 
build_isolation
 = 
options
 . 
build_isolation
 ,

145 
req_tracker
 = 
req_tracker
 ,

148 
resolver
 = 
Resolver
 (

149 
preparer
 = 
preparer
 ,

150 
finder
 = 
finder
 ,

151 
session
 = 
session
 ,

152 
wheel_cache
 = 
wheel_cache
 ,

153 
use_user_site
 = False ,

154 
upgrade_strategy
 = "to-satisfy-only" ,

155 
force_reinstall
 = False ,

156 
ignore_dependencies
 = 
options
 . 
ignore_dependencies
 ,

157 
ignore_requires_python
 = 
options
 . 
ignore_requires_python
 ,

158 
ignore_installed
 = True ,

159 
isolated
 = 
options
 . 
isolated_mode
 ,

161 
resolver
 . 
resolve
 ( 
requirement_set
 )

164 
wb
 = 
WheelBuilder
 (

165 
finder
 , 
preparer
 , 
wheel_cache
 ,

166 
build_options
 = 
options
 . 
build_options
 or [ ] ,

167 
global_options
 = 
options
 . 
global_options
 or [ ] ,

168 
no_clean
 = 
options
 . 
no_clean
 ,

170 
wheels_built_successfully
 = 
wb
 . 
build
 (

171 
requirement_set
 . 
requirements
 . 
values
 ( ) , 
session
 = 
session
 ,

173 if not 
wheels_built_successfully
 :

174 raise 
CommandError
 ( "Failed to build one or more wheels"

177 except 
PreviousBuildDirError
 :

178 
options
 . 
no_clean
 = True

181 if not 
options
 . 
no_clean
 :

182 
requirement_set
 . 
cleanup_files
 ( )

183 
wheel_cache
 . 
cleanup
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/install.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~errno

4 import 
	~logging

5 import 
	~operator

6 import 
	~os

7 import 
	~shutil

8 from 
	~optparse
 import 
SUPPRESS_HELP

10 from 
	~pip._vendor
 import 
pkg_resources

12 from 
	~pip._internal.cache
 import 
WheelCache

13 from 
	~pip._internal.cli
 import 
cmdoptions

14 from 
	~pip._internal.cli.base_command
 import 
RequirementCommand

15 from 
	~pip._internal.cli.status_codes
 import 
ERROR

16 from 
	~pip._internal.exceptions
 import (

17 
CommandError
 , 
InstallationError
 , 
PreviousBuildDirError
 ,

19 from 
	~pip._internal.locations
 import 
distutils_scheme
 , 
virtualenv_no_global

20 from 
	~pip._internal.operations.check
 import 
check_install_conflicts

21 from 
	~pip._internal.operations.prepare
 import 
RequirementPreparer

22 from 
	~pip._internal.req
 import 
RequirementSet
 , 
install_given_reqs

23 from 
	~pip._internal.req.req_tracker
 import 
RequirementTracker

24 from 
	~pip._internal.resolve
 import 
Resolver

25 from 
	~pip._internal.utils.filesystem
 import 
check_path_owner

26 from 
	~pip._internal.utils.misc
 import (

27 
ensure_dir
 , 
get_installed_version
 ,

28 
protect_pip_from_modification_on_windows
 ,

30 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

31 from 
	~pip._internal.wheel
 import 
WheelBuilder

34 import 
	~wheel

35 except 
ImportError
 :

36 
wheel
 = None

38 from 
	~pip._internal.locations
 import 
running_under_virtualenv

40 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

43 class 
	cInstallCommand
 ( 
RequirementCommand
 ) :

55 
name
 = 'install'

57 
usage
 = """\n      %prog [options] <requirement specifier> [package-index-options] ...\n      %prog [options] -r <requirements file> [package-index-options] ...\n      %prog [options] [-e] <vcs project url> ...\n      %prog [options] [-e] <local project path> ...\n      %prog [options] <archive url/path> ..."""

64 
summary
 = 'Install packages.'

66 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

67 
super
 ( 
InstallCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

69 
cmd_opts
 = 
self
 . 
cmd_opts

71 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
requirements
 ( ) )

72 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
constraints
 ( ) )

73 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_deps
 ( ) )

74 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
pre
 ( ) )

76 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
editable
 ( ) )

77 
cmd_opts
 . 
add_option
 ( '-t'

79 
dest
 = 'target_dir' ,

80 
metavar
 = 'dir' ,

81 
default
 = None ,

82 
help
 = 'Install packages into <dir>. ' 'By default this will not replace existing files/folders in ' '<dir>. Use --upgrade to replace existing packages in <dir> ' 'with new versions.'

87 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
platform
 ( ) )

88 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
python_version
 ( ) )

89 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
implementation
 ( ) )

90 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
abi
 ( ) )

92 
cmd_opts
 . 
add_option
 ( '--user'

94 
dest
 = 'use_user_site' ,

95 
action
 = 'store_true' ,

96 
help
 = "Install to the Python user install directory for your " "platform. Typically ~/.local/, or %APPDATA%\\Python on " "Windows. (See the Python documentation for site.USER_BASE " "for full details.)  On Debian systems, this is the " "default when running outside of a virtual environment " "and not as root."

103 
cmd_opts
 . 
add_option
 ( '--no-user'

105 
dest
 = 'use_system_location' ,

106 
action
 = 'store_true' ,

107 
help
 = 
SUPPRESS_HELP
 )

108 
cmd_opts
 . 
add_option
 ( '--root'

110 
dest
 = 'root_path' ,

111 
metavar
 = 'dir' ,

112 
default
 = None ,

113 
help
 = "Install everything relative to this alternate root " "directory."

115 
cmd_opts
 . 
add_option
 ( '--prefix'

117 
dest
 = 'prefix_path' ,

118 
metavar
 = 'dir' ,

119 
default
 = None ,

120 
help
 = "Installation prefix where lib, bin and other top-level " "folders are placed"

123 
cmd_opts
 . 
add_option
 ( '--system'

125 
dest
 = 'use_system_location' ,

126 
action
 = 'store_true' ,

127 
help
 = "Install using the system scheme (overrides --user on " "Debian systems)"

130 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
build_dir
 ( ) )

132 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
src
 ( ) )

134 
cmd_opts
 . 
add_option
 ( '-U'

136 
dest
 = 'upgrade' ,

137 
action
 = 'store_true' ,

138 
help
 = 'Upgrade all specified packages to the newest available ' 'version. The handling of dependencies depends on the ' 'upgrade-strategy used.'

143 
cmd_opts
 . 
add_option
 ( '--upgrade-strategy'

145 
dest
 = 'upgrade_strategy' ,

146 
default
 = 'only-if-needed' ,

147 
choices
 = [ 'only-if-needed' , 'eager' ] ,

148 
help
 = 'Determines how dependency upgrading should be handled ' '[default: %default]. ' '"eager" - dependencies are upgraded regardless of ' 'whether the currently installed version satisfies the ' 'requirements of the upgraded package(s). ' '"only-if-needed" -  are upgraded only when they do not ' 'satisfy the requirements of the upgraded package(s).'

157 
cmd_opts
 . 
add_option
 ( '--force-reinstall'

159 
dest
 = 'force_reinstall' ,

160 
action
 = 'store_true' ,

161 
help
 = 'Reinstall all packages even if they are already ' 'up-to-date.'

164 
cmd_opts
 . 
add_option
 ( '-I'

166 
dest
 = 'ignore_installed' ,

167 
action
 = 'store_true' ,

168 
help
 = 'Ignore the installed packages (reinstalling instead).' )

170 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
ignore_requires_python
 ( ) )

171 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_build_isolation
 ( ) )

173 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
install_options
 ( ) )

174 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
global_options
 ( ) )

176 
cmd_opts
 . 
add_option
 ( "--compile"

178 
action
 = "store_true" ,

179 
dest
 = "compile" ,

180 
default
 = True ,

181 
help
 = "Compile Python source files to bytecode" ,

184 
cmd_opts
 . 
add_option
 ( "--no-compile"

186 
action
 = "store_false" ,

187 
dest
 = "compile" ,

188 
help
 = "Do not compile Python source files to bytecode" ,

191 
cmd_opts
 . 
add_option
 ( "--no-warn-script-location"

193 
action
 = "store_false" ,

194 
dest
 = "warn_script_location" ,

195 
default
 = True ,

196 
help
 = "Do not warn when installing scripts outside PATH" ,

198 
cmd_opts
 . 
add_option
 ( "--no-warn-conflicts"

200 
action
 = "store_false" ,

201 
dest
 = "warn_about_conflicts" ,

202 
default
 = True ,

203 
help
 = "Do not warn about broken dependencies" ,

206 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_binary
 ( ) )

207 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
only_binary
 ( ) )

208 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
prefer_binary
 ( ) )

209 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_clean
 ( ) )

210 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
require_hashes
 ( ) )

211 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
progress_bar
 ( ) )

213 
index_opts
 = 
cmdoptions
 . 
make_option_group
 (

214 
cmdoptions
 . 
index_group
 ,

215 
self
 . 
parser
 ,

218 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
index_opts
 )

219 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
cmd_opts
 ) 
	}

221 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

222 
cmdoptions
 . 
check_install_build_global
 ( 
options
 )

223 
upgrade_strategy
 = "to-satisfy-only"

224 if 
options
 . 
upgrade
 :

225 
upgrade_strategy
 = 
options
 . 
upgrade_strategy

227 if 
options
 . 
build_dir
 :

228 
options
 . 
build_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
build_dir
 )

230 
cmdoptions
 . 
check_dist_restriction
 ( 
options
 , 
check_target
 = True )

232 if 
options
 . 
python_version
 :

233 
python_versions
 = [ 
options
 . 
python_version
 ]

235 
python_versions
 = None

238 if ( not 
options
 . 
use_user_site
 and not 
options
 . 
prefix_path
 and not

239 
options
 . 
target_dir
 and not 
options
 . 
use_system_location
 ) :

240 if not 
running_under_virtualenv
 ( ) and 
os
 . 
geteuid
 ( ) != 0 :

241 
options
 . 
use_user_site
 = True

243 if 
options
 . 
use_system_location
 :

244 
options
 . 
use_user_site
 = False

246 
options
 . 
src_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
src_dir
 )

247 
install_options
 = 
options
 . 
install_options
 or [ ]

248 if 
options
 . 
use_user_site
 :

249 if 
options
 . 
prefix_path
 :

250 raise 
CommandError
 ( "Can not combine '--user' and '--prefix' as they imply " "different installation locations"

254 if 
virtualenv_no_global
 ( ) :

255 raise 
InstallationError
 ( "Can not perform a '--user' install. User site-packages " "are not visible in this virtualenv."

259 
install_options
 . 
append
 ( '--user' )

260 
install_options
 . 
append
 ( '--prefix=' )

262 
target_temp_dir
 = 
TempDirectory
 ( 
kind
 = "target" )

263 if 
options
 . 
target_dir
 :

264 
options
 . 
ignore_installed
 = True

265 
options
 . 
target_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
target_dir
 )

266 if ( 
os
 . 
path
 . 
exists
 ( 
options
 . 
target_dir
 ) and not

267 
os
 . 
path
 . 
isdir
 ( 
options
 . 
target_dir
 ) ) :

268 raise 
CommandError
 ( "Target path exists but is not a directory, will not " "continue."

274 
target_temp_dir
 . 
create
 ( )

275 
install_options
 . 
append
 ( '--home=' + 
target_temp_dir
 . 
path
 )

277 
global_options
 = 
options
 . 
global_options
 or [ ]

279 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

280 
finder
 = 
self
 . 
_build_package_finder
 (

281 
options
 = 
options
 ,

282 
session
 = 
session
 ,

283 
platform
 = 
options
 . 
platform
 ,

284 
python_versions
 = 
python_versions
 ,

285 
abi
 = 
options
 . 
abi
 ,

286 
implementation
 = 
options
 . 
implementation
 ,

288 
build_delete
 = ( not ( 
options
 . 
no_clean
 or 
options
 . 
build_dir
 ) )

289 
wheel_cache
 = 
WheelCache
 ( 
options
 . 
cache_dir
 , 
options
 . 
format_control
 )

291 if 
options
 . 
cache_dir
 and not 
check_path_owner
 ( 
options
 . 
cache_dir
 ) :

292 
logger
 . 
warning
 ( "The directory '%s' or its parent directory is not owned " "by the current user and caching wheels has been " "disabled. check the permissions and owner of that " "directory. If executing pip with sudo, you may want " "sudo's -H flag."

298 
options
 . 
cache_dir
 ,

300 
options
 . 
cache_dir
 = None

302 with 
RequirementTracker
 ( ) as 
req_tracker
 , 
TempDirectory
 (

303 
options
 . 
build_dir
 , 
delete
 = 
build_delete
 , 
kind
 = "install"

304 ) as 
directory
 :

305 
requirement_set
 = 
RequirementSet
 (

306 
require_hashes
 = 
options
 . 
require_hashes
 ,

307 
check_supported_wheels
 = not 
options
 . 
target_dir
 ,

311 
self
 . 
populate_requirement_set
 (

312 
requirement_set
 , 
args
 , 
options
 , 
finder
 , 
session
 ,

313 
self
 . 
name
 , 
wheel_cache

315 
preparer
 = 
RequirementPreparer
 (

316 
build_dir
 = 
directory
 . 
path
 ,

317 
src_dir
 = 
options
 . 
src_dir
 ,

318 
download_dir
 = None ,

319 
wheel_download_dir
 = None ,

320 
progress_bar
 = 
options
 . 
progress_bar
 ,

321 
build_isolation
 = 
options
 . 
build_isolation
 ,

322 
req_tracker
 = 
req_tracker
 ,

325 
resolver
 = 
Resolver
 (

326 
preparer
 = 
preparer
 ,

327 
finder
 = 
finder
 ,

328 
session
 = 
session
 ,

329 
wheel_cache
 = 
wheel_cache
 ,

330 
use_user_site
 = 
options
 . 
use_user_site
 ,

331 
upgrade_strategy
 = 
upgrade_strategy
 ,

332 
force_reinstall
 = 
options
 . 
force_reinstall
 ,

333 
ignore_dependencies
 = 
options
 . 
ignore_dependencies
 ,

334 
ignore_requires_python
 = 
options
 . 
ignore_requires_python
 ,

335 
ignore_installed
 = 
options
 . 
ignore_installed
 ,

336 
isolated
 = 
options
 . 
isolated_mode
 ,

338 
resolver
 . 
resolve
 ( 
requirement_set
 )

340 
protect_pip_from_modification_on_windows
 (

341 
modifying_pip
 = 
requirement_set
 . 
has_requirement
 ( "pip" )

346 if 
wheel
 and 
options
 . 
cache_dir
 :

348 
wb
 = 
WheelBuilder
 (

349 
finder
 , 
preparer
 , 
wheel_cache
 ,

350 
build_options
 = [ ] , 
global_options
 = [ ] ,

354 
wb
 . 
build
 (

355 
requirement_set
 . 
requirements
 . 
values
 ( ) ,

356 
session
 = 
session
 , 
autobuilding
 = True

359 
to_install
 = 
resolver
 . 
get_installation_order
 (

360 
requirement_set

364 
should_warn_about_conflicts
 = (

365 not 
options
 . 
ignore_dependencies
 and

366 
options
 . 
warn_about_conflicts

368 if 
should_warn_about_conflicts
 :

369 
self
 . 
_warn_about_conflicts
 ( 
to_install
 )

373 
warn_script_location
 = 
options
 . 
warn_script_location

374 if 
options
 . 
target_dir
 :

375 
warn_script_location
 = False

377 
installed
 = 
install_given_reqs
 (

378 
to_install
 ,

379 
install_options
 ,

380 
global_options
 ,

381 
root
 = 
options
 . 
root_path
 ,

382 
home
 = 
target_temp_dir
 . 
path
 ,

383 
prefix
 = 
options
 . 
prefix_path
 ,

384 
pycompile
 = 
options
 . 
compile
 ,

385 
warn_script_location
 = 
warn_script_location
 ,

386 
use_user_site
 = 
options
 . 
use_user_site
 ,

389 
lib_locations
 = 
get_lib_location_guesses
 (

390 
user
 = 
options
 . 
use_user_site
 ,

391 
home
 = 
target_temp_dir
 . 
path
 ,

392 
root
 = 
options
 . 
root_path
 ,

393 
prefix
 = 
options
 . 
prefix_path
 ,

394 
isolated
 = 
options
 . 
isolated_mode
 ,

396 
working_set
 = 
pkg_resources
 . 
WorkingSet
 ( 
lib_locations
 )

398 
reqs
 = 
sorted
 ( 
installed
 , 
key
 = 
operator
 . 
attrgetter
 ( 'name' ) )

399 
items
 = [ ]

400 for 
req
 in 
reqs
 :

401 
item
 = 
req
 . 
name

403 
installed_version
 = 
get_installed_version
 (

404 
req
 . 
name
 , 
working_set
 = 
working_set

406 if 
installed_version
 :

407 
item
 += '-' + 
installed_version

408 except 
Exception
 :

410 
items
 . 
append
 ( 
item
 )

411 
installed
 = ' ' . 
join
 ( 
items
 )

412 if 
installed
 :

413 
logger
 . 
info
 ( 'Successfully installed %s' , 
installed
 )

414 except 
EnvironmentError
 as 
error
 :

415 
show_traceback
 = ( 
self
 . 
verbosity
 >= 1 )

417 
message
 = 
create_env_error_message
 (

418 
error
 , 
show_traceback
 , 
options
 . 
use_user_site
 ,

420 
logger
 . 
error
 ( 
message
 , 
exc_info
 = 
show_traceback
 )

422 return 
ERROR

423 except 
PreviousBuildDirError
 :

424 
options
 . 
no_clean
 = True

428 if not 
options
 . 
no_clean
 :

429 
requirement_set
 . 
cleanup_files
 ( )

430 
wheel_cache
 . 
cleanup
 ( )

432 if 
options
 . 
target_dir
 :

433 
self
 . 
_handle_target_dir
 (

434 
options
 . 
target_dir
 , 
target_temp_dir
 , 
options
 . 
upgrade

436 return 
requirement_set
 
	}

438 def 
	$_handle_target_dir
 ( 
self
 , 
target_dir
 , 
target_temp_dir
 , 
upgrade
 ) :

439 
ensure_dir
 ( 
target_dir
 )

443 
lib_dir_list
 = [ ]

445 with 
target_temp_dir
 :

448 
scheme
 = 
distutils_scheme
 ( '' , 
home
 = 
target_temp_dir
 . 
path
 )

449 
purelib_dir
 = 
scheme
 [ 'purelib' ]

450 
platlib_dir
 = 
scheme
 [ 'platlib' ]

451 
data_dir
 = 
scheme
 [ 'data' ]

453 if 
os
 . 
path
 . 
exists
 ( 
purelib_dir
 ) :

454 
lib_dir_list
 . 
append
 ( 
purelib_dir
 )

455 if 
os
 . 
path
 . 
exists
 ( 
platlib_dir
 ) and 
platlib_dir
 != 
purelib_dir
 :

456 
lib_dir_list
 . 
append
 ( 
platlib_dir
 )

457 if 
os
 . 
path
 . 
exists
 ( 
data_dir
 ) :

458 
lib_dir_list
 . 
append
 ( 
data_dir
 )

460 for 
lib_dir
 in 
lib_dir_list
 :

461 for 
item
 in 
os
 . 
listdir
 ( 
lib_dir
 ) :

462 if 
lib_dir
 == 
data_dir
 :

463 
ddir
 = 
os
 . 
path
 . 
join
 ( 
data_dir
 , 
item
 )

464 if 
any
 ( 
s
 . 
startswith
 ( 
ddir
 ) for 
s
 in 
lib_dir_list
 [ : - 1 ] ) :

466 
target_item_dir
 = 
os
 . 
path
 . 
join
 ( 
target_dir
 , 
item
 )

467 if 
os
 . 
path
 . 
exists
 ( 
target_item_dir
 ) :

468 if not 
upgrade
 :

469 
logger
 . 
warning
 ( 'Target directory %s already exists. Specify ' '--upgrade to force replacement.'

472 
target_item_dir

475 if 
os
 . 
path
 . 
islink
 ( 
target_item_dir
 ) :

476 
logger
 . 
warning
 ( 'Target directory %s already exists and is ' 'a link. Pip will not automatically replace ' 'links, please remove if replacement is ' 'desired.'

481 
target_item_dir

484 if 
os
 . 
path
 . 
isdir
 ( 
target_item_dir
 ) :

485 
shutil
 . 
rmtree
 ( 
target_item_dir
 )

487 
os
 . 
remove
 ( 
target_item_dir
 )

489 
shutil
 . 
move
 (

490 
os
 . 
path
 . 
join
 ( 
lib_dir
 , 
item
 ) ,

491 
target_item_dir

492 ) 
	}

494 def 
	$_warn_about_conflicts
 ( 
self
 , 
to_install
 ) :

495 
package_set
 , 
_dep_info
 = 
check_install_conflicts
 ( 
to_install
 )

496 
missing
 , 
conflicting
 = 
_dep_info

499 for 
project_name
 in 
missing
 :

500 
version
 = 
package_set
 [ 
project_name
 ] [ 0 ]

501 for 
dependency
 in 
missing
 [ 
project_name
 ] :

502 
logger
 . 
critical
 ( "%s %s requires %s, which is not installed."

504 
project_name
 , 
version
 , 
dependency
 [ 1 ] ,

507 for 
project_name
 in 
conflicting
 :

508 
version
 = 
package_set
 [ 
project_name
 ] [ 0 ]

509 for 
dep_name
 , 
dep_version
 , 
req
 in 
conflicting
 [ 
project_name
 ] :

510 
logger
 . 
critical
 ( "%s %s has requirement %s, but you'll have %s %s which is " "incompatible."

513 
project_name
 , 
version
 , 
req
 , 
dep_name
 , 
dep_version
 ,

514 ) 
	}

517 def 
	$get_lib_location_guesses
 ( * 
args
 , ** 
kwargs
 ) :

518 
scheme
 = 
distutils_scheme
 ( '' , * 
args
 , ** 
kwargs
 )

519 return [ 
scheme
 [ 'purelib' ] , 
scheme
 [ 'platlib' ] ] 
	}

522 def 
	$create_env_error_message
 ( 
error
 , 
show_traceback
 , 
using_user_site
 ) :

527 
parts
 = [ ]

530 
parts
 . 
append
 ( "Could not install packages due to an EnvironmentError" )

531 if not 
show_traceback
 :

532 
parts
 . 
append
 ( ": " )

533 
parts
 . 
append
 ( 
str
 ( 
error
 ) )

535 
parts
 . 
append
 ( "." )

538 
parts
 [ - 1 ] += "\n"

542 if 
error
 . 
errno
 == 
errno
 . 
EACCES
 :

543 
user_option_part
 = "Consider using the `--user` option"

544 
permissions_part
 = "Check the permissions"

546 if not 
using_user_site
 :

547 
parts
 . 
extend
 ( [

548 
user_option_part
 , " or " ,

549 
permissions_part
 . 
lower
 ( ) ,

552 
parts
 . 
append
 ( 
permissions_part
 )

553 
parts
 . 
append
 ( ".\n" )

555 return "" . 
join
 ( 
parts
 ) . 
strip
 ( ) + "\n" 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/configuration.py

1 import 
	~logging

2 import 
	~os

3 import 
	~subprocess

5 from 
	~pip._internal.cli.base_command
 import 
Command

6 from 
	~pip._internal.cli.status_codes
 import 
ERROR
 , 
SUCCESS

7 from 
	~pip._internal.configuration
 import 
Configuration
 , 
kinds

8 from 
	~pip._internal.exceptions
 import 
PipError

9 from 
	~pip._internal.locations
 import 
venv_config_file

10 from 
	~pip._internal.utils.misc
 import 
get_prog

12 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

15 class 
	cConfigurationCommand
 ( 
Command
 ) :

32 
name
 = 'config'

33 
usage
 = """\n        %prog [<file-option>] list\n        %prog [<file-option>] [--editor <editor-path>] edit\n\n        %prog [<file-option>] get name\n        %prog [<file-option>] set name value\n        %prog [<file-option>] unset name\n    """

42 
summary
 = "Manage local and global configuration."

44 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

45 
super
 ( 
ConfigurationCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

47 
self
 . 
configuration
 = None

49 
self
 . 
cmd_opts
 . 
add_option
 ( '--editor'

51 
dest
 = 'editor' ,

52 
action
 = 'store' ,

53 
default
 = None ,

54 
help
 = ( 'Editor to use to edit the file. Uses VISUAL or EDITOR ' 'environment variables if not provided.'

60 
self
 . 
cmd_opts
 . 
add_option
 ( '--global'

62 
dest
 = 'global_file' ,

63 
action
 = 'store_true' ,

64 
default
 = False ,

65 
help
 = 'Use the system-wide configuration file only'

68 
self
 . 
cmd_opts
 . 
add_option
 ( '--user'

70 
dest
 = 'user_file' ,

71 
action
 = 'store_true' ,

72 
default
 = False ,

73 
help
 = 'Use the user configuration file only'

76 
self
 . 
cmd_opts
 . 
add_option
 ( '--venv'

78 
dest
 = 'venv_file' ,

79 
action
 = 'store_true' ,

80 
default
 = False ,

81 
help
 = 'Use the virtualenv configuration file only'

84 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

86 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

87 
handlers
 = { "list"

88 : 
self
 . 
list_values
 , "edit"

89 : 
self
 . 
open_in_editor
 , "get"

90 : 
self
 . 
get_name
 , "set"

91 : 
self
 . 
set_name_value
 , "unset"

92 : 
self
 . 
unset_name

96 if not 
args
 or 
args
 [ 0 ] not in 
handlers
 :

97 
logger
 . 
error
 ( "Need an action ({}) to perform." . 
format
 ( ", "

98 . 
join
 ( 
sorted
 ( 
handlers
 ) ) )

100 return 
ERROR

102 
action
 = 
args
 [ 0 ]

107 
load_only
 = 
self
 . 
_determine_file
 (

108 
options
 , 
need_value
 = ( 
action
 in [ "get" , "set" , "unset" , "edit" ] )

110 except 
PipError
 as 
e
 :

111 
logger
 . 
error
 ( 
e
 . 
args
 [ 0 ] )

112 return 
ERROR

115 
self
 . 
configuration
 = 
Configuration
 (

116 
isolated
 = 
options
 . 
isolated_mode
 , 
load_only
 = 
load_only

118 
self
 . 
configuration
 . 
load
 ( )

122 
handlers
 [ 
action
 ] ( 
options
 , 
args
 [ 1 : ] )

123 except 
PipError
 as 
e
 :

124 
logger
 . 
error
 ( 
e
 . 
args
 [ 0 ] )

125 return 
ERROR

127 return 
SUCCESS
 
	}

129 def 
	$_determine_file
 ( 
self
 , 
options
 , 
need_value
 ) :

130 
file_options
 = {

131 
kinds
 . 
USER
 : 
options
 . 
user_file
 ,

132 
kinds
 . 
GLOBAL
 : 
options
 . 
global_file
 ,

133 
kinds
 . 
VENV
 : 
options
 . 
venv_file

136 if 
sum
 ( 
file_options
 . 
values
 ( ) ) == 0 :

137 if not 
need_value
 :

140 elif 
os
 . 
path
 . 
exists
 ( 
venv_config_file
 ) :

141 return 
kinds
 . 
VENV

143 return 
kinds
 . 
USER

144 elif 
sum
 ( 
file_options
 . 
values
 ( ) ) == 1 :

146 return [ 
key
 for 
key
 in 
file_options
 if 
file_options
 [ 
key
 ] ] [ 0 ]

148 raise 
PipError
 ( "Need exactly one file to operate upon " "(--user, --venv, --global) to perform."

151 ) 
	}

153 def 
	$list_values
 ( 
self
 , 
options
 , 
args
 ) :

154 
self
 . 
_get_n_args
 ( 
args
 , "list" , 
n
 = 0 )

156 for 
key
 , 
value
 in 
sorted
 ( 
self
 . 
configuration
 . 
items
 ( ) ) :

157 
logger
 . 
info
 ( "%s=%r" , 
key
 , 
value
 ) 
	}

159 def 
	$get_name
 ( 
self
 , 
options
 , 
args
 ) :

160 
key
 = 
self
 . 
_get_n_args
 ( 
args
 , "get [name]" , 
n
 = 1 )

161 
value
 = 
self
 . 
configuration
 . 
get_value
 ( 
key
 )

163 
logger
 . 
info
 ( "%s" , 
value
 ) 
	}

165 def 
	$set_name_value
 ( 
self
 , 
options
 , 
args
 ) :

166 
key
 , 
value
 = 
self
 . 
_get_n_args
 ( 
args
 , "set [name] [value]" , 
n
 = 2 )

167 
self
 . 
configuration
 . 
set_value
 ( 
key
 , 
value
 )

169 
self
 . 
_save_configuration
 ( ) 
	}

171 def 
	$unset_name
 ( 
self
 , 
options
 , 
args
 ) :

172 
key
 = 
self
 . 
_get_n_args
 ( 
args
 , "unset [name]" , 
n
 = 1 )

173 
self
 . 
configuration
 . 
unset_value
 ( 
key
 )

175 
self
 . 
_save_configuration
 ( ) 
	}

177 def 
	$open_in_editor
 ( 
self
 , 
options
 , 
args
 ) :

178 
editor
 = 
self
 . 
_determine_editor
 ( 
options
 )

180 
fname
 = 
self
 . 
configuration
 . 
get_file_to_edit
 ( )

181 if 
fname
 is None :

182 raise 
PipError
 ( "Could not determine appropriate file." )

185 
subprocess
 . 
check_call
 ( [ 
editor
 , 
fname
 ] )

186 except 
subprocess
 . 
CalledProcessError
 as 
e
 :

187 raise 
PipError
 ( "Editor Subprocess exited with exit code {}"

189 . 
format
 ( 
e
 . 
returncode
 )

190 ) 
	}

192 def 
	$_get_n_args
 ( 
self
 , 
args
 , 
example
 , 
n
 ) :

195 if 
len
 ( 
args
 ) != 
n
 :

196 
msg
 = ( 'Got unexpected number of arguments, expected {}. ' '(example: "{} config {}")'

199 ) . 
format
 ( 
n
 , 
get_prog
 ( ) , 
example
 )

200 raise 
PipError
 ( 
msg
 )

202 if 
n
 == 1 :

203 return 
args
 [ 0 ]

205 return 
args
 
	}

207 def 
	$_save_configuration
 ( 
self
 ) :

211 
self
 . 
configuration
 . 
save
 ( )

212 except 
Exception
 :

213 
logger
 . 
error
 ( "Unable to save configuration. Please report this as a bug."

215 
exc_info
 = 1

217 raise 
PipError
 ( "Internal Error." ) 
	}

219 def 
	$_determine_editor
 ( 
self
 , 
options
 ) :

220 if 
options
 . 
editor
 is not None :

221 return 
options
 . 
editor

222 elif "VISUAL" in 
os
 . 
environ
 :

223 return 
os
 . 
environ
 [ "VISUAL" ]

224 elif "EDITOR" in 
os
 . 
environ
 :

225 return 
os
 . 
environ
 [ "EDITOR" ]

227 raise 
PipError
 ( "Could not determine editor to use." ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/list.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~json

4 import 
	~logging

6 from 
	~pip._vendor
 import 
six

7 from 
	~pip._vendor.six.moves
 import 
zip_longest

9 from 
	~pip._internal.cli
 import 
cmdoptions

10 from 
	~pip._internal.cli.base_command
 import 
Command

11 from 
	~pip._internal.exceptions
 import 
CommandError

12 from 
	~pip._internal.index
 import 
PackageFinder

13 from 
	~pip._internal.utils.misc
 import (

14 
dist_is_editable
 , 
get_installed_distributions
 ,

16 from 
	~pip._internal.utils.packaging
 import 
get_installer

18 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

21 class 
	cListCommand
 ( 
Command
 ) :

27 
name
 = 'list'

28 
usage
 = """\n      %prog [options]"""

30 
summary
 = 'List installed packages.'

32 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

33 
super
 ( 
ListCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

35 
cmd_opts
 = 
self
 . 
cmd_opts

37 
cmd_opts
 . 
add_option
 ( '-o'

39 
action
 = 'store_true' ,

40 
default
 = False ,

41 
help
 = 'List outdated packages' )

42 
cmd_opts
 . 
add_option
 ( '-u'

44 
action
 = 'store_true' ,

45 
default
 = False ,

46 
help
 = 'List uptodate packages' )

47 
cmd_opts
 . 
add_option
 ( '-e'

49 
action
 = 'store_true' ,

50 
default
 = False ,

51 
help
 = 'List editable projects.' )

52 
cmd_opts
 . 
add_option
 ( '-l'

54 
action
 = 'store_true' ,

55 
default
 = False ,

56 
help
 = ( 'If in a virtualenv that has global access, do not list ' 'globally-installed packages.'

59 
self
 . 
cmd_opts
 . 
add_option
 ( '--user'

61 
dest
 = 'user' ,

62 
action
 = 'store_true' ,

63 
default
 = False ,

64 
help
 = 'Only output packages installed in user-site.' )

66 
cmd_opts
 . 
add_option
 ( '--pre'

68 
action
 = 'store_true' ,

69 
default
 = False ,

70 
help
 = ( "Include pre-release and development versions. By default, " "pip only finds stable versions."

74 
cmd_opts
 . 
add_option
 ( '--format'

76 
action
 = 'store' ,

77 
dest
 = 'list_format' ,

78 
default
 = "columns" ,

79 
choices
 = ( 'columns' , 'freeze' , 'json' ) ,

80 
help
 = "Select the output format among: columns (default), freeze, " "or json"

84 
cmd_opts
 . 
add_option
 ( '--not-required'

86 
action
 = 'store_true' ,

87 
dest
 = 'not_required' ,

88 
help
 = "List packages that are not dependencies of " "installed packages."

92 
cmd_opts
 . 
add_option
 ( '--exclude-editable'

94 
action
 = 'store_false' ,

95 
dest
 = 'include_editable' ,

96 
help
 = 'Exclude editable package from output.' ,

98 
cmd_opts
 . 
add_option
 ( '--include-editable'

100 
action
 = 'store_true' ,

101 
dest
 = 'include_editable' ,

102 
help
 = 'Include editable package from output.' ,

103 
default
 = True ,

105 
index_opts
 = 
cmdoptions
 . 
make_option_group
 (

106 
cmdoptions
 . 
index_group
 , 
self
 . 
parser

109 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
index_opts
 )

110 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
cmd_opts
 ) 
	}

112 def 
	$_build_package_finder
 ( 
self
 , 
options
 , 
index_urls
 , 
session
 ) :

116 return 
PackageFinder
 (

117 
find_links
 = 
options
 . 
find_links
 ,

118 
index_urls
 = 
index_urls
 ,

119 
allow_all_prereleases
 = 
options
 . 
pre
 ,

120 
trusted_hosts
 = 
options
 . 
trusted_hosts
 ,

121 
process_dependency_links
 = 
options
 . 
process_dependency_links
 ,

122 
session
 = 
session
 ,

123 ) 
	}

125 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

126 if 
options
 . 
outdated
 and 
options
 . 
uptodate
 :

127 raise 
CommandError
 ( "Options --outdated and --uptodate cannot be combined."

130 
packages
 = 
get_installed_distributions
 (

131 
local_only
 = 
options
 . 
local
 ,

132 
user_only
 = 
options
 . 
user
 ,

133 
editables_only
 = 
options
 . 
editable
 ,

134 
include_editables
 = 
options
 . 
include_editable
 ,

137 if 
options
 . 
outdated
 :

138 
packages
 = 
self
 . 
get_outdated
 ( 
packages
 , 
options
 )

139 elif 
options
 . 
uptodate
 :

140 
packages
 = 
self
 . 
get_uptodate
 ( 
packages
 , 
options
 )

142 if 
options
 . 
not_required
 :

143 
packages
 = 
self
 . 
get_not_required
 ( 
packages
 , 
options
 )

145 
self
 . 
output_package_listing
 ( 
packages
 , 
options
 ) 
	}

147 def 
	$get_outdated
 ( 
self
 , 
packages
 , 
options
 ) :

149 
dist
 for 
dist
 in 
self
 . 
iter_packages_latest_infos
 ( 
packages
 , 
options
 )

150 if 
dist
 . 
latest_version
 > 
dist
 . 
parsed_version

151 ] 
	}

153 def 
	$get_uptodate
 ( 
self
 , 
packages
 , 
options
 ) :

155 
dist
 for 
dist
 in 
self
 . 
iter_packages_latest_infos
 ( 
packages
 , 
options
 )

156 if 
dist
 . 
latest_version
 == 
dist
 . 
parsed_version

157 ] 
	}

159 def 
	$get_not_required
 ( 
self
 , 
packages
 , 
options
 ) :

160 
dep_keys
 = 
set
 ( )

161 for 
dist
 in 
packages
 :

162 
dep_keys
 . 
update
 ( 
requirement
 . 
key
 for 
requirement
 in 
dist
 . 
requires
 ( ) )

163 return { 
pkg
 for 
pkg
 in 
packages
 if 
pkg
 . 
key
 not in 
dep_keys
 } 
	}

165 def 
	$iter_packages_latest_infos
 ( 
self
 , 
packages
 , 
options
 ) :

166 
index_urls
 = [ 
options
 . 
index_url
 ] + 
options
 . 
extra_index_urls

167 if 
options
 . 
no_index
 :

168 
logger
 . 
debug
 ( 'Ignoring indexes: %s' , ',' . 
join
 ( 
index_urls
 ) )

169 
index_urls
 = [ ]

171 
dependency_links
 = [ ]

172 for 
dist
 in 
packages
 :

173 if 
dist
 . 
has_metadata
 ( 'dependency_links.txt' ) :

174 
dependency_links
 . 
extend
 (

175 
dist
 . 
get_metadata_lines
 ( 'dependency_links.txt' ) ,

178 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

179 
finder
 = 
self
 . 
_build_package_finder
 ( 
options
 , 
index_urls
 , 
session
 )

180 
finder
 . 
add_dependency_links
 ( 
dependency_links
 )

182 for 
dist
 in 
packages
 :

183 
typ
 = 'unknown'

184 
all_candidates
 = 
finder
 . 
find_all_candidates
 ( 
dist
 . 
key
 )

185 if not 
options
 . 
pre
 :

187 
all_candidates
 = [ 
candidate
 for 
candidate
 in 
all_candidates

188 if not 
candidate
 . 
version
 . 
is_prerelease
 ]

190 if not 
all_candidates
 :

192 
best_candidate
 = 
max
 ( 
all_candidates
 ,

193 
key
 = 
finder
 . 
_candidate_sort_key
 )

194 
remote_version
 = 
best_candidate
 . 
version

195 if 
best_candidate
 . 
location
 . 
is_wheel
 :

196 
typ
 = 'wheel'

198 
typ
 = 'sdist'

200 
dist
 . 
latest_version
 = 
remote_version

201 
dist
 . 
latest_filetype
 = 
typ

202 yield 
dist
 
	}

204 def 
	$output_package_listing
 ( 
self
 , 
packages
 , 
options
 ) :

205 
packages
 = 
sorted
 (

206 
packages
 ,

207 
key
 = lambda 
dist
 : 
dist
 . 
project_name
 . 
lower
 ( ) ,

209 if 
options
 . 
list_format
 == 'columns' and 
packages
 :

210 
data
 , 
header
 = 
format_for_columns
 ( 
packages
 , 
options
 )

211 
self
 . 
output_package_listing_columns
 ( 
data
 , 
header
 )

212 elif 
options
 . 
list_format
 == 'freeze' :

213 for 
dist
 in 
packages
 :

214 if 
options
 . 
verbose
 >= 1 :

215 
logger
 . 
info
 ( "%s==%s (%s)" , 
dist
 . 
project_name
 ,

216 
dist
 . 
version
 , 
dist
 . 
location
 )

218 
logger
 . 
info
 ( "%s==%s" , 
dist
 . 
project_name
 , 
dist
 . 
version
 )

219 elif 
options
 . 
list_format
 == 'json' :

220 
logger
 . 
info
 ( 
format_for_json
 ( 
packages
 , 
options
 ) ) 
	}

222 def 
	$output_package_listing_columns
 ( 
self
 , 
data
 , 
header
 ) :

224 if 
len
 ( 
data
 ) > 0 :

225 
data
 . 
insert
 ( 0 , 
header
 )

227 
pkg_strings
 , 
sizes
 = 
tabulate
 ( 
data
 )

230 if 
len
 ( 
data
 ) > 0 :

231 
pkg_strings
 . 
insert
 ( 1 , " " . 
join
 ( 
map
 ( lambda 
x
 : '-' * 
x
 , 
sizes
 ) ) )

233 for 
val
 in 
pkg_strings
 :

234 
logger
 . 
info
 ( 
val
 ) 
	}

237 def 
	$tabulate
 ( 
vals
 ) :

240 assert 
len
 ( 
vals
 ) > 0

242 
sizes
 = [ 0 ] * 
max
 ( 
len
 ( 
x
 ) for 
x
 in 
vals
 )

243 for 
row
 in 
vals
 :

244 
sizes
 = [ 
max
 ( 
s
 , 
len
 ( 
str
 ( 
c
 ) ) ) for 
s
 , 
c
 in 
zip_longest
 ( 
sizes
 , 
row
 ) ]

246 
result
 = [ ]

247 for 
row
 in 
vals
 :

248 
display
 = " " . 
join
 ( [ 
str
 ( 
c
 ) . 
ljust
 ( 
s
 ) if 
c
 is not None else ''

249 for 
s
 , 
c
 in 
zip_longest
 ( 
sizes
 , 
row
 ) ] )

250 
result
 . 
append
 ( 
display
 )

252 return 
result
 , 
sizes
 
	}

255 def 
	$format_for_columns
 ( 
pkgs
 , 
options
 ) :

260 
running_outdated
 = 
options
 . 
outdated

262 if 
running_outdated
 :

263 
header
 = [ "Package" , "Version" , "Latest" , "Type" ]

265 
header
 = [ "Package" , "Version" ]

267 
data
 = [ ]

268 if 
options
 . 
verbose
 >= 1 or 
any
 ( 
dist_is_editable
 ( 
x
 ) for 
x
 in 
pkgs
 ) :

269 
header
 . 
append
 ( "Location" )

270 if 
options
 . 
verbose
 >= 1 :

271 
header
 . 
append
 ( "Installer" )

273 for 
proj
 in 
pkgs
 :

276 
row
 = [ 
proj
 . 
project_name
 , 
proj
 . 
version
 ]

278 if 
running_outdated
 :

279 
row
 . 
append
 ( 
proj
 . 
latest_version
 )

280 
row
 . 
append
 ( 
proj
 . 
latest_filetype
 )

282 if 
options
 . 
verbose
 >= 1 or 
dist_is_editable
 ( 
proj
 ) :

283 
row
 . 
append
 ( 
proj
 . 
location
 )

284 if 
options
 . 
verbose
 >= 1 :

285 
row
 . 
append
 ( 
get_installer
 ( 
proj
 ) )

287 
data
 . 
append
 ( 
row
 )

289 return 
data
 , 
header
 
	}

292 def 
	$format_for_json
 ( 
packages
 , 
options
 ) :

293 
data
 = [ ]

294 for 
dist
 in 
packages
 :

295 
info
 = { 'name'

296 : 
dist
 . 
project_name
 , 'version'

297 : 
six
 . 
text_type
 ( 
dist
 . 
version
 ) ,

299 if 
options
 . 
verbose
 >= 1 :

300 
info
 [ 'location' ] = 
dist
 . 
location

301 
info
 [ 'installer' ] = 
get_installer
 ( 
dist
 )

302 if 
options
 . 
outdated
 :

303 
info
 [ 'latest_version' ] = 
six
 . 
text_type
 ( 
dist
 . 
latest_version
 )

304 
info
 [ 'latest_filetype' ] = 
dist
 . 
latest_filetype

305 
data
 . 
append
 ( 
info
 )

306 return 
json
 . 
dumps
 ( 
data
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/hash.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~hashlib

4 import 
	~logging

5 import 
	~sys

7 from 
	~pip._internal.cli.base_command
 import 
Command

8 from 
	~pip._internal.cli.status_codes
 import 
ERROR

9 from 
	~pip._internal.utils.hashes
 import 
FAVORITE_HASH
 , 
STRONG_HASHES

10 from 
	~pip._internal.utils.misc
 import 
read_chunks

12 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

15 class 
	cHashCommand
 ( 
Command
 ) :

23 
name
 = 'hash'

24 
usage
 = '%prog [options] <file> ...'

25 
summary
 = 'Compute hashes of package archives.'

26 
ignore_require_venv
 = True

28 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

29 
super
 ( 
HashCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

30 
self
 . 
cmd_opts
 . 
add_option
 ( '-a'

32 
dest
 = 'algorithm' ,

33 
choices
 = 
STRONG_HASHES
 ,

34 
action
 = 'store' ,

35 
default
 = 
FAVORITE_HASH
 ,

36 
help
 = 'The hash algorithm to use: one of %s' % ', '

37 . 
join
 ( 
STRONG_HASHES
 ) )

38 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

40 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

41 if not 
args
 :

42 
self
 . 
parser
 . 
print_usage
 ( 
sys
 . 
stderr
 )

43 return 
ERROR

45 
algorithm
 = 
options
 . 
algorithm

46 for 
path
 in 
args
 :

47 
logger
 . 
info
 ( '%s:\n--hash=%s:%s' ,

48 
path
 , 
algorithm
 , 
_hash_of_file
 ( 
path
 , 
algorithm
 ) ) 
	}

51 def 
	$_hash_of_file
 ( 
path
 , 
algorithm
 ) :

53 with 
open
 ( 
path
 , 'rb' ) as 
archive
 :

54 
hash
 = 
hashlib
 . 
new
 ( 
algorithm
 )

55 for 
chunk
 in 
read_chunks
 ( 
archive
 ) :

56 
hash
 . 
update
 ( 
chunk
 )

57 return 
hash
 . 
hexdigest
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/check.py

1 import 
	~logging

3 from 
	~pip._internal.cli.base_command
 import 
Command

4 from 
	~pip._internal.operations.check
 import (

5 
check_package_set
 , 
create_package_set_from_installed
 ,

8 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

11 class 
	cCheckCommand
 ( 
Command
 ) :

13 
name
 = 'check'

14 
usage
 = """\n      %prog [options]"""

16 
summary
 = 'Verify installed packages have compatible dependencies.'

18 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

19 
package_set
 = 
create_package_set_from_installed
 ( )

20 
missing
 , 
conflicting
 = 
check_package_set
 ( 
package_set
 )

22 for 
project_name
 in 
missing
 :

23 
version
 = 
package_set
 [ 
project_name
 ] . 
version

24 for 
dependency
 in 
missing
 [ 
project_name
 ] :

25 
logger
 . 
info
 ( "%s %s requires %s, which is not installed."

27 
project_name
 , 
version
 , 
dependency
 [ 0 ] ,

30 for 
project_name
 in 
conflicting
 :

31 
version
 = 
package_set
 [ 
project_name
 ] . 
version

32 for 
dep_name
 , 
dep_version
 , 
req
 in 
conflicting
 [ 
project_name
 ] :

33 
logger
 . 
info
 ( "%s %s has requirement %s, but you have %s %s."

35 
project_name
 , 
version
 , 
req
 , 
dep_name
 , 
dep_version
 ,

38 if 
missing
 or 
conflicting
 :

41 
logger
 . 
info
 ( "No broken requirements found." ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/search.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~sys

5 import 
	~textwrap

6 from 
	~collections
 import 
OrderedDict

8 from 
	~pip._vendor
 import 
pkg_resources

9 from 
	~pip._vendor.packaging.version
 import 
parse
 as 
parse_version

12 from 
	~pip._vendor.six.moves
 import 
xmlrpc_client

14 from 
	~pip._internal.cli.base_command
 import 
Command

15 from 
	~pip._internal.cli.status_codes
 import 
NO_MATCHES_FOUND
 , 
SUCCESS

16 from 
	~pip._internal.download
 import 
PipXmlrpcTransport

17 from 
	~pip._internal.exceptions
 import 
CommandError

18 from 
	~pip._internal.models.index
 import 
PyPI

19 from 
	~pip._internal.utils.compat
 import 
get_terminal_size

20 from 
	~pip._internal.utils.logging
 import 
indent_log

22 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

25 class 
	cSearchCommand
 ( 
Command
 ) :

27 
name
 = 'search'

28 
usage
 = """\n      %prog [options] <query>"""

30 
summary
 = 'Search PyPI for packages.'

31 
ignore_require_venv
 = True

33 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

34 
super
 ( 
SearchCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

35 
self
 . 
cmd_opts
 . 
add_option
 ( '-i'

37 
dest
 = 'index' ,

38 
metavar
 = 'URL' ,

39 
default
 = 
PyPI
 . 
pypi_url
 ,

40 
help
 = 'Base URL of Python Package Index (default %default)' )

42 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

44 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

45 if not 
args
 :

46 raise 
CommandError
 ( 'Missing required argument (search query).' )

47 
query
 = 
args

48 
pypi_hits
 = 
self
 . 
search
 ( 
query
 , 
options
 )

49 
hits
 = 
transform_hits
 ( 
pypi_hits
 )

51 
terminal_width
 = None

52 if 
sys
 . 
stdout
 . 
isatty
 ( ) :

53 
terminal_width
 = 
get_terminal_size
 ( ) [ 0 ]

55 
print_results
 ( 
hits
 , 
terminal_width
 = 
terminal_width
 )

56 if 
pypi_hits
 :

57 return 
SUCCESS

58 return 
NO_MATCHES_FOUND
 
	}

60 def 
	$search
 ( 
self
 , 
query
 , 
options
 ) :

61 
index_url
 = 
options
 . 
index

62 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

63 
transport
 = 
PipXmlrpcTransport
 ( 
index_url
 , 
session
 )

64 
pypi
 = 
xmlrpc_client
 . 
ServerProxy
 ( 
index_url
 , 
transport
 )

65 
hits
 = 
pypi
 . 
search
 ( { 'name' : 
query
 , 'summary' : 
query
 } , 'or' )

66 return 
hits
 
	}

69 def 
	$transform_hits
 ( 
hits
 ) :

75 
packages
 = 
OrderedDict
 ( )

76 for 
hit
 in 
hits
 :

77 
name
 = 
hit
 [ 'name' ]

78 
summary
 = 
hit
 [ 'summary' ]

79 
version
 = 
hit
 [ 'version' ]

81 if 
name
 not in 
packages
 . 
keys
 ( ) :

82 
packages
 [ 
name
 ] = { 'name'

83 : 
name
 , 'summary'

84 : 
summary
 , 'versions'

85 : [ 
version
 ] ,

88 
packages
 [ 
name
 ] [ 'versions' ] . 
append
 ( 
version
 )

91 if 
version
 == 
highest_version
 ( 
packages
 [ 
name
 ] [ 'versions' ] ) :

92 
packages
 [ 
name
 ] [ 'summary' ] = 
summary

94 return 
list
 ( 
packages
 . 
values
 ( ) ) 
	}

97 def 
	$print_results
 ( 
hits
 , 
name_column_width
 = None , 
terminal_width
 = None ) :

98 if not 
hits
 :

100 if 
name_column_width
 is None :

101 
name_column_width
 = 
max
 ( [

102 
len
 ( 
hit
 [ 'name' ] ) + 
len
 ( 
highest_version
 ( 
hit
 . 
get
 ( 'versions' , [ '-' ] ) ) )

103 for 
hit
 in 
hits

106 
installed_packages
 = [ 
p
 . 
project_name
 for 
p
 in 
pkg_resources
 . 
working_set
 ]

107 for 
hit
 in 
hits
 :

108 
name
 = 
hit
 [ 'name' ]

109 
summary
 = 
hit
 [ 'summary' ] or ''

110 
latest
 = 
highest_version
 ( 
hit
 . 
get
 ( 'versions' , [ '-' ] ) )

111 if 
terminal_width
 is not None :

112 
target_width
 = 
terminal_width
 - 
name_column_width
 - 5

113 if 
target_width
 > 10 :

115 
summary
 = 
textwrap
 . 
wrap
 ( 
summary
 , 
target_width
 )

116 
summary
 = ( '\n' + ' ' * ( 
name_column_width
 + 3 ) ) . 
join
 ( 
summary
 )

118 
line
 = '%-*s - %s' % ( 
name_column_width
 , '%s (%s)'

119 % ( 
name
 , 
latest
 ) , 
summary
 )

121 
logger
 . 
info
 ( 
line
 )

122 if 
name
 in 
installed_packages
 :

123 
dist
 = 
pkg_resources
 . 
get_distribution
 ( 
name
 )

124 with 
indent_log
 ( ) :

125 if 
dist
 . 
version
 == 
latest
 :

126 
logger
 . 
info
 ( 'INSTALLED: %s (latest)' , 
dist
 . 
version
 )

128 
logger
 . 
info
 ( 'INSTALLED: %s' , 
dist
 . 
version
 )

129 
logger
 . 
info
 ( 'LATEST:    %s' , 
latest
 )

130 except 
UnicodeEncodeError
 :

131 pass 
	}

134 def 
	$highest_version
 ( 
versions
 ) :

135 return 
max
 ( 
versions
 , 
key
 = 
parse_version
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/__init__.py

4 from 
	~__future__
 import 
absolute_import

6 from 
	~pip._internal.commands.completion
 import 
CompletionCommand

7 from 
	~pip._internal.commands.configuration
 import 
ConfigurationCommand

8 from 
	~pip._internal.commands.download
 import 
DownloadCommand

9 from 
	~pip._internal.commands.freeze
 import 
FreezeCommand

10 from 
	~pip._internal.commands.hash
 import 
HashCommand

11 from 
	~pip._internal.commands.help
 import 
HelpCommand

12 from 
	~pip._internal.commands.list
 import 
ListCommand

13 from 
	~pip._internal.commands.check
 import 
CheckCommand

14 from 
	~pip._internal.commands.search
 import 
SearchCommand

15 from 
	~pip._internal.commands.show
 import 
ShowCommand

16 from 
	~pip._internal.commands.install
 import 
InstallCommand

17 from 
	~pip._internal.commands.uninstall
 import 
UninstallCommand

18 from 
	~pip._internal.commands.wheel
 import 
WheelCommand

20 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

22 if 
MYPY_CHECK_RUNNING
 :

23 from 
	~typing
 import 
List
 , 
Type

24 from 
	~pip._internal.cli.base_command
 import 
Command

26 
commands_order
 = [

27 
InstallCommand
 ,

28 
DownloadCommand
 ,

29 
UninstallCommand
 ,

30 
FreezeCommand
 ,

31 
ListCommand
 ,

32 
ShowCommand
 ,

33 
CheckCommand
 ,

34 
ConfigurationCommand
 ,

35 
SearchCommand
 ,

36 
WheelCommand
 ,

37 
HashCommand
 ,

38 
CompletionCommand
 ,

39 
HelpCommand
 ,

42 
commands_dict
 = { 
c
 . 
name
 : 
c
 for 
c
 in 
commands_order
 }

45 def 
	$get_summaries
 ( 
ordered
 = True ) :

48 if 
ordered
 :

49 
cmditems
 = 
_sort_commands
 ( 
commands_dict
 , 
commands_order
 )

51 
cmditems
 = 
commands_dict
 . 
items
 ( )

53 for 
name
 , 
command_class
 in 
cmditems
 :

54 yield ( 
name
 , 
command_class
 . 
summary
 ) 
	}

57 def 
	$get_similar_commands
 ( 
name
 ) :

59 from 
	~difflib
 import 
get_close_matches

61 
name
 = 
name
 . 
lower
 ( )

63 
close_commands
 = 
get_close_matches
 ( 
name
 , 
commands_dict
 . 
keys
 ( ) )

65 if 
close_commands
 :

66 return 
close_commands
 [ 0 ]

68 return False 
	}

71 def 
	$_sort_commands
 ( 
cmddict
 , 
order
 ) :

72 def 
keyfn
 ( 
key
 ) :

74 return 
order
 . 
index
 ( 
key
 [ 1 ] )

75 except 
ValueError
 :

79 return 
sorted
 ( 
cmddict
 . 
items
 ( ) , 
key
 = 
keyfn
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/download.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

6 from 
	~pip._internal.cli
 import 
cmdoptions

7 from 
	~pip._internal.cli.base_command
 import 
RequirementCommand

8 from 
	~pip._internal.operations.prepare
 import 
RequirementPreparer

9 from 
	~pip._internal.req
 import 
RequirementSet

10 from 
	~pip._internal.req.req_tracker
 import 
RequirementTracker

11 from 
	~pip._internal.resolve
 import 
Resolver

12 from 
	~pip._internal.utils.filesystem
 import 
check_path_owner

13 from 
	~pip._internal.utils.misc
 import 
ensure_dir
 , 
normalize_path

14 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

16 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

19 class 
	cDownloadCommand
 ( 
RequirementCommand
 ) :

31 
name
 = 'download'

33 
usage
 = """\n      %prog [options] <requirement specifier> [package-index-options] ...\n      %prog [options] -r <requirements file> [package-index-options] ...\n      %prog [options] <vcs project url> ...\n      %prog [options] <local project path> ...\n      %prog [options] <archive url/path> ..."""

40 
summary
 = 'Download packages.'

42 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

43 
super
 ( 
DownloadCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

45 
cmd_opts
 = 
self
 . 
cmd_opts

47 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
constraints
 ( ) )

48 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
requirements
 ( ) )

49 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
build_dir
 ( ) )

50 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_deps
 ( ) )

51 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
global_options
 ( ) )

52 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_binary
 ( ) )

53 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
only_binary
 ( ) )

54 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
prefer_binary
 ( ) )

55 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
src
 ( ) )

56 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
pre
 ( ) )

57 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_clean
 ( ) )

58 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
require_hashes
 ( ) )

59 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
progress_bar
 ( ) )

60 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
no_build_isolation
 ( ) )

62 
cmd_opts
 . 
add_option
 ( '-d'

64 
dest
 = 'download_dir' ,

65 
metavar
 = 'dir' ,

66 
default
 = 
os
 . 
curdir
 ,

67 
help
 = ( "Download packages into <dir>." ) ,

70 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
platform
 ( ) )

71 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
python_version
 ( ) )

72 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
implementation
 ( ) )

73 
cmd_opts
 . 
add_option
 ( 
cmdoptions
 . 
abi
 ( ) )

75 
index_opts
 = 
cmdoptions
 . 
make_option_group
 (

76 
cmdoptions
 . 
index_group
 ,

77 
self
 . 
parser
 ,

80 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
index_opts
 )

81 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
cmd_opts
 ) 
	}

83 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

84 
options
 . 
ignore_installed
 = True

87 
options
 . 
editables
 = [ ]

89 if 
options
 . 
python_version
 :

90 
python_versions
 = [ 
options
 . 
python_version
 ]

92 
python_versions
 = None

94 
cmdoptions
 . 
check_dist_restriction
 ( 
options
 )

96 
options
 . 
src_dir
 = 
os
 . 
path
 . 
abspath
 ( 
options
 . 
src_dir
 )

97 
options
 . 
download_dir
 = 
normalize_path
 ( 
options
 . 
download_dir
 )

99 
ensure_dir
 ( 
options
 . 
download_dir
 )

101 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

102 
finder
 = 
self
 . 
_build_package_finder
 (

103 
options
 = 
options
 ,

104 
session
 = 
session
 ,

105 
platform
 = 
options
 . 
platform
 ,

106 
python_versions
 = 
python_versions
 ,

107 
abi
 = 
options
 . 
abi
 ,

108 
implementation
 = 
options
 . 
implementation
 ,

110 
build_delete
 = ( not ( 
options
 . 
no_clean
 or 
options
 . 
build_dir
 ) )

111 if 
options
 . 
cache_dir
 and not 
check_path_owner
 ( 
options
 . 
cache_dir
 ) :

112 
logger
 . 
warning
 ( "The directory '%s' or its parent directory is not owned " "by the current user and caching wheels has been " "disabled. check the permissions and owner of that " "directory. If executing pip with sudo, you may want " "sudo's -H flag."

118 
options
 . 
cache_dir
 ,

120 
options
 . 
cache_dir
 = None

122 with 
RequirementTracker
 ( ) as 
req_tracker
 , 
TempDirectory
 (

123 
options
 . 
build_dir
 , 
delete
 = 
build_delete
 , 
kind
 = "download"

124 ) as 
directory
 :

126 
requirement_set
 = 
RequirementSet
 (

127 
require_hashes
 = 
options
 . 
require_hashes
 ,

129 
self
 . 
populate_requirement_set
 (

130 
requirement_set
 ,

131 
args
 ,

132 
options
 ,

133 
finder
 ,

134 
session
 ,

135 
self
 . 
name
 ,

139 
preparer
 = 
RequirementPreparer
 (

140 
build_dir
 = 
directory
 . 
path
 ,

141 
src_dir
 = 
options
 . 
src_dir
 ,

142 
download_dir
 = 
options
 . 
download_dir
 ,

143 
wheel_download_dir
 = None ,

144 
progress_bar
 = 
options
 . 
progress_bar
 ,

145 
build_isolation
 = 
options
 . 
build_isolation
 ,

146 
req_tracker
 = 
req_tracker
 ,

149 
resolver
 = 
Resolver
 (

150 
preparer
 = 
preparer
 ,

151 
finder
 = 
finder
 ,

152 
session
 = 
session
 ,

153 
wheel_cache
 = None ,

154 
use_user_site
 = False ,

155 
upgrade_strategy
 = "to-satisfy-only" ,

156 
force_reinstall
 = False ,

157 
ignore_dependencies
 = 
options
 . 
ignore_dependencies
 ,

158 
ignore_requires_python
 = False ,

159 
ignore_installed
 = True ,

160 
isolated
 = 
options
 . 
isolated_mode
 ,

162 
resolver
 . 
resolve
 ( 
requirement_set
 )

164 
downloaded
 = ' ' . 
join
 ( [

165 
req
 . 
name
 for 
req
 in 
requirement_set
 . 
successfully_downloaded

167 if 
downloaded
 :

168 
logger
 . 
info
 ( 'Successfully downloaded %s' , 
downloaded
 )

171 if not 
options
 . 
no_clean
 :

172 
requirement_set
 . 
cleanup_files
 ( )

174 return 
requirement_set
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/freeze.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~sys

5 from 
	~pip._internal.cache
 import 
WheelCache

6 from 
	~pip._internal.cli.base_command
 import 
Command

7 from 
	~pip._internal.models.format_control
 import 
FormatControl

8 from 
	~pip._internal.operations.freeze
 import 
freeze

9 from 
	~pip._internal.utils.compat
 import 
stdlib_pkgs

11 
DEV_PKGS
 = { 'pip' , 'setuptools' , 'distribute' , 'wheel' }

14 class 
	cFreezeCommand
 ( 
Command
 ) :

20 
name
 = 'freeze'

21 
usage
 = """\n      %prog [options]"""

23 
summary
 = 'Output installed packages in requirements format.'

24 
log_streams
 = ( "ext://sys.stderr" , "ext://sys.stderr" )

26 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

27 
super
 ( 
FreezeCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

29 
self
 . 
cmd_opts
 . 
add_option
 ( '-r'

31 
dest
 = 'requirements' ,

32 
action
 = 'append' ,

33 
default
 = [ ] ,

34 
metavar
 = 'file' ,

35 
help
 = "Use the order in the given requirements file and its " "comments when generating output. This option can be " "used multiple times."

38 
self
 . 
cmd_opts
 . 
add_option
 ( '-f'

40 
dest
 = 'find_links' ,

41 
action
 = 'append' ,

42 
default
 = [ ] ,

43 
metavar
 = 'URL' ,

44 
help
 = 'URL for finding packages, which will be added to the ' 'output.'

46 
self
 . 
cmd_opts
 . 
add_option
 ( '-l'

48 
dest
 = 'local' ,

49 
action
 = 'store_true' ,

50 
default
 = False ,

51 
help
 = 'If in a virtualenv that has global access, do not output ' 'globally-installed packages.'

53 
self
 . 
cmd_opts
 . 
add_option
 ( '--user'

55 
dest
 = 'user' ,

56 
action
 = 'store_true' ,

57 
default
 = False ,

58 
help
 = 'Only output packages installed in user-site.' )

59 
self
 . 
cmd_opts
 . 
add_option
 ( '--all'

61 
dest
 = 'freeze_all' ,

62 
action
 = 'store_true' ,

63 
help
 = 'Do not skip these packages in the output:' ' %s'

64 % ', ' . 
join
 ( 
DEV_PKGS
 ) )

65 
self
 . 
cmd_opts
 . 
add_option
 ( '--exclude-editable'

67 
dest
 = 'exclude_editable' ,

68 
action
 = 'store_true' ,

69 
help
 = 'Exclude editable package from output.' )

71 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

73 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

74 
format_control
 = 
FormatControl
 ( 
set
 ( ) , 
set
 ( ) )

75 
wheel_cache
 = 
WheelCache
 ( 
options
 . 
cache_dir
 , 
format_control
 )

76 
skip
 = 
set
 ( 
stdlib_pkgs
 )

77 if not 
options
 . 
freeze_all
 :

78 
skip
 . 
update
 ( 
DEV_PKGS
 )

80 
freeze_kwargs
 = 
dict
 (

81 
requirement
 = 
options
 . 
requirements
 ,

82 
find_links
 = 
options
 . 
find_links
 ,

83 
local_only
 = 
options
 . 
local
 ,

84 
user_only
 = 
options
 . 
user
 ,

85 
skip_regex
 = 
options
 . 
skip_requirements_regex
 ,

86 
isolated
 = 
options
 . 
isolated_mode
 ,

87 
wheel_cache
 = 
wheel_cache
 ,

88 
skip
 = 
skip
 ,

89 
exclude_editable
 = 
options
 . 
exclude_editable
 ,

93 for 
line
 in 
freeze
 ( ** 
freeze_kwargs
 ) :

94 
sys
 . 
stdout
 . 
write
 ( 
line
 + '\n' )

96 
wheel_cache
 . 
cleanup
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/commands/uninstall.py

1 from 
	~__future__
 import 
absolute_import

3 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

5 from 
	~pip._internal.cli.base_command
 import 
Command

6 from 
	~pip._internal.exceptions
 import 
InstallationError

7 from 
	~pip._internal.req
 import 
parse_requirements

8 from 
	~pip._internal.req.constructors
 import 
install_req_from_line

9 from 
	~pip._internal.utils.misc
 import 
protect_pip_from_modification_on_windows

12 class 
	cUninstallCommand
 ( 
Command
 ) :

22 
name
 = 'uninstall'

23 
usage
 = """\n      %prog [options] <package> ...\n      %prog [options] -r <requirements file> ..."""

26 
summary
 = 'Uninstall packages.'

28 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kw
 ) :

29 
super
 ( 
UninstallCommand
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kw
 )

30 
self
 . 
cmd_opts
 . 
add_option
 ( '-r'

32 
dest
 = 'requirements' ,

33 
action
 = 'append' ,

34 
default
 = [ ] ,

35 
metavar
 = 'file' ,

36 
help
 = 'Uninstall all the packages listed in the given requirements ' 'file.  This option can be used multiple times.'

39 
self
 . 
cmd_opts
 . 
add_option
 ( '-y'

41 
dest
 = 'yes' ,

42 
action
 = 'store_true' ,

43 
help
 = "Don't ask for confirmation of uninstall deletions." )

45 
self
 . 
parser
 . 
insert_option_group
 ( 0 , 
self
 . 
cmd_opts
 ) 
	}

47 def 
	$run
 ( 
self
 , 
options
 , 
args
 ) :

48 with 
self
 . 
_build_session
 ( 
options
 ) as 
session
 :

49 
reqs_to_uninstall
 = { }

50 for 
name
 in 
args
 :

51 
req
 = 
install_req_from_line
 (

52 
name
 , 
isolated
 = 
options
 . 
isolated_mode
 ,

54 if 
req
 . 
name
 :

55 
reqs_to_uninstall
 [ 
canonicalize_name
 ( 
req
 . 
name
 ) ] = 
req

56 for 
filename
 in 
options
 . 
requirements
 :

57 for 
req
 in 
parse_requirements
 (

58 
filename
 ,

59 
options
 = 
options
 ,

60 
session
 = 
session
 ) :

61 if 
req
 . 
name
 :

62 
reqs_to_uninstall
 [ 
canonicalize_name
 ( 
req
 . 
name
 ) ] = 
req

63 if not 
reqs_to_uninstall
 :

64 raise 
InstallationError
 ( 'You must give at least one requirement to %(name)s (see ' '"pip help %(name)s")'

66 % 
dict
 ( 
name
 = 
self
 . 
name
 )

69 
protect_pip_from_modification_on_windows
 (

70 
modifying_pip
 = "pip" in 
reqs_to_uninstall

73 for 
req
 in 
reqs_to_uninstall
 . 
values
 ( ) :

74 
uninstall_pathset
 = 
req
 . 
uninstall
 (

75 
auto_confirm
 = 
options
 . 
yes
 , 
verbose
 = 
self
 . 
verbosity
 > 0 ,

77 if 
uninstall_pathset
 :

78 
uninstall_pathset
 . 
commit
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/configuration.py

14 import 
	~locale

15 import 
	~logging

16 import 
	~os

18 from 
	~pip._vendor
 import 
six

19 from 
	~pip._vendor.six.moves
 import 
configparser

21 from 
	~pip._internal.exceptions
 import (

22 
ConfigurationError
 , 
ConfigurationFileCouldNotBeLoaded
 ,

24 from 
	~pip._internal.locations
 import (

25 
legacy_config_file
 , 
new_config_file
 , 
running_under_virtualenv
 ,

26 
site_config_files
 , 
venv_config_file
 ,

28 from 
	~pip._internal.utils.misc
 import 
ensure_dir
 , 
enum

29 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

31 if 
MYPY_CHECK_RUNNING
 :

32 from 
	~typing
 import (

33 
Any
 , 
Dict
 , 
Iterable
 , 
List
 , 
NewType
 , 
Optional
 , 
Tuple

36 
RawConfigParser
 = 
configparser
 . 
RawConfigParser

37 
Kind
 = 
NewType
 ( "Kind" , 
str
 )

39 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

43 def 
	$_normalize_name
 ( 
name
 ) :

47 
name
 = 
name
 . 
lower
 ( ) . 
replace
 ( '_' , '-' )

48 if 
name
 . 
startswith
 ( '--' ) :

49 
name
 = 
name
 [ 2 : ]

50 return 
name
 
	}

53 def 
	$_disassemble_key
 ( 
name
 ) :

55 return 
name
 . 
split
 ( "." , 1 ) 
	}

59 
kinds
 = 
enum
 (

60 
USER
 = "user" ,

61 
GLOBAL
 = "global" ,

62 
VENV
 = "venv" ,

63 
ENV
 = "env" ,

64 
ENV_VAR
 = "env-var" ,

68 class 
	cConfiguration
 ( 
object
 ) :

82 def 
	$__init__
 ( 
self
 , 
isolated
 , 
load_only
 = None ) :

84 
super
 ( 
Configuration
 , 
self
 ) . 
__init__
 ( )

86 
_valid_load_only
 = [ 
kinds
 . 
USER
 , 
kinds
 . 
GLOBAL
 , 
kinds
 . 
VENV
 , None ]

87 if 
load_only
 not in 
_valid_load_only
 :

88 raise 
ConfigurationError
 ( "Got invalid value for load_only - should be one of {}"

89 . 
format
 ( ", "

90 . 
join
 ( 
map
 ( 
repr
 , 
_valid_load_only
 [ : - 1 ] ) )

93 
self
 . 
isolated
 = 
isolated

94 
self
 . 
load_only
 = 
load_only

97 
self
 . 
_override_order
 = [

98 
kinds
 . 
GLOBAL
 , 
kinds
 . 
USER
 , 
kinds
 . 
VENV
 , 
kinds
 . 
ENV
 , 
kinds
 . 
ENV_VAR

101 
self
 . 
_ignore_env_names
 = [ "version" , "help" ]

104 
self
 . 
_parsers
 = {

105 
variant
 : [ ] for 
variant
 in 
self
 . 
_override_order

107 
self
 . 
_config
 = {

108 
variant
 : { } for 
variant
 in 
self
 . 
_override_order

110 
self
 . 
_modified_parsers
 = [ ] 
	}

112 def 
	$load
 ( 
self
 ) :

116 
self
 . 
_load_config_files
 ( )

117 if not 
self
 . 
isolated
 :

118 
self
 . 
_load_environment_vars
 ( ) 
	}

120 def 
	$get_file_to_edit
 ( 
self
 ) :

124 assert 
self
 . 
load_only
 is not None , "Need to be specified a file to be editing"

128 return 
self
 . 
_get_parser_to_modify
 ( ) [ 0 ]

129 except 
IndexError
 :

130 return None 
	}

132 def 
	$items
 ( 
self
 ) :

137 return 
self
 . 
_dictionary
 . 
items
 ( ) 
	}

139 def 
	$get_value
 ( 
self
 , 
key
 ) :

144 return 
self
 . 
_dictionary
 [ 
key
 ]

145 except 
KeyError
 :

146 raise 
ConfigurationError
 ( "No such key - {}" . 
format
 ( 
key
 ) ) 
	}

148 def 
	$set_value
 ( 
self
 , 
key
 , 
value
 ) :

152 
self
 . 
_ensure_have_load_only
 ( )

154 
fname
 , 
parser
 = 
self
 . 
_get_parser_to_modify
 ( )

156 if 
parser
 is not None :

157 
section
 , 
name
 = 
_disassemble_key
 ( 
key
 )

160 if not 
parser
 . 
has_section
 ( 
section
 ) :

161 
parser
 . 
add_section
 ( 
section
 )

162 
parser
 . 
set
 ( 
section
 , 
name
 , 
value
 )

164 
self
 . 
_config
 [ 
self
 . 
load_only
 ] [ 
key
 ] = 
value

165 
self
 . 
_mark_as_modified
 ( 
fname
 , 
parser
 ) 
	}

167 def 
	$unset_value
 ( 
self
 , 
key
 ) :

171 
self
 . 
_ensure_have_load_only
 ( )

173 if 
key
 not in 
self
 . 
_config
 [ 
self
 . 
load_only
 ] :

174 raise 
ConfigurationError
 ( "No such key - {}" . 
format
 ( 
key
 ) )

176 
fname
 , 
parser
 = 
self
 . 
_get_parser_to_modify
 ( )

178 if 
parser
 is not None :

179 
section
 , 
name
 = 
_disassemble_key
 ( 
key
 )

182 
modified_something
 = False

183 if 
parser
 . 
has_section
 ( 
section
 ) :

185 
modified_something
 = 
parser
 . 
remove_option
 ( 
section
 , 
name
 )

187 if 
modified_something
 :

189 
section_iter
 = 
iter
 ( 
parser
 . 
items
 ( 
section
 ) )

191 
val
 = 
six
 . 
next
 ( 
section_iter
 )

192 except 
StopIteration
 :

193 
val
 = None

195 if 
val
 is None :

196 
parser
 . 
remove_section
 ( 
section
 )

198 
self
 . 
_mark_as_modified
 ( 
fname
 , 
parser
 )

200 raise 
ConfigurationError
 ( "Fatal Internal error [id=1]. Please report as a bug."

204 del 
self
 . 
_config
 [ 
self
 . 
load_only
 ] [ 
key
 ] 
	}

206 def 
	$save
 ( 
self
 ) :

210 
self
 . 
_ensure_have_load_only
 ( )

212 for 
fname
 , 
parser
 in 
self
 . 
_modified_parsers
 :

213 
logger
 . 
info
 ( "Writing to %s" , 
fname
 )

216 
ensure_dir
 ( 
os
 . 
path
 . 
dirname
 ( 
fname
 ) )

218 with 
open
 ( 
fname
 , "w" ) as 
f
 :

219 
parser
 . 
write
 ( 
f
 ) 
	}

225 def 
	$_ensure_have_load_only
 ( 
self
 ) :

227 if 
self
 . 
load_only
 is None :

228 raise 
ConfigurationError
 ( "Needed a specific file to be modifying." )

229 
logger
 . 
debug
 ( "Will be working with %s variant only" , 
self
 . 
load_only
 ) 
	}

231 @ 
property

232 def 
	$_dictionary
 ( 
self
 ) :

238 
retval
 = { }

240 for 
variant
 in 
self
 . 
_override_order
 :

241 
retval
 . 
update
 ( 
self
 . 
_config
 [ 
variant
 ] )

243 return 
retval
 
	}

245 def 
	$_load_config_files
 ( 
self
 ) :

249 
config_files
 = 
dict
 ( 
self
 . 
_iter_config_files
 ( ) )

250 if 
config_files
 [ 
kinds
 . 
ENV
 ] [ 0 : 1 ] == [ 
os
 . 
devnull
 ] :

251 
logger
 . 
debug
 ( "Skipping loading configuration files due to " "environment's PIP_CONFIG_FILE being os.devnull"

257 for 
variant
 , 
files
 in 
config_files
 . 
items
 ( ) :

258 for 
fname
 in 
files
 :

261 if 
self
 . 
load_only
 is not None and 
variant
 != 
self
 . 
load_only
 :

262 
logger
 . 
debug
 ( "Skipping file '%s' (variant: %s)"

263 , 
fname
 , 
variant

267 
parser
 = 
self
 . 
_load_file
 ( 
variant
 , 
fname
 )

270 
self
 . 
_parsers
 [ 
variant
 ] . 
append
 ( ( 
fname
 , 
parser
 ) ) 
	}

272 def 
	$_load_file
 ( 
self
 , 
variant
 , 
fname
 ) :

274 
logger
 . 
debug
 ( "For variant '%s', will try loading '%s'" , 
variant
 , 
fname
 )

275 
parser
 = 
self
 . 
_construct_parser
 ( 
fname
 )

277 for 
section
 in 
parser
 . 
sections
 ( ) :

278 
items
 = 
parser
 . 
items
 ( 
section
 )

279 
self
 . 
_config
 [ 
variant
 ] . 
update
 ( 
self
 . 
_normalized_keys
 ( 
section
 , 
items
 ) )

281 return 
parser
 
	}

283 def 
	$_construct_parser
 ( 
self
 , 
fname
 ) :

285 
parser
 = 
configparser
 . 
RawConfigParser
 ( )

290 if 
os
 . 
path
 . 
exists
 ( 
fname
 ) :

292 
parser
 . 
read
 ( 
fname
 )

293 except 
UnicodeDecodeError
 :

295 raise 
ConfigurationFileCouldNotBeLoaded
 (

296 
reason
 = "contains invalid {} characters" . 
format
 (

297 
locale
 . 
getpreferredencoding
 ( False )

299 
fname
 = 
fname
 ,

301 except 
configparser
 . 
Error
 as 
error
 :

303 raise 
ConfigurationFileCouldNotBeLoaded
 ( 
error
 = 
error
 )

304 return 
parser
 
	}

306 def 
	$_load_environment_vars
 ( 
self
 ) :

310 
self
 . 
_config
 [ 
kinds
 . 
ENV_VAR
 ] . 
update
 (

311 
self
 . 
_normalized_keys
 ( ":env:" , 
self
 . 
_get_environ_vars
 ( ) )

312 ) 
	}

314 def 
	$_normalized_keys
 ( 
self
 , 
section
 , 
items
 ) :

321 
normalized
 = { }

322 for 
name
 , 
val
 in 
items
 :

323 
key
 = 
section
 + "." + 
_normalize_name
 ( 
name
 )

324 
normalized
 [ 
key
 ] = 
val

325 return 
normalized
 
	}

327 def 
	$_get_environ_vars
 ( 
self
 ) :

330 for 
key
 , 
val
 in 
os
 . 
environ
 . 
items
 ( ) :

331 
should_be_yielded
 = (

332 
key
 . 
startswith
 ( "PIP_" ) and

333 
key
 [ 4 : ] . 
lower
 ( ) not in 
self
 . 
_ignore_env_names

335 if 
should_be_yielded
 :

336 yield 
key
 [ 4 : ] . 
lower
 ( ) , 
val
 
	}

339 def 
	$_iter_config_files
 ( 
self
 ) :

348 
config_file
 = 
os
 . 
environ
 . 
get
 ( 'PIP_CONFIG_FILE' , None )

349 if 
config_file
 is not None :

350 yield 
kinds
 . 
ENV
 , [ 
config_file
 ]

352 yield 
kinds
 . 
ENV
 , [ ]

355 yield 
kinds
 . 
GLOBAL
 , 
list
 ( 
site_config_files
 )

358 
should_load_user_config
 = not 
self
 . 
isolated
 and not (

359 
config_file
 and 
os
 . 
path
 . 
exists
 ( 
config_file
 )

361 if 
should_load_user_config
 :

363 yield 
kinds
 . 
USER
 , [ 
legacy_config_file
 , 
new_config_file
 ]

366 if 
running_under_virtualenv
 ( ) :

367 yield 
kinds
 . 
VENV
 , [ 
venv_config_file
 ] 
	}

369 def 
	$_get_parser_to_modify
 ( 
self
 ) :

372 
parsers
 = 
self
 . 
_parsers
 [ 
self
 . 
load_only
 ]

373 if not 
parsers
 :

375 raise 
ConfigurationError
 ( "Fatal Internal error [id=2]. Please report as a bug."

380 return 
parsers
 [ - 1 ] 
	}

383 def 
	$_mark_as_modified
 ( 
self
 , 
fname
 , 
parser
 ) :

385 
file_parser_tuple
 = ( 
fname
 , 
parser
 )

386 if 
file_parser_tuple
 not in 
self
 . 
_modified_parsers
 :

387 
self
 . 
_modified_parsers
 . 
append
 ( 
file_parser_tuple
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/__init__.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~locale

5 import 
	~logging

6 import 
	~os

7 import 
	~warnings

9 import 
	~sys

19 from 
	~pip._vendor.urllib3.exceptions
 import 
DependencyWarning

20 
warnings
 . 
filterwarnings
 ( "ignore" , 
category
 = 
DependencyWarning
 )

27 import 
	~ssl

28 except 
ImportError
 :

32 if 
sys
 . 
platform
 == "darwin" and 
ssl
 . 
OPENSSL_VERSION_NUMBER
 < 0x1000100f :

34 from 
	~pip._vendor.urllib3.contrib
 import 
securetransport

35 except ( 
ImportError
 , 
OSError
 ) :

38 
securetransport
 . 
inject_into_urllib3
 ( )

40 from 
	~pip._internal.cli.autocompletion
 import 
autocomplete

41 from 
	~pip._internal.cli.main_parser
 import 
parse_command

42 from 
	~pip._internal.commands
 import 
commands_dict

43 from 
	~pip._internal.exceptions
 import 
PipError

44 from 
	~pip._internal.utils
 import 
deprecation

45 from 
	~pip._internal.vcs
 import 
git
 , 
mercurial
 , 
subversion
 , 
bazaar

46 from 
	~pip._vendor.urllib3.exceptions
 import 
InsecureRequestWarning

48 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

51 
warnings
 . 
filterwarnings
 ( "ignore" , 
category
 = 
InsecureRequestWarning
 )

54 def 
	$main
 ( 
args
 = None ) :

55 if 
args
 is None :

56 
args
 = 
sys
 . 
argv
 [ 1 : ]

59 
deprecation
 . 
install_warning_logger
 ( )

61 
autocomplete
 ( )

64 
cmd_name
 , 
cmd_args
 = 
parse_command
 ( 
args
 )

65 except 
PipError
 as 
exc
 :

66 
sys
 . 
stderr
 . 
write
 ( "ERROR: %s" % 
exc
 )

67 
sys
 . 
stderr
 . 
write
 ( 
os
 . 
linesep
 )

68 
sys
 . 
exit
 ( 1 )

73 
locale
 . 
setlocale
 ( 
locale
 . 
LC_ALL
 , '' )

74 except 
locale
 . 
Error
 as 
e
 :

76 
logger
 . 
debug
 ( "Ignoring error %s when setting locale" , 
e
 )

77 
command
 = 
commands_dict
 [ 
cmd_name
 ] ( 
isolated
 = ( "--isolated" in 
cmd_args
 ) )

78 return 
command
 . 
main
 ( 
cmd_args
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/models.py

4 import 
	~operator

7 class 
	cKeyBasedCompareMixin
 ( 
object
 ) :

11 def 
	$__init__
 ( 
self
 , 
key
 , 
defining_class
 ) :

12 
self
 . 
_compare_key
 = 
key

13 
self
 . 
_defining_class
 = 
defining_class
 
	}

15 def 
	$__hash__
 ( 
self
 ) :

16 return 
hash
 ( 
self
 . 
_compare_key
 ) 
	}

18 def 
	$__lt__
 ( 
self
 , 
other
 ) :

19 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__lt__
 ) 
	}

21 def 
	$__le__
 ( 
self
 , 
other
 ) :

22 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__le__
 ) 
	}

24 def 
	$__gt__
 ( 
self
 , 
other
 ) :

25 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__gt__
 ) 
	}

27 def 
	$__ge__
 ( 
self
 , 
other
 ) :

28 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__ge__
 ) 
	}

30 def 
	$__eq__
 ( 
self
 , 
other
 ) :

31 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__eq__
 ) 
	}

33 def 
	$__ne__
 ( 
self
 , 
other
 ) :

34 return 
self
 . 
_compare
 ( 
other
 , 
operator
 . 
__ne__
 ) 
	}

36 def 
	$_compare
 ( 
self
 , 
other
 , 
method
 ) :

37 if not 
isinstance
 ( 
other
 , 
self
 . 
_defining_class
 ) :

38 return 
NotImplemented

40 return 
method
 ( 
self
 . 
_compare_key
 , 
other
 . 
_compare_key
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/misc.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~contextlib

4 import 
	~errno

5 import 
	~io

6 import 
	~locale

9 import 
	~logging
 as 
std_logging

10 import 
	~os

11 import 
	~posixpath

12 import 
	~re

13 import 
	~shutil

14 import 
	~stat

15 import 
	~subprocess

16 import 
	~sys

17 import 
	~tarfile

18 import 
	~zipfile

19 from 
	~collections
 import 
deque

21 from 
	~pip._vendor
 import 
pkg_resources

24 from 
	~pip._vendor.retrying
 import 
retry

25 from 
	~pip._vendor.six
 import 
PY2

26 from 
	~pip._vendor.six.moves
 import 
input

27 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

29 from 
	~pip._internal.exceptions
 import 
CommandError
 , 
InstallationError

30 from 
	~pip._internal.locations
 import (

31 
running_under_virtualenv
 , 
site_packages
 , 
user_site
 , 
virtualenv_no_global
 ,

32 
write_delete_marker_file
 ,

34 from 
	~pip._internal.utils.compat
 import (

35 
WINDOWS
 , 
console_to_str
 , 
expanduser
 , 
stdlib_pkgs
 ,

38 if 
PY2
 :

39 from 
	~io
 import 
BytesIO
 as 
StringIO

41 from 
	~io
 import 
StringIO

43 
__all__
 = [ 'rmtree' , 'display_path' , 'backup_dir' , 'ask'

56 
logger
 = 
std_logging
 . 
getLogger
 ( 
__name__
 )

58 
BZ2_EXTENSIONS
 = ( '.tar.bz2' , '.tbz' )

59 
XZ_EXTENSIONS
 = ( '.tar.xz' , '.txz' , '.tlz' , '.tar.lz' , '.tar.lzma' )

60 
ZIP_EXTENSIONS
 = ( '.zip' , '.whl' )

61 
TAR_EXTENSIONS
 = ( '.tar.gz' , '.tgz' , '.tar' )

62 
ARCHIVE_EXTENSIONS
 = (

63 
ZIP_EXTENSIONS
 + 
BZ2_EXTENSIONS
 + 
TAR_EXTENSIONS
 + 
XZ_EXTENSIONS
 )

64 
SUPPORTED_EXTENSIONS
 = 
ZIP_EXTENSIONS
 + 
TAR_EXTENSIONS

66 import 
	~bz2

67 
SUPPORTED_EXTENSIONS
 += 
BZ2_EXTENSIONS

68 except 
ImportError
 :

69 
logger
 . 
debug
 ( 'bz2 module is not available' )

73 import 
	~lzma

74 
SUPPORTED_EXTENSIONS
 += 
XZ_EXTENSIONS

75 except 
ImportError
 :

76 
logger
 . 
debug
 ( 'lzma module is not available' )

79 def 
	$import_or_raise
 ( 
pkg_or_module_string
 , 
ExceptionType
 , * 
args
 , ** 
kwargs
 ) :

81 return 
__import__
 ( 
pkg_or_module_string
 )

82 except 
ImportError
 :

83 raise 
ExceptionType
 ( * 
args
 , ** 
kwargs
 ) 
	}

86 def 
	$ensure_dir
 ( 
path
 ) :

89 
os
 . 
makedirs
 ( 
path
 )

90 except 
OSError
 as 
e
 :

91 if 
e
 . 
errno
 != 
errno
 . 
EEXIST
 :

92 raise 
	}

95 def 
	$get_prog
 ( ) :

97 
prog
 = 
os
 . 
path
 . 
basename
 ( 
sys
 . 
argv
 [ 0 ] )

98 if 
prog
 in ( '__main__.py' , '-c' ) :

99 return "%s -m pip" % 
sys
 . 
executable

101 return 
prog

102 except ( 
AttributeError
 , 
TypeError
 , 
IndexError
 ) :

104 return 'pip' 
	}

108 @ 
	`retry
 ( 
stop_max_delay
 = 3000 , 
wait_fixed
 = 500 )

109 def 
	$rmtree
 ( 
dir
 , 
ignore_errors
 = False ) :

110 
shutil
 . 
rmtree
 ( 
dir
 , 
ignore_errors
 = 
ignore_errors
 ,

111 
onerror
 = 
rmtree_errorhandler
 ) 
	}

114 def 
	$rmtree_errorhandler
 ( 
func
 , 
path
 , 
exc_info
 ) :

119 if 
os
 . 
stat
 ( 
path
 ) . 
st_mode
 & 
stat
 . 
S_IREAD
 :

121 
os
 . 
chmod
 ( 
path
 , 
stat
 . 
S_IWRITE
 )

123 
func
 ( 
path
 )

126 raise 
	}

129 def 
	$display_path
 ( 
path
 ) :

132 
path
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
abspath
 ( 
path
 ) )

133 if 
sys
 . 
version_info
 [ 0 ] == 2 :

134 
path
 = 
path
 . 
decode
 ( 
sys
 . 
getfilesystemencoding
 ( ) , 'replace' )

135 
path
 = 
path
 . 
encode
 ( 
sys
 . 
getdefaultencoding
 ( ) , 'replace' )

136 if 
path
 . 
startswith
 ( 
os
 . 
getcwd
 ( ) + 
os
 . 
path
 . 
sep
 ) :

137 
path
 = '.' + 
path
 [ 
len
 ( 
os
 . 
getcwd
 ( ) ) : ]

138 return 
path
 
	}

141 def 
	$backup_dir
 ( 
dir
 , 
ext
 = '.bak' ) :

144 
n
 = 1

145 
extension
 = 
ext

146 while 
os
 . 
path
 . 
exists
 ( 
dir
 + 
extension
 ) :

147 
n
 += 1

148 
extension
 = 
ext
 + 
str
 ( 
n
 )

149 return 
dir
 + 
extension
 
	}

152 def 
	$ask_path_exists
 ( 
message
 , 
options
 ) :

153 for 
action
 in 
os
 . 
environ
 . 
get
 ( 'PIP_EXISTS_ACTION' , '' ) . 
split
 ( ) :

154 if 
action
 in 
options
 :

155 return 
action

156 return 
ask
 ( 
message
 , 
options
 ) 
	}

159 def 
	$ask
 ( 
message
 , 
options
 ) :

162 if 
os
 . 
environ
 . 
get
 ( 'PIP_NO_INPUT' ) :

163 raise 
Exception
 ( 'No input was expected ($PIP_NO_INPUT set); question: %s'

165 
message

167 
response
 = 
input
 ( 
message
 )

168 
response
 = 
response
 . 
strip
 ( ) . 
lower
 ( )

169 if 
response
 not in 
options
 :

170 
print
 ( 'Your response (%r) was not one of the expected responses: ' '%s'

172 % ( 
response
 , ', ' . 
join
 ( 
options
 ) )

175 return 
response
 
	}

178 def 
	$format_size
 ( 
bytes
 ) :

179 if 
bytes
 > 1000 * 1000 :

180 return '%.1fMB' % ( 
bytes
 / 1000.0 / 1000 )

181 elif 
bytes
 > 10 * 1000 :

182 return '%ikB' % ( 
bytes
 / 1000 )

183 elif 
bytes
 > 1000 :

184 return '%.1fkB' % ( 
bytes
 / 1000.0 )

186 return '%ibytes' % 
bytes
 
	}

189 def 
	$is_installable_dir
 ( 
path
 ) :

192 if not 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

194 
setup_py
 = 
os
 . 
path
 . 
join
 ( 
path
 , 'setup.py' )

195 if 
os
 . 
path
 . 
isfile
 ( 
setup_py
 ) :

197 
pyproject_toml
 = 
os
 . 
path
 . 
join
 ( 
path
 , 'pyproject.toml' )

198 if 
os
 . 
path
 . 
isfile
 ( 
pyproject_toml
 ) :

200 return False 
	}

203 def 
	$is_svn_page
 ( 
html
 ) :

207 return ( 
re
 . 
search
 ( r'<title>[^<]*Revision \d+:' , 
html
 ) and

208 
re
 . 
search
 ( r'Powered by (?:<a[^>]*?>)?Subversion' , 
html
 , 
re
 . 
I
 ) ) 
	}

211 def 
	$file_contents
 ( 
filename
 ) :

212 with 
open
 ( 
filename
 , 'rb' ) as 
fp
 :

213 return 
fp
 . 
read
 ( ) . 
decode
 ( 'utf-8' ) 
	}

216 def 
	$read_chunks
 ( 
file
 , 
size
 = 
io
 . 
DEFAULT_BUFFER_SIZE
 ) :

219 
chunk
 = 
file
 . 
read
 ( 
size
 )

220 if not 
chunk
 :

222 yield 
chunk
 
	}

225 def 
	$split_leading_dir
 ( 
path
 ) :

226 
path
 = 
path
 . 
lstrip
 ( '/' ) . 
lstrip
 ( '\\' )

227 if '/' in 
path
 and ( ( '\\' in 
path
 and 
path
 . 
find
 ( '/' ) < 
path
 . 
find
 ( '\\' ) ) or '\\'

228 not in 
path
 ) :

229 return 
path
 . 
split
 ( '/' , 1 )

230 elif '\\' in 
path
 :

231 return 
path
 . 
split
 ( '\\' , 1 )

233 return 
path
 , '' 
	}

236 def 
	$has_leading_dir
 ( 
paths
 ) :

239 
common_prefix
 = None

240 for 
path
 in 
paths
 :

241 
prefix
 , 
rest
 = 
split_leading_dir
 ( 
path
 )

242 if not 
prefix
 :

244 elif 
common_prefix
 is None :

245 
common_prefix
 = 
prefix

246 elif 
prefix
 != 
common_prefix
 :

248 return True 
	}

251 def 
	$normalize_path
 ( 
path
 , 
resolve_symlinks
 = True ) :

256 
path
 = 
expanduser
 ( 
path
 )

257 if 
resolve_symlinks
 :

258 
path
 = 
os
 . 
path
 . 
realpath
 ( 
path
 )

260 
path
 = 
os
 . 
path
 . 
abspath
 ( 
path
 )

261 return 
os
 . 
path
 . 
normcase
 ( 
path
 ) 
	}

264 def 
	$splitext
 ( 
path
 ) :

266 
base
 , 
ext
 = 
posixpath
 . 
splitext
 ( 
path
 )

267 if 
base
 . 
lower
 ( ) . 
endswith
 ( '.tar' ) :

268 
ext
 = 
base
 [ - 4 : ] + 
ext

269 
base
 = 
base
 [ : - 4 ]

270 return 
base
 , 
ext
 
	}

273 def 
	$renames
 ( 
old
 , 
new
 ) :

276 
head
 , 
tail
 = 
os
 . 
path
 . 
split
 ( 
new
 )

277 if 
head
 and 
tail
 and not 
os
 . 
path
 . 
exists
 ( 
head
 ) :

278 
os
 . 
makedirs
 ( 
head
 )

280 
shutil
 . 
move
 ( 
old
 , 
new
 )

282 
head
 , 
tail
 = 
os
 . 
path
 . 
split
 ( 
old
 )

283 if 
head
 and 
tail
 :

285 
os
 . 
removedirs
 ( 
head
 )

286 except 
OSError
 :

287 pass 
	}

290 def 
	$is_local
 ( 
path
 ) :

306 
path
 = 
normalize_path
 ( 
path
 )

307 
prefix
 = 
normalize_path
 ( 
sys
 . 
prefix
 )

309 if 
running_under_virtualenv
 ( ) :

310 return 
path
 . 
startswith
 ( 
normalize_path
 ( 
sys
 . 
prefix
 ) )

312 from 
	~pip._internal.locations
 import 
distutils_scheme

313 if 
path
 . 
startswith
 ( 
prefix
 ) :

314 for 
local_path
 in 
distutils_scheme
 ( "" ) . 
values
 ( ) :

315 if 
path
 . 
startswith
 ( 
normalize_path
 ( 
local_path
 ) ) :

319 return True 
	}

322 def 
	$dist_is_local
 ( 
dist
 ) :

328 return 
is_local
 ( 
dist_location
 ( 
dist
 ) ) 
	}

331 def 
	$dist_in_usersite
 ( 
dist
 ) :

335 
norm_path
 = 
normalize_path
 ( 
dist_location
 ( 
dist
 ) )

336 return 
norm_path
 . 
startswith
 ( 
normalize_path
 ( 
user_site
 ) ) 
	}

339 def 
	$dist_in_site_packages
 ( 
dist
 ) :

344 return 
normalize_path
 (

345 
dist_location
 ( 
dist
 )

346 ) . 
startswith
 ( 
normalize_path
 ( 
site_packages
 ) ) 
	}

349 def 
	$dist_is_editable
 ( 
dist
 ) :

351 for 
path_item
 in 
sys
 . 
path
 :

352 
egg_link
 = 
os
 . 
path
 . 
join
 ( 
path_item
 , 
dist
 . 
project_name
 + '.egg-link' )

353 if 
os
 . 
path
 . 
isfile
 ( 
egg_link
 ) :

355 return False 
	}

358 def 
	$get_installed_distributions
 ( 
local_only
 = True ,

359 
skip
 = 
stdlib_pkgs
 ,

360 
include_editables
 = True ,

361 
editables_only
 = False ,

362 
user_only
 = False ) :

380 if 
local_only
 :

381 
local_test
 = 
dist_is_local

383 def 
local_test
 ( 
d
 ) :

386 if 
include_editables
 :

387 def 
editable_test
 ( 
d
 ) :

390 def 
editable_test
 ( 
d
 ) :

391 return not 
dist_is_editable
 ( 
d
 )

393 if 
editables_only
 :

394 def 
editables_only_test
 ( 
d
 ) :

395 return 
dist_is_editable
 ( 
d
 )

397 def 
editables_only_test
 ( 
d
 ) :

400 if 
user_only
 :

401 
user_test
 = 
dist_in_usersite

403 def 
user_test
 ( 
d
 ) :

406 return [ 
d
 for 
d
 in 
pkg_resources
 . 
working_set

407 if 
local_test
 ( 
d
 ) and

408 
d
 . 
key
 not in 
skip
 and

409 
editable_test
 ( 
d
 ) and

410 
editables_only_test
 ( 
d
 ) and

411 
user_test
 ( 
d
 )

412 ] 
	}

415 def 
	$egg_link_path
 ( 
dist
 ) :

433 
sites
 = [ ]

434 if 
running_under_virtualenv
 ( ) :

435 if 
virtualenv_no_global
 ( ) :

436 
sites
 . 
append
 ( 
site_packages
 )

438 
sites
 . 
append
 ( 
site_packages
 )

439 if 
user_site
 :

440 
sites
 . 
append
 ( 
user_site
 )

442 if 
user_site
 :

443 
sites
 . 
append
 ( 
user_site
 )

444 
sites
 . 
append
 ( 
site_packages
 )

446 for 
site
 in 
sites
 :

447 
egglink
 = 
os
 . 
path
 . 
join
 ( 
site
 , 
dist
 . 
project_name
 ) + '.egg-link'

448 if 
os
 . 
path
 . 
isfile
 ( 
egglink
 ) :

449 return 
egglink
 
	}

452 def 
	$dist_location
 ( 
dist
 ) :

460 
egg_link
 = 
egg_link_path
 ( 
dist
 )

461 if 
egg_link
 :

462 return 
egg_link

463 return 
dist
 . 
location
 
	}

466 def 
	$current_umask
 ( ) :

468 
mask
 = 
os
 . 
umask
 ( 0 )

469 
os
 . 
umask
 ( 
mask
 )

470 return 
mask
 
	}

473 def 
	$unzip_file
 ( 
filename
 , 
location
 , 
flatten
 = True ) :

482 
ensure_dir
 ( 
location
 )

483 
zipfp
 = 
open
 ( 
filename
 , 'rb' )

485 
zip
 = 
zipfile
 . 
ZipFile
 ( 
zipfp
 , 
allowZip64
 = True )

486 
leading
 = 
has_leading_dir
 ( 
zip
 . 
namelist
 ( ) ) and 
flatten

487 for 
info
 in 
zip
 . 
infolist
 ( ) :

488 
name
 = 
info
 . 
filename

489 
data
 = 
zip
 . 
read
 ( 
name
 )

490 
fn
 = 
name

491 if 
leading
 :

492 
fn
 = 
split_leading_dir
 ( 
name
 ) [ 1 ]

493 
fn
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
fn
 )

494 
dir
 = 
os
 . 
path
 . 
dirname
 ( 
fn
 )

495 if 
fn
 . 
endswith
 ( '/' ) or 
fn
 . 
endswith
 ( '\\' ) :

497 
ensure_dir
 ( 
fn
 )

499 
ensure_dir
 ( 
dir
 )

500 
fp
 = 
open
 ( 
fn
 , 'wb' )

502 
fp
 . 
write
 ( 
data
 )

504 
fp
 . 
close
 ( )

505 
mode
 = 
info
 . 
external_attr
 >> 16

508 if 
mode
 and 
stat
 . 
S_ISREG
 ( 
mode
 ) and 
mode
 & 0o111 :

511 
os
 . 
chmod
 ( 
fn
 , ( 0o777 - 
current_umask
 ( ) | 0o111 ) )

513 
zipfp
 . 
close
 ( ) 
	}

516 def 
	$untar_file
 ( 
filename
 , 
location
 ) :

525 
ensure_dir
 ( 
location
 )

526 if 
filename
 . 
lower
 ( ) . 
endswith
 ( '.gz' ) or 
filename
 . 
lower
 ( ) . 
endswith
 ( '.tgz' ) :

527 
mode
 = 'r:gz'

528 elif 
filename
 . 
lower
 ( ) . 
endswith
 ( 
BZ2_EXTENSIONS
 ) :

529 
mode
 = 'r:bz2'

530 elif 
filename
 . 
lower
 ( ) . 
endswith
 ( 
XZ_EXTENSIONS
 ) :

531 
mode
 = 'r:xz'

532 elif 
filename
 . 
lower
 ( ) . 
endswith
 ( '.tar' ) :

533 
mode
 = 'r'

535 
logger
 . 
warning
 ( 'Cannot determine compression type for file %s'

536 , 
filename
 ,

538 
mode
 = 'r:*'

539 
tar
 = 
tarfile
 . 
open
 ( 
filename
 , 
mode
 )

542 
leading
 = 
has_leading_dir
 ( [

543 
member
 . 
name
 for 
member
 in 
tar
 . 
getmembers
 ( )

544 if 
member
 . 
name
 != 'pax_global_header'

546 for 
member
 in 
tar
 . 
getmembers
 ( ) :

547 
fn
 = 
member
 . 
name

548 if 
fn
 == 'pax_global_header' :

550 if 
leading
 :

551 
fn
 = 
split_leading_dir
 ( 
fn
 ) [ 1 ]

552 
path
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
fn
 )

553 if 
member
 . 
isdir
 ( ) :

554 
ensure_dir
 ( 
path
 )

555 elif 
member
 . 
issym
 ( ) :

557 
tar
 . 
_extract_member
 ( 
member
 , 
path
 )

558 except 
Exception
 as 
exc
 :

561 
logger
 . 
warning
 ( 'In the tar file %s the member %s is invalid: %s'

563 
filename
 , 
member
 . 
name
 , 
exc
 ,

568 
fp
 = 
tar
 . 
extractfile
 ( 
member
 )

569 except ( 
KeyError
 , 
AttributeError
 ) as 
exc
 :

572 
logger
 . 
warning
 ( 'In the tar file %s the member %s is invalid: %s'

574 
filename
 , 
member
 . 
name
 , 
exc
 ,

577 
ensure_dir
 ( 
os
 . 
path
 . 
dirname
 ( 
path
 ) )

578 with 
open
 ( 
path
 , 'wb' ) as 
destfp
 :

579 
shutil
 . 
copyfileobj
 ( 
fp
 , 
destfp
 )

580 
fp
 . 
close
 ( )

582 
tar
 . 
utime
 ( 
member
 , 
path
 )

584 if 
member
 . 
mode
 & 0o111 :

587 
os
 . 
chmod
 ( 
path
 , ( 0o777 - 
current_umask
 ( ) | 0o111 ) )

589 
tar
 . 
close
 ( ) 
	}

592 def 
	$unpack_file
 ( 
filename
 , 
location
 , 
content_type
 , 
link
 ) :

593 
filename
 = 
os
 . 
path
 . 
realpath
 ( 
filename
 )

594 if ( 
content_type
 == 'application/zip' or

595 
filename
 . 
lower
 ( ) . 
endswith
 ( 
ZIP_EXTENSIONS
 ) or

596 
zipfile
 . 
is_zipfile
 ( 
filename
 ) ) :

597 
unzip_file
 (

598 
filename
 ,

599 
location
 ,

600 
flatten
 = not 
filename
 . 
endswith
 ( '.whl' )

602 elif ( 
content_type
 == 'application/x-gzip' or

603 
tarfile
 . 
is_tarfile
 ( 
filename
 ) or

604 
filename
 . 
lower
 ( ) . 
endswith
 (

605 
TAR_EXTENSIONS
 + 
BZ2_EXTENSIONS
 + 
XZ_EXTENSIONS
 ) ) :

606 
untar_file
 ( 
filename
 , 
location
 )

607 elif ( 
content_type
 and 
content_type
 . 
startswith
 ( 'text/html' ) and

608 
is_svn_page
 ( 
file_contents
 ( 
filename
 ) ) ) :

610 from 
	~pip._internal.vcs.subversion
 import 
Subversion

611 
Subversion
 ( 'svn+' + 
link
 . 
url
 ) . 
unpack
 ( 
location
 )

615 
logger
 . 
critical
 ( 'Cannot unpack file %s (downloaded from %s, content-type: %s); ' 'cannot detect archive format'

618 
filename
 , 
location
 , 
content_type
 ,

620 raise 
InstallationError
 ( 'Cannot determine archive format of %s'

621 % 
location

622 ) 
	}

625 def 
	$call_subprocess
 ( 
cmd
 , 
show_stdout
 = True , 
cwd
 = None ,

626 
on_returncode
 = 'raise' ,

627 
command_desc
 = None ,

628 
extra_environ
 = None , 
unset_environ
 = None , 
spinner
 = None ) :

634 if 
unset_environ
 is None :

635 
unset_environ
 = [ ]

657 if 
show_stdout
 :

658 
stdout
 = None

660 
stdout
 = 
subprocess
 . 
PIPE

661 if 
command_desc
 is None :

662 
cmd_parts
 = [ ]

663 for 
part
 in 
cmd
 :

664 if ' ' in 
part
 or '\n' in 
part
 or '"' in 
part
 or "'" in 
part
 :

665 
part
 = '"%s"' % 
part
 . 
replace
 ( '"' , '\\"' )

666 
cmd_parts
 . 
append
 ( 
part
 )

667 
command_desc
 = ' ' . 
join
 ( 
cmd_parts
 )

668 
logger
 . 
debug
 ( "Running command %s" , 
command_desc
 )

669 
env
 = 
os
 . 
environ
 . 
copy
 ( )

670 if 
extra_environ
 :

671 
env
 . 
update
 ( 
extra_environ
 )

672 for 
name
 in 
unset_environ
 :

673 
env
 . 
pop
 ( 
name
 , None )

675 
proc
 = 
subprocess
 . 
Popen
 (

676 
cmd
 , 
stderr
 = 
subprocess
 . 
STDOUT
 , 
stdin
 = 
subprocess
 . 
PIPE
 ,

677 
stdout
 = 
stdout
 , 
cwd
 = 
cwd
 , 
env
 = 
env
 ,

679 
proc
 . 
stdin
 . 
close
 ( )

680 except 
Exception
 as 
exc
 :

681 
logger
 . 
critical
 ( "Error %s while executing command %s"

682 , 
exc
 , 
command_desc
 ,

685 
all_output
 = [ ]

686 if 
stdout
 is not None :

688 
line
 = 
console_to_str
 ( 
proc
 . 
stdout
 . 
readline
 ( ) )

689 if not 
line
 :

691 
line
 = 
line
 . 
rstrip
 ( )

692 
all_output
 . 
append
 ( 
line
 + '\n' )

693 if 
logger
 . 
getEffectiveLevel
 ( ) <= 
std_logging
 . 
DEBUG
 :

695 
logger
 . 
debug
 ( 
line
 )

698 if 
spinner
 is not None :

699 
spinner
 . 
spin
 ( )

701 
proc
 . 
wait
 ( )

703 if 
proc
 . 
stdout
 :

704 
proc
 . 
stdout
 . 
close
 ( )

705 if 
spinner
 is not None :

706 if 
proc
 . 
returncode
 :

707 
spinner
 . 
finish
 ( "error" )

709 
spinner
 . 
finish
 ( "done" )

710 if 
proc
 . 
returncode
 :

711 if 
on_returncode
 == 'raise' :

712 if ( 
logger
 . 
getEffectiveLevel
 ( ) > 
std_logging
 . 
DEBUG
 and

713 not 
show_stdout
 ) :

714 
logger
 . 
info
 ( 'Complete output from command %s:'

715 , 
command_desc
 ,

717 
logger
 . 
info
 ( ''

718 . 
join
 ( 
all_output
 ) + '\n----------------------------------------'

721 raise 
InstallationError
 ( 'Command "%s" failed with error code %s in %s'

723 % ( 
command_desc
 , 
proc
 . 
returncode
 , 
cwd
 ) )

724 elif 
on_returncode
 == 'warn' :

725 
logger
 . 
warning
 ( 'Command "%s" had error code %s in %s'

727 
command_desc
 , 
proc
 . 
returncode
 , 
cwd
 ,

729 elif 
on_returncode
 == 'ignore' :

732 raise 
ValueError
 ( 'Invalid value: on_returncode=%s' %

733 
repr
 ( 
on_returncode
 ) )

734 if not 
show_stdout
 :

735 return '' . 
join
 ( 
all_output
 ) 
	}

738 def 
	$read_text_file
 ( 
filename
 ) :

747 with 
open
 ( 
filename
 , 'rb' ) as 
fp
 :

748 
data
 = 
fp
 . 
read
 ( )

750 
encodings
 = [ 'utf-8' , 
locale
 . 
getpreferredencoding
 ( False ) , 'latin1' ]

751 for 
enc
 in 
encodings
 :

753 
data
 = 
data
 . 
decode
 ( 
enc
 )

754 except 
UnicodeDecodeError
 :

758 assert 
type
 ( 
data
 ) != 
bytes

759 return 
data
 
	}

762 def 
	$_make_build_dir
 ( 
build_dir
 ) :

763 
os
 . 
makedirs
 ( 
build_dir
 )

764 
write_delete_marker_file
 ( 
build_dir
 ) 
	}

767 class 
	cFakeFile
 ( 
object
 ) :

770 def 
	$__init__
 ( 
self
 , 
lines
 ) :

771 
self
 . 
_gen
 = ( 
l
 for 
l
 in 
lines
 ) 
	}

773 def 
	$readline
 ( 
self
 ) :

776 return 
next
 ( 
self
 . 
_gen
 )

777 except 
NameError
 :

778 return 
self
 . 
_gen
 . 
next
 ( )

779 except 
StopIteration
 :

780 return '' 
	}

782 def 
	$__iter__
 ( 
self
 ) :

783 return 
self
 . 
_gen
 
	}

786 class 
	cStreamWrapper
 ( 
StringIO
 ) :

788 @ 
classmethod

789 def 
	$from_stream
 ( 
cls
 , 
orig_stream
 ) :

790 
cls
 . 
orig_stream
 = 
orig_stream

791 return 
cls
 ( ) 
	}

794 @ 
property

795 def 
	$encoding
 ( 
self
 ) :

796 return 
self
 . 
orig_stream
 . 
encoding
 
	}

799 @ 
contextlib
 . 
	`contextmanager

800 def 
	$captured_output
 ( 
stream_name
 ) :

806 
orig_stdout
 = 
getattr
 ( 
sys
 , 
stream_name
 )

807 
setattr
 ( 
sys
 , 
stream_name
 , 
StreamWrapper
 . 
from_stream
 ( 
orig_stdout
 ) )

809 yield 
getattr
 ( 
sys
 , 
stream_name
 )

811 
setattr
 ( 
sys
 , 
stream_name
 , 
orig_stdout
 ) 
	}

814 def 
	$captured_stdout
 ( ) :

823 return 
captured_output
 ( 'stdout' ) 
	}

826 class 
	ccached_property
 ( 
object
 ) :

834 def 
	$__init__
 ( 
self
 , 
func
 ) :

835 
self
 . 
__doc__
 = 
getattr
 ( 
func
 , '__doc__' )

836 
self
 . 
func
 = 
func
 
	}

838 def 
	$__get__
 ( 
self
 , 
obj
 , 
cls
 ) :

839 if 
obj
 is None :

841 return 
self

842 
value
 = 
obj
 . 
__dict__
 [ 
self
 . 
func
 . 
__name__
 ] = 
self
 . 
func
 ( 
obj
 )

843 return 
value
 
	}

846 def 
	$get_installed_version
 ( 
dist_name
 , 
working_set
 = None ) :

849 
req
 = 
pkg_resources
 . 
Requirement
 . 
parse
 ( 
dist_name
 )

851 if 
working_set
 is None :

854 
working_set
 = 
pkg_resources
 . 
WorkingSet
 ( )

857 
dist
 = 
working_set
 . 
find
 ( 
req
 )

861 return 
dist
 . 
version
 if 
dist
 else None 
	}

864 def 
	$consume
 ( 
iterator
 ) :

866 
deque
 ( 
iterator
 , 
maxlen
 = 0 ) 
	}

870 def 
	$enum
 ( * 
sequential
 , ** 
named
 ) :

871 
enums
 = 
dict
 ( 
zip
 ( 
sequential
 , 
range
 ( 
len
 ( 
sequential
 ) ) ) , ** 
named
 )

872 
reverse
 = { 
value
 : 
key
 for 
key
 , 
value
 in 
enums
 . 
items
 ( ) }

873 
enums
 [ 'reverse_mapping' ] = 
reverse

874 return 
type
 ( 'Enum' , ( ) , 
enums
 ) 
	}

877 def 
	$make_vcs_requirement_url
 ( 
repo_url
 , 
rev
 , 
egg_project_name
 , 
subdir
 = None ) :

884 
req
 = '{}@{}#egg={}' . 
format
 ( 
repo_url
 , 
rev
 , 
egg_project_name
 )

885 if 
subdir
 :

886 
req
 += '&subdirectory={}' . 
format
 ( 
subdir
 )

888 return 
req
 
	}

891 def 
	$split_auth_from_netloc
 ( 
netloc
 ) :

897 if '@' not in 
netloc
 :

898 return 
netloc
 , ( None , None )

903 
auth
 , 
netloc
 = 
netloc
 . 
rsplit
 ( '@' , 1 )

904 if ':' in 
auth
 :

908 
user_pass
 = 
tuple
 ( 
auth
 . 
split
 ( ':' , 1 ) )

910 
user_pass
 = 
auth
 , None

912 return 
netloc
 , 
user_pass
 
	}

915 def 
	$remove_auth_from_url
 ( 
url
 ) :

921 
purl
 = 
urllib_parse
 . 
urlsplit
 ( 
url
 )

922 
netloc
 , 
user_pass
 = 
split_auth_from_netloc
 ( 
purl
 . 
netloc
 )

925 
url_pieces
 = (

926 
purl
 . 
scheme
 , 
netloc
 , 
purl
 . 
path
 , 
purl
 . 
query
 , 
purl
 . 
fragment

928 
surl
 = 
urllib_parse
 . 
urlunsplit
 ( 
url_pieces
 )

929 return 
surl
 
	}

932 def 
	$protect_pip_from_modification_on_windows
 ( 
modifying_pip
 ) :

938 
pip_names
 = [ "pip.exe"

940 . 
format
 ( 
sys
 . 
version_info
 [ 0 ] ) , "pip{}.{}.exe"

941 . 
format
 ( * 
sys
 . 
version_info
 [ : 2 ] )

945 
should_show_use_python_msg
 = (

946 
modifying_pip
 and

947 
WINDOWS
 and

948 
os
 . 
path
 . 
basename
 ( 
sys
 . 
argv
 [ 0 ] ) in 
pip_names

951 if 
should_show_use_python_msg
 :

952 
new_command
 = [

953 
sys
 . 
executable
 , "-m" , "pip"

954 ] + 
sys
 . 
argv
 [ 1 : ]

955 raise 
CommandError
 ( 'To modify pip, please run the following command:\n{}'

957 . 
format
 ( " " . 
join
 ( 
new_command
 ) )

958 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/logging.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~contextlib

4 import 
	~logging

5 import 
	~logging.handlers

6 import 
	~os

8 from 
	~pip._internal.utils.compat
 import 
WINDOWS

9 from 
	~pip._internal.utils.misc
 import 
ensure_dir

12 import 
	~threading

13 except 
ImportError
 :

14 import 
	~dummy_threading
 as 
threading

18 from 
	~pip._vendor
 import 
colorama

21 except 
Exception
 :

22 
colorama
 = None

25 
_log_state
 = 
threading
 . 
local
 ( )

26 
_log_state
 . 
indentation
 = 0

29 @ 
contextlib
 . 
	`contextmanager

30 def 
	$indent_log
 ( 
num
 = 2 ) :

35 
_log_state
 . 
indentation
 += 
num

39 
_log_state
 . 
indentation
 -= 
num
 
	}

42 def 
	$get_indentation
 ( ) :

43 return 
getattr
 ( 
_log_state
 , 'indentation' , 0 ) 
	}

46 class 
	cIndentingFormatter
 ( 
logging
 . 
Formatter
 ) :

48 def 
	$format
 ( 
self
 , 
record
 ) :

53 
formatted
 = 
logging
 . 
Formatter
 . 
format
 ( 
self
 , 
record
 )

54 
formatted
 = "" . 
join
 ( [

55 ( " " * 
get_indentation
 ( ) ) + 
line

56 for 
line
 in 
formatted
 . 
splitlines
 ( True )

58 return 
formatted
 
	}

61 def 
	$_color_wrap
 ( * 
colors
 ) :

62 def 
wrapped
 ( 
inp
 ) :

63 return "" . 
join
 ( 
list
 ( 
colors
 ) + [ 
inp
 , 
colorama
 . 
Style
 . 
RESET_ALL
 ] )

64 return 
wrapped
 
	}

67 class 
	cColorizedStreamHandler
 ( 
logging
 . 
StreamHandler
 ) :

70 if 
colorama
 :

71 
COLORS
 = [

73 ( 
logging
 . 
ERROR
 , 
_color_wrap
 ( 
colorama
 . 
Fore
 . 
RED
 ) ) ,

74 ( 
logging
 . 
WARNING
 , 
_color_wrap
 ( 
colorama
 . 
Fore
 . 
YELLOW
 ) ) ,

77 
COLORS
 = [ ]

79 def 
	$__init__
 ( 
self
 , 
stream
 = None , 
no_color
 = None ) :

80 
logging
 . 
StreamHandler
 . 
__init__
 ( 
self
 , 
stream
 )

81 
self
 . 
_no_color
 = 
no_color

83 if 
WINDOWS
 and 
colorama
 :

84 
self
 . 
stream
 = 
colorama
 . 
AnsiToWin32
 ( 
self
 . 
stream
 ) 
	}

86 def 
	$should_color
 ( 
self
 ) :

88 if not 
colorama
 or 
self
 . 
_no_color
 :

91 
real_stream
 = (

92 
self
 . 
stream
 if not 
isinstance
 ( 
self
 . 
stream
 , 
colorama
 . 
AnsiToWin32
 )

93 else 
self
 . 
stream
 . 
wrapped

97 if 
hasattr
 ( 
real_stream
 , "isatty" ) and 
real_stream
 . 
isatty
 ( ) :

101 if 
os
 . 
environ
 . 
get
 ( "TERM" ) == "ANSI" :

105 return False 
	}

107 def 
	$format
 ( 
self
 , 
record
 ) :

108 
msg
 = 
logging
 . 
StreamHandler
 . 
format
 ( 
self
 , 
record
 )

110 if 
self
 . 
should_color
 ( ) :

111 for 
level
 , 
color
 in 
self
 . 
COLORS
 :

112 if 
record
 . 
levelno
 >= 
level
 :

113 
msg
 = 
color
 ( 
msg
 )

116 return 
msg
 
	}

119 class 
	cBetterRotatingFileHandler
 ( 
logging
 . 
handlers
 . 
RotatingFileHandler
 ) :

121 def 
	$_open
 ( 
self
 ) :

122 
ensure_dir
 ( 
os
 . 
path
 . 
dirname
 ( 
self
 . 
baseFilename
 ) )

123 return 
logging
 . 
handlers
 . 
RotatingFileHandler
 . 
_open
 ( 
self
 ) 
	}

126 class 
	cMaxLevelFilter
 ( 
logging
 . 
Filter
 ) :

128 def 
	$__init__
 ( 
self
 , 
level
 ) :

129 
self
 . 
level
 = 
level
 
	}

131 def 
	$filter
 ( 
self
 , 
record
 ) :

132 return 
record
 . 
levelno
 < 
self
 . 
level
 
	}

135 def 
	$setup_logging
 ( 
verbosity
 , 
no_color
 , 
user_log_file
 ) :

140 if 
verbosity
 >= 1 :

141 
level
 = "DEBUG"

142 elif 
verbosity
 == - 1 :

143 
level
 = "WARNING"

144 elif 
verbosity
 == - 2 :

145 
level
 = "ERROR"

146 elif 
verbosity
 <= - 3 :

147 
level
 = "CRITICAL"

149 
level
 = "INFO"

153 
include_user_log
 = 
user_log_file
 is not None

154 if 
include_user_log
 :

155 
additional_log_file
 = 
user_log_file

156 
root_level
 = "DEBUG"

158 
additional_log_file
 = "/dev/null"

159 
root_level
 = 
level

163 
vendored_log_level
 = "WARNING" if 
level
 in [ "INFO" , "ERROR" ] else "DEBUG"

166 
log_streams
 = { "stdout"

170 
handler_classes
 = { "stream"

175 
logging
 . 
config
 . 
dictConfig
 ( { "version"

181 : 
logging
 . 
WARNING
 ,

186 : 
IndentingFormatter
 , "format"

192 : 
level
 , "class"

193 : 
handler_classes
 [ "stream" ] , "no_color"

194 : 
no_color
 , "stream"

195 : 
log_streams
 [ "stdout" ] , "filters"

201 : 
handler_classes
 [ "stream" ] , "no_color"

202 : 
no_color
 , "stream"

203 : 
log_streams
 [ "stderr" ] , "formatter"

208 : 
handler_classes
 [ "file" ] , "filename"

209 : 
additional_log_file
 , "delay"

215 : 
root_level
 , "handlers"

217 [ "user_log" ] if 
include_user_log
 else [ ]

222 : 
vendored_log_level

225 } ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/compat.py

3 from 
	~__future__
 import 
absolute_import
 , 
division

5 import 
	~codecs

6 import 
	~locale

7 import 
	~logging

8 import 
	~os

9 import 
	~shutil

10 import 
	~sys

12 from 
	~pip._vendor.six
 import 
text_type

15 import 
	~ipaddress

16 except 
ImportError
 :

18 from 
	~pip._vendor
 import 
ipaddress

19 except 
ImportError
 :

20 import 
	~ipaddr
 as 
ipaddress

21 
ipaddress
 . 
ip_address
 = 
ipaddress
 . 
IPAddress

22 
ipaddress
 . 
ip_network
 = 
ipaddress
 . 
IPNetwork

25 
__all__
 = [ "ipaddress"

32 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

34 if 
sys
 . 
version_info
 >= ( 3 , 4 ) :

35 
uses_pycache
 = True

36 from 
	~importlib.util
 import 
cache_from_source

38 import 
	~imp

41 
cache_from_source
 = 
imp
 . 
cache_from_source

42 except 
AttributeError
 :

44 
cache_from_source
 = None

46 
uses_pycache
 = 
cache_from_source
 is not None

49 if 
sys
 . 
version_info
 >= ( 3 , 5 ) :

50 
backslashreplace_decode
 = "backslashreplace"

57 def 
	$backslashreplace_decode_fn
 ( 
err
 ) :

58 
raw_bytes
 = ( 
err
 . 
object
 [ 
i
 ] for 
i
 in 
range
 ( 
err
 . 
start
 , 
err
 . 
end
 ) )

59 if 
sys
 . 
version_info
 [ 0 ] == 2 :

61 
raw_bytes
 = ( 
ord
 ( 
b
 ) for 
b
 in 
raw_bytes
 )

62 return u"" . 
join
 ( u"\\x%x" % 
c
 for 
c
 in 
raw_bytes
 ) , 
err
 . 
end
 
	}

63 
codecs
 . 
register_error
 ( "backslashreplace_decode"

65 
backslashreplace_decode_fn
 ,

67 
backslashreplace_decode
 = "backslashreplace_decode"

70 def 
	$console_to_str
 ( 
data
 ) :

84 
encoding
 = 
locale
 . 
getpreferredencoding
 ( )

85 if ( not 
encoding
 ) or 
codecs
 . 
lookup
 ( 
encoding
 ) . 
name
 == "ascii" :

86 
encoding
 = "utf-8"

91 
s
 = 
data
 . 
decode
 ( 
encoding
 )

92 except 
UnicodeDecodeError
 :

93 
logger
 . 
warning
 ( "Subprocess output does not appear to be encoded as %s"

95 
encoding
 ,

97 
s
 = 
data
 . 
decode
 ( 
encoding
 , 
errors
 = 
backslashreplace_decode
 )

111 
output_encoding
 = 
getattr
 ( 
getattr
 ( 
sys
 , "__stderr__" , None ) , "encoding"

114 if 
output_encoding
 :

115 
s
 = 
s
 . 
encode
 ( 
output_encoding
 , 
errors
 = "backslashreplace" )

116 
s
 = 
s
 . 
decode
 ( 
output_encoding
 )

118 return 
s
 
	}

121 if 
sys
 . 
version_info
 >= ( 3 , ) :

122 def 
	$native_str
 ( 
s
 , 
replace
 = False ) :

123 if 
isinstance
 ( 
s
 , 
bytes
 ) :

124 return 
s
 . 
decode
 ( 'utf-8' , 'replace' if 
replace
 else 'strict' )

125 return 
s
 
	}

128 def 
	$native_str
 ( 
s
 , 
replace
 = False ) :

130 if 
isinstance
 ( 
s
 , 
text_type
 ) :

131 return 
s
 . 
encode
 ( 'utf-8' )

132 return 
s
 
	}

135 def 
	$get_path_uid
 ( 
path
 ) :

147 if 
hasattr
 ( 
os
 , 'O_NOFOLLOW' ) :

148 
fd
 = 
os
 . 
open
 ( 
path
 , 
os
 . 
O_RDONLY
 | 
os
 . 
O_NOFOLLOW
 )

149 
file_uid
 = 
os
 . 
fstat
 ( 
fd
 ) . 
st_uid

150 
os
 . 
close
 ( 
fd
 )

153 if not 
os
 . 
path
 . 
islink
 ( 
path
 ) :

155 
file_uid
 = 
os
 . 
stat
 ( 
path
 ) . 
st_uid

158 raise 
OSError
 ( "%s is a symlink; Will not return uid for symlinks"

159 % 
path

161 return 
file_uid
 
	}

164 if 
sys
 . 
version_info
 >= ( 3 , 4 ) :

165 from 
	~importlib.machinery
 import 
EXTENSION_SUFFIXES

167 def 
	$get_extension_suffixes
 ( ) :

168 return 
EXTENSION_SUFFIXES
 
	}

170 from 
	~imp
 import 
get_suffixes

172 def 
	$get_extension_suffixes
 ( ) :

173 return [ 
suffix
 [ 0 ] for 
suffix
 in 
get_suffixes
 ( ) ] 
	}

176 def 
	$expanduser
 ( 
path
 ) :

182 
expanded
 = 
os
 . 
path
 . 
expanduser
 ( 
path
 )

183 if 
path
 . 
startswith
 ( '~/' ) and 
expanded
 . 
startswith
 ( '//' ) :

184 
expanded
 = 
expanded
 [ 1 : ]

185 return 
expanded
 
	}

193 
stdlib_pkgs
 = { "python" , "wsgiref" , "argparse" }

197 
WINDOWS
 = ( 
sys
 . 
platform
 . 
startswith
 ( "win" ) or

198 ( 
sys
 . 
platform
 == 'cli' and 
os
 . 
name
 == 'nt' ) )

201 def 
	$samefile
 ( 
file1
 , 
file2
 ) :

203 if 
hasattr
 ( 
os
 . 
path
 , 'samefile' ) :

204 return 
os
 . 
path
 . 
samefile
 ( 
file1
 , 
file2
 )

206 
path1
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
abspath
 ( 
file1
 ) )

207 
path2
 = 
os
 . 
path
 . 
normcase
 ( 
os
 . 
path
 . 
abspath
 ( 
file2
 ) )

208 return 
path1
 == 
path2
 
	}

211 if 
hasattr
 ( 
shutil
 , 'get_terminal_size' ) :

212 def 
	$get_terminal_size
 ( ) :

217 return 
tuple
 ( 
shutil
 . 
get_terminal_size
 ( ) ) 
	}

219 def 
	$get_terminal_size
 ( ) :

224 def 
ioctl_GWINSZ
 ( 
fd
 ) :

226 import 
	~fcntl

227 import 
	~termios

228 import 
	~struct

229 
cr
 = 
struct
 . 
unpack_from
 ( 'hh'

231 
fcntl
 . 
ioctl
 ( 
fd
 , 
termios
 . 
TIOCGWINSZ
 , '12345678' )

233 except 
Exception
 :

235 if 
cr
 == ( 0 , 0 ) :

237 return 
cr

238 
cr
 = 
ioctl_GWINSZ
 ( 0 ) or 
ioctl_GWINSZ
 ( 1 ) or 
ioctl_GWINSZ
 ( 2 )

239 if not 
cr
 :

241 
fd
 = 
os
 . 
open
 ( 
os
 . 
ctermid
 ( ) , 
os
 . 
O_RDONLY
 )

242 
cr
 = 
ioctl_GWINSZ
 ( 
fd
 )

243 
os
 . 
close
 ( 
fd
 )

244 except 
Exception
 :

246 if not 
cr
 :

247 
cr
 = ( 
os
 . 
environ
 . 
get
 ( 'LINES' , 25 ) , 
os
 . 
environ
 . 
get
 ( 'COLUMNS' , 80 ) )

248 return 
int
 ( 
cr
 [ 1 ] ) , 
int
 ( 
cr
 [ 0 ] ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/typing.py

29 
MYPY_CHECK_RUNNING
 = False


	@./env/lib/python3.7/site-packages/pip/_internal/utils/outdated.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~datetime

4 import 
	~json

5 import 
	~logging

6 import 
	~os.path

7 import 
	~sys

9 from 
	~pip._vendor
 import 
lockfile
 , 
pkg_resources

10 from 
	~pip._vendor.packaging
 import 
version
 as 
packaging_version

12 from 
	~pip._internal.index
 import 
PackageFinder

13 from 
	~pip._internal.utils.compat
 import 
WINDOWS

14 from 
	~pip._internal.utils.filesystem
 import 
check_path_owner

15 from 
	~pip._internal.utils.misc
 import 
ensure_dir
 , 
get_installed_version

17 
SELFCHECK_DATE_FMT
 = "%Y-%m-%dT%H:%M:%SZ"

20 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

23 class 
	cSelfCheckState
 ( 
object
 ) :

24 def 
	$__init__
 ( 
self
 , 
cache_dir
 ) :

25 
self
 . 
state
 = { }

26 
self
 . 
statefile_path
 = None

29 if 
cache_dir
 :

30 
self
 . 
statefile_path
 = 
os
 . 
path
 . 
join
 ( 
cache_dir
 , "selfcheck.json" )

32 with 
open
 ( 
self
 . 
statefile_path
 ) as 
statefile
 :

33 
self
 . 
state
 = 
json
 . 
load
 ( 
statefile
 ) [ 
sys
 . 
prefix
 ]

34 except ( 
IOError
 , 
ValueError
 , 
KeyError
 ) :

37 pass 
	}

39 def 
	$save
 ( 
self
 , 
pypi_version
 , 
current_time
 ) :

41 if not 
self
 . 
statefile_path
 :

45 if not 
check_path_owner
 ( 
os
 . 
path
 . 
dirname
 ( 
self
 . 
statefile_path
 ) ) :

50 
ensure_dir
 ( 
os
 . 
path
 . 
dirname
 ( 
self
 . 
statefile_path
 ) )

53 with 
lockfile
 . 
LockFile
 ( 
self
 . 
statefile_path
 ) :

54 if 
os
 . 
path
 . 
exists
 ( 
self
 . 
statefile_path
 ) :

55 with 
open
 ( 
self
 . 
statefile_path
 ) as 
statefile
 :

56 
state
 = 
json
 . 
load
 ( 
statefile
 )

58 
state
 = { }

60 
state
 [ 
sys
 . 
prefix
 ] = { "last_check"

61 : 
current_time
 . 
strftime
 ( 
SELFCHECK_DATE_FMT
 ) , "pypi_version"

62 : 
pypi_version
 ,

65 with 
open
 ( 
self
 . 
statefile_path
 , "w" ) as 
statefile
 :

66 
json
 . 
dump
 ( 
state
 , 
statefile
 , 
sort_keys
 = True ,

67 
separators
 = ( "," , ":" ) ) 
	}

70 def 
	$was_installed_by_pip
 ( 
pkg
 ) :

77 
dist
 = 
pkg_resources
 . 
get_distribution
 ( 
pkg
 )

78 return ( 
dist
 . 
has_metadata
 ( 'INSTALLER' ) and 'pip'

79 in 
dist
 . 
get_metadata_lines
 ( 'INSTALLER' ) )

80 except 
pkg_resources
 . 
DistributionNotFound
 :

81 return False 
	}

84 def 
	$pip_version_check
 ( 
session
 , 
options
 ) :

91 
installed_version
 = 
get_installed_version
 ( "pip" )

92 if not 
installed_version
 :

95 
pip_version
 = 
packaging_version
 . 
parse
 ( 
installed_version
 )

96 
pypi_version
 = None

99 
state
 = 
SelfCheckState
 ( 
cache_dir
 = 
options
 . 
cache_dir
 )

101 
current_time
 = 
datetime
 . 
datetime
 . 
utcnow
 ( )

103 if "last_check" in 
state
 . 
state
 and "pypi_version" in 
state
 . 
state
 :

104 
last_check
 = 
datetime
 . 
datetime
 . 
strptime
 (

105 
state
 . 
state
 [ "last_check" ] ,

106 
SELFCHECK_DATE_FMT

108 if ( 
current_time
 - 
last_check
 ) . 
total_seconds
 ( ) < 7 * 24 * 60 * 60 :

109 
pypi_version
 = 
state
 . 
state
 [ "pypi_version" ]

112 if 
pypi_version
 is None :

114 
finder
 = 
PackageFinder
 (

115 
find_links
 = 
options
 . 
find_links
 ,

116 
index_urls
 = [ 
options
 . 
index_url
 ] + 
options
 . 
extra_index_urls
 ,

117 
allow_all_prereleases
 = False ,

118 
trusted_hosts
 = 
options
 . 
trusted_hosts
 ,

119 
process_dependency_links
 = 
options
 . 
process_dependency_links
 ,

120 
session
 = 
session
 ,

122 
all_candidates
 = 
finder
 . 
find_all_candidates
 ( "pip" )

123 if not 
all_candidates
 :

125 
pypi_version
 = 
str
 (

126 
max
 ( 
all_candidates
 , 
key
 = lambda 
c
 : 
c
 . 
version
 ) . 
version

130 
state
 . 
save
 ( 
pypi_version
 , 
current_time
 )

132 
remote_version
 = 
packaging_version
 . 
parse
 ( 
pypi_version
 )

135 if ( 
pip_version
 < 
remote_version
 and

136 
pip_version
 . 
base_version
 != 
remote_version
 . 
base_version
 and

137 
was_installed_by_pip
 ( 'pip' ) ) :

140 if 
WINDOWS
 :

141 
pip_cmd
 = "python -m pip"

143 
pip_cmd
 = "pip"

144 
logger
 . 
warning
 ( "You are using pip version %s, however version %s is " "available.\nYou should consider upgrading via the " "'%s install --upgrade pip' command."

148 
pip_version
 , 
pypi_version
 , 
pip_cmd

150 except 
Exception
 :

151 
logger
 . 
debug
 ( "There was an error checking the latest version of pip"

153 
exc_info
 = True ,

154 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/encoding.py

1 import 
	~codecs

2 import 
	~locale

3 import 
	~re

4 import 
	~sys

6 
BOMS
 = [

7 ( 
codecs
 . 
BOM_UTF8
 , 'utf8' ) ,

8 ( 
codecs
 . 
BOM_UTF16
 , 'utf16' ) ,

9 ( 
codecs
 . 
BOM_UTF16_BE
 , 'utf16-be' ) ,

10 ( 
codecs
 . 
BOM_UTF16_LE
 , 'utf16-le' ) ,

11 ( 
codecs
 . 
BOM_UTF32
 , 'utf32' ) ,

12 ( 
codecs
 . 
BOM_UTF32_BE
 , 'utf32-be' ) ,

13 ( 
codecs
 . 
BOM_UTF32_LE
 , 'utf32-le' ) ,

16 
ENCODING_RE
 = 
re
 . 
compile
 ( br'coding[:=]\s*([-\w.]+)' )

19 def 
	$auto_decode
 ( 
data
 ) :

23 for 
bom
 , 
encoding
 in 
BOMS
 :

24 if 
data
 . 
startswith
 ( 
bom
 ) :

25 return 
data
 [ 
len
 ( 
bom
 ) : ] . 
decode
 ( 
encoding
 )

27 for 
line
 in 
data
 . 
split
 ( b'\n' ) [ : 2 ] :

28 if 
line
 [ 0 : 1 ] == b'#' and 
ENCODING_RE
 . 
search
 ( 
line
 ) :

29 
encoding
 = 
ENCODING_RE
 . 
search
 ( 
line
 ) . 
groups
 ( ) [ 0 ] . 
decode
 ( 'ascii' )

30 return 
data
 . 
decode
 ( 
encoding
 )

31 return 
data
 . 
decode
 (

32 
locale
 . 
getpreferredencoding
 ( False ) or 
sys
 . 
getdefaultencoding
 ( ) ,

33 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/deprecation.py

4 from 
	~__future__
 import 
absolute_import

6 import 
	~logging

7 import 
	~warnings

9 from 
	~pip._vendor.packaging.version
 import 
parse

11 from 
	~pip
 import 
__version__
 as 
current_version

12 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

14 if 
MYPY_CHECK_RUNNING
 :

15 from 
	~typing
 import 
Any
 , 
Optional

18 class 
	cPipDeprecationWarning
 ( 
Warning
 ) :

22 
_original_showwarning
 = None

26 def 
	$_showwarning
 ( 
message
 , 
category
 , 
filename
 , 
lineno
 , 
file
 = None , 
line
 = None ) :

27 if 
file
 is not None :

28 if 
_original_showwarning
 is not None :

29 
_original_showwarning
 (

30 
message
 , 
category
 , 
filename
 , 
lineno
 , 
file
 , 
line
 ,

32 elif 
issubclass
 ( 
category
 , 
PipDeprecationWarning
 ) :

35 
logger
 = 
logging
 . 
getLogger
 ( "pip._internal.deprecations" )

36 
logger
 . 
warning
 ( 
message
 )

38 
_original_showwarning
 (

39 
message
 , 
category
 , 
filename
 , 
lineno
 , 
file
 , 
line
 ,

40 ) 
	}

43 def 
	$install_warning_logger
 ( ) :

45 
warnings
 . 
simplefilter
 ( "default" , 
PipDeprecationWarning
 , 
append
 = True )

47 global 
	g_original_showwarning

49 if 
_original_showwarning
 is None :

50 
_original_showwarning
 = 
warnings
 . 
showwarning

51 
warnings
 . 
showwarning
 = 
_showwarning
 
	}

54 def 
	$deprecated
 ( 
reason
 , 
replacement
 , 
gone_in
 , 
issue
 = None ) :

79 
message
 = "DEPRECATION: " + 
reason

80 if 
replacement
 is not None :

81 
message
 += " A possible replacement is {}." . 
format
 ( 
replacement
 )

82 if 
issue
 is not None :

83 
url
 = "https://github.com/pypa/pip/issues/" + 
str
 ( 
issue
 )

84 
message
 += " You can find discussion regarding this at {}." . 
format
 ( 
url
 )

87 if 
gone_in
 is not None and 
parse
 ( 
current_version
 ) >= 
parse
 ( 
gone_in
 ) :

88 raise 
PipDeprecationWarning
 ( 
message
 )

89 
warnings
 . 
warn
 ( 
message
 , 
category
 = 
PipDeprecationWarning
 , 
stacklevel
 = 2 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/glibc.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~ctypes

4 import 
	~re

5 import 
	~warnings

8 def 
	$glibc_version_string
 ( ) :

15 
process_namespace
 = 
ctypes
 . 
CDLL
 ( None )

17 
gnu_get_libc_version
 = 
process_namespace
 . 
gnu_get_libc_version

18 except 
AttributeError
 :

24 
gnu_get_libc_version
 . 
restype
 = 
ctypes
 . 
c_char_p

25 
version_str
 = 
gnu_get_libc_version
 ( )

27 if not 
isinstance
 ( 
version_str
 , 
str
 ) :

28 
version_str
 = 
version_str
 . 
decode
 ( "ascii" )

30 return 
version_str
 
	}

34 def 
	$check_glibc_version
 ( 
version_str
 , 
required_major
 , 
minimum_minor
 ) :

41 
m
 = 
re
 . 
match
 ( r"(?P<major>[0-9]+)\.(?P<minor>[0-9]+)" , 
version_str
 )

42 if not 
m
 :

43 
warnings
 . 
warn
 ( "Expected glibc version with 2 components major.minor," " got: %s"

44 % 
version_str
 , 
RuntimeWarning
 )

46 return ( 
int
 ( 
m
 . 
group
 ( "major" ) ) == 
required_major
 and

47 
int
 ( 
m
 . 
group
 ( "minor" ) ) >= 
minimum_minor
 ) 
	}

50 def 
	$have_compatible_glibc
 ( 
required_major
 , 
minimum_minor
 ) :

51 
version_str
 = 
glibc_version_string
 ( )

52 if 
version_str
 is None :

54 return 
check_glibc_version
 ( 
version_str
 , 
required_major
 , 
minimum_minor
 ) 
	}

74 def 
	$libc_ver
 ( ) :

80 
glibc_version
 = 
glibc_version_string
 ( )

81 if 
glibc_version
 is None :

84 return ( "glibc" , 
glibc_version
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/appdirs.py

5 from 
	~__future__
 import 
absolute_import

7 import 
	~os

8 import 
	~sys

10 from 
	~pip._vendor.six
 import 
PY2
 , 
text_type

12 from 
	~pip._internal.utils.compat
 import 
WINDOWS
 , 
expanduser

15 def 
	$user_cache_dir
 ( 
appname
 ) :

36 if 
WINDOWS
 :

38 
path
 = 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( "CSIDL_LOCAL_APPDATA" ) )

42 if 
PY2
 and 
isinstance
 ( 
path
 , 
text_type
 ) :

43 
path
 = 
_win_path_to_bytes
 ( 
path
 )

46 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 , "Cache" )

47 elif 
sys
 . 
platform
 == "darwin" :

49 
path
 = 
expanduser
 ( "~/Library/Caches" )

52 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

55 
path
 = 
os
 . 
getenv
 ( "XDG_CACHE_HOME" , 
expanduser
 ( "~/.cache" ) )

58 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

60 return 
path
 
	}

63 def 
	$user_data_dir
 ( 
appname
 , 
roaming
 = False ) :

91 if 
WINDOWS
 :

92 
const
 = 
roaming
 and "CSIDL_APPDATA" or "CSIDL_LOCAL_APPDATA"

93 
path
 = 
os
 . 
path
 . 
join
 ( 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( 
const
 ) ) , 
appname
 )

94 elif 
sys
 . 
platform
 == "darwin" :

95 
path
 = 
os
 . 
path
 . 
join
 (

96 
expanduser
 ( '~/Library/Application Support/' ) ,

97 
appname
 ,

98 ) if 
os
 . 
path
 . 
isdir
 ( 
os
 . 
path
 . 
join
 (

99 
expanduser
 ( '~/Library/Application Support/' ) ,

100 
appname
 ,

102 ) else 
os
 . 
path
 . 
join
 (

103 
expanduser
 ( '~/.config/' ) ,

104 
appname
 ,

107 
path
 = 
os
 . 
path
 . 
join
 (

108 
os
 . 
getenv
 ( 'XDG_DATA_HOME' , 
expanduser
 ( "~/.local/share" ) ) ,

109 
appname
 ,

112 return 
path
 
	}

115 def 
	$user_config_dir
 ( 
appname
 , 
roaming
 = True ) :

135 if 
WINDOWS
 :

136 
path
 = 
user_data_dir
 ( 
appname
 , 
roaming
 = 
roaming
 )

137 elif 
sys
 . 
platform
 == "darwin" :

138 
path
 = 
user_data_dir
 ( 
appname
 )

140 
path
 = 
os
 . 
getenv
 ( 'XDG_CONFIG_HOME' , 
expanduser
 ( "~/.config" ) )

141 
path
 = 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 )

143 return 
path
 
	}

148 def 
	$site_config_dirs
 ( 
appname
 ) :

164 if 
WINDOWS
 :

165 
path
 = 
os
 . 
path
 . 
normpath
 ( 
_get_win_folder
 ( "CSIDL_COMMON_APPDATA" ) )

166 
pathlist
 = [ 
os
 . 
path
 . 
join
 ( 
path
 , 
appname
 ) ]

167 elif 
sys
 . 
platform
 == 'darwin' :

168 
pathlist
 = [ 
os
 . 
path
 . 
join
 ( '/Library/Application Support' , 
appname
 ) ]

171 
xdg_config_dirs
 = 
os
 . 
getenv
 ( 'XDG_CONFIG_DIRS' , '/etc/xdg' )

172 if 
xdg_config_dirs
 :

173 
pathlist
 = [

174 
os
 . 
path
 . 
join
 ( 
expanduser
 ( 
x
 ) , 
appname
 )

175 for 
x
 in 
xdg_config_dirs
 . 
split
 ( 
os
 . 
pathsep
 )

178 
pathlist
 = [ ]

181 
pathlist
 . 
append
 ( '/etc' )

183 return 
pathlist
 
	}

188 def 
	$_get_win_folder_from_registry
 ( 
csidl_name
 ) :

194 import 
	~_winreg

196 
shell_folder_name
 = { "CSIDL_APPDATA"

200 } [ 
csidl_name
 ]

202 
key
 = 
_winreg
 . 
OpenKey
 (

203 
_winreg
 . 
HKEY_CURRENT_USER
 , r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"

206 
directory
 , 
_type
 = 
_winreg
 . 
QueryValueEx
 ( 
key
 , 
shell_folder_name
 )

207 return 
directory
 
	}

210 def 
	$_get_win_folder_with_ctypes
 ( 
csidl_name
 ) :

211 
csidl_const
 = { "CSIDL_APPDATA"

215 } [ 
csidl_name
 ]

217 
buf
 = 
ctypes
 . 
create_unicode_buffer
 ( 1024 )

218 
ctypes
 . 
windll
 . 
shell32
 . 
SHGetFolderPathW
 ( None , 
csidl_const
 , None , 0 , 
buf
 )

222 
has_high_char
 = False

223 for 
c
 in 
buf
 :

224 if 
ord
 ( 
c
 ) > 255 :

225 
has_high_char
 = True

227 if 
has_high_char
 :

228 
buf2
 = 
ctypes
 . 
create_unicode_buffer
 ( 1024 )

229 if 
ctypes
 . 
windll
 . 
kernel32
 . 
GetShortPathNameW
 ( 
buf
 . 
value
 , 
buf2
 , 1024 ) :

230 
buf
 = 
buf2

232 return 
buf
 . 
value
 
	}

235 if 
WINDOWS
 :

237 import 
	~ctypes

238 
_get_win_folder
 = 
_get_win_folder_with_ctypes

239 except 
ImportError
 :

240 
_get_win_folder
 = 
_get_win_folder_from_registry

243 def 
	$_win_path_to_bytes
 ( 
path
 ) :

253 for 
encoding
 in ( 'ASCII' , 'MBCS' ) :

255 return 
path
 . 
encode
 ( 
encoding
 )

256 except ( 
UnicodeEncodeError
 , 
LookupError
 ) :

258 return 
path
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/hashes.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~hashlib

5 from 
	~pip._vendor.six
 import 
iteritems
 , 
iterkeys
 , 
itervalues

7 from 
	~pip._internal.exceptions
 import (

8 
HashMismatch
 , 
HashMissing
 , 
InstallationError
 ,

10 from 
	~pip._internal.utils.misc
 import 
read_chunks

14 
FAVORITE_HASH
 = 'sha256'

19 
STRONG_HASHES
 = [ 'sha256' , 'sha384' , 'sha512' ]

22 class 
	cHashes
 ( 
object
 ) :

27 def 
	$__init__
 ( 
self
 , 
hashes
 = None ) :

32 
self
 . 
_allowed
 = { } if 
hashes
 is None else 
hashes
 
	}

34 def 
	$check_against_chunks
 ( 
self
 , 
chunks
 ) :

41 
gots
 = { }

42 for 
hash_name
 in 
iterkeys
 ( 
self
 . 
_allowed
 ) :

44 
gots
 [ 
hash_name
 ] = 
hashlib
 . 
new
 ( 
hash_name
 )

45 except ( 
ValueError
 , 
TypeError
 ) :

46 raise 
InstallationError
 ( 'Unknown hash name: %s' % 
hash_name
 )

48 for 
chunk
 in 
chunks
 :

49 for 
hash
 in 
itervalues
 ( 
gots
 ) :

50 
hash
 . 
update
 ( 
chunk
 )

52 for 
hash_name
 , 
got
 in 
iteritems
 ( 
gots
 ) :

53 if 
got
 . 
hexdigest
 ( ) in 
self
 . 
_allowed
 [ 
hash_name
 ] :

55 
self
 . 
_raise
 ( 
gots
 ) 
	}

57 def 
	$_raise
 ( 
self
 , 
gots
 ) :

58 raise 
HashMismatch
 ( 
self
 . 
_allowed
 , 
gots
 ) 
	}

60 def 
	$check_against_file
 ( 
self
 , 
file
 ) :

66 return 
self
 . 
check_against_chunks
 ( 
read_chunks
 ( 
file
 ) ) 
	}

68 def 
	$check_against_path
 ( 
self
 , 
path
 ) :

69 with 
open
 ( 
path
 , 'rb' ) as 
file
 :

70 return 
self
 . 
check_against_file
 ( 
file
 ) 
	}

72 def 
	$__nonzero__
 ( 
self
 ) :

74 return 
bool
 ( 
self
 . 
_allowed
 ) 
	}

76 def 
	$__bool__
 ( 
self
 ) :

77 return 
self
 . 
__nonzero__
 ( ) 
	}

80 class 
	cMissingHashes
 ( 
Hashes
 ) :

87 def 
	$__init__
 ( 
self
 ) :

91 
super
 ( 
MissingHashes
 , 
self
 ) . 
__init__
 ( 
hashes
 = { 
FAVORITE_HASH
 : [ ] } ) 
	}

93 def 
	$_raise
 ( 
self
 , 
gots
 ) :

94 raise 
HashMissing
 ( 
gots
 [ 
FAVORITE_HASH
 ] . 
hexdigest
 ( ) ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/temp_dir.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os.path

5 import 
	~tempfile

7 from 
	~pip._internal.utils.misc
 import 
rmtree

9 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

12 class 
	cTempDirectory
 ( 
object
 ) :

37 def 
	$__init__
 ( 
self
 , 
path
 = None , 
delete
 = None , 
kind
 = "temp" ) :

38 
super
 ( 
TempDirectory
 , 
self
 ) . 
__init__
 ( )

40 if 
path
 is None and 
delete
 is None :

43 
delete
 = True

45 
self
 . 
path
 = 
path

46 
self
 . 
delete
 = 
delete

47 
self
 . 
kind
 = 
kind
 
	}

49 def 
	$__repr__
 ( 
self
 ) :

50 return "<{} {!r}>" . 
format
 ( 
self
 . 
__class__
 . 
__name__
 , 
self
 . 
path
 ) 
	}

52 def 
	$__enter__
 ( 
self
 ) :

53 
self
 . 
create
 ( )

54 return 
self
 
	}

56 def 
	$__exit__
 ( 
self
 , 
exc
 , 
value
 , 
tb
 ) :

57 if 
self
 . 
delete
 :

58 
self
 . 
cleanup
 ( ) 
	}

60 def 
	$create
 ( 
self
 ) :

63 if 
self
 . 
path
 is not None :

64 
logger
 . 
debug
 ( "Skipped creation of temporary directory: {}"

65 . 
format
 ( 
self
 . 
path
 )

72 
self
 . 
path
 = 
os
 . 
path
 . 
realpath
 (

73 
tempfile
 . 
mkdtemp
 ( 
prefix
 = "pip-{}-" . 
format
 ( 
self
 . 
kind
 ) )

75 
logger
 . 
debug
 ( "Created temporary directory: {}" . 
format
 ( 
self
 . 
path
 ) ) 
	}

77 def 
	$cleanup
 ( 
self
 ) :

80 if 
self
 . 
path
 is not None and 
os
 . 
path
 . 
exists
 ( 
self
 . 
path
 ) :

81 
rmtree
 ( 
self
 . 
path
 )

82 
self
 . 
path
 = None 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/filesystem.py

1 import 
	~os

2 import 
	~os.path

4 from 
	~pip._internal.utils.compat
 import 
get_path_uid

7 def 
	$check_path_owner
 ( 
path
 ) :

10 if not 
hasattr
 ( 
os
 , "geteuid" ) :

13 
previous
 = None

14 while 
path
 != 
previous
 :

15 if 
os
 . 
path
 . 
lexists
 ( 
path
 ) :

17 if 
os
 . 
geteuid
 ( ) == 0 :

21 
path_uid
 = 
get_path_uid
 ( 
path
 )

22 except 
OSError
 :

24 return 
path_uid
 == 0

26 return 
os
 . 
access
 ( 
path
 , 
os
 . 
W_OK
 )

28 
previous
 , 
path
 = 
path
 , 
os
 . 
path
 . 
dirname
 ( 
path
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/__init__.py


	@./env/lib/python3.7/site-packages/pip/_internal/utils/ui.py

1 from 
	~__future__
 import 
absolute_import
 , 
division

3 import 
	~contextlib

4 import 
	~itertools

5 import 
	~logging

6 import 
	~sys

7 import 
	~time

8 from 
	~signal
 import 
SIGINT
 , 
default_int_handler
 , 
signal

10 from 
	~pip._vendor
 import 
six

11 from 
	~pip._vendor.progress.bar
 import (

12 
Bar
 , 
ChargingBar
 , 
FillingCirclesBar
 , 
FillingSquaresBar
 , 
IncrementalBar
 ,

13 
ShadyBar
 ,

15 from 
	~pip._vendor.progress.helpers
 import 
HIDE_CURSOR
 , 
SHOW_CURSOR
 , 
WritelnMixin

16 from 
	~pip._vendor.progress.spinner
 import 
Spinner

18 from 
	~pip._internal.utils.compat
 import 
WINDOWS

19 from 
	~pip._internal.utils.logging
 import 
get_indentation

20 from 
	~pip._internal.utils.misc
 import 
format_size

21 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

23 if 
MYPY_CHECK_RUNNING
 :

24 from 
	~typing
 import 
Any

27 from 
	~pip._vendor
 import 
colorama

30 except 
Exception
 :

31 
colorama
 = None

33 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

36 def 
	$_select_progress_class
 ( 
preferred
 , 
fallback
 ) :

37 
encoding
 = 
getattr
 ( 
preferred
 . 
file
 , "encoding" , None )

41 if not 
encoding
 :

42 return 
fallback

46 
characters
 = [

47 
getattr
 ( 
preferred
 , "empty_fill" , 
six
 . 
text_type
 ( ) ) ,

48 
getattr
 ( 
preferred
 , "fill" , 
six
 . 
text_type
 ( ) ) ,

50 
characters
 += 
list
 ( 
getattr
 ( 
preferred
 , "phases" , [ ] ) )

56 
six
 . 
text_type
 ( ) . 
join
 ( 
characters
 ) . 
encode
 ( 
encoding
 )

57 except 
UnicodeEncodeError
 :

58 return 
fallback

60 return 
preferred
 
	}

63 
_BaseBar
 = 
_select_progress_class
 ( 
IncrementalBar
 , 
Bar
 )

66 class 
	cInterruptibleMixin
 ( 
object
 ) :

84 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

88 
super
 ( 
InterruptibleMixin
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

90 
self
 . 
original_handler
 = 
signal
 ( 
SIGINT
 , 
self
 . 
handle_sigint
 )

97 if 
self
 . 
original_handler
 is None :

98 
self
 . 
original_handler
 = 
default_int_handler
 
	}

100 def 
	$finish
 ( 
self
 ) :

107 
super
 ( 
InterruptibleMixin
 , 
self
 ) . 
finish
 ( )

108 
signal
 ( 
SIGINT
 , 
self
 . 
original_handler
 ) 
	}

110 def 
	$handle_sigint
 ( 
self
 , 
signum
 , 
frame
 ) :

117 
self
 . 
finish
 ( )

118 
self
 . 
original_handler
 ( 
signum
 , 
frame
 ) 
	}

121 class 
	cSilentBar
 ( 
Bar
 ) :

123 def 
	$update
 ( 
self
 ) :

124 pass 
	}

127 class 
	cBlueEmojiBar
 ( 
IncrementalBar
 ) :

129 
suffix
 = "%(percent)d%%"

130 
bar_prefix
 = " "

131 
bar_suffix
 = " "

132 
phases
 = ( u"\U0001F539" , u"\U0001F537" , u"\U0001F535" )

135 class 
	cDownloadProgressMixin
 ( 
object
 ) :

137 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

138 
super
 ( 
DownloadProgressMixin
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

139 
self
 . 
message
 = ( " " * ( 
get_indentation
 ( ) + 2 ) ) + 
self
 . 
message
 
	}

141 @ 
property

142 def 
	$downloaded
 ( 
self
 ) :

143 return 
format_size
 ( 
self
 . 
index
 ) 
	}

145 @ 
property

146 def 
	$download_speed
 ( 
self
 ) :

148 if 
self
 . 
avg
 == 0.0 :

150 return 
format_size
 ( 1 / 
self
 . 
avg
 ) + "/s" 
	}

152 @ 
property

153 def 
	$pretty_eta
 ( 
self
 ) :

154 if 
self
 . 
eta
 :

155 return "eta %s" % 
self
 . 
eta_td

156 return "" 
	}

158 def 
	$iter
 ( 
self
 , 
it
 , 
n
 = 1 ) :

159 for 
x
 in 
it
 :

160 yield 
x

161 
self
 . 
next
 ( 
n
 )

162 
self
 . 
finish
 ( ) 
	}

165 class 
	cWindowsMixin
 ( 
object
 ) :

167 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

175 if 
WINDOWS
 and 
self
 . 
hide_cursor
 :

176 
self
 . 
hide_cursor
 = False

178 
super
 ( 
WindowsMixin
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

182 if 
WINDOWS
 and 
colorama
 :

183 
self
 . 
file
 = 
colorama
 . 
AnsiToWin32
 ( 
self
 . 
file
 )

187 
self
 . 
file
 . 
isatty
 = lambda : 
self
 . 
file
 . 
wrapped
 . 
isatty
 ( )

191 
self
 . 
file
 . 
flush
 = lambda : 
self
 . 
file
 . 
wrapped
 . 
flush
 ( ) 
	}

194 class 
	cBaseDownloadProgressBar
 ( 
WindowsMixin
 , 
InterruptibleMixin
 ,

195 
DownloadProgressMixin
 ) :

197 
file
 = 
sys
 . 
stdout

198 
message
 = "%(percent)d%%"

199 
suffix
 = "%(downloaded)s %(download_speed)s %(pretty_eta)s"

205 class 
	cDefaultDownloadProgressBar
 ( 
BaseDownloadProgressBar
 ,

206 
_BaseBar
 ) :

210 class 
	cDownloadSilentBar
 ( 
BaseDownloadProgressBar
 , 
SilentBar
 ) :

214 class 
	cDownloadIncrementalBar
 ( 
BaseDownloadProgressBar
 ,

215 
IncrementalBar
 ) :

219 class 
	cDownloadChargingBar
 ( 
BaseDownloadProgressBar
 ,

220 
ChargingBar
 ) :

224 class 
	cDownloadShadyBar
 ( 
BaseDownloadProgressBar
 , 
ShadyBar
 ) :

228 class 
	cDownloadFillingSquaresBar
 ( 
BaseDownloadProgressBar
 ,

229 
FillingSquaresBar
 ) :

233 class 
	cDownloadFillingCirclesBar
 ( 
BaseDownloadProgressBar
 ,

234 
FillingCirclesBar
 ) :

238 class 
	cDownloadBlueEmojiProgressBar
 ( 
BaseDownloadProgressBar
 ,

239 
BlueEmojiBar
 ) :

243 class 
	cDownloadProgressSpinner
 ( 
WindowsMixin
 , 
InterruptibleMixin
 ,

244 
DownloadProgressMixin
 , 
WritelnMixin
 , 
Spinner
 ) :

246 
file
 = 
sys
 . 
stdout

247 
suffix
 = "%(downloaded)s %(download_speed)s"

249 def 
	$next_phase
 ( 
self
 ) :

250 if not 
hasattr
 ( 
self
 , "_phaser" ) :

251 
self
 . 
_phaser
 = 
itertools
 . 
cycle
 ( 
self
 . 
phases
 )

252 return 
next
 ( 
self
 . 
_phaser
 ) 
	}

254 def 
	$update
 ( 
self
 ) :

255 
message
 = 
self
 . 
message
 % 
self

256 
phase
 = 
self
 . 
next_phase
 ( )

257 
suffix
 = 
self
 . 
suffix
 % 
self

258 
line
 = '' . 
join
 ( [

259 
message
 , " "

260 if 
message
 else "" ,

261 
phase
 , " "

262 if 
suffix
 else "" ,

263 
suffix
 ,

266 
self
 . 
writeln
 ( 
line
 ) 
	}

269 
BAR_TYPES
 = { "off"

270 : ( 
DownloadSilentBar
 , 
DownloadSilentBar
 ) , "on"

271 : ( 
DefaultDownloadProgressBar
 , 
DownloadProgressSpinner
 ) , "ascii"

272 : ( 
DownloadIncrementalBar
 , 
DownloadProgressSpinner
 ) , "pretty"

273 : ( 
DownloadFillingCirclesBar
 , 
DownloadProgressSpinner
 ) , "emoji"

274 : ( 
DownloadBlueEmojiProgressBar
 , 
DownloadProgressSpinner
 )

278 def 
	$DownloadProgressProvider
 ( 
progress_bar
 , 
max
 = None ) :

279 if 
max
 is None or 
max
 == 0 :

280 return 
BAR_TYPES
 [ 
progress_bar
 ] [ 1 ] ( ) . 
iter

282 return 
BAR_TYPES
 [ 
progress_bar
 ] [ 0 ] ( 
max
 = 
max
 ) . 
iter
 
	}

293 @ 
contextlib
 . 
	`contextmanager

294 def 
	$hidden_cursor
 ( 
file
 ) :

297 if 
WINDOWS
 :

302 elif not 
file
 . 
isatty
 ( ) or 
logger
 . 
getEffectiveLevel
 ( ) > 
logging
 . 
INFO
 :

305 
file
 . 
write
 ( 
HIDE_CURSOR
 )

309 
file
 . 
write
 ( 
SHOW_CURSOR
 ) 
	}

312 class 
	cRateLimiter
 ( 
object
 ) :

313 def 
	$__init__
 ( 
self
 , 
min_update_interval_seconds
 ) :

314 
self
 . 
_min_update_interval_seconds
 = 
min_update_interval_seconds

315 
self
 . 
_last_update
 = 0 
	}

317 def 
	$ready
 ( 
self
 ) :

318 
now
 = 
time
 . 
time
 ( )

319 
delta
 = 
now
 - 
self
 . 
_last_update

320 return 
delta
 >= 
self
 . 
_min_update_interval_seconds
 
	}

322 def 
	$reset
 ( 
self
 ) :

323 
self
 . 
_last_update
 = 
time
 . 
time
 ( ) 
	}

326 class 
	cInteractiveSpinner
 ( 
object
 ) :

327 def 
	$__init__
 ( 
self
 , 
message
 , 
file
 = None , 
spin_chars
 = "-\\|/" ,

329 
min_update_interval_seconds
 = 0.125 ) :

330 
self
 . 
_message
 = 
message

331 if 
file
 is None :

332 
file
 = 
sys
 . 
stdout

333 
self
 . 
_file
 = 
file

334 
self
 . 
_rate_limiter
 = 
RateLimiter
 ( 
min_update_interval_seconds
 )

335 
self
 . 
_finished
 = False

337 
self
 . 
_spin_cycle
 = 
itertools
 . 
cycle
 ( 
spin_chars
 )

339 
self
 . 
_file
 . 
write
 ( " " * 
get_indentation
 ( ) + 
self
 . 
_message
 + " ... " )

340 
self
 . 
_width
 = 0 
	}

342 def 
	$_write
 ( 
self
 , 
status
 ) :

343 assert not 
self
 . 
_finished

346 
backup
 = "\b" * 
self
 . 
_width

347 
self
 . 
_file
 . 
write
 ( 
backup
 + " " * 
self
 . 
_width
 + 
backup
 )

349 
self
 . 
_file
 . 
write
 ( 
status
 )

350 
self
 . 
_width
 = 
len
 ( 
status
 )

351 
self
 . 
_file
 . 
flush
 ( )

352 
self
 . 
_rate_limiter
 . 
reset
 ( ) 
	}

354 def 
	$spin
 ( 
self
 ) :

355 if 
self
 . 
_finished
 :

357 if not 
self
 . 
_rate_limiter
 . 
ready
 ( ) :

359 
self
 . 
_write
 ( 
next
 ( 
self
 . 
_spin_cycle
 ) ) 
	}

361 def 
	$finish
 ( 
self
 , 
final_status
 ) :

362 if 
self
 . 
_finished
 :

364 
self
 . 
_write
 ( 
final_status
 )

365 
self
 . 
_file
 . 
write
 ( "\n" )

366 
self
 . 
_file
 . 
flush
 ( )

367 
self
 . 
_finished
 = True 
	}

374 class 
	cNonInteractiveSpinner
 ( 
object
 ) :

375 def 
	$__init__
 ( 
self
 , 
message
 , 
min_update_interval_seconds
 = 60 ) :

376 
self
 . 
_message
 = 
message

377 
self
 . 
_finished
 = False

378 
self
 . 
_rate_limiter
 = 
RateLimiter
 ( 
min_update_interval_seconds
 )

379 
self
 . 
_update
 ( "started" ) 
	}

381 def 
	$_update
 ( 
self
 , 
status
 ) :

382 assert not 
self
 . 
_finished

383 
self
 . 
_rate_limiter
 . 
reset
 ( )

384 
logger
 . 
info
 ( "%s: %s" , 
self
 . 
_message
 , 
status
 ) 
	}

386 def 
	$spin
 ( 
self
 ) :

387 if 
self
 . 
_finished
 :

389 if not 
self
 . 
_rate_limiter
 . 
ready
 ( ) :

391 
self
 . 
_update
 ( "still running..." ) 
	}

393 def 
	$finish
 ( 
self
 , 
final_status
 ) :

394 if 
self
 . 
_finished
 :

396 
self
 . 
_update
 ( "finished with status '%s'" % ( 
final_status
 , ) )

397 
self
 . 
_finished
 = True 
	}

400 @ 
contextlib
 . 
	`contextmanager

401 def 
	$open_spinner
 ( 
message
 ) :

407 if 
sys
 . 
stdout
 . 
isatty
 ( ) and 
logger
 . 
getEffectiveLevel
 ( ) <= 
logging
 . 
INFO
 :

408 
spinner
 = 
InteractiveSpinner
 ( 
message
 )

410 
spinner
 = 
NonInteractiveSpinner
 ( 
message
 )

412 with 
hidden_cursor
 ( 
sys
 . 
stdout
 ) :

413 yield 
spinner

414 except 
KeyboardInterrupt
 :

415 
spinner
 . 
finish
 ( "canceled" )

417 except 
Exception
 :

418 
spinner
 . 
finish
 ( "error" )

421 
spinner
 . 
finish
 ( "done" ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/utils/setuptools_build.py

2 
SETUPTOOLS_SHIM
 = ( "import setuptools, tokenize;__file__=%r;" "f=getattr(tokenize, 'open', open)(__file__);" "code=f.read().replace('\\r\\n', '\\n');" "f.close();" "exec(compile(code, __file__, 'exec'))"


	@./env/lib/python3.7/site-packages/pip/_internal/utils/packaging.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~sys

5 from 
	~email.parser
 import 
FeedParser

7 from 
	~pip._vendor
 import 
pkg_resources

8 from 
	~pip._vendor.packaging
 import 
specifiers
 , 
version

10 from 
	~pip._internal
 import 
exceptions

11 from 
	~pip._internal.utils.misc
 import 
display_path

13 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

16 def 
	$check_requires_python
 ( 
requires_python
 ) :

26 if 
requires_python
 is None :

29 
requires_python_specifier
 = 
specifiers
 . 
SpecifierSet
 ( 
requires_python
 )

32 
python_version
 = 
version
 . 
parse
 ( '.' . 
join
 ( 
map
 ( 
str
 , 
sys
 . 
version_info
 [ : 3 ] ) ) )

33 return 
python_version
 in 
requires_python_specifier
 
	}

36 def 
	$get_metadata
 ( 
dist
 ) :

37 if ( 
isinstance
 ( 
dist
 , 
pkg_resources
 . 
DistInfoDistribution
 ) and

38 
dist
 . 
has_metadata
 ( 'METADATA' ) ) :

39 
metadata
 = 
dist
 . 
get_metadata
 ( 'METADATA' )

40 elif 
dist
 . 
has_metadata
 ( 'PKG-INFO' ) :

41 
metadata
 = 
dist
 . 
get_metadata
 ( 'PKG-INFO' )

43 
logger
 . 
warning
 ( "No metadata found in %s" , 
display_path
 ( 
dist
 . 
location
 ) )

44 
metadata
 = ''

46 
feed_parser
 = 
FeedParser
 ( )

47 
feed_parser
 . 
feed
 ( 
metadata
 )

48 return 
feed_parser
 . 
close
 ( ) 
	}

51 def 
	$check_dist_requires_python
 ( 
dist
 ) :

52 
pkg_info_dict
 = 
get_metadata
 ( 
dist
 )

53 
requires_python
 = 
pkg_info_dict
 . 
get
 ( 'Requires-Python' )

55 if not 
check_requires_python
 ( 
requires_python
 ) :

56 raise 
exceptions
 . 
UnsupportedPythonVersion
 ( "%s requires Python '%s' but the running Python is %s"

58 
dist
 . 
project_name
 ,

59 
requires_python
 , '.'

60 . 
join
 ( 
map
 ( 
str
 , 
sys
 . 
version_info
 [ : 3 ] ) ) , )

62 except 
specifiers
 . 
InvalidSpecifier
 as 
e
 :

63 
logger
 . 
warning
 ( "Package %s has an invalid Requires-Python entry %s - %s"

65 
dist
 . 
project_name
 , 
requires_python
 , 
e
 ,

67 return 
	}

70 def 
	$get_installer
 ( 
dist
 ) :

71 if 
dist
 . 
has_metadata
 ( 'INSTALLER' ) :

72 for 
line
 in 
dist
 . 
get_metadata_lines
 ( 'INSTALLER' ) :

73 if 
line
 . 
strip
 ( ) :

74 return 
line
 . 
strip
 ( )

75 return '' 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/resolve.py

13 import 
	~logging

14 from 
	~collections
 import 
defaultdict

15 from 
	~itertools
 import 
chain

17 from 
	~pip._internal.exceptions
 import (

18 
BestVersionAlreadyInstalled
 , 
DistributionNotFound
 , 
HashError
 , 
HashErrors
 ,

19 
UnsupportedPythonVersion
 ,

21 from 
	~pip._internal.req.constructors
 import 
install_req_from_req

22 from 
	~pip._internal.utils.logging
 import 
indent_log

23 from 
	~pip._internal.utils.misc
 import 
dist_in_usersite
 , 
ensure_dir

24 from 
	~pip._internal.utils.packaging
 import 
check_dist_requires_python

26 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

29 class 
	cResolver
 ( 
object
 ) :

34 
_allowed_strategies
 = { "eager" , "only-if-needed" , "to-satisfy-only" }

36 def 
	$__init__
 ( 
self
 , 
preparer
 , 
session
 , 
finder
 , 
wheel_cache
 , 
use_user_site
 ,

37 
ignore_dependencies
 , 
ignore_installed
 , 
ignore_requires_python
 ,

38 
force_reinstall
 , 
isolated
 , 
upgrade_strategy
 ) :

39 
super
 ( 
Resolver
 , 
self
 ) . 
__init__
 ( )

40 assert 
upgrade_strategy
 in 
self
 . 
_allowed_strategies

42 
self
 . 
preparer
 = 
preparer

43 
self
 . 
finder
 = 
finder

44 
self
 . 
session
 = 
session

48 
self
 . 
wheel_cache
 = 
wheel_cache

50 
self
 . 
require_hashes
 = None

52 
self
 . 
upgrade_strategy
 = 
upgrade_strategy

53 
self
 . 
force_reinstall
 = 
force_reinstall

54 
self
 . 
isolated
 = 
isolated

55 
self
 . 
ignore_dependencies
 = 
ignore_dependencies

56 
self
 . 
ignore_installed
 = 
ignore_installed

57 
self
 . 
ignore_requires_python
 = 
ignore_requires_python

58 
self
 . 
use_user_site
 = 
use_user_site

60 
self
 . 
_discovered_dependencies
 = 
defaultdict
 ( 
list
 ) 
	}

62 def 
	$resolve
 ( 
self
 , 
requirement_set
 ) :

74 if 
self
 . 
preparer
 . 
wheel_download_dir
 :

75 
ensure_dir
 ( 
self
 . 
preparer
 . 
wheel_download_dir
 )

79 
root_reqs
 = (

80 
requirement_set
 . 
unnamed_requirements
 +

81 
list
 ( 
requirement_set
 . 
requirements
 . 
values
 ( ) )

83 
self
 . 
require_hashes
 = (

84 
requirement_set
 . 
require_hashes
 or

85 
any
 ( 
req
 . 
has_hash_options
 for 
req
 in 
root_reqs
 )

89 
locations
 = 
self
 . 
finder
 . 
get_formatted_locations
 ( )

90 if 
locations
 :

91 
logger
 . 
info
 ( 
locations
 )

97 
discovered_reqs
 = [ ]

98 
hash_errors
 = 
HashErrors
 ( )

99 for 
req
 in 
chain
 ( 
root_reqs
 , 
discovered_reqs
 ) :

101 
discovered_reqs
 . 
extend
 (

102 
self
 . 
_resolve_one
 ( 
requirement_set
 , 
req
 )

104 except 
HashError
 as 
exc
 :

105 
exc
 . 
req
 = 
req

106 
hash_errors
 . 
append
 ( 
exc
 )

108 if 
hash_errors
 :

109 raise 
hash_errors
 
	}

111 def 
	$_is_upgrade_allowed
 ( 
self
 , 
req
 ) :

112 if 
self
 . 
upgrade_strategy
 == "to-satisfy-only" :

114 elif 
self
 . 
upgrade_strategy
 == "eager" :

117 assert 
self
 . 
upgrade_strategy
 == "only-if-needed"

118 return 
req
 . 
is_direct
 
	}

120 def 
	$_set_req_to_reinstall
 ( 
self
 , 
req
 ) :

126 if not 
self
 . 
use_user_site
 or 
dist_in_usersite
 ( 
req
 . 
satisfied_by
 ) :

127 
req
 . 
conflicts_with
 = 
req
 . 
satisfied_by

128 
req
 . 
satisfied_by
 = None 
	}

131 def 
	$_check_skip_installed
 ( 
self
 , 
req_to_install
 ) :

149 if 
self
 . 
ignore_installed
 :

152 
req_to_install
 . 
check_if_exists
 ( 
self
 . 
use_user_site
 )

153 if not 
req_to_install
 . 
satisfied_by
 :

156 if 
self
 . 
force_reinstall
 :

157 
self
 . 
_set_req_to_reinstall
 ( 
req_to_install
 )

160 if not 
self
 . 
_is_upgrade_allowed
 ( 
req_to_install
 ) :

161 if 
self
 . 
upgrade_strategy
 == "only-if-needed" :

168 if not 
req_to_install
 . 
link
 :

170 
self
 . 
finder
 . 
find_requirement
 ( 
req_to_install
 , 
upgrade
 = True )

171 except 
BestVersionAlreadyInstalled
 :

174 except 
DistributionNotFound
 :

180 
self
 . 
_set_req_to_reinstall
 ( 
req_to_install
 )

181 return None 
	}

183 def 
	$_get_abstract_dist_for
 ( 
self
 , 
req
 ) :

187 assert 
self
 . 
require_hashes
 is not None , ( "require_hashes should have been set in Resolver.resolve()"

191 if 
req
 . 
editable
 :

192 return 
self
 . 
preparer
 . 
prepare_editable_requirement
 (

193 
req
 , 
self
 . 
require_hashes
 , 
self
 . 
use_user_site
 , 
self
 . 
finder
 ,

198 assert 
req
 . 
satisfied_by
 is None

199 
skip_reason
 = 
self
 . 
_check_skip_installed
 ( 
req
 )

201 if 
req
 . 
satisfied_by
 :

202 return 
self
 . 
preparer
 . 
prepare_installed_requirement
 (

203 
req
 , 
self
 . 
require_hashes
 , 
skip_reason

206 
upgrade_allowed
 = 
self
 . 
_is_upgrade_allowed
 ( 
req
 )

207 
abstract_dist
 = 
self
 . 
preparer
 . 
prepare_linked_requirement
 (

208 
req
 , 
self
 . 
session
 , 
self
 . 
finder
 , 
upgrade_allowed
 ,

209 
self
 . 
require_hashes

220 if not 
self
 . 
ignore_installed
 :

221 
req
 . 
check_if_exists
 ( 
self
 . 
use_user_site
 )

223 if 
req
 . 
satisfied_by
 :

224 
should_modify
 = (

225 
self
 . 
upgrade_strategy
 != "to-satisfy-only" or

226 
self
 . 
force_reinstall
 or

227 
self
 . 
ignore_installed
 or

228 
req
 . 
link
 . 
scheme
 == 'file'

230 if 
should_modify
 :

231 
self
 . 
_set_req_to_reinstall
 ( 
req
 )

233 
logger
 . 
info
 ( 'Requirement already satisfied (use --upgrade to upgrade):' ' %s'

235 , 
req
 ,

238 return 
abstract_dist
 
	}

240 def 
	$_resolve_one
 ( 
self
 , 
requirement_set
 , 
req_to_install
 ) :

248 if 
req_to_install
 . 
constraint
 or 
req_to_install
 . 
prepared
 :

251 
req_to_install
 . 
prepared
 = True

254 
requirement_set
 . 
reqs_to_cleanup
 . 
append
 ( 
req_to_install
 )

256 
abstract_dist
 = 
self
 . 
_get_abstract_dist_for
 ( 
req_to_install
 )

259 
dist
 = 
abstract_dist
 . 
dist
 ( 
self
 . 
finder
 )

261 
check_dist_requires_python
 ( 
dist
 )

262 except 
UnsupportedPythonVersion
 as 
err
 :

263 if 
self
 . 
ignore_requires_python
 :

264 
logger
 . 
warning
 ( 
err
 . 
args
 [ 0 ] )

268 
more_reqs
 = [ ]

270 def 
add_req
 ( 
subreq
 , 
extras_requested
 ) :

271 
sub_install_req
 = 
install_req_from_req
 (

272 
str
 ( 
subreq
 ) ,

273 
req_to_install
 ,

274 
isolated
 = 
self
 . 
isolated
 ,

275 
wheel_cache
 = 
self
 . 
wheel_cache
 ,

277 
parent_req_name
 = 
req_to_install
 . 
name

278 
to_scan_again
 , 
add_to_parent
 = 
requirement_set
 . 
add_requirement
 (

279 
sub_install_req
 ,

280 
parent_req_name
 = 
parent_req_name
 ,

281 
extras_requested
 = 
extras_requested
 ,

283 if 
parent_req_name
 and 
add_to_parent
 :

284 
self
 . 
_discovered_dependencies
 [ 
parent_req_name
 ] . 
append
 (

285 
add_to_parent

287 
more_reqs
 . 
extend
 ( 
to_scan_again
 )

289 with 
indent_log
 ( ) :

292 if not 
requirement_set
 . 
has_requirement
 ( 
req_to_install
 . 
name
 ) :

294 
req_to_install
 . 
is_direct
 = True

295 
requirement_set
 . 
add_requirement
 (

296 
req_to_install
 , 
parent_req_name
 = None ,

299 if not 
self
 . 
ignore_dependencies
 :

300 if 
req_to_install
 . 
extras
 :

301 
logger
 . 
debug
 ( "Installing extra requirements: %r"

303 . 
join
 ( 
req_to_install
 . 
extras
 ) ,

305 
missing_requested
 = 
sorted
 (

306 
set
 ( 
req_to_install
 . 
extras
 ) - 
set
 ( 
dist
 . 
extras
 )

308 for 
missing
 in 
missing_requested
 :

309 
logger
 . 
warning
 ( '%s does not provide the extra \'%s\''

311 
dist
 , 
missing

314 
available_requested
 = 
sorted
 (

315 
set
 ( 
dist
 . 
extras
 ) & 
set
 ( 
req_to_install
 . 
extras
 )

317 for 
subreq
 in 
dist
 . 
requires
 ( 
available_requested
 ) :

318 
add_req
 ( 
subreq
 , 
extras_requested
 = 
available_requested
 )

320 if not 
req_to_install
 . 
editable
 and not 
req_to_install
 . 
satisfied_by
 :

324 
requirement_set
 . 
successfully_downloaded
 . 
append
 ( 
req_to_install
 )

326 return 
more_reqs
 
	}

328 def 
	$get_installation_order
 ( 
self
 , 
req_set
 ) :

338 
order
 = [ ]

339 
ordered_reqs
 = 
set
 ( )

341 def 
schedule
 ( 
req
 ) :

342 if 
req
 . 
satisfied_by
 or 
req
 in 
ordered_reqs
 :

344 if 
req
 . 
constraint
 :

346 
ordered_reqs
 . 
add
 ( 
req
 )

347 for 
dep
 in 
self
 . 
_discovered_dependencies
 [ 
req
 . 
name
 ] :

348 
schedule
 ( 
dep
 )

349 
order
 . 
append
 ( 
req
 )

351 for 
install_req
 in 
req_set
 . 
requirements
 . 
values
 ( ) :

352 
schedule
 ( 
install_req
 )

353 return 
order
 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/exceptions.py

2 from 
	~__future__
 import 
absolute_import

4 from 
	~itertools
 import 
chain
 , 
groupby
 , 
repeat

6 from 
	~pip._vendor.six
 import 
iteritems

9 class 
	cPipError
 ( 
Exception
 ) :

13 class 
	cConfigurationError
 ( 
PipError
 ) :

17 class 
	cInstallationError
 ( 
PipError
 ) :

21 class 
	cUninstallationError
 ( 
PipError
 ) :

25 class 
	cDistributionNotFound
 ( 
InstallationError
 ) :

29 class 
	cRequirementsFileParseError
 ( 
InstallationError
 ) :

33 class 
	cBestVersionAlreadyInstalled
 ( 
PipError
 ) :

38 class 
	cBadCommand
 ( 
PipError
 ) :

42 class 
	cCommandError
 ( 
PipError
 ) :

46 class 
	cPreviousBuildDirError
 ( 
PipError
 ) :

50 class 
	cInvalidWheelFilename
 ( 
InstallationError
 ) :

54 class 
	cUnsupportedWheel
 ( 
InstallationError
 ) :

58 class 
	cHashErrors
 ( 
InstallationError
 ) :

61 def 
	$__init__
 ( 
self
 ) :

62 
self
 . 
errors
 = [ ] 
	}

64 def 
	$append
 ( 
self
 , 
error
 ) :

65 
self
 . 
errors
 . 
append
 ( 
error
 ) 
	}

67 def 
	$__str__
 ( 
self
 ) :

68 
lines
 = [ ]

69 
self
 . 
errors
 . 
sort
 ( 
key
 = lambda 
e
 : 
e
 . 
order
 )

70 for 
cls
 , 
errors_of_cls
 in 
groupby
 ( 
self
 . 
errors
 , lambda 
e
 : 
e
 . 
__class__
 ) :

71 
lines
 . 
append
 ( 
cls
 . 
head
 )

72 
lines
 . 
extend
 ( 
e
 . 
body
 ( ) for 
e
 in 
errors_of_cls
 )

73 if 
lines
 :

74 return '\n' . 
join
 ( 
lines
 ) 
	}

76 def 
	$__nonzero__
 ( 
self
 ) :

77 return 
bool
 ( 
self
 . 
errors
 ) 
	}

79 def 
	$__bool__
 ( 
self
 ) :

80 return 
self
 . 
__nonzero__
 ( ) 
	}

83 class 
	cHashError
 ( 
InstallationError
 ) :

99 
req
 = None

100 
head
 = ''

102 def 
	$body
 ( 
self
 ) :

112 return '    %s' % 
self
 . 
_requirement_name
 ( ) 
	}

114 def 
	$__str__
 ( 
self
 ) :

115 return '%s\n%s' % ( 
self
 . 
head
 , 
self
 . 
body
 ( ) ) 
	}

117 def 
	$_requirement_name
 ( 
self
 ) :

124 return 
str
 ( 
self
 . 
req
 ) if 
self
 . 
req
 else 'unknown package' 
	}

127 class 
	cVcsHashUnsupported
 ( 
HashError
 ) :

131 
order
 = 0

132 
head
 = ( "Can't verify hashes for these requirements because we don't " "have a way to hash version control repositories:"

136 class 
	cDirectoryUrlHashUnsupported
 ( 
HashError
 ) :

140 
order
 = 1

141 
head
 = ( "Can't verify hashes for these file:// requirements because they " "point to directories:"

145 class 
	cHashMissing
 ( 
HashError
 ) :

148 
order
 = 2

149 
head
 = ( 'Hashes are required in --require-hashes mode, but they are ' 'missing from some requirements. Here is a list of those ' 'requirements along with the hashes their downloaded archives ' 'actually had. Add lines like these to your requirements files to ' 'prevent tampering. (If you did not enable --require-hashes ' 'manually, note that it turns on automatically when any package ' 'has a hash.)'

157 def 
	$__init__
 ( 
self
 , 
gotten_hash
 ) :

162 
self
 . 
gotten_hash
 = 
gotten_hash
 
	}

164 def 
	$body
 ( 
self
 ) :

166 from 
	~pip._internal.utils.hashes
 import 
FAVORITE_HASH

168 
package
 = None

169 if 
self
 . 
req
 :

173 
package
 = ( 
self
 . 
req
 . 
original_link
 if 
self
 . 
req
 . 
original_link

176 else 
getattr
 ( 
self
 . 
req
 , 'req' , None ) )

177 return '    %s --hash=%s:%s' % ( 
package
 or 'unknown package' ,

178 
FAVORITE_HASH
 ,

179 
self
 . 
gotten_hash
 ) 
	}

182 class 
	cHashUnpinned
 ( 
HashError
 ) :

186 
order
 = 3

187 
head
 = ( 'In --require-hashes mode, all requirements must have their ' 'versions pinned with ==. These do not:'

191 class 
	cHashMismatch
 ( 
HashError
 ) :

200 
order
 = 4

201 
head
 = ( 'THESE PACKAGES DO NOT MATCH THE HASHES FROM THE REQUIREMENTS ' 'FILE. If you have updated the package versions, please update ' 'the hashes. Otherwise, examine the package contents carefully; ' 'someone may have tampered with them.'

206 def 
	$__init__
 ( 
self
 , 
allowed
 , 
gots
 ) :

213 
self
 . 
allowed
 = 
allowed

214 
self
 . 
gots
 = 
gots
 
	}

216 def 
	$body
 ( 
self
 ) :

217 return '    %s:\n%s' % ( 
self
 . 
_requirement_name
 ( ) ,

218 
self
 . 
_hash_comparison
 ( ) ) 
	}

220 def 
	$_hash_comparison
 ( 
self
 ) :

231 def 
hash_then_or
 ( 
hash_name
 ) :

234 return 
chain
 ( [ 
hash_name
 ] , 
repeat
 ( '    or' ) )

236 
lines
 = [ ]

237 for 
hash_name
 , 
expecteds
 in 
iteritems
 ( 
self
 . 
allowed
 ) :

238 
prefix
 = 
hash_then_or
 ( 
hash_name
 )

239 
lines
 . 
extend
 ( ( '        Expected %s %s' % ( 
next
 ( 
prefix
 ) , 
e
 ) )

240 for 
e
 in 
expecteds
 )

241 
lines
 . 
append
 ( '             Got        %s\n' %

242 
self
 . 
gots
 [ 
hash_name
 ] . 
hexdigest
 ( ) )

243 
prefix
 = '    or'

244 return '\n' . 
join
 ( 
lines
 ) 
	}

247 class 
	cUnsupportedPythonVersion
 ( 
InstallationError
 ) :

252 class 
	cConfigurationFileCouldNotBeLoaded
 ( 
ConfigurationError
 ) :

256 def 
	$__init__
 ( 
self
 , 
reason
 = "could not be loaded" , 
fname
 = None , 
error
 = None ) :

257 
super
 ( 
ConfigurationFileCouldNotBeLoaded
 , 
self
 ) . 
__init__
 ( 
error
 )

258 
self
 . 
reason
 = 
reason

259 
self
 . 
fname
 = 
fname

260 
self
 . 
error
 = 
error
 
	}

262 def 
	$__str__
 ( 
self
 ) :

263 if 
self
 . 
fname
 is not None :

264 
message_part
 = " in {}." . 
format
 ( 
self
 . 
fname
 )

266 assert 
self
 . 
error
 is not None

267 
message_part
 = ".\n{}\n" . 
format
 ( 
self
 . 
error
 . 
message
 )

268 return "Configuration file {}{}" . 
format
 ( 
self
 . 
reason
 , 
message_part
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/download.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~cgi

4 import 
	~email.utils

5 import 
	~getpass

6 import 
	~json

7 import 
	~logging

8 import 
	~mimetypes

9 import 
	~os

10 import 
	~platform

11 import 
	~re

12 import 
	~shutil

13 import 
	~sys

15 from 
	~pip._vendor
 import 
requests
 , 
six
 , 
urllib3

16 from 
	~pip._vendor.cachecontrol
 import 
CacheControlAdapter

17 from 
	~pip._vendor.cachecontrol.caches
 import 
FileCache

18 from 
	~pip._vendor.lockfile
 import 
LockError

19 from 
	~pip._vendor.requests.adapters
 import 
BaseAdapter
 , 
HTTPAdapter

20 from 
	~pip._vendor.requests.auth
 import 
AuthBase
 , 
HTTPBasicAuth

21 from 
	~pip._vendor.requests.models
 import 
CONTENT_CHUNK_SIZE
 , 
Response

22 from 
	~pip._vendor.requests.structures
 import 
CaseInsensitiveDict

23 from 
	~pip._vendor.requests.utils
 import 
get_netrc_auth

26 from 
	~pip._vendor.six.moves
 import 
xmlrpc_client

27 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

28 from 
	~pip._vendor.six.moves.urllib
 import 
request
 as 
urllib_request

29 from 
	~pip._vendor.six.moves.urllib.parse
 import 
unquote
 as 
urllib_unquote

30 from 
	~pip._vendor.urllib3.util
 import 
IS_PYOPENSSL

32 import 
	~pip

33 from 
	~pip._internal.exceptions
 import 
HashMismatch
 , 
InstallationError

34 from 
	~pip._internal.locations
 import 
write_delete_marker_file

35 from 
	~pip._internal.models.index
 import 
PyPI

36 from 
	~pip._internal.utils.encoding
 import 
auto_decode

37 from 
	~pip._internal.utils.filesystem
 import 
check_path_owner

38 from 
	~pip._internal.utils.glibc
 import 
libc_ver

39 from 
	~pip._internal.utils.logging
 import 
indent_log

40 from 
	~pip._internal.utils.misc
 import (

41 
ARCHIVE_EXTENSIONS
 , 
ask_path_exists
 , 
backup_dir
 , 
call_subprocess
 , 
consume
 ,

42 
display_path
 , 
format_size
 , 
get_installed_version
 , 
rmtree
 , 
splitext
 ,

43 
unpack_file
 ,

45 from 
	~pip._internal.utils.setuptools_build
 import 
SETUPTOOLS_SHIM

46 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

47 from 
	~pip._internal.utils.ui
 import 
DownloadProgressProvider

48 from 
	~pip._internal.vcs
 import 
vcs

51 import 
	~ssl

52 except 
ImportError
 :

53 
ssl
 = None

55 
HAS_TLS
 = ( 
ssl
 is not None ) or 
IS_PYOPENSSL

57 
__all__
 = [ 'get_file_content' , 'is_url'

64 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

67 def 
	$user_agent
 ( ) :

71 
data
 = { "installer"

72 : { "name" : "pip" , "version" : 
pip
 . 
__version__
 } , "python"

73 : 
platform
 . 
python_version
 ( ) , "implementation"

75 : 
platform
 . 
python_implementation
 ( ) ,

79 if 
data
 [ "implementation" ] [ "name" ] == 'CPython' :

80 
data
 [ "implementation" ] [ "version" ] = 
platform
 . 
python_version
 ( )

81 elif 
data
 [ "implementation" ] [ "name" ] == 'PyPy' :

82 if 
sys
 . 
pypy_version_info
 . 
releaselevel
 == 'final' :

83 
pypy_version_info
 = 
sys
 . 
pypy_version_info
 [ : 3 ]

85 
pypy_version_info
 = 
sys
 . 
pypy_version_info

86 
data
 [ "implementation" ] [ "version" ] = "." . 
join
 (

87 [ 
str
 ( 
x
 ) for 
x
 in 
pypy_version_info
 ]

89 elif 
data
 [ "implementation" ] [ "name" ] == 'Jython' :

91 
data
 [ "implementation" ] [ "version" ] = 
platform
 . 
python_version
 ( )

92 elif 
data
 [ "implementation" ] [ "name" ] == 'IronPython' :

94 
data
 [ "implementation" ] [ "version" ] = 
platform
 . 
python_version
 ( )

96 if 
sys
 . 
platform
 . 
startswith
 ( "linux" ) :

97 from 
	~pip._vendor
 import 
distro

98 
distro_infos
 = 
dict
 ( 
filter
 (

99 lambda 
x
 : 
x
 [ 1 ] ,

100 
zip
 ( [ "name" , "version" , "id" ] , 
distro
 . 
linux_distribution
 ( ) ) ,

102 
libc
 = 
dict
 ( 
filter
 (

103 lambda 
x
 : 
x
 [ 1 ] ,

104 
zip
 ( [ "lib" , "version" ] , 
libc_ver
 ( ) ) ,

106 if 
libc
 :

107 
distro_infos
 [ "libc" ] = 
libc

108 if 
distro_infos
 :

109 
data
 [ "distro" ] = 
distro_infos

111 if 
sys
 . 
platform
 . 
startswith
 ( "darwin" ) and 
platform
 . 
mac_ver
 ( ) [ 0 ] :

112 
data
 [ "distro" ] = { "name" : "macOS" , "version" : 
platform
 . 
mac_ver
 ( ) [ 0 ] }

114 if 
platform
 . 
system
 ( ) :

115 
data
 . 
setdefault
 ( "system" , { } ) [ "name" ] = 
platform
 . 
system
 ( )

117 if 
platform
 . 
release
 ( ) :

118 
data
 . 
setdefault
 ( "system" , { } ) [ "release" ] = 
platform
 . 
release
 ( )

120 if 
platform
 . 
machine
 ( ) :

121 
data
 [ "cpu" ] = 
platform
 . 
machine
 ( )

123 if 
HAS_TLS
 :

124 
data
 [ "openssl_version" ] = 
ssl
 . 
OPENSSL_VERSION

126 
setuptools_version
 = 
get_installed_version
 ( "setuptools" )

127 if 
setuptools_version
 is not None :

128 
data
 [ "setuptools_version" ] = 
setuptools_version

130 return "{data[installer][name]}/{data[installer][version]} {json}" . 
format
 (

131 
data
 = 
data
 ,

132 
json
 = 
json
 . 
dumps
 ( 
data
 , 
separators
 = ( "," , ":" ) , 
sort_keys
 = True ) ,

133 ) 
	}

136 class 
	cMultiDomainBasicAuth
 ( 
AuthBase
 ) :

138 def 
	$__init__
 ( 
self
 , 
prompting
 = True ) :

139 
self
 . 
prompting
 = 
prompting

140 
self
 . 
passwords
 = { } 
	}

142 def 
	$__call__
 ( 
self
 , 
req
 ) :

143 
parsed
 = 
urllib_parse
 . 
urlparse
 ( 
req
 . 
url
 )

146 
netloc
 = 
parsed
 . 
netloc
 . 
rsplit
 ( "@" , 1 ) [ - 1 ]

149 
req
 . 
url
 = 
urllib_parse
 . 
urlunparse
 ( 
parsed
 [ : 1 ] + ( 
netloc
 , ) + 
parsed
 [ 2 : ] )

152 
username
 , 
password
 = 
self
 . 
passwords
 . 
get
 ( 
netloc
 , ( None , None ) )

155 if 
username
 is None :

156 
username
 , 
password
 = 
self
 . 
parse_credentials
 ( 
parsed
 . 
netloc
 )

159 if 
username
 is None and 
password
 is None :

160 
netrc_auth
 = 
get_netrc_auth
 ( 
req
 . 
url
 )

161 
username
 , 
password
 = 
netrc_auth
 if 
netrc_auth
 else ( None , None )

163 if 
username
 or 
password
 :

165 
self
 . 
passwords
 [ 
netloc
 ] = ( 
username
 , 
password
 )

168 
req
 = 
HTTPBasicAuth
 ( 
username
 or "" , 
password
 or "" ) ( 
req
 )

171 
req
 . 
register_hook
 ( "response" , 
self
 . 
handle_401
 )

173 return 
req
 
	}

175 def 
	$handle_401
 ( 
self
 , 
resp
 , ** 
kwargs
 ) :

178 if 
resp
 . 
status_code
 != 401 :

179 return 
resp

182 if not 
self
 . 
prompting
 :

183 return 
resp

185 
parsed
 = 
urllib_parse
 . 
urlparse
 ( 
resp
 . 
url
 )

188 
username
 = 
six
 . 
moves
 . 
input
 ( "User for %s: " % 
parsed
 . 
netloc
 )

189 
password
 = 
getpass
 . 
getpass
 ( "Password: " )

192 if 
username
 or 
password
 :

193 
self
 . 
passwords
 [ 
parsed
 . 
netloc
 ] = ( 
username
 , 
password
 )

197 
resp
 . 
content

198 
resp
 . 
raw
 . 
release_conn
 ( )

201 
req
 = 
HTTPBasicAuth
 ( 
username
 or "" , 
password
 or "" ) ( 
resp
 . 
request
 )

204 
new_resp
 = 
resp
 . 
connection
 . 
send
 ( 
req
 , ** 
kwargs
 )

205 
new_resp
 . 
history
 . 
append
 ( 
resp
 )

207 return 
new_resp
 
	}

209 def 
	$parse_credentials
 ( 
self
 , 
netloc
 ) :

210 if "@" in 
netloc
 :

211 
userinfo
 = 
netloc
 . 
rsplit
 ( "@" , 1 ) [ 0 ]

212 if ":" in 
userinfo
 :

213 
user
 , 
pwd
 = 
userinfo
 . 
split
 ( ":" , 1 )

214 return ( 
urllib_unquote
 ( 
user
 ) , 
urllib_unquote
 ( 
pwd
 ) )

215 return 
urllib_unquote
 ( 
userinfo
 ) , None

216 return None , None 
	}

219 class 
	cLocalFSAdapter
 ( 
BaseAdapter
 ) :

221 def 
	$send
 ( 
self
 , 
request
 , 
stream
 = None , 
timeout
 = None , 
verify
 = None , 
cert
 = None ,

222 
proxies
 = None ) :

223 
pathname
 = 
url_to_path
 ( 
request
 . 
url
 )

225 
resp
 = 
Response
 ( )

226 
resp
 . 
status_code
 = 200

227 
resp
 . 
url
 = 
request
 . 
url

230 
stats
 = 
os
 . 
stat
 ( 
pathname
 )

231 except 
OSError
 as 
exc
 :

232 
resp
 . 
status_code
 = 404

233 
resp
 . 
raw
 = 
exc

235 
modified
 = 
email
 . 
utils
 . 
formatdate
 ( 
stats
 . 
st_mtime
 , 
usegmt
 = True )

236 
content_type
 = 
mimetypes
 . 
guess_type
 ( 
pathname
 ) [ 0 ] or "text/plain"

237 
resp
 . 
headers
 = 
CaseInsensitiveDict
 ( { "Content-Type"

238 : 
content_type
 , "Content-Length"

239 : 
stats
 . 
st_size
 , "Last-Modified"

240 : 
modified
 ,

243 
resp
 . 
raw
 = 
open
 ( 
pathname
 , "rb" )

244 
resp
 . 
close
 = 
resp
 . 
raw
 . 
close

246 return 
resp
 
	}

248 def 
	$close
 ( 
self
 ) :

249 pass 
	}

252 class 
	cSafeFileCache
 ( 
FileCache
 ) :

258 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

259 
super
 ( 
SafeFileCache
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

266 if not 
check_path_owner
 ( 
self
 . 
directory
 ) :

267 
logger
 . 
warning
 ( "The directory '%s' or its parent directory is not owned by " "the current user and the cache has been disabled. Please " "check the permissions and owner of that directory. If " "executing pip with sudo, you may want sudo's -H flag."

272 
self
 . 
directory
 ,

276 
self
 . 
directory
 = None 
	}

278 def 
	$get
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

280 if 
self
 . 
directory
 is None :

284 return 
super
 ( 
SafeFileCache
 , 
self
 ) . 
get
 ( * 
args
 , ** 
kwargs
 )

285 except ( 
LockError
 , 
OSError
 , 
IOError
 ) :

289 pass 
	}

291 def 
	$set
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

293 if 
self
 . 
directory
 is None :

297 return 
super
 ( 
SafeFileCache
 , 
self
 ) . 
set
 ( * 
args
 , ** 
kwargs
 )

298 except ( 
LockError
 , 
OSError
 , 
IOError
 ) :

302 pass 
	}

304 def 
	$delete
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

306 if 
self
 . 
directory
 is None :

310 return 
super
 ( 
SafeFileCache
 , 
self
 ) . 
delete
 ( * 
args
 , ** 
kwargs
 )

311 except ( 
LockError
 , 
OSError
 , 
IOError
 ) :

315 pass 
	}

318 class 
	cInsecureHTTPAdapter
 ( 
HTTPAdapter
 ) :

320 def 
	$cert_verify
 ( 
self
 , 
conn
 , 
url
 , 
verify
 , 
cert
 ) :

321 
conn
 . 
cert_reqs
 = 'CERT_NONE'

322 
conn
 . 
ca_certs
 = None 
	}

325 class 
	cPipSession
 ( 
requests
 . 
Session
 ) :

327 
timeout
 = None

329 def 
	$__init__
 ( 
self
 , * 
args
 , ** 
kwargs
 ) :

330 
retries
 = 
kwargs
 . 
pop
 ( "retries" , 0 )

331 
cache
 = 
kwargs
 . 
pop
 ( "cache" , None )

332 
insecure_hosts
 = 
kwargs
 . 
pop
 ( "insecure_hosts" , [ ] )

334 
super
 ( 
PipSession
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 )

337 
self
 . 
headers
 [ "User-Agent" ] = 
user_agent
 ( )

340 
self
 . 
auth
 = 
MultiDomainBasicAuth
 ( )

344 
retries
 = 
urllib3
 . 
Retry
 (

347 
total
 = 
retries
 ,

355 
status_forcelist
 = [ 500 , 503 , 520 , 527 ] ,

359 
backoff_factor
 = 0.25 ,

366 if 
cache
 :

367 
secure_adapter
 = 
CacheControlAdapter
 (

368 
cache
 = 
SafeFileCache
 ( 
cache
 , 
use_dir_lock
 = True ) ,

369 
max_retries
 = 
retries
 ,

372 
secure_adapter
 = 
HTTPAdapter
 ( 
max_retries
 = 
retries
 )

378 
insecure_adapter
 = 
InsecureHTTPAdapter
 ( 
max_retries
 = 
retries
 )

380 
self
 . 
mount
 ( "https://" , 
secure_adapter
 )

381 
self
 . 
mount
 ( "http://" , 
insecure_adapter
 )

384 
self
 . 
mount
 ( "file://" , 
LocalFSAdapter
 ( ) )

388 for 
host
 in 
insecure_hosts
 :

389 
self
 . 
mount
 ( "https://{}/" . 
format
 ( 
host
 ) , 
insecure_adapter
 ) 
	}

391 def 
	$request
 ( 
self
 , 
method
 , 
url
 , * 
args
 , ** 
kwargs
 ) :

393 
kwargs
 . 
setdefault
 ( "timeout" , 
self
 . 
timeout
 )

396 return 
super
 ( 
PipSession
 , 
self
 ) . 
request
 ( 
method
 , 
url
 , * 
args
 , ** 
kwargs
 ) 
	}

399 def 
	$get_file_content
 ( 
url
 , 
comes_from
 = None , 
session
 = None ) :

407 if 
session
 is None :

408 raise 
TypeError
 ( "get_file_content() missing 1 required keyword argument: 'session'"

412 
match
 = 
_scheme_re
 . 
search
 ( 
url
 )

413 if 
match
 :

414 
scheme
 = 
match
 . 
group
 ( 1 ) . 
lower
 ( )

415 if ( 
scheme
 == 'file' and 
comes_from
 and

416 
comes_from
 . 
startswith
 ( 'http' ) ) :

417 raise 
InstallationError
 ( 'Requirements file %s references URL %s, which is local'

419 % ( 
comes_from
 , 
url
 ) )

420 if 
scheme
 == 'file' :

421 
path
 = 
url
 . 
split
 ( ':' , 1 ) [ 1 ]

422 
path
 = 
path
 . 
replace
 ( '\\' , '/' )

423 
match
 = 
_url_slash_drive_re
 . 
match
 ( 
path
 )

424 if 
match
 :

425 
path
 = 
match
 . 
group
 ( 1 ) + ':' + 
path
 . 
split
 ( '|' , 1 ) [ 1 ]

426 
path
 = 
urllib_parse
 . 
unquote
 ( 
path
 )

427 if 
path
 . 
startswith
 ( '/' ) :

428 
path
 = '/' + 
path
 . 
lstrip
 ( '/' )

429 
url
 = 
path

432 
resp
 = 
session
 . 
get
 ( 
url
 )

433 
resp
 . 
raise_for_status
 ( )

434 return 
resp
 . 
url
 , 
resp
 . 
text

436 with 
open
 ( 
url
 , 'rb' ) as 
f
 :

437 
content
 = 
auto_decode
 ( 
f
 . 
read
 ( ) )

438 except 
IOError
 as 
exc
 :

439 raise 
InstallationError
 ( 'Could not open requirements file: %s'

440 % 
str
 ( 
exc
 )

442 return 
url
 , 
content
 
	}

445 
_scheme_re
 = 
re
 . 
compile
 ( r'^(http|https|file):' , 
re
 . 
I
 )

446 
_url_slash_drive_re
 = 
re
 . 
compile
 ( r'/*([a-z])\|' , 
re
 . 
I
 )

449 def 
	$is_url
 ( 
name
 ) :

451 if ':' not in 
name
 :

453 
scheme
 = 
name
 . 
split
 ( ':' , 1 ) [ 0 ] . 
lower
 ( )

454 return 
scheme
 in [ 'http' , 'https' , 'file' , 'ftp' ] + 
vcs
 . 
all_schemes
 
	}

457 def 
	$url_to_path
 ( 
url
 ) :

461 assert 
url
 . 
startswith
 ( 'file:' ) , ( "You can only turn file: urls into filenames (not %r)"

462 % 
url
 )

464 
_
 , 
netloc
 , 
path
 , 
_
 , 
_
 = 
urllib_parse
 . 
urlsplit
 ( 
url
 )

467 if 
netloc
 :

468 
netloc
 = '\\\\' + 
netloc

470 
path
 = 
urllib_request
 . 
url2pathname
 ( 
netloc
 + 
path
 )

471 return 
path
 
	}

474 def 
	$path_to_url
 ( 
path
 ) :

479 
path
 = 
os
 . 
path
 . 
normpath
 ( 
os
 . 
path
 . 
abspath
 ( 
path
 ) )

480 
url
 = 
urllib_parse
 . 
urljoin
 ( 'file:' , 
urllib_request
 . 
pathname2url
 ( 
path
 ) )

481 return 
url
 
	}

484 def 
	$is_archive_file
 ( 
name
 ) :

486 
ext
 = 
splitext
 ( 
name
 ) [ 1 ] . 
lower
 ( )

487 if 
ext
 in 
ARCHIVE_EXTENSIONS
 :

489 return False 
	}

492 def 
	$unpack_vcs_link
 ( 
link
 , 
location
 ) :

493 
vcs_backend
 = 
_get_used_vcs_backend
 ( 
link
 )

494 
vcs_backend
 . 
unpack
 ( 
location
 ) 
	}

497 def 
	$_get_used_vcs_backend
 ( 
link
 ) :

498 for 
backend
 in 
vcs
 . 
backends
 :

499 if 
link
 . 
scheme
 in 
backend
 . 
schemes
 :

500 
vcs_backend
 = 
backend
 ( 
link
 . 
url
 )

501 return 
vcs_backend
 
	}

504 def 
	$is_vcs_url
 ( 
link
 ) :

505 return 
bool
 ( 
_get_used_vcs_backend
 ( 
link
 ) ) 
	}

508 def 
	$is_file_url
 ( 
link
 ) :

509 return 
link
 . 
url
 . 
lower
 ( ) . 
startswith
 ( 'file:' ) 
	}

512 def 
	$is_dir_url
 ( 
link
 ) :

519 
link_path
 = 
url_to_path
 ( 
link
 . 
url_without_fragment
 )

520 return 
os
 . 
path
 . 
isdir
 ( 
link_path
 ) 
	}

523 def 
	$_progress_indicator
 ( 
iterable
 , * 
args
 , ** 
kwargs
 ) :

524 return 
iterable
 
	}

527 def 
	$_download_url
 ( 
resp
 , 
link
 , 
content_file
 , 
hashes
 , 
progress_bar
 ) :

529 
total_length
 = 
int
 ( 
resp
 . 
headers
 [ 'content-length' ] )

530 except ( 
ValueError
 , 
KeyError
 , 
TypeError
 ) :

531 
total_length
 = 0

533 
cached_resp
 = 
getattr
 ( 
resp
 , "from_cache" , False )

534 if 
logger
 . 
getEffectiveLevel
 ( ) > 
logging
 . 
INFO
 :

535 
show_progress
 = False

536 elif 
cached_resp
 :

537 
show_progress
 = False

538 elif 
total_length
 > ( 40 * 1000 ) :

539 
show_progress
 = True

540 elif not 
total_length
 :

541 
show_progress
 = True

543 
show_progress
 = False

545 
show_url
 = 
link
 . 
show_url

547 def 
resp_read
 ( 
chunk_size
 ) :

550 for 
chunk
 in 
resp
 . 
raw
 . 
stream
 (

551 
chunk_size
 ,

574 
decode_content
 = False ) :

575 yield 
chunk

576 except 
AttributeError
 :

579 
chunk
 = 
resp
 . 
raw
 . 
read
 ( 
chunk_size
 )

580 if not 
chunk
 :

582 yield 
chunk

584 def 
written_chunks
 ( 
chunks
 ) :

585 for 
chunk
 in 
chunks
 :

586 
content_file
 . 
write
 ( 
chunk
 )

587 yield 
chunk

589 
progress_indicator
 = 
_progress_indicator

591 if 
link
 . 
netloc
 == 
PyPI
 . 
netloc
 :

592 
url
 = 
show_url

594 
url
 = 
link
 . 
url_without_fragment

596 if 
show_progress
 :

597 
progress_indicator
 = 
DownloadProgressProvider
 ( 
progress_bar
 ,

598 
max
 = 
total_length
 )

599 if 
total_length
 :

600 
logger
 . 
info
 ( "Downloading %s (%s)" , 
url
 , 
format_size
 ( 
total_length
 ) )

602 
logger
 . 
info
 ( "Downloading %s" , 
url
 )

603 elif 
cached_resp
 :

604 
logger
 . 
info
 ( "Using cached %s" , 
url
 )

606 
logger
 . 
info
 ( "Downloading %s" , 
url
 )

608 
logger
 . 
debug
 ( 'Downloading from URL %s' , 
link
 )

610 
downloaded_chunks
 = 
written_chunks
 (

611 
progress_indicator
 (

612 
resp_read
 ( 
CONTENT_CHUNK_SIZE
 ) ,

613 
CONTENT_CHUNK_SIZE

616 if 
hashes
 :

617 
hashes
 . 
check_against_chunks
 ( 
downloaded_chunks
 )

619 
consume
 ( 
downloaded_chunks
 ) 
	}

622 def 
	$_copy_file
 ( 
filename
 , 
location
 , 
link
 ) :

623 
copy
 = True

624 
download_location
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
link
 . 
filename
 )

625 if 
os
 . 
path
 . 
exists
 ( 
download_location
 ) :

626 
response
 = 
ask_path_exists
 ( 'The file %s exists. (i)gnore, (w)ipe, (b)ackup, (a)abort'

628 
display_path
 ( 
download_location
 ) , ( 'i' , 'w' , 'b' , 'a' ) )

629 if 
response
 == 'i' :

630 
copy
 = False

631 elif 
response
 == 'w' :

632 
logger
 . 
warning
 ( 'Deleting %s' , 
display_path
 ( 
download_location
 ) )

633 
os
 . 
remove
 ( 
download_location
 )

634 elif 
response
 == 'b' :

635 
dest_file
 = 
backup_dir
 ( 
download_location
 )

636 
logger
 . 
warning
 ( 'Backing up %s to %s'

638 
display_path
 ( 
download_location
 ) ,

639 
display_path
 ( 
dest_file
 ) ,

641 
shutil
 . 
move
 ( 
download_location
 , 
dest_file
 )

642 elif 
response
 == 'a' :

643 
sys
 . 
exit
 ( - 1 )

644 if 
copy
 :

645 
shutil
 . 
copy
 ( 
filename
 , 
download_location
 )

646 
logger
 . 
info
 ( 'Saved %s' , 
display_path
 ( 
download_location
 ) ) 
	}

649 def 
	$unpack_http_url
 ( 
link
 , 
location
 , 
download_dir
 = None ,

650 
session
 = None , 
hashes
 = None , 
progress_bar
 = "on" ) :

651 if 
session
 is None :

652 raise 
TypeError
 ( "unpack_http_url() missing 1 required keyword argument: 'session'"

656 with 
TempDirectory
 ( 
kind
 = "unpack" ) as 
temp_dir
 :

658 
already_downloaded_path
 = None

659 if 
download_dir
 :

660 
already_downloaded_path
 = 
_check_download_dir
 ( 
link
 ,

661 
download_dir
 ,

662 
hashes
 )

664 if 
already_downloaded_path
 :

665 
from_path
 = 
already_downloaded_path

666 
content_type
 = 
mimetypes
 . 
guess_type
 ( 
from_path
 ) [ 0 ]

669 
from_path
 , 
content_type
 = 
_download_http_url
 ( 
link
 ,

670 
session
 ,

671 
temp_dir
 . 
path
 ,

672 
hashes
 ,

673 
progress_bar
 )

677 
unpack_file
 ( 
from_path
 , 
location
 , 
content_type
 , 
link
 )

680 if 
download_dir
 and not 
already_downloaded_path
 :

681 
_copy_file
 ( 
from_path
 , 
download_dir
 , 
link
 )

683 if not 
already_downloaded_path
 :

684 
os
 . 
unlink
 ( 
from_path
 ) 
	}

687 def 
	$unpack_file_url
 ( 
link
 , 
location
 , 
download_dir
 = None , 
hashes
 = None ) :

693 
link_path
 = 
url_to_path
 ( 
link
 . 
url_without_fragment
 )

696 if 
is_dir_url
 ( 
link
 ) :

697 if 
os
 . 
path
 . 
isdir
 ( 
location
 ) :

698 
rmtree
 ( 
location
 )

699 
shutil
 . 
copytree
 ( 
link_path
 , 
location
 , 
symlinks
 = True )

700 if 
download_dir
 :

701 
logger
 . 
info
 ( 'Link is a directory, ignoring download_dir' )

709 if 
hashes
 :

710 
hashes
 . 
check_against_path
 ( 
link_path
 )

713 
already_downloaded_path
 = None

714 if 
download_dir
 :

715 
already_downloaded_path
 = 
_check_download_dir
 ( 
link
 ,

716 
download_dir
 ,

717 
hashes
 )

719 if 
already_downloaded_path
 :

720 
from_path
 = 
already_downloaded_path

722 
from_path
 = 
link_path

724 
content_type
 = 
mimetypes
 . 
guess_type
 ( 
from_path
 ) [ 0 ]

728 
unpack_file
 ( 
from_path
 , 
location
 , 
content_type
 , 
link
 )

731 if 
download_dir
 and not 
already_downloaded_path
 :

732 
_copy_file
 ( 
from_path
 , 
download_dir
 , 
link
 ) 
	}

735 def 
	$_copy_dist_from_dir
 ( 
link_path
 , 
location
 ) :

750 if 
os
 . 
path
 . 
isdir
 ( 
location
 ) :

751 
rmtree
 ( 
location
 )

754 
setup_py
 = 'setup.py'

755 
sdist_args
 = [ 
sys
 . 
executable
 ]

756 
sdist_args
 . 
append
 ( '-c' )

757 
sdist_args
 . 
append
 ( 
SETUPTOOLS_SHIM
 % 
setup_py
 )

758 
sdist_args
 . 
append
 ( 'sdist' )

759 
sdist_args
 += [ '--dist-dir' , 
location
 ]

760 
logger
 . 
info
 ( 'Running setup.py sdist for %s' , 
link_path
 )

762 with 
indent_log
 ( ) :

763 
call_subprocess
 ( 
sdist_args
 , 
cwd
 = 
link_path
 , 
show_stdout
 = False )

766 
sdist
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
os
 . 
listdir
 ( 
location
 ) [ 0 ] )

767 
logger
 . 
info
 ( 'Unpacking sdist %s into %s' , 
sdist
 , 
location
 )

768 
unpack_file
 ( 
sdist
 , 
location
 , 
content_type
 = None , 
link
 = None ) 
	}

771 class 
	cPipXmlrpcTransport
 ( 
xmlrpc_client
 . 
Transport
 ) :

776 def 
	$__init__
 ( 
self
 , 
index_url
 , 
session
 , 
use_datetime
 = False ) :

777 
xmlrpc_client
 . 
Transport
 . 
__init__
 ( 
self
 , 
use_datetime
 )

778 
index_parts
 = 
urllib_parse
 . 
urlparse
 ( 
index_url
 )

779 
self
 . 
_scheme
 = 
index_parts
 . 
scheme

780 
self
 . 
_session
 = 
session
 
	}

782 def 
	$request
 ( 
self
 , 
host
 , 
handler
 , 
request_body
 , 
verbose
 = False ) :

783 
parts
 = ( 
self
 . 
_scheme
 , 
host
 , 
handler
 , None , None , None )

784 
url
 = 
urllib_parse
 . 
urlunparse
 ( 
parts
 )

786 
headers
 = { 'Content-Type' : 'text/xml' }

787 
response
 = 
self
 . 
_session
 . 
post
 ( 
url
 , 
data
 = 
request_body
 ,

788 
headers
 = 
headers
 , 
stream
 = True )

789 
response
 . 
raise_for_status
 ( )

790 
self
 . 
verbose
 = 
verbose

791 return 
self
 . 
parse_response
 ( 
response
 . 
raw
 )

792 except 
requests
 . 
HTTPError
 as 
exc
 :

793 
logger
 . 
critical
 ( "HTTP error %s while getting %s"

795 
exc
 . 
response
 . 
status_code
 , 
url
 ,

797 raise 
	}

800 def 
	$unpack_url
 ( 
link
 , 
location
 , 
download_dir
 = None ,

801 
only_download
 = False , 
session
 = None , 
hashes
 = None ,

802 
progress_bar
 = "on" ) :

818 if 
is_vcs_url
 ( 
link
 ) :

819 
unpack_vcs_link
 ( 
link
 , 
location
 )

822 elif 
is_file_url
 ( 
link
 ) :

823 
unpack_file_url
 ( 
link
 , 
location
 , 
download_dir
 , 
hashes
 = 
hashes
 )

827 if 
session
 is None :

828 
session
 = 
PipSession
 ( )

830 
unpack_http_url
 (

831 
link
 ,

832 
location
 ,

833 
download_dir
 ,

834 
session
 ,

835 
hashes
 = 
hashes
 ,

836 
progress_bar
 = 
progress_bar

838 if 
only_download
 :

839 
write_delete_marker_file
 ( 
location
 ) 
	}

842 def 
	$_download_http_url
 ( 
link
 , 
session
 , 
temp_dir
 , 
hashes
 , 
progress_bar
 ) :

844 
target_url
 = 
link
 . 
url
 . 
split
 ( '#' , 1 ) [ 0 ]

846 
resp
 = 
session
 . 
get
 (

847 
target_url
 ,

867 
headers
 = { "Accept-Encoding" : "identity" } ,

868 
stream
 = True ,

870 
resp
 . 
raise_for_status
 ( )

871 except 
requests
 . 
HTTPError
 as 
exc
 :

872 
logger
 . 
critical
 ( "HTTP error %s while getting %s"

873 , 
exc
 . 
response
 . 
status_code
 , 
link
 ,

877 
content_type
 = 
resp
 . 
headers
 . 
get
 ( 'content-type' , '' )

878 
filename
 = 
link
 . 
filename

880 
content_disposition
 = 
resp
 . 
headers
 . 
get
 ( 'content-disposition' )

881 if 
content_disposition
 :

882 
type
 , 
params
 = 
cgi
 . 
parse_header
 ( 
content_disposition
 )

885 
filename
 = 
params
 . 
get
 ( 'filename' ) or 
filename

886 
ext
 = 
splitext
 ( 
filename
 ) [ 1 ]

887 if not 
ext
 :

888 
ext
 = 
mimetypes
 . 
guess_extension
 ( 
content_type
 )

889 if 
ext
 :

890 
filename
 += 
ext

891 if not 
ext
 and 
link
 . 
url
 != 
resp
 . 
url
 :

892 
ext
 = 
os
 . 
path
 . 
splitext
 ( 
resp
 . 
url
 ) [ 1 ]

893 if 
ext
 :

894 
filename
 += 
ext

895 
file_path
 = 
os
 . 
path
 . 
join
 ( 
temp_dir
 , 
filename
 )

896 with 
open
 ( 
file_path
 , 'wb' ) as 
content_file
 :

897 
_download_url
 ( 
resp
 , 
link
 , 
content_file
 , 
hashes
 , 
progress_bar
 )

898 return 
file_path
 , 
content_type
 
	}

901 def 
	$_check_download_dir
 ( 
link
 , 
download_dir
 , 
hashes
 ) :

905 
download_path
 = 
os
 . 
path
 . 
join
 ( 
download_dir
 , 
link
 . 
filename
 )

906 if 
os
 . 
path
 . 
exists
 ( 
download_path
 ) :

908 
logger
 . 
info
 ( 'File was already downloaded %s' , 
download_path
 )

909 if 
hashes
 :

911 
hashes
 . 
check_against_path
 ( 
download_path
 )

912 except 
HashMismatch
 :

913 
logger
 . 
warning
 ( 'Previously-downloaded file %s has bad hash. ' 'Re-downloading.'

916 
download_path

918 
os
 . 
unlink
 ( 
download_path
 )

920 return 
download_path

921 return None 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/index.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~cgi

5 import 
	~itertools

6 import 
	~logging

7 import 
	~mimetypes

8 import 
	~os

9 import 
	~posixpath

10 import 
	~re

11 import 
	~sys

12 from 
	~collections
 import 
namedtuple

14 from 
	~pip._vendor
 import 
html5lib
 , 
requests
 , 
six

15 from 
	~pip._vendor.distlib.compat
 import 
unescape

16 from 
	~pip._vendor.packaging
 import 
specifiers

17 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

18 from 
	~pip._vendor.packaging.version
 import 
parse
 as 
parse_version

19 from 
	~pip._vendor.requests.exceptions
 import 
HTTPError
 , 
SSLError

20 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

21 from 
	~pip._vendor.six.moves.urllib
 import 
request
 as 
urllib_request

23 from 
	~pip._internal.download
 import 
HAS_TLS
 , 
is_url
 , 
path_to_url
 , 
url_to_path

24 from 
	~pip._internal.exceptions
 import (

25 
BestVersionAlreadyInstalled
 , 
DistributionNotFound
 , 
InvalidWheelFilename
 ,

26 
UnsupportedWheel
 ,

28 from 
	~pip._internal.models.candidate
 import 
InstallationCandidate

29 from 
	~pip._internal.models.format_control
 import 
FormatControl

30 from 
	~pip._internal.models.index
 import 
PyPI

31 from 
	~pip._internal.models.link
 import 
Link

32 from 
	~pip._internal.pep425tags
 import 
get_supported

33 from 
	~pip._internal.utils.compat
 import 
ipaddress

34 from 
	~pip._internal.utils.deprecation
 import 
deprecated

35 from 
	~pip._internal.utils.logging
 import 
indent_log

36 from 
	~pip._internal.utils.misc
 import (

37 
ARCHIVE_EXTENSIONS
 , 
SUPPORTED_EXTENSIONS
 , 
normalize_path
 ,

38 
remove_auth_from_url
 ,

40 from 
	~pip._internal.utils.packaging
 import 
check_requires_python

41 from 
	~pip._internal.wheel
 import 
Wheel
 , 
wheel_ext

43 
__all__
 = [ 'FormatControl' , 'PackageFinder' ]

46 
SECURE_ORIGINS
 = [

59 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

62 def 
	$_get_content_type
 ( 
url
 , 
session
 ) :

64 
scheme
 , 
netloc
 , 
path
 , 
query
 , 
fragment
 = 
urllib_parse
 . 
urlsplit
 ( 
url
 )

65 if 
scheme
 not in { 'http' , 'https' } :

70 
resp
 = 
session
 . 
head
 ( 
url
 , 
allow_redirects
 = True )

71 
resp
 . 
raise_for_status
 ( )

73 return 
resp
 . 
headers
 . 
get
 ( "Content-Type" , "" ) 
	}

76 def 
	$_handle_get_page_fail
 ( 
link
 , 
reason
 , 
url
 , 
meth
 = None ) :

77 if 
meth
 is None :

78 
meth
 = 
logger
 . 
debug

79 
meth
 ( "Could not fetch URL %s: %s - skipping" , 
link
 , 
reason
 ) 
	}

82 def 
	$_get_html_page
 ( 
link
 , 
session
 = None ) :

83 if 
session
 is None :

84 raise 
TypeError
 ( "_get_html_page() missing 1 required keyword argument: 'session'"

88 
url
 = 
link
 . 
url

89 
url
 = 
url
 . 
split
 ( '#' , 1 ) [ 0 ]

92 from 
	~pip._internal.vcs
 import 
VcsSupport

93 for 
scheme
 in 
VcsSupport
 . 
schemes
 :

94 if 
url
 . 
lower
 ( ) . 
startswith
 ( 
scheme
 ) and 
url
 [ 
len
 ( 
scheme
 ) ] in '+:' :

95 
logger
 . 
debug
 ( 'Cannot look at %s URL %s' , 
scheme
 , 
link
 )

99 
filename
 = 
link
 . 
filename

100 for 
bad_ext
 in 
ARCHIVE_EXTENSIONS
 :

101 if 
filename
 . 
endswith
 ( 
bad_ext
 ) :

102 
content_type
 = 
_get_content_type
 ( 
url
 , 
session
 = 
session
 )

103 if 
content_type
 . 
lower
 ( ) . 
startswith
 ( 'text/html' ) :

106 
logger
 . 
debug
 ( 'Skipping page %s because of Content-Type: %s'

108 
link
 ,

109 
content_type
 ,

113 
logger
 . 
debug
 ( 'Getting page %s' , 
url
 )

116 ( 
scheme
 , 
netloc
 , 
path
 , 
params
 , 
query
 , 
fragment
 ) =

117 
urllib_parse
 . 
urlparse
 ( 
url
 )

118 if ( 
scheme
 == 'file' and

119 
os
 . 
path
 . 
isdir
 ( 
urllib_request
 . 
url2pathname
 ( 
path
 ) ) ) :

122 if not 
url
 . 
endswith
 ( '/' ) :

123 
url
 += '/'

124 
url
 = 
urllib_parse
 . 
urljoin
 ( 
url
 , 'index.html' )

125 
logger
 . 
debug
 ( ' file: URL is directory, getting %s' , 
url
 )

127 
resp
 = 
session
 . 
get
 (

128 
url
 ,

129 
headers
 = { "Accept"

147 
resp
 . 
raise_for_status
 ( )

154 
content_type
 = 
resp
 . 
headers
 . 
get
 ( 'Content-Type' , 'unknown' )

155 if not 
content_type
 . 
lower
 ( ) . 
startswith
 ( "text/html" ) :

156 
logger
 . 
debug
 ( 'Skipping page %s because of Content-Type: %s'

158 
link
 ,

159 
content_type
 ,

163 
inst
 = 
HTMLPage
 ( 
resp
 . 
content
 , 
resp
 . 
url
 , 
resp
 . 
headers
 )

164 except 
HTTPError
 as 
exc
 :

165 
_handle_get_page_fail
 ( 
link
 , 
exc
 , 
url
 )

166 except 
SSLError
 as 
exc
 :

167 
reason
 = "There was a problem confirming the ssl certificate: "

168 
reason
 += 
str
 ( 
exc
 )

169 
_handle_get_page_fail
 ( 
link
 , 
reason
 , 
url
 , 
meth
 = 
logger
 . 
info
 )

170 except 
requests
 . 
ConnectionError
 as 
exc
 :

171 
_handle_get_page_fail
 ( 
link
 , "connection error: %s" % 
exc
 , 
url
 )

172 except 
requests
 . 
Timeout
 :

173 
_handle_get_page_fail
 ( 
link
 , "timed out" , 
url
 )

175 return 
inst
 
	}

178 class 
	cPackageFinder
 ( 
object
 ) :

185 def 
	$__init__
 ( 
self
 , 
find_links
 , 
index_urls
 , 
allow_all_prereleases
 = False ,

186 
trusted_hosts
 = None , 
process_dependency_links
 = False ,

187 
session
 = None , 
format_control
 = None , 
platform
 = None ,

188 
versions
 = None , 
abi
 = None , 
implementation
 = None ,

189 
prefer_binary
 = False ) :

207 if 
session
 is None :

208 raise 
TypeError
 ( "PackageFinder() missing 1 required keyword argument: " "'session'"

218 
self
 . 
find_links
 = [ ]

219 for 
link
 in 
find_links
 :

220 if 
link
 . 
startswith
 ( '~' ) :

221 
new_link
 = 
normalize_path
 ( 
link
 )

222 if 
os
 . 
path
 . 
exists
 ( 
new_link
 ) :

223 
link
 = 
new_link

224 
self
 . 
find_links
 . 
append
 ( 
link
 )

226 
self
 . 
index_urls
 = 
index_urls

227 
self
 . 
dependency_links
 = [ ]

230 
self
 . 
logged_links
 = 
set
 ( )

232 
self
 . 
format_control
 = 
format_control
 or 
FormatControl
 ( 
set
 ( ) , 
set
 ( ) )

235 
self
 . 
secure_origins
 = [

236 ( "*" , 
host
 , "*" )

237 for 
host
 in ( 
trusted_hosts
 if 
trusted_hosts
 else [ ] )

241 
self
 . 
allow_all_prereleases
 = 
allow_all_prereleases

244 
self
 . 
process_dependency_links
 = 
process_dependency_links

247 
self
 . 
session
 = 
session

250 
self
 . 
valid_tags
 = 
get_supported
 (

251 
versions
 = 
versions
 ,

252 
platform
 = 
platform
 ,

253 
abi
 = 
abi
 ,

254 
impl
 = 
implementation
 ,

258 
self
 . 
prefer_binary
 = 
prefer_binary

262 if not 
HAS_TLS
 :

263 for 
link
 in 
itertools
 . 
chain
 ( 
self
 . 
index_urls
 , 
self
 . 
find_links
 ) :

264 
parsed
 = 
urllib_parse
 . 
urlparse
 ( 
link
 )

265 if 
parsed
 . 
scheme
 == "https" :

266 
logger
 . 
warning
 ( "pip is configured with locations that require " "TLS/SSL, however the ssl module in Python is not " "available."

271 break 
	}

273 def 
	$get_formatted_locations
 ( 
self
 ) :

274 
lines
 = [ ]

275 if 
self
 . 
index_urls
 and 
self
 . 
index_urls
 != [ 
PyPI
 . 
simple_url
 ] :

276 
lines
 . 
append
 ( "Looking in indexes: {}"

277 . 
format
 ( ", " . 
join
 (

278 
remove_auth_from_url
 ( 
url
 ) for 
url
 in 
self
 . 
index_urls
 ) )

280 if 
self
 . 
find_links
 :

281 
lines
 . 
append
 ( "Looking in links: {}"

282 . 
format
 ( ", " . 
join
 ( 
self
 . 
find_links
 ) )

284 return "\n" . 
join
 ( 
lines
 ) 
	}

286 def 
	$add_dependency_links
 ( 
self
 , 
links
 ) :

291 if 
self
 . 
process_dependency_links
 :

292 
deprecated
 ( "Dependency Links processing has been deprecated and will be " "removed in a future release."

295 
replacement
 = "PEP 508 URL dependencies" ,

296 
gone_in
 = "18.2" ,

297 
issue
 = 4187 ,

299 
self
 . 
dependency_links
 . 
extend
 ( 
links
 ) 
	}

301 @ 
	`staticmethod

302 def 
	$_sort_locations
 ( 
locations
 , 
expand_dir
 = False ) :

307 
files
 = [ ]

308 
urls
 = [ ]

311 def 
sort_path
 ( 
path
 ) :

312 
url
 = 
path_to_url
 ( 
path
 )

313 if 
mimetypes
 . 
guess_type
 ( 
url
 , 
strict
 = False ) [ 0 ] == 'text/html' :

314 
urls
 . 
append
 ( 
url
 )

316 
files
 . 
append
 ( 
url
 )

318 for 
url
 in 
locations
 :

320 
is_local_path
 = 
os
 . 
path
 . 
exists
 ( 
url
 )

321 
is_file_url
 = 
url
 . 
startswith
 ( 'file:' )

323 if 
is_local_path
 or 
is_file_url
 :

324 if 
is_local_path
 :

325 
path
 = 
url

327 
path
 = 
url_to_path
 ( 
url
 )

328 if 
os
 . 
path
 . 
isdir
 ( 
path
 ) :

329 if 
expand_dir
 :

330 
path
 = 
os
 . 
path
 . 
realpath
 ( 
path
 )

331 for 
item
 in 
os
 . 
listdir
 ( 
path
 ) :

332 
sort_path
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
item
 ) )

333 elif 
is_file_url
 :

334 
urls
 . 
append
 ( 
url
 )

335 elif 
os
 . 
path
 . 
isfile
 ( 
path
 ) :

336 
sort_path
 ( 
path
 )

338 
logger
 . 
warning
 ( "Url '%s' is ignored: it is neither a file " "nor a directory."

340 , 
url
 ,

342 elif 
is_url
 ( 
url
 ) :

344 
urls
 . 
append
 ( 
url
 )

346 
logger
 . 
warning
 ( "Url '%s' is ignored. It is either a non-existing " "path or lacks a specific scheme."

348 , 
url
 ,

351 return 
files
 , 
urls
 
	}

353 def 
	$_candidate_sort_key
 ( 
self
 , 
candidate
 ) :

367 
support_num
 = 
len
 ( 
self
 . 
valid_tags
 )

368 
build_tag
 = 
tuple
 ( )

369 
binary_preference
 = 0

370 if 
candidate
 . 
location
 . 
is_wheel
 :

372 
wheel
 = 
Wheel
 ( 
candidate
 . 
location
 . 
filename
 )

373 if not 
wheel
 . 
supported
 ( 
self
 . 
valid_tags
 ) :

374 raise 
UnsupportedWheel
 ( "%s is not a supported wheel for this platform. It " "can't be sorted."

376 % 
wheel
 . 
filename

378 if 
self
 . 
prefer_binary
 :

379 
binary_preference
 = 1

380 
pri
 = - ( 
wheel
 . 
support_index_min
 ( 
self
 . 
valid_tags
 ) )

381 if 
wheel
 . 
build_tag
 is not None :

382 
match
 = 
re
 . 
match
 ( r'^(\d+)(.*)$' , 
wheel
 . 
build_tag
 )

383 
build_tag_groups
 = 
match
 . 
groups
 ( )

384 
build_tag
 = ( 
int
 ( 
build_tag_groups
 [ 0 ] ) , 
build_tag_groups
 [ 1 ] )

386 
pri
 = - ( 
support_num
 )

387 return ( 
binary_preference
 , 
candidate
 . 
version
 , 
build_tag
 , 
pri
 ) 
	}

389 def 
	$_validate_secure_origin
 ( 
self
 , 
logger
 , 
location
 ) :

391 
parsed
 = 
urllib_parse
 . 
urlparse
 ( 
str
 ( 
location
 ) )

392 
origin
 = ( 
parsed
 . 
scheme
 , 
parsed
 . 
hostname
 , 
parsed
 . 
port
 )

398 
protocol
 = 
origin
 [ 0 ] . 
rsplit
 ( '+' , 1 ) [ - 1 ]

403 for 
secure_origin
 in ( 
SECURE_ORIGINS
 + 
self
 . 
secure_origins
 ) :

404 if 
protocol
 != 
secure_origin
 [ 0 ] and 
secure_origin
 [ 0 ] != "*" :

410 
addr
 = 
ipaddress
 . 
ip_address
 (

411 
origin
 [ 1 ]

413 
isinstance
 ( 
origin
 [ 1 ] , 
six
 . 
text_type
 ) or

414 
origin
 [ 1 ] is None

416 else 
origin
 [ 1 ] . 
decode
 ( "utf8" )

418 
network
 = 
ipaddress
 . 
ip_network
 (

419 
secure_origin
 [ 1 ]

420 if 
isinstance
 ( 
secure_origin
 [ 1 ] , 
six
 . 
text_type
 )

421 else 
secure_origin
 [ 1 ] . 
decode
 ( "utf8" )

423 except 
ValueError
 :

426 if ( 
origin
 [ 1 ] and

427 
origin
 [ 1 ] . 
lower
 ( ) != 
secure_origin
 [ 1 ] . 
lower
 ( ) and

428 
secure_origin
 [ 1 ] != "*" ) :

433 if 
addr
 not in 
network
 :

437 if ( 
origin
 [ 2 ] != 
secure_origin
 [ 2 ] and

438 
secure_origin
 [ 2 ] != "*" and

439 
secure_origin
 [ 2 ] is not None ) :

449 
logger
 . 
warning
 ( "The repository located at %s is not a trusted or secure host and " "is being ignored. If this repository is available via HTTPS we " "recommend you use HTTPS instead, otherwise you may silence " "this warning and allow it anyway with '--trusted-host %s'."

454 
parsed
 . 
hostname
 ,

455 
parsed
 . 
hostname
 ,

458 return False 
	}

460 def 
	$_get_index_urls_locations
 ( 
self
 , 
project_name
 ) :

467 def 
mkurl_pypi_url
 ( 
url
 ) :

468 
loc
 = 
posixpath
 . 
join
 (

469 
url
 ,

470 
urllib_parse
 . 
quote
 ( 
canonicalize_name
 ( 
project_name
 ) ) )

476 if not 
loc
 . 
endswith
 ( '/' ) :

477 
loc
 = 
loc
 + '/'

478 return 
loc

480 return [ 
mkurl_pypi_url
 ( 
url
 ) for 
url
 in 
self
 . 
index_urls
 ] 
	}

482 def 
	$find_all_candidates
 ( 
self
 , 
project_name
 ) :

490 
index_locations
 = 
self
 . 
_get_index_urls_locations
 ( 
project_name
 )

491 
index_file_loc
 , 
index_url_loc
 = 
self
 . 
_sort_locations
 ( 
index_locations
 )

492 
fl_file_loc
 , 
fl_url_loc
 = 
self
 . 
_sort_locations
 (

493 
self
 . 
find_links
 , 
expand_dir
 = True ,

495 
dep_file_loc
 , 
dep_url_loc
 = 
self
 . 
_sort_locations
 ( 
self
 . 
dependency_links
 )

497 
file_locations
 = ( 
Link
 ( 
url
 ) for 
url
 in 
itertools
 . 
chain
 (

498 
index_file_loc
 , 
fl_file_loc
 , 
dep_file_loc
 ,

505 
url_locations
 = [

506 
link
 for 
link
 in 
itertools
 . 
chain
 (

507 ( 
Link
 ( 
url
 ) for 
url
 in 
index_url_loc
 ) ,

508 ( 
Link
 ( 
url
 ) for 
url
 in 
fl_url_loc
 ) ,

509 ( 
Link
 ( 
url
 ) for 
url
 in 
dep_url_loc
 ) ,

511 if 
self
 . 
_validate_secure_origin
 ( 
logger
 , 
link
 )

514 
logger
 . 
debug
 ( '%d location(s) to search for versions of %s:' ,

515 
len
 ( 
url_locations
 ) , 
project_name
 )

517 for 
location
 in 
url_locations
 :

518 
logger
 . 
debug
 ( '* %s' , 
location
 )

520 
canonical_name
 = 
canonicalize_name
 ( 
project_name
 )

521 
formats
 = 
self
 . 
format_control
 . 
get_allowed_formats
 ( 
canonical_name
 )

522 
search
 = 
Search
 ( 
project_name
 , 
canonical_name
 , 
formats
 )

523 
find_links_versions
 = 
self
 . 
_package_versions
 (

525 ( 
Link
 ( 
url
 , '-f' ) for 
url
 in 
self
 . 
find_links
 ) ,

526 
search

529 
page_versions
 = [ ]

530 for 
page
 in 
self
 . 
_get_pages
 ( 
url_locations
 , 
project_name
 ) :

531 
logger
 . 
debug
 ( 'Analyzing links from page %s' , 
page
 . 
url
 )

532 with 
indent_log
 ( ) :

533 
page_versions
 . 
extend
 (

534 
self
 . 
_package_versions
 ( 
page
 . 
iter_links
 ( ) , 
search
 )

537 
dependency_versions
 = 
self
 . 
_package_versions
 (

538 ( 
Link
 ( 
url
 ) for 
url
 in 
self
 . 
dependency_links
 ) , 
search

540 if 
dependency_versions
 :

541 
logger
 . 
debug
 ( 'dependency_links found: %s'

543 . 
join
 ( [

544 
version
 . 
location
 . 
url
 for 
version
 in 
dependency_versions

548 
file_versions
 = 
self
 . 
_package_versions
 ( 
file_locations
 , 
search
 )

549 if 
file_versions
 :

550 
file_versions
 . 
sort
 ( 
reverse
 = True )

551 
logger
 . 
debug
 ( 'Local files found: %s'

553 . 
join
 ( [

554 
url_to_path
 ( 
candidate
 . 
location
 . 
url
 )

555 for 
candidate
 in 
file_versions

561 
file_versions
 + 
find_links_versions
 + 
page_versions
 +

562 
dependency_versions

563 ) 
	}

565 def 
	$find_requirement
 ( 
self
 , 
req
 , 
upgrade
 ) :

572 
all_candidates
 = 
self
 . 
find_all_candidates
 ( 
req
 . 
name
 )

575 
compatible_versions
 = 
set
 (

576 
req
 . 
specifier
 . 
filter
 (

584 [ 
str
 ( 
c
 . 
version
 ) for 
c
 in 
all_candidates
 ] ,

585 
prereleases
 = (

586 
self
 . 
allow_all_prereleases

587 if 
self
 . 
allow_all_prereleases
 else None

591 
applicable_candidates
 = [

593 
c
 for 
c
 in 
all_candidates
 if 
str
 ( 
c
 . 
version
 ) in 
compatible_versions

596 if 
applicable_candidates
 :

597 
best_candidate
 = 
max
 ( 
applicable_candidates
 ,

598 
key
 = 
self
 . 
_candidate_sort_key
 )

600 
best_candidate
 = None

602 if 
req
 . 
satisfied_by
 is not None :

603 
installed_version
 = 
parse_version
 ( 
req
 . 
satisfied_by
 . 
version
 )

605 
installed_version
 = None

607 if 
installed_version
 is None and 
best_candidate
 is None :

608 
logger
 . 
critical
 ( 'Could not find a version that satisfies the requirement %s ' '(from versions: %s)'

611 
req
 , ', '

612 . 
join
 (

613 
sorted
 (

614 { 
str
 ( 
c
 . 
version
 ) for 
c
 in 
all_candidates
 } ,

615 
key
 = 
parse_version
 ,

620 raise 
DistributionNotFound
 ( 'No matching distribution found for %s'

621 % 
req

624 
best_installed
 = False

625 if 
installed_version
 and (

626 
best_candidate
 is None or

627 
best_candidate
 . 
version
 <= 
installed_version
 ) :

628 
best_installed
 = True

630 if not 
upgrade
 and 
installed_version
 is not None :

631 if 
best_installed
 :

632 
logger
 . 
debug
 ( 'Existing installed version (%s) is most up-to-date and ' 'satisfies requirement'

635 
installed_version
 ,

638 
logger
 . 
debug
 ( 'Existing installed version (%s) satisfies requirement ' '(most up-to-date version is %s)'

641 
installed_version
 ,

642 
best_candidate
 . 
version
 ,

646 if 
best_installed
 :

648 
logger
 . 
debug
 ( 'Installed version (%s) is most up-to-date (past versions: ' '%s)'

651 
installed_version
 , ', '

652 . 
join
 ( 
sorted
 ( 
compatible_versions
 , 
key
 = 
parse_version
 ) ) or "none"

655 raise 
BestVersionAlreadyInstalled

657 
logger
 . 
debug
 ( 'Using version %s (newest of versions: %s)'

659 
best_candidate
 . 
version
 , ', '

660 . 
join
 ( 
sorted
 ( 
compatible_versions
 , 
key
 = 
parse_version
 ) )

662 return 
best_candidate
 . 
location
 
	}

664 def 
	$_get_pages
 ( 
self
 , 
locations
 , 
project_name
 ) :

669 
seen
 = 
set
 ( )

670 for 
location
 in 
locations
 :

671 if 
location
 in 
seen
 :

673 
seen
 . 
add
 ( 
location
 )

675 
page
 = 
self
 . 
_get_page
 ( 
location
 )

676 if 
page
 is None :

679 yield 
page
 
	}

681 
_py_version_re
 = 
re
 . 
compile
 ( r'-py([123]\.?[0-9]?)$' )

683 def 
	$_sort_links
 ( 
self
 , 
links
 ) :

688 
eggs
 , 
no_eggs
 = [ ] , [ ]

689 
seen
 = 
set
 ( )

690 for 
link
 in 
links
 :

691 if 
link
 not in 
seen
 :

692 
seen
 . 
add
 ( 
link
 )

693 if 
link
 . 
egg_fragment
 :

694 
eggs
 . 
append
 ( 
link
 )

696 
no_eggs
 . 
append
 ( 
link
 )

697 return 
no_eggs
 + 
eggs
 
	}

699 def 
	$_package_versions
 ( 
self
 , 
links
 , 
search
 ) :

700 
result
 = [ ]

701 for 
link
 in 
self
 . 
_sort_links
 ( 
links
 ) :

702 
v
 = 
self
 . 
_link_package_versions
 ( 
link
 , 
search
 )

703 if 
v
 is not None :

704 
result
 . 
append
 ( 
v
 )

705 return 
result
 
	}

707 def 
	$_log_skipped_link
 ( 
self
 , 
link
 , 
reason
 ) :

708 if 
link
 not in 
self
 . 
logged_links
 :

709 
logger
 . 
debug
 ( 'Skipping link %s; %s' , 
link
 , 
reason
 )

710 
self
 . 
logged_links
 . 
add
 ( 
link
 ) 
	}

712 def 
	$_link_package_versions
 ( 
self
 , 
link
 , 
search
 ) :

714 
version
 = None

715 if 
link
 . 
egg_fragment
 :

716 
egg_info
 = 
link
 . 
egg_fragment

717 
ext
 = 
link
 . 
ext

719 
egg_info
 , 
ext
 = 
link
 . 
splitext
 ( )

720 if not 
ext
 :

721 
self
 . 
_log_skipped_link
 ( 
link
 , 'not a file' )

723 if 
ext
 not in 
SUPPORTED_EXTENSIONS
 :

724 
self
 . 
_log_skipped_link
 (

725 
link
 , 'unsupported archive format: %s' % 
ext
 ,

728 if "binary" not in 
search
 . 
formats
 and 
ext
 == 
wheel_ext
 :

729 
self
 . 
_log_skipped_link
 (

730 
link
 , 'No binaries permitted for %s' % 
search
 . 
supplied
 ,

733 if "macosx10" in 
link
 . 
path
 and 
ext
 == '.zip' :

734 
self
 . 
_log_skipped_link
 ( 
link
 , 'macosx10 one' )

736 if 
ext
 == 
wheel_ext
 :

738 
wheel
 = 
Wheel
 ( 
link
 . 
filename
 )

739 except 
InvalidWheelFilename
 :

740 
self
 . 
_log_skipped_link
 ( 
link
 , 'invalid wheel filename' )

742 if 
canonicalize_name
 ( 
wheel
 . 
name
 ) != 
search
 . 
canonical
 :

743 
self
 . 
_log_skipped_link
 (

744 
link
 , 'wrong project name (not %s)' % 
search
 . 
supplied
 )

747 if not 
wheel
 . 
supported
 ( 
self
 . 
valid_tags
 ) :

748 
self
 . 
_log_skipped_link
 (

749 
link
 , 'it is not compatible with this Python' )

752 
version
 = 
wheel
 . 
version

755 if "source" not in 
search
 . 
formats
 and 
ext
 != 
wheel_ext
 :

756 
self
 . 
_log_skipped_link
 (

757 
link
 , 'No sources permitted for %s' % 
search
 . 
supplied
 ,

761 if not 
version
 :

762 
version
 = 
egg_info_matches
 ( 
egg_info
 , 
search
 . 
supplied
 , 
link
 )

763 if 
version
 is None :

764 
self
 . 
_log_skipped_link
 (

765 
link
 , 'Missing project version for %s' % 
search
 . 
supplied
 )

768 
match
 = 
self
 . 
_py_version_re
 . 
search
 ( 
version
 )

769 if 
match
 :

770 
version
 = 
version
 [ : 
match
 . 
start
 ( ) ]

771 
py_version
 = 
match
 . 
group
 ( 1 )

772 if 
py_version
 != 
sys
 . 
version
 [ : 3 ] :

773 
self
 . 
_log_skipped_link
 (

774 
link
 , 'Python version is incorrect' )

777 
support_this_python
 = 
check_requires_python
 ( 
link
 . 
requires_python
 )

778 except 
specifiers
 . 
InvalidSpecifier
 :

779 
logger
 . 
debug
 ( "Package %s has an invalid Requires-Python entry: %s" ,

780 
link
 . 
filename
 , 
link
 . 
requires_python
 )

781 
support_this_python
 = True

783 if not 
support_this_python
 :

784 
logger
 . 
debug
 ( "The package %s is incompatible with the python" "version in use. Acceptable python versions are:%s"

786 
link
 , 
link
 . 
requires_python
 )

788 
logger
 . 
debug
 ( 'Found link %s, version: %s' , 
link
 , 
version
 )

790 return 
InstallationCandidate
 ( 
search
 . 
supplied
 , 
version
 , 
link
 ) 
	}

792 def 
	$_get_page
 ( 
self
 , 
link
 ) :

793 return 
_get_html_page
 ( 
link
 , 
session
 = 
self
 . 
session
 ) 
	}

796 def 
	$egg_info_matches
 (

797 
egg_info
 , 
search_name
 , 
link
 ,

798 
_egg_info_re
 = 
re
 . 
compile
 ( r'([a-z0-9_.]+)-([a-z0-9_.!+-]+)' , 
re
 . 
I
 ) ) :

807 
match
 = 
_egg_info_re
 . 
search
 ( 
egg_info
 )

808 if not 
match
 :

809 
logger
 . 
debug
 ( 'Could not parse version from link: %s' , 
link
 )

811 if 
search_name
 is None :

812 
full_match
 = 
match
 . 
group
 ( 0 )

813 return 
full_match
 . 
split
 ( '-' , 1 ) [ - 1 ]

814 
name
 = 
match
 . 
group
 ( 0 ) . 
lower
 ( )

816 
name
 = 
name
 . 
replace
 ( '_' , '-' )

818 
look_for
 = 
search_name
 . 
lower
 ( ) + "-"

819 if 
name
 . 
startswith
 ( 
look_for
 ) :

820 return 
match
 . 
group
 ( 0 ) [ 
len
 ( 
look_for
 ) : ]

822 return None 
	}

825 def 
	$_determine_base_url
 ( 
document
 , 
page_url
 ) :

837 for 
base
 in 
document
 . 
findall
 ( ".//base" ) :

838 
href
 = 
base
 . 
get
 ( "href" )

839 if 
href
 is not None :

840 return 
href

841 return 
page_url
 
	}

844 def 
	$_get_encoding_from_headers
 ( 
headers
 ) :

847 if 
headers
 and "Content-Type" in 
headers
 :

848 
content_type
 , 
params
 = 
cgi
 . 
parse_header
 ( 
headers
 [ "Content-Type" ] )

849 if "charset" in 
params
 :

850 return 
params
 [ 'charset' ]

851 return None 
	}

854 
_CLEAN_LINK_RE
 = 
re
 . 
compile
 ( r'[^a-z0-9$&+,/:;=?@.#%_\\|-]' , 
re
 . 
I
 )

857 def 
	$_clean_link
 ( 
url
 ) :

861 return 
_CLEAN_LINK_RE
 . 
sub
 ( lambda 
match
 : '%%%2x' % 
ord
 ( 
match
 . 
group
 ( 0 ) ) , 
url
 ) 
	}

864 class 
	cHTMLPage
 ( 
object
 ) :

867 def 
	$__init__
 ( 
self
 , 
content
 , 
url
 , 
headers
 = None ) :

868 
self
 . 
content
 = 
content

869 
self
 . 
url
 = 
url

870 
self
 . 
headers
 = 
headers
 
	}

872 def 
	$__str__
 ( 
self
 ) :

873 return 
self
 . 
url
 
	}

875 def 
	$iter_links
 ( 
self
 ) :

877 
document
 = 
html5lib
 . 
parse
 (

878 
self
 . 
content
 ,

879 
transport_encoding
 = 
_get_encoding_from_headers
 ( 
self
 . 
headers
 ) ,

880 
namespaceHTMLElements
 = False ,

882 
base_url
 = 
_determine_base_url
 ( 
document
 , 
self
 . 
url
 )

883 for 
anchor
 in 
document
 . 
findall
 ( ".//a" ) :

884 if 
anchor
 . 
get
 ( "href" ) :

885 
href
 = 
anchor
 . 
get
 ( "href" )

886 
url
 = 
_clean_link
 ( 
urllib_parse
 . 
urljoin
 ( 
base_url
 , 
href
 ) )

887 
pyrequire
 = 
anchor
 . 
get
 ( 'data-requires-python' )

888 
pyrequire
 = 
unescape
 ( 
pyrequire
 ) if 
pyrequire
 else None

889 yield 
Link
 ( 
url
 , 
self
 . 
url
 , 
requires_python
 = 
pyrequire
 ) 
	}

892 
Search
 = 
namedtuple
 ( 'Search' , 'supplied canonical formats' ) """Capture key aspects of a search.\n\n:attribute supplied: The user supplied package.\n:attribute canonical: The canonical package name.\n:attribute formats: The formats allowed for this package. Should be a set\n    with 'binary' or 'source' or both in it.\n"""


	@./env/lib/python3.7/site-packages/pip/_internal/models/candidate.py

1 from 
	~pip._vendor.packaging.version
 import 
parse
 as 
parse_version

3 from 
	~pip._internal.utils.models
 import 
KeyBasedCompareMixin

6 class 
	cInstallationCandidate
 ( 
KeyBasedCompareMixin
 ) :

10 def 
	$__init__
 ( 
self
 , 
project
 , 
version
 , 
location
 ) :

11 
self
 . 
project
 = 
project

12 
self
 . 
version
 = 
parse_version
 ( 
version
 )

13 
self
 . 
location
 = 
location

15 
super
 ( 
InstallationCandidate
 , 
self
 ) . 
__init__
 (

16 
key
 = ( 
self
 . 
project
 , 
self
 . 
version
 , 
self
 . 
location
 ) ,

17 
defining_class
 = 
InstallationCandidate

18 ) 
	}

20 def 
	$__repr__
 ( 
self
 ) :

21 return "<InstallationCandidate({!r}, {!r}, {!r})>" . 
format
 (

22 
self
 . 
project
 , 
self
 . 
version
 , 
self
 . 
location
 ,

23 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/models/link.py

1 import 
	~posixpath

2 import 
	~re

4 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

6 from 
	~pip._internal.download
 import 
path_to_url

7 from 
	~pip._internal.utils.misc
 import 
splitext

8 from 
	~pip._internal.utils.models
 import 
KeyBasedCompareMixin

9 from 
	~pip._internal.wheel
 import 
wheel_ext

12 class 
	cLink
 ( 
KeyBasedCompareMixin
 ) :

16 def 
	$__init__
 ( 
self
 , 
url
 , 
comes_from
 = None , 
requires_python
 = None ) :

29 if 
url
 . 
startswith
 ( '\\\\' ) :

30 
url
 = 
path_to_url
 ( 
url
 )

32 
self
 . 
url
 = 
url

33 
self
 . 
comes_from
 = 
comes_from

34 
self
 . 
requires_python
 = 
requires_python
 if 
requires_python
 else None

36 
super
 ( 
Link
 , 
self
 ) . 
__init__
 (

37 
key
 = ( 
self
 . 
url
 ) ,

38 
defining_class
 = 
Link

39 ) 
	}

41 def 
	$__str__
 ( 
self
 ) :

42 if 
self
 . 
requires_python
 :

43 
rp
 = ' (requires-python:%s)' % 
self
 . 
requires_python

45 
rp
 = ''

46 if 
self
 . 
comes_from
 :

47 return '%s (from %s)%s' % ( 
self
 . 
url
 , 
self
 . 
comes_from
 , 
rp
 )

49 return 
str
 ( 
self
 . 
url
 ) 
	}

51 def 
	$__repr__
 ( 
self
 ) :

52 return '<Link %s>' % 
self
 
	}

54 @ 
property

55 def 
	$filename
 ( 
self
 ) :

56 
_
 , 
netloc
 , 
path
 , 
_
 , 
_
 = 
urllib_parse
 . 
urlsplit
 ( 
self
 . 
url
 )

57 
name
 = 
posixpath
 . 
basename
 ( 
path
 . 
rstrip
 ( '/' ) ) or 
netloc

58 
name
 = 
urllib_parse
 . 
unquote
 ( 
name
 )

59 assert 
name
 , ( 'URL %r produced no filename' % 
self
 . 
url
 )

60 return 
name
 
	}

62 @ 
property

63 def 
	$scheme
 ( 
self
 ) :

64 return 
urllib_parse
 . 
urlsplit
 ( 
self
 . 
url
 ) [ 0 ] 
	}

66 @ 
property

67 def 
	$netloc
 ( 
self
 ) :

68 return 
urllib_parse
 . 
urlsplit
 ( 
self
 . 
url
 ) [ 1 ] 
	}

70 @ 
property

71 def 
	$path
 ( 
self
 ) :

72 return 
urllib_parse
 . 
unquote
 ( 
urllib_parse
 . 
urlsplit
 ( 
self
 . 
url
 ) [ 2 ] ) 
	}

74 def 
	$splitext
 ( 
self
 ) :

75 return 
splitext
 ( 
posixpath
 . 
basename
 ( 
self
 . 
path
 . 
rstrip
 ( '/' ) ) ) 
	}

77 @ 
property

78 def 
	$ext
 ( 
self
 ) :

79 return 
self
 . 
splitext
 ( ) [ 1 ] 
	}

81 @ 
property

82 def 
	$url_without_fragment
 ( 
self
 ) :

83 
scheme
 , 
netloc
 , 
path
 , 
query
 , 
fragment
 = 
urllib_parse
 . 
urlsplit
 ( 
self
 . 
url
 )

84 return 
urllib_parse
 . 
urlunsplit
 ( ( 
scheme
 , 
netloc
 , 
path
 , 
query
 , None ) ) 
	}

86 
_egg_fragment_re
 = 
re
 . 
compile
 ( r'[#&]egg=([^&]*)' )

88 @ 
property

89 def 
	$egg_fragment
 ( 
self
 ) :

90 
match
 = 
self
 . 
_egg_fragment_re
 . 
search
 ( 
self
 . 
url
 )

91 if not 
match
 :

93 return 
match
 . 
group
 ( 1 ) 
	}

95 
_subdirectory_fragment_re
 = 
re
 . 
compile
 ( r'[#&]subdirectory=([^&]*)' )

97 @ 
property

98 def 
	$subdirectory_fragment
 ( 
self
 ) :

99 
match
 = 
self
 . 
_subdirectory_fragment_re
 . 
search
 ( 
self
 . 
url
 )

100 if not 
match
 :

102 return 
match
 . 
group
 ( 1 ) 
	}

104 
_hash_re
 = 
re
 . 
compile
 ( r'(sha1|sha224|sha384|sha256|sha512|md5)=([a-f0-9]+)'

108 @ 
property

109 def 
	$hash
 ( 
self
 ) :

110 
match
 = 
self
 . 
_hash_re
 . 
search
 ( 
self
 . 
url
 )

111 if 
match
 :

112 return 
match
 . 
group
 ( 2 )

113 return None 
	}

115 @ 
property

116 def 
	$hash_name
 ( 
self
 ) :

117 
match
 = 
self
 . 
_hash_re
 . 
search
 ( 
self
 . 
url
 )

118 if 
match
 :

119 return 
match
 . 
group
 ( 1 )

120 return None 
	}

122 @ 
property

123 def 
	$show_url
 ( 
self
 ) :

124 return 
posixpath
 . 
basename
 ( 
self
 . 
url
 . 
split
 ( '#' , 1 ) [ 0 ] . 
split
 ( '?' , 1 ) [ 0 ] ) 
	}

126 @ 
property

127 def 
	$is_wheel
 ( 
self
 ) :

128 return 
self
 . 
ext
 == 
wheel_ext
 
	}

130 @ 
property

131 def 
	$is_artifact
 ( 
self
 ) :

136 from 
	~pip._internal.vcs
 import 
vcs

138 if 
self
 . 
scheme
 in 
vcs
 . 
all_schemes
 :

141 return True 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/models/__init__.py


	@./env/lib/python3.7/site-packages/pip/_internal/models/index.py

1 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

4 class 
	cPackageIndex
 ( 
object
 ) :

8 def 
	$__init__
 ( 
self
 , 
url
 , 
file_storage_domain
 ) :

9 
super
 ( 
PackageIndex
 , 
self
 ) . 
__init__
 ( )

10 
self
 . 
url
 = 
url

11 
self
 . 
netloc
 = 
urllib_parse
 . 
urlsplit
 ( 
url
 ) . 
netloc

12 
self
 . 
simple_url
 = 
self
 . 
_url_for_path
 ( 'simple' )

13 
self
 . 
pypi_url
 = 
self
 . 
_url_for_path
 ( 'pypi' )

18 
self
 . 
file_storage_domain
 = 
file_storage_domain
 
	}

20 def 
	$_url_for_path
 ( 
self
 , 
path
 ) :

21 return 
urllib_parse
 . 
urljoin
 ( 
self
 . 
url
 , 
path
 ) 
	}

24 
PyPI
 = 
PackageIndex
 ( 'https://pypi.org/'

25 , 
file_storage_domain
 = 'files.pythonhosted.org'

27 
TestPyPI
 = 
PackageIndex
 ( 'https://test.pypi.org/'

28 , 
file_storage_domain
 = 'test-files.pythonhosted.org'


	@./env/lib/python3.7/site-packages/pip/_internal/models/format_control.py

1 from 
	~pip._vendor.packaging.utils
 import 
canonicalize_name

4 class 
	cFormatControl
 ( 
object
 ) :

11 def 
	$__init__
 ( 
self
 , 
no_binary
 = None , 
only_binary
 = None ) :

12 
self
 . 
no_binary
 = 
set
 ( ) if 
no_binary
 is None else 
no_binary

13 
self
 . 
only_binary
 = 
set
 ( ) if 
only_binary
 is None else 
only_binary
 
	}

15 def 
	$__eq__
 ( 
self
 , 
other
 ) :

16 return 
self
 . 
__dict__
 == 
other
 . 
__dict__
 
	}

18 def 
	$__ne__
 ( 
self
 , 
other
 ) :

19 return not 
self
 . 
__eq__
 ( 
other
 ) 
	}

21 def 
	$__repr__
 ( 
self
 ) :

22 return "{}({}, {})" . 
format
 (

23 
self
 . 
__class__
 . 
__name__
 ,

24 
self
 . 
no_binary
 ,

25 
self
 . 
only_binary

26 ) 
	}

28 @ 
	`staticmethod

29 def 
	$handle_mutual_excludes
 ( 
value
 , 
target
 , 
other
 ) :

30 
new
 = 
value
 . 
split
 ( ',' )

31 while ':all:' in 
new
 :

32 
other
 . 
clear
 ( )

33 
target
 . 
clear
 ( )

34 
target
 . 
add
 ( ':all:' )

35 del 
new
 [ : 
new
 . 
index
 ( ':all:' ) + 1 ]

37 if ':none:' not in 
new
 :

39 for 
name
 in 
new
 :

40 if 
name
 == ':none:' :

41 
target
 . 
clear
 ( )

43 
name
 = 
canonicalize_name
 ( 
name
 )

44 
other
 . 
discard
 ( 
name
 )

45 
target
 . 
add
 ( 
name
 ) 
	}

47 def 
	$get_allowed_formats
 ( 
self
 , 
canonical_name
 ) :

48 
result
 = { "binary" , "source" }

49 if 
canonical_name
 in 
self
 . 
only_binary
 :

50 
result
 . 
discard
 ( 'source' )

51 elif 
canonical_name
 in 
self
 . 
no_binary
 :

52 
result
 . 
discard
 ( 'binary' )

53 elif ':all:' in 
self
 . 
only_binary
 :

54 
result
 . 
discard
 ( 'source' )

55 elif ':all:' in 
self
 . 
no_binary
 :

56 
result
 . 
discard
 ( 'binary' )

57 return 
frozenset
 ( 
result
 ) 
	}

59 def 
	$disallow_binaries
 ( 
self
 ) :

60 
self
 . 
handle_mutual_excludes
 ( ':all:'

61 , 
self
 . 
no_binary
 , 
self
 . 
only_binary
 ,

62 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/vcs/mercurial.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

6 from 
	~pip._vendor.six.moves
 import 
configparser

8 from 
	~pip._internal.download
 import 
path_to_url

9 from 
	~pip._internal.utils.misc
 import 
display_path
 , 
make_vcs_requirement_url

10 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

11 from 
	~pip._internal.vcs
 import 
VersionControl
 , 
vcs

13 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

16 class 
	cMercurial
 ( 
VersionControl
 ) :

17 
name
 = 'hg'

18 
dirname
 = '.hg'

19 
repo_name
 = 'clone'

20 
schemes
 = ( 'hg' , 'hg+http' , 'hg+https' , 'hg+ssh' , 'hg+static-http' )

22 def 
	$get_base_rev_args
 ( 
self
 , 
rev
 ) :

23 return [ 
rev
 ] 
	}

25 def 
	$export
 ( 
self
 , 
location
 ) :

27 with 
TempDirectory
 ( 
kind
 = "export" ) as 
temp_dir
 :

28 
self
 . 
unpack
 ( 
temp_dir
 . 
path
 )

30 
self
 . 
run_command
 (

31 [ 'archive' , 
location
 ] , 
show_stdout
 = False , 
cwd
 = 
temp_dir
 . 
path

32 ) 
	}

34 def 
	$fetch_new
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

35 
rev_display
 = 
rev_options
 . 
to_display
 ( )

36 
logger
 . 
info
 ( 'Cloning hg %s%s to %s'

38 
url
 ,

39 
rev_display
 ,

40 
display_path
 ( 
dest
 ) ,

42 
self
 . 
run_command
 ( [ 'clone' , '--noupdate' , '-q' , 
url
 , 
dest
 ] )

43 
cmd_args
 = [ 'update' , '-q' ] + 
rev_options
 . 
to_args
 ( )

44 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 ) 
	}

46 def 
	$switch
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

47 
repo_config
 = 
os
 . 
path
 . 
join
 ( 
dest
 , 
self
 . 
dirname
 , 'hgrc' )

48 
config
 = 
configparser
 . 
SafeConfigParser
 ( )

50 
config
 . 
read
 ( 
repo_config
 )

51 
config
 . 
set
 ( 'paths' , 'default' , 
url
 )

52 with 
open
 ( 
repo_config
 , 'w' ) as 
config_file
 :

53 
config
 . 
write
 ( 
config_file
 )

54 except ( 
OSError
 , 
configparser
 . 
NoSectionError
 ) as 
exc
 :

55 
logger
 . 
warning
 ( 'Could not switch Mercurial repository to %s: %s'

56 , 
url
 , 
exc
 ,

59 
cmd_args
 = [ 'update' , '-q' ] + 
rev_options
 . 
to_args
 ( )

60 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 ) 
	}

62 def 
	$update
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

63 
self
 . 
run_command
 ( [ 'pull' , '-q' ] , 
cwd
 = 
dest
 )

64 
cmd_args
 = [ 'update' , '-q' ] + 
rev_options
 . 
to_args
 ( )

65 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 ) 
	}

67 def 
	$get_url
 ( 
self
 , 
location
 ) :

68 
url
 = 
self
 . 
run_command
 (

70 
show_stdout
 = False , 
cwd
 = 
location
 ) . 
strip
 ( )

71 if 
self
 . 
_is_local_repository
 ( 
url
 ) :

72 
url
 = 
path_to_url
 ( 
url
 )

73 return 
url
 . 
strip
 ( ) 
	}

75 def 
	$get_revision
 ( 
self
 , 
location
 ) :

76 
current_revision
 = 
self
 . 
run_command
 (

78 
show_stdout
 = False , 
cwd
 = 
location
 ) . 
strip
 ( )

79 return 
current_revision
 
	}

81 def 
	$get_revision_hash
 ( 
self
 , 
location
 ) :

82 
current_rev_hash
 = 
self
 . 
run_command
 (

84 
show_stdout
 = False , 
cwd
 = 
location
 ) . 
strip
 ( )

85 return 
current_rev_hash
 
	}

87 def 
	$get_src_requirement
 ( 
self
 , 
dist
 , 
location
 ) :

88 
repo
 = 
self
 . 
get_url
 ( 
location
 )

89 if not 
repo
 . 
lower
 ( ) . 
startswith
 ( 'hg:' ) :

90 
repo
 = 'hg+' + 
repo

91 
current_rev_hash
 = 
self
 . 
get_revision_hash
 ( 
location
 )

92 
egg_project_name
 = 
dist
 . 
egg_name
 ( ) . 
split
 ( '-' , 1 ) [ 0 ]

93 return 
make_vcs_requirement_url
 ( 
repo
 , 
current_rev_hash
 ,

94 
egg_project_name
 ) 
	}

96 def 
	$is_commit_id_equal
 ( 
self
 , 
dest
 , 
name
 ) :

98 return False 
	}

101 
vcs
 . 
register
 ( 
Mercurial
 )


	@./env/lib/python3.7/site-packages/pip/_internal/vcs/git.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os.path

5 import 
	~re

7 from 
	~pip._vendor.packaging.version
 import 
parse
 as 
parse_version

8 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

9 from 
	~pip._vendor.six.moves.urllib
 import 
request
 as 
urllib_request

11 from 
	~pip._internal.exceptions
 import 
BadCommand

12 from 
	~pip._internal.utils.compat
 import 
samefile

13 from 
	~pip._internal.utils.misc
 import 
display_path
 , 
make_vcs_requirement_url

14 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

15 from 
	~pip._internal.vcs
 import 
VersionControl
 , 
vcs

17 
urlsplit
 = 
urllib_parse
 . 
urlsplit

18 
urlunsplit
 = 
urllib_parse
 . 
urlunsplit

21 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

24 
HASH_REGEX
 = 
re
 . 
compile
 ( '[a-fA-F0-9]{40}' )

27 def 
	$looks_like_hash
 ( 
sha
 ) :

28 return 
bool
 ( 
HASH_REGEX
 . 
match
 ( 
sha
 ) ) 
	}

31 class 
	cGit
 ( 
VersionControl
 ) :

32 
name
 = 'git'

33 
dirname
 = '.git'

34 
repo_name
 = 'clone'

35 
schemes
 = ( 'git'

40 
unset_environ
 = ( 'GIT_DIR' , 'GIT_WORK_TREE' )

41 
default_arg_rev
 = 'HEAD'

43 def 
	$__init__
 ( 
self
 , 
url
 = None , * 
args
 , ** 
kwargs
 ) :

47 if 
url
 :

48 
scheme
 , 
netloc
 , 
path
 , 
query
 , 
fragment
 = 
urlsplit
 ( 
url
 )

49 if 
scheme
 . 
endswith
 ( 'file' ) :

50 
initial_slashes
 = 
path
 [ : - 
len
 ( 
path
 . 
lstrip
 ( '/' ) ) ]

51 
newpath
 = (

52 
initial_slashes
 +

53 
urllib_request
 . 
url2pathname
 ( 
path
 )

54 . 
replace
 ( '\\' , '/' ) . 
lstrip
 ( '/' )

56 
url
 = 
urlunsplit
 ( ( 
scheme
 , 
netloc
 , 
newpath
 , 
query
 , 
fragment
 ) )

57 
after_plus
 = 
scheme
 . 
find
 ( '+' ) + 1

58 
url
 = 
scheme
 [ : 
after_plus
 ] + 
urlunsplit
 (

59 ( 
scheme
 [ 
after_plus
 : ] , 
netloc
 , 
newpath
 , 
query
 , 
fragment
 ) ,

62 
super
 ( 
Git
 , 
self
 ) . 
__init__
 ( 
url
 , * 
args
 , ** 
kwargs
 ) 
	}

64 def 
	$get_base_rev_args
 ( 
self
 , 
rev
 ) :

65 return [ 
rev
 ] 
	}

67 def 
	$get_git_version
 ( 
self
 ) :

68 
VERSION_PFX
 = 'git version '

69 
version
 = 
self
 . 
run_command
 ( [ 'version' ] , 
show_stdout
 = False )

70 if 
version
 . 
startswith
 ( 
VERSION_PFX
 ) :

71 
version
 = 
version
 [ 
len
 ( 
VERSION_PFX
 ) : ] . 
split
 ( ) [ 0 ]

73 
version
 = ''

77 
version
 = '.' . 
join
 ( 
version
 . 
split
 ( '.' ) [ : 3 ] )

78 return 
parse_version
 ( 
version
 ) 
	}

80 def 
	$get_branch
 ( 
self
 , 
location
 ) :

85 
args
 = [ 'rev-parse' , '--abbrev-ref' , 'HEAD' ]

86 
output
 = 
self
 . 
run_command
 ( 
args
 , 
show_stdout
 = False , 
cwd
 = 
location
 )

87 
branch
 = 
output
 . 
strip
 ( )

89 if 
branch
 == 'HEAD' :

92 return 
branch
 
	}

94 def 
	$export
 ( 
self
 , 
location
 ) :

96 if not 
location
 . 
endswith
 ( '/' ) :

97 
location
 = 
location
 + '/'

99 with 
TempDirectory
 ( 
kind
 = "export" ) as 
temp_dir
 :

100 
self
 . 
unpack
 ( 
temp_dir
 . 
path
 )

101 
self
 . 
run_command
 (

102 [ 'checkout-index' , '-a' , '-f' , '--prefix' , 
location
 ] ,

103 
show_stdout
 = False , 
cwd
 = 
temp_dir
 . 
path

104 ) 
	}

106 def 
	$get_revision_sha
 ( 
self
 , 
dest
 , 
rev
 ) :

116 
output
 = 
self
 . 
run_command
 ( [ 'show-ref' , 
rev
 ] , 
cwd
 = 
dest
 ,

117 
show_stdout
 = False , 
on_returncode
 = 'ignore' )

118 
refs
 = { }

119 for 
line
 in 
output
 . 
strip
 ( ) . 
splitlines
 ( ) :

121 
sha
 , 
ref
 = 
line
 . 
split
 ( )

122 except 
ValueError
 :

125 raise 
ValueError
 ( 'unexpected show-ref line: {!r}' . 
format
 ( 
line
 ) )

127 
refs
 [ 
ref
 ] = 
sha

129 
branch_ref
 = 'refs/remotes/origin/{}' . 
format
 ( 
rev
 )

130 
tag_ref
 = 'refs/tags/{}' . 
format
 ( 
rev
 )

132 
sha
 = 
refs
 . 
get
 ( 
branch_ref
 )

133 if 
sha
 is not None :

134 return ( 
sha
 , True )

136 
sha
 = 
refs
 . 
get
 ( 
tag_ref
 )

138 return ( 
sha
 , False ) 
	}

140 def 
	$resolve_revision
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

148 
rev
 = 
rev_options
 . 
arg_rev

149 
sha
 , 
is_branch
 = 
self
 . 
get_revision_sha
 ( 
dest
 , 
rev
 )

151 if 
sha
 is not None :

152 
rev_options
 = 
rev_options
 . 
make_new
 ( 
sha
 )

153 
rev_options
 . 
branch_name
 = 
rev
 if 
is_branch
 else None

155 return 
rev_options

159 if not 
looks_like_hash
 ( 
rev
 ) :

160 
logger
 . 
warning
 ( "Did not find branch or tag '%s', assuming revision or ref."

162 
rev
 ,

165 if not 
rev
 . 
startswith
 ( 'refs/' ) :

166 return 
rev_options

169 
self
 . 
run_command
 (

170 [ 'fetch' , '-q' , 
url
 ] + 
rev_options
 . 
to_args
 ( ) ,

171 
cwd
 = 
dest
 ,

174 
sha
 = 
self
 . 
get_revision
 ( 
dest
 , 
rev
 = 'FETCH_HEAD' )

175 
rev_options
 = 
rev_options
 . 
make_new
 ( 
sha
 )

177 return 
rev_options
 
	}

179 def 
	$is_commit_id_equal
 ( 
self
 , 
dest
 , 
name
 ) :

187 if not 
name
 :

191 return 
self
 . 
get_revision
 ( 
dest
 ) == 
name
 
	}

193 def 
	$fetch_new
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

194 
rev_display
 = 
rev_options
 . 
to_display
 ( )

195 
logger
 . 
info
 ( 'Cloning %s%s to %s'

196 , 
url
 , 
rev_display
 , 
display_path
 ( 
dest
 ) ,

198 
self
 . 
run_command
 ( [ 'clone' , '-q' , 
url
 , 
dest
 ] )

200 if 
rev_options
 . 
rev
 :

202 
rev_options
 = 
self
 . 
resolve_revision
 ( 
dest
 , 
url
 , 
rev_options
 )

203 
branch_name
 = 
getattr
 ( 
rev_options
 , 'branch_name' , None )

204 if 
branch_name
 is None :

207 if not 
self
 . 
is_commit_id_equal
 ( 
dest
 , 
rev_options
 . 
rev
 ) :

208 
cmd_args
 = [ 'checkout' , '-q' ] + 
rev_options
 . 
to_args
 ( )

209 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 )

210 elif 
self
 . 
get_branch
 ( 
dest
 ) != 
branch_name
 :

213 
track_branch
 = 'origin/{}' . 
format
 ( 
branch_name
 )

214 
cmd_args
 = [ 'checkout'

215 , '-b' , 
branch_name
 , '--track' , 
track_branch
 ,

217 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 )

220 
self
 . 
update_submodules
 ( 
dest
 ) 
	}

222 def 
	$switch
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

223 
self
 . 
run_command
 ( [ 'config' , 'remote.origin.url' , 
url
 ] , 
cwd
 = 
dest
 )

224 
cmd_args
 = [ 'checkout' , '-q' ] + 
rev_options
 . 
to_args
 ( )

225 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 )

227 
self
 . 
update_submodules
 ( 
dest
 ) 
	}

229 def 
	$update
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

231 if 
self
 . 
get_git_version
 ( ) >= 
parse_version
 ( '1.9.0' ) :

233 
self
 . 
run_command
 ( [ 'fetch' , '-q' , '--tags' ] , 
cwd
 = 
dest
 )

235 
self
 . 
run_command
 ( [ 'fetch' , '-q' ] , 
cwd
 = 
dest
 )

237 
rev_options
 = 
self
 . 
resolve_revision
 ( 
dest
 , 
url
 , 
rev_options
 )

238 
cmd_args
 = [ 'reset' , '--hard' , '-q' ] + 
rev_options
 . 
to_args
 ( )

239 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 )

241 
self
 . 
update_submodules
 ( 
dest
 ) 
	}

243 def 
	$get_url
 ( 
self
 , 
location
 ) :

245 
remotes
 = 
self
 . 
run_command
 (

247 
show_stdout
 = False , 
cwd
 = 
location
 ,

249 
remotes
 = 
remotes
 . 
splitlines
 ( )

250 
found_remote
 = 
remotes
 [ 0 ]

251 for 
remote
 in 
remotes
 :

252 if 
remote
 . 
startswith
 ( 'remote.origin.url ' ) :

253 
found_remote
 = 
remote

255 
url
 = 
found_remote
 . 
split
 ( ' ' ) [ 1 ]

256 return 
url
 . 
strip
 ( ) 
	}

258 def 
	$get_revision
 ( 
self
 , 
location
 , 
rev
 = None ) :

259 if 
rev
 is None :

260 
rev
 = 'HEAD'

261 
current_rev
 = 
self
 . 
run_command
 (

262 [ 'rev-parse' , 
rev
 ] , 
show_stdout
 = False , 
cwd
 = 
location
 ,

264 return 
current_rev
 . 
strip
 ( ) 
	}

266 def 
	$_get_subdirectory
 ( 
self
 , 
location
 ) :

269 
git_dir
 = 
self
 . 
run_command
 ( [ 'rev-parse' , '--git-dir' ] ,

270 
show_stdout
 = False , 
cwd
 = 
location
 ) . 
strip
 ( )

271 if not 
os
 . 
path
 . 
isabs
 ( 
git_dir
 ) :

272 
git_dir
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
git_dir
 )

273 
root_dir
 = 
os
 . 
path
 . 
join
 ( 
git_dir
 , '..' )

275 
orig_location
 = 
location

276 while not 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
location
 , 'setup.py' ) ) :

277 
last_location
 = 
location

278 
location
 = 
os
 . 
path
 . 
dirname
 ( 
location
 )

279 if 
location
 == 
last_location
 :

282 
logger
 . 
warning
 ( "Could not find setup.py for directory %s (tried all " "parent directories)"

285 
orig_location
 ,

289 if 
samefile
 ( 
root_dir
 , 
location
 ) :

291 return 
os
 . 
path
 . 
relpath
 ( 
location
 , 
root_dir
 ) 
	}

293 def 
	$get_src_requirement
 ( 
self
 , 
dist
 , 
location
 ) :

294 
repo
 = 
self
 . 
get_url
 ( 
location
 )

295 if not 
repo
 . 
lower
 ( ) . 
startswith
 ( 'git:' ) :

296 
repo
 = 'git+' + 
repo

297 
current_rev
 = 
self
 . 
get_revision
 ( 
location
 )

298 
egg_project_name
 = 
dist
 . 
egg_name
 ( ) . 
split
 ( '-' , 1 ) [ 0 ]

299 
subdir
 = 
self
 . 
_get_subdirectory
 ( 
location
 )

300 
req
 = 
make_vcs_requirement_url
 ( 
repo
 , 
current_rev
 , 
egg_project_name
 ,

301 
subdir
 = 
subdir
 )

303 return 
req
 
	}

305 def 
	$get_url_rev_and_auth
 ( 
self
 , 
url
 ) :

312 if '://' not in 
url
 :

313 assert 'file:' not in 
url

314 
url
 = 
url
 . 
replace
 ( 'git+' , 'git+ssh://' )

315 
url
 , 
rev
 , 
user_pass
 = 
super
 ( 
Git
 , 
self
 ) . 
get_url_rev_and_auth
 ( 
url
 )

316 
url
 = 
url
 . 
replace
 ( 'ssh://' , '' )

318 
url
 , 
rev
 , 
user_pass
 = 
super
 ( 
Git
 , 
self
 ) . 
get_url_rev_and_auth
 ( 
url
 )

320 return 
url
 , 
rev
 , 
user_pass
 
	}

322 def 
	$update_submodules
 ( 
self
 , 
location
 ) :

323 if not 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
location
 , '.gitmodules' ) ) :

325 
self
 . 
run_command
 (

327 
cwd
 = 
location
 ,

328 ) 
	}

330 @ 
classmethod

331 def 
	$controls_location
 ( 
cls
 , 
location
 ) :

332 if 
super
 ( 
Git
 , 
cls
 ) . 
controls_location
 ( 
location
 ) :

335 
r
 = 
cls
 ( ) . 
run_command
 ( [ 'rev-parse' ] ,

336 
cwd
 = 
location
 ,

337 
show_stdout
 = False ,

338 
on_returncode
 = 'ignore' )

339 return not 
r

340 except 
BadCommand
 :

341 
logger
 . 
debug
 ( "could not determine if %s is under git control " "because git is not available"

342 , 
location
 )

343 return False 
	}

346 
vcs
 . 
register
 ( 
Git
 )


	@./env/lib/python3.7/site-packages/pip/_internal/vcs/subversion.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

5 import 
	~re

7 from 
	~pip._internal.models.link
 import 
Link

8 from 
	~pip._internal.utils.logging
 import 
indent_log

9 from 
	~pip._internal.utils.misc
 import (

10 
display_path
 , 
make_vcs_requirement_url
 , 
rmtree
 , 
split_auth_from_netloc
 ,

12 from 
	~pip._internal.vcs
 import 
VersionControl
 , 
vcs

14 
_svn_xml_url_re
 = 
re
 . 
compile
 ( 'url="([^"]+)"' )

15 
_svn_rev_re
 = 
re
 . 
compile
 ( r'committed-rev="(\d+)"' )

16 
_svn_info_xml_rev_re
 = 
re
 . 
compile
 ( r'\s*revision="(\d+)"' )

17 
_svn_info_xml_url_re
 = 
re
 . 
compile
 ( r'<url>(.*)</url>' )

20 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

23 class 
	cSubversion
 ( 
VersionControl
 ) :

24 
name
 = 'svn'

25 
dirname
 = '.svn'

26 
repo_name
 = 'checkout'

27 
schemes
 = ( 'svn' , 'svn+ssh' , 'svn+http' , 'svn+https' , 'svn+svn' )

29 def 
	$get_base_rev_args
 ( 
self
 , 
rev
 ) :

30 return [ '-r' , 
rev
 ] 
	}

32 def 
	$export
 ( 
self
 , 
location
 ) :

34 
url
 , 
rev_options
 = 
self
 . 
get_url_rev_options
 ( 
self
 . 
url
 )

36 
logger
 . 
info
 ( 'Exporting svn repository %s to %s' , 
url
 , 
location
 )

37 with 
indent_log
 ( ) :

38 if 
os
 . 
path
 . 
exists
 ( 
location
 ) :

41 
rmtree
 ( 
location
 )

42 
cmd_args
 = [ 'export' ] + 
rev_options
 . 
to_args
 ( ) + [ 
url
 , 
location
 ]

43 
self
 . 
run_command
 ( 
cmd_args
 , 
show_stdout
 = False ) 
	}

45 def 
	$fetch_new
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

46 
rev_display
 = 
rev_options
 . 
to_display
 ( )

47 
logger
 . 
info
 ( 'Checking out %s%s to %s'

49 
url
 ,

50 
rev_display
 ,

51 
display_path
 ( 
dest
 ) ,

53 
cmd_args
 = [ 'checkout' , '-q' ] + 
rev_options
 . 
to_args
 ( ) + [ 
url
 , 
dest
 ]

54 
self
 . 
run_command
 ( 
cmd_args
 ) 
	}

56 def 
	$switch
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

57 
cmd_args
 = [ 'switch' ] + 
rev_options
 . 
to_args
 ( ) + [ 
url
 , 
dest
 ]

58 
self
 . 
run_command
 ( 
cmd_args
 ) 
	}

60 def 
	$update
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

61 
cmd_args
 = [ 'update' ] + 
rev_options
 . 
to_args
 ( ) + [ 
dest
 ]

62 
self
 . 
run_command
 ( 
cmd_args
 ) 
	}

64 def 
	$get_location
 ( 
self
 , 
dist
 , 
dependency_links
 ) :

65 for 
url
 in 
dependency_links
 :

66 
egg_fragment
 = 
Link
 ( 
url
 ) . 
egg_fragment

67 if not 
egg_fragment
 :

69 if '-' in 
egg_fragment
 :

71 
key
 = '-' . 
join
 ( 
egg_fragment
 . 
split
 ( '-' ) [ : - 1 ] ) . 
lower
 ( )

73 
key
 = 
egg_fragment

74 if 
key
 == 
dist
 . 
key
 :

75 return 
url
 . 
split
 ( '#' , 1 ) [ 0 ]

76 return None 
	}

78 def 
	$get_revision
 ( 
self
 , 
location
 ) :

83 
revision
 = 0

85 for 
base
 , 
dirs
 , 
files
 in 
os
 . 
walk
 ( 
location
 ) :

86 if 
self
 . 
dirname
 not in 
dirs
 :

87 
dirs
 [ : ] = [ ]

89 
dirs
 . 
remove
 ( 
self
 . 
dirname
 )

90 
entries_fn
 = 
os
 . 
path
 . 
join
 ( 
base
 , 
self
 . 
dirname
 , 'entries' )

91 if not 
os
 . 
path
 . 
exists
 ( 
entries_fn
 ) :

95 
dirurl
 , 
localrev
 = 
self
 . 
_get_svn_url_rev
 ( 
base
 )

97 if 
base
 == 
location
 :

98 
base
 = 
dirurl
 + '/'

99 elif not 
dirurl
 or not 
dirurl
 . 
startswith
 ( 
base
 ) :

100 
dirs
 [ : ] = [ ]

102 
revision
 = 
max
 ( 
revision
 , 
localrev
 )

103 return 
revision
 
	}

105 def 
	$get_netloc_and_auth
 ( 
self
 , 
netloc
 , 
scheme
 ) :

110 if 
scheme
 == 'ssh' :

113 return 
super
 ( 
Subversion
 , 
self
 ) . 
get_netloc_and_auth
 (

114 
netloc
 , 
scheme
 )

116 return 
split_auth_from_netloc
 ( 
netloc
 ) 
	}

118 def 
	$get_url_rev_and_auth
 ( 
self
 , 
url
 ) :

120 
url
 , 
rev
 , 
user_pass
 = 
super
 ( 
Subversion
 , 
self
 ) . 
get_url_rev_and_auth
 ( 
url
 )

121 if 
url
 . 
startswith
 ( 'ssh://' ) :

122 
url
 = 'svn+' + 
url

123 return 
url
 , 
rev
 , 
user_pass
 
	}

125 def 
	$make_rev_args
 ( 
self
 , 
username
 , 
password
 ) :

126 
extra_args
 = [ ]

127 if 
username
 :

128 
extra_args
 += [ '--username' , 
username
 ]

129 if 
password
 :

130 
extra_args
 += [ '--password' , 
password
 ]

132 return 
extra_args
 
	}

134 def 
	$get_url
 ( 
self
 , 
location
 ) :

138 
orig_location
 = 
location

139 while not 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
location
 , 'setup.py' ) ) :

140 
last_location
 = 
location

141 
location
 = 
os
 . 
path
 . 
dirname
 ( 
location
 )

142 if 
location
 == 
last_location
 :

145 
logger
 . 
warning
 ( "Could not find setup.py for directory %s (tried all " "parent directories)"

148 
orig_location
 ,

152 return 
self
 . 
_get_svn_url_rev
 ( 
location
 ) [ 0 ] 
	}

154 def 
	$_get_svn_url_rev
 ( 
self
 , 
location
 ) :

155 from 
	~pip._internal.exceptions
 import 
InstallationError

157 
entries_path
 = 
os
 . 
path
 . 
join
 ( 
location
 , 
self
 . 
dirname
 , 'entries' )

158 if 
os
 . 
path
 . 
exists
 ( 
entries_path
 ) :

159 with 
open
 ( 
entries_path
 ) as 
f
 :

160 
data
 = 
f
 . 
read
 ( )

162 
data
 = ''

164 if ( 
data
 . 
startswith
 ( '8' ) or

165 
data
 . 
startswith
 ( '9' ) or

166 
data
 . 
startswith
 ( '10' ) ) :

167 
data
 = 
list
 ( 
map
 ( 
str
 . 
splitlines
 , 
data
 . 
split
 ( '\n\x0c\n' ) ) )

168 del 
data
 [ 0 ] [ 0 ]

169 
url
 = 
data
 [ 0 ] [ 3 ]

170 
revs
 = [ 
int
 ( 
d
 [ 9 ] ) for 
d
 in 
data
 if 
len
 ( 
d
 ) > 9 and 
d
 [ 9 ] ] + [ 0 ]

171 elif 
data
 . 
startswith
 ( '<?xml' ) :

172 
match
 = 
_svn_xml_url_re
 . 
search
 ( 
data
 )

173 if not 
match
 :

174 raise 
ValueError
 ( 'Badly formatted data: %r' % 
data
 )

175 
url
 = 
match
 . 
group
 ( 1 )

176 
revs
 = [ 
int
 ( 
m
 . 
group
 ( 1 ) ) for 
m
 in 
_svn_rev_re
 . 
finditer
 ( 
data
 ) ] + [ 0 ]

180 
xml
 = 
self
 . 
run_command
 (

181 [ 'info' , '--xml' , 
location
 ] ,

182 
show_stdout
 = False ,

184 
url
 = 
_svn_info_xml_url_re
 . 
search
 ( 
xml
 ) . 
group
 ( 1 )

185 
revs
 = [

186 
int
 ( 
m
 . 
group
 ( 1 ) ) for 
m
 in 
_svn_info_xml_rev_re
 . 
finditer
 ( 
xml
 )

188 except 
InstallationError
 :

189 
url
 , 
revs
 = None , [ ]

191 if 
revs
 :

192 
rev
 = 
max
 ( 
revs
 )

194 
rev
 = 0

196 return 
url
 , 
rev
 
	}

198 def 
	$get_src_requirement
 ( 
self
 , 
dist
 , 
location
 ) :

199 
repo
 = 
self
 . 
get_url
 ( 
location
 )

200 if 
repo
 is None :

202 
repo
 = 'svn+' + 
repo

203 
rev
 = 
self
 . 
get_revision
 ( 
location
 )

205 
egg_project_name
 = 
dist
 . 
egg_name
 ( ) . 
split
 ( '-' , 1 ) [ 0 ]

206 return 
make_vcs_requirement_url
 ( 
repo
 , 
rev
 , 
egg_project_name
 ) 
	}

208 def 
	$is_commit_id_equal
 ( 
self
 , 
dest
 , 
name
 ) :

210 return False 
	}

213 
vcs
 . 
register
 ( 
Subversion
 )


	@./env/lib/python3.7/site-packages/pip/_internal/vcs/__init__.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~errno

5 import 
	~logging

6 import 
	~os

7 import 
	~shutil

8 import 
	~sys

10 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

12 from 
	~pip._internal.exceptions
 import 
BadCommand

13 from 
	~pip._internal.utils.misc
 import (

14 
display_path
 , 
backup_dir
 , 
call_subprocess
 , 
rmtree
 , 
ask_path_exists
 ,

16 from 
	~pip._internal.utils.typing
 import 
MYPY_CHECK_RUNNING

18 if 
MYPY_CHECK_RUNNING
 :

19 from 
	~typing
 import 
Dict
 , 
Optional
 , 
Tuple

20 from 
	~pip._internal.cli.base_command
 import 
Command

22 
__all__
 = [ 'vcs' , 'get_src_requirement' ]

25 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

28 class 
	cRevOptions
 ( 
object
 ) :

37 def 
	$__init__
 ( 
self
 , 
vcs
 , 
rev
 = None , 
extra_args
 = None ) :

44 if 
extra_args
 is None :

45 
extra_args
 = [ ]

47 
self
 . 
extra_args
 = 
extra_args

48 
self
 . 
rev
 = 
rev

49 
self
 . 
vcs
 = 
vcs
 
	}

51 def 
	$__repr__
 ( 
self
 ) :

52 return '<RevOptions {}: rev={!r}>' . 
format
 ( 
self
 . 
vcs
 . 
name
 , 
self
 . 
rev
 ) 
	}

54 @ 
property

55 def 
	$arg_rev
 ( 
self
 ) :

56 if 
self
 . 
rev
 is None :

57 return 
self
 . 
vcs
 . 
default_arg_rev

59 return 
self
 . 
rev
 
	}

61 def 
	$to_args
 ( 
self
 ) :

65 
args
 = [ ]

66 
rev
 = 
self
 . 
arg_rev

67 if 
rev
 is not None :

68 
args
 += 
self
 . 
vcs
 . 
get_base_rev_args
 ( 
rev
 )

69 
args
 += 
self
 . 
extra_args

71 return 
args
 
	}

73 def 
	$to_display
 ( 
self
 ) :

74 if not 
self
 . 
rev
 :

77 return ' (to revision {})' . 
format
 ( 
self
 . 
rev
 ) 
	}

79 def 
	$make_new
 ( 
self
 , 
rev
 ) :

86 return 
self
 . 
vcs
 . 
make_rev_options
 ( 
rev
 , 
extra_args
 = 
self
 . 
extra_args
 ) 
	}

89 class 
	cVcsSupport
 ( 
object
 ) :

90 
_registry
 = { }

91 
schemes
 = [ 'ssh' , 'git' , 'hg' , 'bzr' , 'sftp' , 'svn' ]

93 def 
	$__init__
 ( 
self
 ) :

96 
urllib_parse
 . 
uses_netloc
 . 
extend
 ( 
self
 . 
schemes
 )

98 if 
getattr
 ( 
urllib_parse
 , 'uses_fragment' , None ) :

99 
urllib_parse
 . 
uses_fragment
 . 
extend
 ( 
self
 . 
schemes
 )

100 
super
 ( 
VcsSupport
 , 
self
 ) . 
__init__
 ( ) 
	}

102 def 
	$__iter__
 ( 
self
 ) :

103 return 
self
 . 
_registry
 . 
__iter__
 ( ) 
	}

105 @ 
property

106 def 
	$backends
 ( 
self
 ) :

107 return 
list
 ( 
self
 . 
_registry
 . 
values
 ( ) ) 
	}

109 @ 
property

110 def 
	$dirnames
 ( 
self
 ) :

111 return [ 
backend
 . 
dirname
 for 
backend
 in 
self
 . 
backends
 ] 
	}

113 @ 
property

114 def 
	$all_schemes
 ( 
self
 ) :

115 
schemes
 = [ ]

116 for 
backend
 in 
self
 . 
backends
 :

117 
schemes
 . 
extend
 ( 
backend
 . 
schemes
 )

118 return 
schemes
 
	}

120 def 
	$register
 ( 
self
 , 
cls
 ) :

121 if not 
hasattr
 ( 
cls
 , 'name' ) :

122 
logger
 . 
warning
 ( 'Cannot register VCS %s' , 
cls
 . 
__name__
 )

124 if 
cls
 . 
name
 not in 
self
 . 
_registry
 :

125 
self
 . 
_registry
 [ 
cls
 . 
name
 ] = 
cls

126 
logger
 . 
debug
 ( 'Registered VCS backend: %s' , 
cls
 . 
name
 ) 
	}

128 def 
	$unregister
 ( 
self
 , 
cls
 = None , 
name
 = None ) :

129 if 
name
 in 
self
 . 
_registry
 :

130 del 
self
 . 
_registry
 [ 
name
 ]

131 elif 
cls
 in 
self
 . 
_registry
 . 
values
 ( ) :

132 del 
self
 . 
_registry
 [ 
cls
 . 
name
 ]

134 
logger
 . 
warning
 ( 'Cannot unregister because no class or name given' ) 
	}

136 def 
	$get_backend_name
 ( 
self
 , 
location
 ) :

141 for 
vc_type
 in 
self
 . 
_registry
 . 
values
 ( ) :

142 if 
vc_type
 . 
controls_location
 ( 
location
 ) :

143 
logger
 . 
debug
 ( 'Determine that %s uses VCS: %s' ,

144 
location
 , 
vc_type
 . 
name
 )

145 return 
vc_type
 . 
name

146 return None 
	}

148 def 
	$get_backend
 ( 
self
 , 
name
 ) :

149 
name
 = 
name
 . 
lower
 ( )

150 if 
name
 in 
self
 . 
_registry
 :

151 return 
self
 . 
_registry
 [ 
name
 ] 
	}

153 def 
	$get_backend_from_location
 ( 
self
 , 
location
 ) :

154 
vc_type
 = 
self
 . 
get_backend_name
 ( 
location
 )

155 if 
vc_type
 :

156 return 
self
 . 
get_backend
 ( 
vc_type
 )

157 return None 
	}

160 
vcs
 = 
VcsSupport
 ( )

163 class 
	cVersionControl
 ( 
object
 ) :

164 
name
 = ''

165 
dirname
 = ''

167 
schemes
 = ( )

169 
unset_environ
 = ( )

170 
default_arg_rev
 = None

172 def 
	$__init__
 ( 
self
 , 
url
 = None , * 
args
 , ** 
kwargs
 ) :

173 
self
 . 
url
 = 
url

174 
super
 ( 
VersionControl
 , 
self
 ) . 
__init__
 ( * 
args
 , ** 
kwargs
 ) 
	}

176 def 
	$get_base_rev_args
 ( 
self
 , 
rev
 ) :

183 raise 
NotImplementedError
 
	}

185 def 
	$make_rev_options
 ( 
self
 , 
rev
 = None , 
extra_args
 = None ) :

193 return 
RevOptions
 ( 
self
 , 
rev
 , 
extra_args
 = 
extra_args
 ) 
	}

195 def 
	$_is_local_repository
 ( 
self
 , 
repo
 ) :

200 
drive
 , 
tail
 = 
os
 . 
path
 . 
splitdrive
 ( 
repo
 )

201 return 
repo
 . 
startswith
 ( 
os
 . 
path
 . 
sep
 ) or 
drive
 
	}

203 def 
	$export
 ( 
self
 , 
location
 ) :

208 raise 
NotImplementedError
 
	}

210 def 
	$get_netloc_and_auth
 ( 
self
 , 
netloc
 , 
scheme
 ) :

226 return 
netloc
 , ( None , None ) 
	}

228 def 
	$get_url_rev_and_auth
 ( 
self
 , 
url
 ) :

235 
scheme
 , 
netloc
 , 
path
 , 
query
 , 
frag
 = 
urllib_parse
 . 
urlsplit
 ( 
url
 )

236 if '+' not in 
scheme
 :

237 raise 
ValueError
 ( "Sorry, {!r} is a malformed VCS url. " "The format is <vcs>+<protocol>://<url>, " "e.g. svn+http://myrepo/svn/MyApp#egg=MyApp"

240 . 
format
 ( 
url
 )

243 
scheme
 = 
scheme
 . 
split
 ( '+' , 1 ) [ 1 ]

244 
netloc
 , 
user_pass
 = 
self
 . 
get_netloc_and_auth
 ( 
netloc
 , 
scheme
 )

245 
rev
 = None

246 if '@' in 
path
 :

247 
path
 , 
rev
 = 
path
 . 
rsplit
 ( '@' , 1 )

248 
url
 = 
urllib_parse
 . 
urlunsplit
 ( ( 
scheme
 , 
netloc
 , 
path
 , 
query
 , '' ) )

249 return 
url
 , 
rev
 , 
user_pass
 
	}

251 def 
	$make_rev_args
 ( 
self
 , 
username
 , 
password
 ) :

255 return [ ] 
	}

257 def 
	$get_url_rev_options
 ( 
self
 , 
url
 ) :

262 
url
 , 
rev
 , 
user_pass
 = 
self
 . 
get_url_rev_and_auth
 ( 
url
 )

263 
username
 , 
password
 = 
user_pass

264 
extra_args
 = 
self
 . 
make_rev_args
 ( 
username
 , 
password
 )

265 
rev_options
 = 
self
 . 
make_rev_options
 ( 
rev
 , 
extra_args
 = 
extra_args
 )

267 return 
url
 , 
rev_options
 
	}

269 def 
	$normalize_url
 ( 
self
 , 
url
 ) :

274 return 
urllib_parse
 . 
unquote
 ( 
url
 ) . 
rstrip
 ( '/' ) 
	}

276 def 
	$compare_urls
 ( 
self
 , 
url1
 , 
url2
 ) :

280 return ( 
self
 . 
normalize_url
 ( 
url1
 ) == 
self
 . 
normalize_url
 ( 
url2
 ) ) 
	}

282 def 
	$fetch_new
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

291 raise 
NotImplementedError
 
	}

293 def 
	$switch
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

300 raise 
NotImplementedError
 
	}

302 def 
	$update
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

309 raise 
NotImplementedError
 
	}

311 def 
	$is_commit_id_equal
 ( 
self
 , 
dest
 , 
name
 ) :

319 raise 
NotImplementedError
 
	}

321 def 
	$obtain
 ( 
self
 , 
dest
 ) :

329 
url
 , 
rev_options
 = 
self
 . 
get_url_rev_options
 ( 
self
 . 
url
 )

331 if not 
os
 . 
path
 . 
exists
 ( 
dest
 ) :

332 
self
 . 
fetch_new
 ( 
dest
 , 
url
 , 
rev_options
 )

335 
rev_display
 = 
rev_options
 . 
to_display
 ( )

336 if 
self
 . 
is_repository_directory
 ( 
dest
 ) :

337 
existing_url
 = 
self
 . 
get_url
 ( 
dest
 )

338 if 
self
 . 
compare_urls
 ( 
existing_url
 , 
url
 ) :

339 
logger
 . 
debug
 ( '%s in %s exists, and has correct URL (%s)'

341 
self
 . 
repo_name
 . 
title
 ( ) ,

342 
display_path
 ( 
dest
 ) ,

343 
url
 ,

345 if not 
self
 . 
is_commit_id_equal
 ( 
dest
 , 
rev_options
 . 
rev
 ) :

346 
logger
 . 
info
 ( 'Updating %s %s%s'

348 
display_path
 ( 
dest
 ) ,

349 
self
 . 
repo_name
 ,

350 
rev_display
 ,

352 
self
 . 
update
 ( 
dest
 , 
url
 , 
rev_options
 )

354 
logger
 . 
info
 ( 'Skipping because already up-to-date.' )

357 
logger
 . 
warning
 ( '%s %s in %s exists with URL %s'

359 
self
 . 
name
 ,

360 
self
 . 
repo_name
 ,

361 
display_path
 ( 
dest
 ) ,

362 
existing_url
 ,

364 
prompt
 = ( '(s)witch, (i)gnore, (w)ipe, (b)ackup ' ,

367 
logger
 . 
warning
 ( 'Directory %s already exists, and is not a %s %s.'

369 
dest
 ,

370 
self
 . 
name
 ,

371 
self
 . 
repo_name
 ,

373 
prompt
 = ( '(i)gnore, (w)ipe, (b)ackup ' , ( 'i' , 'w' , 'b' ) )

375 
logger
 . 
warning
 ( 'The plan is to install the %s repository %s'

377 
self
 . 
name
 ,

378 
url
 ,

380 
response
 = 
ask_path_exists
 ( 'What to do?  %s' % 
prompt
 [ 0 ] , 
prompt
 [ 1 ] )

382 if 
response
 == 'a' :

383 
sys
 . 
exit
 ( - 1 )

385 if 
response
 == 'w' :

386 
logger
 . 
warning
 ( 'Deleting %s' , 
display_path
 ( 
dest
 ) )

387 
rmtree
 ( 
dest
 )

388 
self
 . 
fetch_new
 ( 
dest
 , 
url
 , 
rev_options
 )

391 if 
response
 == 'b' :

392 
dest_dir
 = 
backup_dir
 ( 
dest
 )

393 
logger
 . 
warning
 ( 'Backing up %s to %s'

394 , 
display_path
 ( 
dest
 ) , 
dest_dir
 ,

396 
shutil
 . 
move
 ( 
dest
 , 
dest_dir
 )

397 
self
 . 
fetch_new
 ( 
dest
 , 
url
 , 
rev_options
 )

401 if 
response
 == 's' :

402 
logger
 . 
info
 ( 'Switching %s %s to %s%s'

404 
self
 . 
repo_name
 ,

405 
display_path
 ( 
dest
 ) ,

406 
url
 ,

407 
rev_display
 ,

409 
self
 . 
switch
 ( 
dest
 , 
url
 , 
rev_options
 ) 
	}

411 def 
	$unpack
 ( 
self
 , 
location
 ) :

416 if 
os
 . 
path
 . 
exists
 ( 
location
 ) :

417 
rmtree
 ( 
location
 )

418 
self
 . 
obtain
 ( 
location
 ) 
	}

420 def 
	$get_src_requirement
 ( 
self
 , 
dist
 , 
location
 ) :

427 raise 
NotImplementedError
 
	}

429 def 
	$get_url
 ( 
self
 , 
location
 ) :

433 raise 
NotImplementedError
 
	}

435 def 
	$get_revision
 ( 
self
 , 
location
 ) :

439 raise 
NotImplementedError
 
	}

441 def 
	$run_command
 ( 
self
 , 
cmd
 , 
show_stdout
 = True , 
cwd
 = None ,

442 
on_returncode
 = 'raise' ,

443 
command_desc
 = None ,

444 
extra_environ
 = None , 
spinner
 = None ) :

450 
cmd
 = [ 
self
 . 
name
 ] + 
cmd

452 return 
call_subprocess
 ( 
cmd
 , 
show_stdout
 , 
cwd
 ,

453 
on_returncode
 ,

454 
command_desc
 , 
extra_environ
 ,

455 
unset_environ
 = 
self
 . 
unset_environ
 ,

456 
spinner
 = 
spinner
 )

457 except 
OSError
 as 
e
 :

460 if 
e
 . 
errno
 == 
errno
 . 
ENOENT
 :

461 raise 
BadCommand
 ( 'Cannot find command %r - do you have ' '%r installed and in your ' 'PATH?'

464 % ( 
self
 . 
name
 , 
self
 . 
name
 ) )

466 raise 
	}

468 @ 
classmethod

469 def 
	$is_repository_directory
 ( 
cls
 , 
path
 ) :

473 
logger
 . 
debug
 ( 'Checking in %s for %s (%s)...' ,

474 
path
 , 
cls
 . 
dirname
 , 
cls
 . 
name
 )

475 return 
os
 . 
path
 . 
exists
 ( 
os
 . 
path
 . 
join
 ( 
path
 , 
cls
 . 
dirname
 ) ) 
	}

477 @ 
classmethod

478 def 
	$controls_location
 ( 
cls
 , 
location
 ) :

487 return 
cls
 . 
is_repository_directory
 ( 
location
 ) 
	}

490 def 
	$get_src_requirement
 ( 
dist
 , 
location
 ) :

491 
version_control
 = 
vcs
 . 
get_backend_from_location
 ( 
location
 )

492 if 
version_control
 :

494 return 
version_control
 ( ) . 
get_src_requirement
 ( 
dist
 ,

495 
location
 )

496 except 
BadCommand
 :

497 
logger
 . 
warning
 ( 'cannot determine version of editable source in %s ' '(%s command not found in path)'

500 
location
 ,

501 
version_control
 . 
name
 ,

503 return 
dist
 . 
as_requirement
 ( )

504 
logger
 . 
warning
 ( 'cannot determine version of editable source in %s (is not SVN ' 'checkout, Git clone, Mercurial clone or Bazaar branch)'

507 
location
 ,

509 return 
dist
 . 
as_requirement
 ( ) 
	}


	@./env/lib/python3.7/site-packages/pip/_internal/vcs/bazaar.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~logging

4 import 
	~os

6 from 
	~pip._vendor.six.moves.urllib
 import 
parse
 as 
urllib_parse

8 from 
	~pip._internal.download
 import 
path_to_url

9 from 
	~pip._internal.utils.misc
 import (

10 
display_path
 , 
make_vcs_requirement_url
 , 
rmtree
 ,

12 from 
	~pip._internal.utils.temp_dir
 import 
TempDirectory

13 from 
	~pip._internal.vcs
 import 
VersionControl
 , 
vcs

15 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

18 class 
	cBazaar
 ( 
VersionControl
 ) :

19 
name
 = 'bzr'

20 
dirname
 = '.bzr'

21 
repo_name
 = 'branch'

22 
schemes
 = ( 'bzr'

27 def 
	$__init__
 ( 
self
 , 
url
 = None , * 
args
 , ** 
kwargs
 ) :

28 
super
 ( 
Bazaar
 , 
self
 ) . 
__init__
 ( 
url
 , * 
args
 , ** 
kwargs
 )

31 if 
getattr
 ( 
urllib_parse
 , 'uses_fragment' , None ) :

32 
urllib_parse
 . 
uses_fragment
 . 
extend
 ( [ 'lp' ] ) 
	}

34 def 
	$get_base_rev_args
 ( 
self
 , 
rev
 ) :

35 return [ '-r' , 
rev
 ] 
	}

37 def 
	$export
 ( 
self
 , 
location
 ) :

42 if 
os
 . 
path
 . 
exists
 ( 
location
 ) :

43 
rmtree
 ( 
location
 )

45 with 
TempDirectory
 ( 
kind
 = "export" ) as 
temp_dir
 :

46 
self
 . 
unpack
 ( 
temp_dir
 . 
path
 )

48 
self
 . 
run_command
 (

49 [ 'export' , 
location
 ] ,

50 
cwd
 = 
temp_dir
 . 
path
 , 
show_stdout
 = False ,

51 ) 
	}

53 def 
	$fetch_new
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

54 
rev_display
 = 
rev_options
 . 
to_display
 ( )

55 
logger
 . 
info
 ( 'Checking out %s%s to %s'

57 
url
 ,

58 
rev_display
 ,

59 
display_path
 ( 
dest
 ) ,

61 
cmd_args
 = [ 'branch' , '-q' ] + 
rev_options
 . 
to_args
 ( ) + [ 
url
 , 
dest
 ]

62 
self
 . 
run_command
 ( 
cmd_args
 ) 
	}

64 def 
	$switch
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

65 
self
 . 
run_command
 ( [ 'switch' , 
url
 ] , 
cwd
 = 
dest
 ) 
	}

67 def 
	$update
 ( 
self
 , 
dest
 , 
url
 , 
rev_options
 ) :

68 
cmd_args
 = [ 'pull' , '-q' ] + 
rev_options
 . 
to_args
 ( )

69 
self
 . 
run_command
 ( 
cmd_args
 , 
cwd
 = 
dest
 ) 
	}

71 def 
	$get_url_rev_and_auth
 ( 
self
 , 
url
 ) :

73 
url
 , 
rev
 , 
user_pass
 = 
super
 ( 
Bazaar
 , 
self
 ) . 
get_url_rev_and_auth
 ( 
url
 )

74 if 
url
 . 
startswith
 ( 'ssh://' ) :

75 
url
 = 'bzr+' + 
url

76 return 
url
 , 
rev
 , 
user_pass
 
	}

78 def 
	$get_url
 ( 
self
 , 
location
 ) :

79 
urls
 = 
self
 . 
run_command
 ( [ 'info' ] , 
show_stdout
 = False , 
cwd
 = 
location
 )

80 for 
line
 in 
urls
 . 
splitlines
 ( ) :

81 
line
 = 
line
 . 
strip
 ( )

82 for 
x
 in ( 'checkout of branch: ' , 'parent branch: '

84 if 
line
 . 
startswith
 ( 
x
 ) :

85 
repo
 = 
line
 . 
split
 ( 
x
 ) [ 1 ]

86 if 
self
 . 
_is_local_repository
 ( 
repo
 ) :

87 return 
path_to_url
 ( 
repo
 )

88 return 
repo

89 return None 
	}

91 def 
	$get_revision
 ( 
self
 , 
location
 ) :

92 
revision
 = 
self
 . 
run_command
 (

93 [ 'revno' ] , 
show_stdout
 = False , 
cwd
 = 
location
 ,

95 return 
revision
 . 
splitlines
 ( ) [ - 1 ] 
	}

97 def 
	$get_src_requirement
 ( 
self
 , 
dist
 , 
location
 ) :

98 
repo
 = 
self
 . 
get_url
 ( 
location
 )

99 if not 
repo
 :

101 if not 
repo
 . 
lower
 ( ) . 
startswith
 ( 'bzr:' ) :

102 
repo
 = 'bzr+' + 
repo

103 
current_rev
 = 
self
 . 
get_revision
 ( 
location
 )

104 
egg_project_name
 = 
dist
 . 
egg_name
 ( ) . 
split
 ( '-' , 1 ) [ 0 ]

105 return 
make_vcs_requirement_url
 ( 
repo
 , 
current_rev
 , 
egg_project_name
 ) 
	}

107 def 
	$is_commit_id_equal
 ( 
self
 , 
dest
 , 
name
 ) :

109 return False 
	}

112 
vcs
 . 
register
 ( 
Bazaar
 )


	@./env/lib/python3.7/site-packages/pip/_internal/pep425tags.py

2 from 
	~__future__
 import 
absolute_import

4 import 
	~distutils.util

5 import 
	~logging

6 import 
	~platform

7 import 
	~re

8 import 
	~sys

9 import 
	~sysconfig

10 import 
	~warnings

11 from 
	~collections
 import 
OrderedDict

13 import 
	~pip._internal.utils.glibc

14 from 
	~pip._internal.utils.compat
 import 
get_extension_suffixes

16 
logger
 = 
logging
 . 
getLogger
 ( 
__name__
 )

18 
_osx_arch_pat
 = 
re
 . 
compile
 ( r'(.+)_(\d+)_(\d+)_(.+)' )

21 def 
	$get_config_var
 ( 
var
 ) :

23 return 
sysconfig
 . 
get_config_var
 ( 
var
 )

24 except 
IOError
 as 
e
 :

25 
warnings
 . 
warn
 ( "{}" . 
format
 ( 
e
 ) , 
RuntimeWarning
 )

26 return None 
	}

29 def 
	$get_abbr_impl
 ( ) :

31 if 
hasattr
 ( 
sys
 , 'pypy_version_info' ) :

32 
pyimpl
 = 'pp'

33 elif 
sys
 . 
platform
 . 
startswith
 ( 'java' ) :

34 
pyimpl
 = 'jy'

35 elif 
sys
 . 
platform
 == 'cli' :

36 
pyimpl
 = 'ip'

38 
pyimpl
 = 'cp'

39 return 
pyimpl
 
	}

42 def 
	$get_impl_ver
 ( ) :

44 
impl_ver
 = 
get_config_var
 ( "py_version_nodot" )

45 if not 
impl_ver
 or 
get_abbr_impl
 ( ) == 'pp' :

46 
impl_ver
 = '' . 
join
 ( 
map
 ( 
str
 , 
get_impl_version_info
 ( ) ) )

47 return 
impl_ver
 
	}

50 def 
	$get_impl_version_info
 ( ) :

53 if 
get_abbr_impl
 ( ) == 'pp' :

55 return ( 
sys
 . 
version_info
 [ 0 ] , 
sys
 . 
pypy_version_info
 . 
major
 ,

56 
sys
 . 
pypy_version_info
 . 
minor
 )

58 return 
sys
 . 
version_info
 [ 0 ] , 
sys
 . 
version_info
 [ 1 ] 
	}

61 def 
	$get_impl_tag
 ( ) :

65 return "{}{}" . 
format
 ( 
get_abbr_impl
 ( ) , 
get_impl_ver
 ( ) ) 
	}

68 def 
	$get_flag
 ( 
var
 , 
fallback
 , 
expected
 = True , 
warn
 = True ) :

71 
val
 = 
get_config_var
 ( 
var
 )

72 if 
val
 is None :

73 if 
warn
 :

74 
logger
 . 
debug
 ( "Config variable '%s' is unset, Python ABI tag may " "be incorrect"

75 , 
var
 )

76 return 
fallback
 ( )

77 return 
val
 == 
expected
 
	}

80 def 
	$get_abi_tag
 ( ) :

83 
soabi
 = 
get_config_var
 ( 'SOABI' )

84 
impl
 = 
get_abbr_impl
 ( )

85 if not 
soabi
 and 
impl
 in { 'cp' , 'pp' } and 
hasattr
 ( 
sys
 , 'maxunicode' ) :

86 
d
 = ''

87 
m
 = ''

88 
u
 = ''

89 if 
get_flag
 ( 'Py_DEBUG' ,

90 lambda : 
hasattr
 ( 
sys
 , 'gettotalrefcount' ) ,

91 
warn
 = ( 
impl
 == 'cp' ) ) :

92 
d
 = 'd'

93 if 
get_flag
 ( 'WITH_PYMALLOC' ,

94 lambda : 
impl
 == 'cp' ,

95 
warn
 = ( 
impl
 == 'cp' ) ) :

96 
m
 = 'm'

97 if 
get_flag
 ( 'Py_UNICODE_SIZE' ,

98 lambda : 
sys
 . 
maxunicode
 == 0x10ffff ,

99 
expected
 = 4 ,

100 
warn
 = ( 
impl
 == 'cp' and

101 
sys
 . 
version_info
 < ( 3 , 3 ) ) )

102 and 
sys
 . 
version_info
 < ( 3 , 3 ) :

103 
u
 = 'u'

104 
abi
 = '%s%s%s%s%s' % ( 
impl
 , 
get_impl_ver
 ( ) , 
d
 , 
m
 , 
u
 )

105 elif 
soabi
 and 
soabi
 . 
startswith
 ( 'cpython-' ) :

106 
abi
 = 'cp' + 
soabi
 . 
split
 ( '-' ) [ 1 ]

107 elif 
soabi
 :

108 
abi
 = 
soabi
 . 
replace
 ( '.' , '_' ) . 
replace
 ( '-' , '_' )

110 
abi
 = None

111 return 
abi
 
	}

114 def 
	$_is_running_32bit
 ( ) :

115 return 
sys
 . 
maxsize
 == 2147483647 
	}

118 def 
	$get_platform
 ( ) :

120 if 
sys
 . 
platform
 == 'darwin' :

124 
release
 , 
_
 , 
machine
 = 
platform
 . 
mac_ver
 ( )

125 
split_ver
 = 
release
 . 
split
 ( '.' )

127 if 
machine
 == "x86_64" and 
_is_running_32bit
 ( ) :

128 
machine
 = "i386"

129 elif 
machine
 == "ppc64" and 
_is_running_32bit
 ( ) :

130 
machine
 = "ppc"

132 return 'macosx_{}_{}_{}' . 
format
 ( 
split_ver
 [ 0 ] , 
split_ver
 [ 1 ] , 
machine
 )

135 
result
 = 
distutils
 . 
util
 . 
get_platform
 ( ) . 
replace
 ( '.' , '_' ) . 
replace
 ( '-' , '_' )

136 if 
result
 == "linux_x86_64" and 
_is_running_32bit
 ( ) :

139 
result
 = "linux_i686"

141 return 
result
 
	}

144 def 
	$is_manylinux1_compatible
 ( ) :

146 if 
get_platform
 ( ) not in { "linux_x86_64" , "linux_i686" } :

151 import 
	~_manylinux

152 return 
bool
 ( 
_manylinux
 . 
manylinux1_compatible
 )

153 except ( 
ImportError
 , 
AttributeError
 ) :

158 return 
pip
 . 
_internal
 . 
utils
 . 
glibc
 . 
have_compatible_glibc
 ( 2 , 5 ) 
	}

161 def 
	$get_darwin_arches
 ( 
major
 , 
minor
 , 
machine
 ) :

165 
arches
 = [ ]

167 def 
_supports_arch
 ( 
major
 , 
minor
 , 
arch
 ) :

189 if 
arch
 == 'ppc' :

190 return ( 
major
 , 
minor
 ) <= ( 10 , 5 )

191 if 
arch
 == 'ppc64' :

192 return ( 
major
 , 
minor
 ) == ( 10 , 5 )

193 if 
arch
 == 'i386' :

194 return ( 
major
 , 
minor
 ) >= ( 10 , 4 )

195 if 
arch
 == 'x86_64' :

196 return ( 
major
 , 
minor
 ) >= ( 10 , 5 )

197 if 
arch
 in 
groups
 :

198 for 
garch
 in 
groups
 [ 
arch
 ] :

199 if 
_supports_arch
 ( 
major
 , 
minor
 , 
garch
 ) :

203 
groups
 = 
OrderedDict
 ( [

210 if 
_supports_arch
 ( 
major
 , 
minor
 , 
machine
 ) :

211 
arches
 . 
append
 ( 
machine
 )

213 for 
garch
 in 
groups
 :

214 if 
machine
 in 
groups
 [ 
garch
 ] and 
_supports_arch
 ( 
major
 , 
minor
 , 
garch
 ) :

215 
arches
 . 
append
 ( 
garch
 )

217 
arches
 . 
append
 ( 'universal' )

219 return 
arches
 
	}

222 def 
	$get_supported
 ( 
versions
 = None , 
noarch
 = False , 
platform
 = None ,

223 
impl
 = None , 
abi
 = None ) :

236 
supported
 = [ ]

239 if 
versions
 is None :

240 
versions
 = [ ]

241 
version_info
 = 
get_impl_version_info
 ( )

242 
major
 = 
version_info
 [ : - 1 ]

244 for 
minor
 in 
range
 ( 
version_info
 [ - 1 ] , - 1 , - 1 ) :

245 
versions
 . 
append
 ( '' . 
join
 ( 
map
 ( 
str
 , 
major
 + ( 
minor
 , ) ) ) )

247 
impl
 = 
impl
 or 
get_abbr_impl
 ( )

249 
abis
 = [ ]

251 
abi
 = 
abi
 or 
get_abi_tag
 ( )

252 if 
abi
 :

253 
abis
 [ 0 : 0 ] = [ 
abi
 ]

255 
abi3s
 = 
set
 ( )

256 for 
suffix
 in 
get_extension_suffixes
 ( ) :

257 if 
suffix
 . 
startswith
 ( '.abi' ) :

258 
abi3s
 . 
add
 ( 
suffix
 . 
split
 ( '.' , 2 ) [ 1 ] )

260 
abis
 . 
extend
 ( 
sorted
 ( 
list
 ( 
abi3s
 ) ) )

262 
abis
 . 
append
 ( 'none' )

264 if not 
noarch
 :

265 
arch
 = 
platform
 or 
get_platform
 ( )

266 if 
arch
 . 
startswith
 ( 'macosx' ) :

268 
match
 = 
_osx_arch_pat
 . 
match
 ( 
arch
 )

269 if 
match
 :

270 
name
 , 
major
 , 
minor
 , 
actual_arch
 = 
match
 . 
groups
 ( )

271 
tpl
 = '{}_{}_%i_%s' . 
format
 ( 
name
 , 
major
 )

272 
arches
 = [ ]

273 for 
m
 in 
reversed
 ( 
range
 ( 
int
 ( 
minor
 ) + 1 ) ) :

274 for 
a
 in 
get_darwin_arches
 ( 
int
 ( 
major
 ) , 
m
 , 
actual_arch
 ) :

275 
arches
 . 
append
 ( 
tpl
 % ( 
m
 , 
a
 ) )

278 
arches
 = [ 
arch
 ]

279 elif 
platform
 is None and 
is_manylinux1_compatible
 ( ) :

280 
arches
 = [ 
arch
 . 
replace
 ( 'linux' , 'manylinux1' ) , 
arch
 ]

282 
arches
 = [ 
arch
 ]

285 for 
abi
 in 
abis
 :

286 for 
arch
 in 
arches
 :

287 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] ) , 
abi
 , 
arch
 ) )

290 for 
version
 in 
versions
 [ 1 : ] :

292 if 
version
 in { '31' , '30' } :

294 for 
abi
 in 
abi3s
 :

295 for 
arch
 in 
arches
 :

296 
supported
 . 
append
 ( ( "%s%s" % ( 
impl
 , 
version
 ) , 
abi
 , 
arch
 ) )

299 for 
arch
 in 
arches
 :

300 
supported
 . 
append
 ( ( 'py%s' % ( 
versions
 [ 0 ] [ 0 ] ) , 'none' , 
arch
 ) )

303 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] ) , 'none' , 'any' ) )

306 
supported
 . 
append
 ( ( '%s%s' % ( 
impl
 , 
versions
 [ 0 ] [ 0 ] ) , 'none' , 'any' ) )

309 for 
i
 , 
version
 in 
enumerate
 ( 
versions
 ) :

310 
supported
 . 
append
 ( ( 'py%s' % ( 
version
 , ) , 'none' , 'any' ) )

311 if 
i
 == 0 :

312 
supported
 . 
append
 ( ( 'py%s' % ( 
version
 [ 0 ] ) , 'none' , 'any' ) )

314 return 
supported
 
	}

317 
implementation_tag
 = 
get_impl_tag
 ( )


	@./env/lib/python3.7/site-packages/pip/__main__.py

1 from 
	~__future__
 import 
absolute_import

3 import 
	~os

4 import 
	~sys

8 if 
__package__
 == '' :

13 
path
 = 
os
 . 
path
 . 
dirname
 ( 
os
 . 
path
 . 
dirname
 ( 
__file__
 ) )

14 
sys
 . 
path
 . 
insert
 ( 0 , 
path
 )

16 from 
	~pip._internal
 import 
main
 as 
_main

18 if 
__name__
 == '__main__' :

19 
sys
 . 
exit
 ( 
_main
 ( ) )


	@./env/lib/python3.7/site-packages/pip/__init__.py

1 
__version__
 = "18.1"


	@./env/lib/python3.7/site-packages/pip/_vendor/__init__.py

8 from 
	~__future__
 import 
absolute_import

10 import 
	~glob

11 import 
	~os.path

12 import 
	~sys

17 
DEBUNDLED
 = True

23 
WHEEL_DIR
 = 
os
 . 
path
 . 
abspath
 ( 
os
 . 
path
 . 
join
 ( 
sys
 . 
prefix
 , 'share' , 'python-wheels' ) )

29 def 
	$vendored
 ( 
modulename
 ) :

30 
vendored_name
 = "{0}.{1}" . 
format
 ( 
__name__
 , 
modulename
 )

33 
__import__
 ( 
vendored_name
 , 
globals
 ( ) , 
locals
 ( ) , 
level
 = 0 )

34 except 
ImportError
 :

36 
__import__
 ( 
modulename
 , 
globals
 ( ) , 
locals
 ( ) , 
level
 = 0 )

37 except 
ImportError
 :

48 
sys
 . 
modules
 [ 
vendored_name
 ] = 
sys
 . 
modules
 [ 
modulename
 ]

49 
base
 , 
head
 = 
vendored_name
 . 
rsplit
 ( "." , 1 )

50 
setattr
 ( 
sys
 . 
modules
 [ 
base
 ] , 
head
 , 
sys
 . 
modules
 [ 
modulename
 ] ) 
	}

58 if 
DEBUNDLED
 :

61 
sys
 . 
path
 [ : ] = 
glob
 . 
glob
 ( 
os
 . 
path
 . 
join
 ( 
WHEEL_DIR
 , "*.whl" ) ) + 
sys
 . 
path

64 
vendored
 ( "cachecontrol" )

65 
vendored
 ( "colorama" )

66 
vendored
 ( "distlib" )

67 
vendored
 ( "distro" )

68 
vendored
 ( "html5lib" )

69 
vendored
 ( "lockfile" )

70 
vendored
 ( "six" )

71 
vendored
 ( "six.moves" )

72 
vendored
 ( "six.moves.urllib" )

73 
vendored
 ( "six.moves.urllib.parse" )

74 
vendored
 ( "packaging" )

75 
vendored
 ( "packaging.version" )

76 
vendored
 ( "packaging.specifiers" )

77 
vendored
 ( "pkg_resources" )

78 
vendored
 ( "progress" )

79 
vendored
 ( "pytoml" )

80 
vendored
 ( "retrying" )

81 
vendored
 ( "requests" )

82 
vendored
 ( "requests.packages" )

83 
vendored
 ( "requests.packages.urllib3" )

84 
vendored
 ( "requests.packages.urllib3._collections" )

85 
vendored
 ( "requests.packages.urllib3.connection" )

86 
vendored
 ( "requests.packages.urllib3.connectionpool" )

87 
vendored
 ( "requests.packages.urllib3.contrib" )

88 
vendored
 ( "requests.packages.urllib3.contrib.ntlmpool" )

89 
vendored
 ( "requests.packages.urllib3.contrib.pyopenssl" )

90 
vendored
 ( "requests.packages.urllib3.exceptions" )

91 
vendored
 ( "requests.packages.urllib3.fields" )

92 
vendored
 ( "requests.packages.urllib3.filepost" )

93 
vendored
 ( "requests.packages.urllib3.packages" )

95 
vendored
 ( "requests.packages.urllib3.packages.ordered_dict" )

96 
vendored
 ( "requests.packages.urllib3.packages.six" )

97 except 
ImportError
 :

100 
vendored
 ( "requests.packages.urllib3.packages.ssl_match_hostname" )

101 
vendored
 ( "requests.packages.urllib3.packages.ssl_match_hostname." "_implementation"

103 
vendored
 ( "requests.packages.urllib3.poolmanager" )

104 
vendored
 ( "requests.packages.urllib3.request" )

105 
vendored
 ( "requests.packages.urllib3.response" )

106 
vendored
 ( "requests.packages.urllib3.util" )

107 
vendored
 ( "requests.packages.urllib3.util.connection" )

108 
vendored
 ( "requests.packages.urllib3.util.request" )

109 
vendored
 ( "requests.packages.urllib3.util.response" )

110 
vendored
 ( "requests.packages.urllib3.util.retry" )

111 
vendored
 ( "requests.packages.urllib3.util.ssl_" )

112 
vendored
 ( "requests.packages.urllib3.util.timeout" )

113 
vendored
 ( "requests.packages.urllib3.util.url" )

114 
vendored
 ( "urllib3" )


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/compat.py

2 import 
	~json

3 import 
	~sys

5 if 
sys
 . 
version_info
 [ 0 ] >= 3 :

7 def 
	$write_json
 ( 
obj
 , 
path
 , ** 
kwargs
 ) :

8 with 
open
 ( 
path
 , 'w' , 
encoding
 = 'utf-8' ) as 
f
 :

9 
json
 . 
dump
 ( 
obj
 , 
f
 , ** 
kwargs
 ) 
	}

11 def 
	$read_json
 ( 
path
 ) :

12 with 
open
 ( 
path
 , 'r' , 
encoding
 = 'utf-8' ) as 
f
 :

13 return 
json
 . 
load
 ( 
f
 ) 
	}

17 def 
	$write_json
 ( 
obj
 , 
path
 , ** 
kwargs
 ) :

18 with 
open
 ( 
path
 , 'wb' ) as 
f
 :

19 
json
 . 
dump
 ( 
obj
 , 
f
 , 
encoding
 = 'utf-8' , ** 
kwargs
 ) 
	}

21 def 
	$read_json
 ( 
path
 ) :

22 with 
open
 ( 
path
 , 'rb' ) as 
f
 :

23 return 
json
 . 
load
 ( 
f
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/wrappers.py

1 from 
	~contextlib
 import 
contextmanager

2 import 
	~os

3 from 
	~os.path
 import 
dirname
 , 
abspath
 , 
join
 as 
pjoin

4 import 
	~shutil

5 from 
	~subprocess
 import 
check_call

6 import 
	~sys

7 from 
	~tempfile
 import 
mkdtemp

9 from . import 
compat

11 
_in_proc_script
 = 
pjoin
 ( 
dirname
 ( 
abspath
 ( 
__file__
 ) ) , '_in_process.py' )

13 @ 
	`contextmanager

14 def 
	$tempdir
 ( ) :

15 
td
 = 
mkdtemp
 ( )

17 yield 
td

19 
shutil
 . 
rmtree
 ( 
td
 ) 
	}

21 class 
	cUnsupportedOperation
 ( 
Exception
 ) :

24 class 
	cPep517HookCaller
 ( 
object
 ) :

30 def 
	$__init__
 ( 
self
 , 
source_dir
 , 
build_backend
 ) :

31 
self
 . 
source_dir
 = 
abspath
 ( 
source_dir
 )

32 
self
 . 
build_backend
 = 
build_backend
 
	}

34 def 
	$get_requires_for_build_wheel
 ( 
self
 , 
config_settings
 = None ) :

44 return 
self
 . 
_call_hook
 ( 'get_requires_for_build_wheel' , { 'config_settings'

45 : 
config_settings

46 } ) 
	}

48 def 
	$prepare_metadata_for_build_wheel
 ( 
self
 , 
metadata_directory
 , 
config_settings
 = None ) :

57 return 
self
 . 
_call_hook
 ( 'prepare_metadata_for_build_wheel' , { 'metadata_directory'

58 : 
abspath
 ( 
metadata_directory
 ) , 'config_settings'

59 : 
config_settings
 ,

60 } ) 
	}

62 def 
	$build_wheel
 ( 
self
 , 
wheel_directory
 , 
config_settings
 = None , 
metadata_directory
 = None ) :

72 if 
metadata_directory
 is not None :

73 
metadata_directory
 = 
abspath
 ( 
metadata_directory
 )

74 return 
self
 . 
_call_hook
 ( 'build_wheel' , { 'wheel_directory'

75 : 
abspath
 ( 
wheel_directory
 ) , 'config_settings'

76 : 
config_settings
 , 'metadata_directory'

77 : 
metadata_directory
 ,

78 } ) 
	}

80 def 
	$get_requires_for_build_sdist
 ( 
self
 , 
config_settings
 = None ) :

90 return 
self
 . 
_call_hook
 ( 'get_requires_for_build_sdist' , { 'config_settings'

91 : 
config_settings

92 } ) 
	}

94 def 
	$build_sdist
 ( 
self
 , 
sdist_directory
 , 
config_settings
 = None ) :

101 return 
self
 . 
_call_hook
 ( 'build_sdist' , { 'sdist_directory'

102 : 
abspath
 ( 
sdist_directory
 ) , 'config_settings'

103 : 
config_settings
 ,

104 } ) 
	}

107 def 
	$_call_hook
 ( 
self
 , 
hook_name
 , 
kwargs
 ) :

108 
env
 = 
os
 . 
environ
 . 
copy
 ( )

116 if 
sys
 . 
version_info
 [ 0 ] == 2 :

117 
build_backend
 = 
self
 . 
build_backend
 . 
encode
 ( 'ASCII' )

119 
build_backend
 = 
self
 . 
build_backend

121 
env
 [ 'PEP517_BUILD_BACKEND' ] = 
build_backend

122 with 
tempdir
 ( ) as 
td
 :

123 
compat
 . 
write_json
 ( { 'kwargs' : 
kwargs
 } , 
pjoin
 ( 
td
 , 'input.json' ) ,

124 
indent
 = 2 )

127 
check_call
 ( [ 
sys
 . 
executable
 , 
_in_proc_script
 , 
hook_name
 , 
td
 ] ,

128 
cwd
 = 
self
 . 
source_dir
 , 
env
 = 
env
 )

130 
data
 = 
compat
 . 
read_json
 ( 
pjoin
 ( 
td
 , 'output.json' ) )

131 if 
data
 . 
get
 ( 'unsupported' ) :

132 raise 
UnsupportedOperation

133 return 
data
 [ 'return_val' ] 
	}


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/envbuild.py

4 import 
	~os

5 import 
	~logging

6 from 
	~pip._vendor
 import 
pytoml

7 import 
	~shutil

8 from 
	~subprocess
 import 
check_call

9 import 
	~sys

10 from 
	~sysconfig
 import 
get_paths

11 from 
	~tempfile
 import 
mkdtemp

13 from . 
	~wrappers
 import 
Pep517HookCaller

15 
log
 = 
logging
 . 
getLogger
 ( 
__name__
 )

17 def 
	$_load_pyproject
 ( 
source_dir
 ) :

18 with 
open
 ( 
os
 . 
path
 . 
join
 ( 
source_dir
 , 'pyproject.toml' ) ) as 
f
 :

19 
pyproject_data
 = 
pytoml
 . 
load
 ( 
f
 )

20 
buildsys
 = 
pyproject_data
 [ 'build-system' ]

21 return 
buildsys
 [ 'requires' ] , 
buildsys
 [ 'build-backend' ] 
	}

24 class 
	cBuildEnvironment
 ( 
object
 ) :

50 
path
 = None

52 def 
	$__init__
 ( 
self
 , 
cleanup
 = True ) :

53 
self
 . 
_cleanup
 = 
cleanup
 
	}

55 def 
	$__enter__
 ( 
self
 ) :

56 
self
 . 
path
 = 
mkdtemp
 ( 
prefix
 = 'pep517-build-env-' )

57 
log
 . 
info
 ( 'Temporary build environment: %s' , 
self
 . 
path
 )

59 
self
 . 
save_path
 = 
os
 . 
environ
 . 
get
 ( 'PATH' , None )

60 
self
 . 
save_pythonpath
 = 
os
 . 
environ
 . 
get
 ( 'PYTHONPATH' , None )

62 
install_scheme
 = 'nt' if ( 
os
 . 
name
 == 'nt' ) else 'posix_prefix'

63 
install_dirs
 = 
get_paths
 ( 
install_scheme
 , 
vars
 = { 'base'

64 : 
self
 . 
path
 , 'platbase'

65 : 
self
 . 
path
 ,

68 
scripts
 = 
install_dirs
 [ 'scripts' ]

69 if 
self
 . 
save_path
 :

70 
os
 . 
environ
 [ 'PATH' ] = 
scripts
 + 
os
 . 
pathsep
 + 
self
 . 
save_path

72 
os
 . 
environ
 [ 'PATH' ] = 
scripts
 + 
os
 . 
pathsep
 + 
os
 . 
defpath

74 if 
install_dirs
 [ 'purelib' ] == 
install_dirs
 [ 'platlib' ] :

75 
lib_dirs
 = 
install_dirs
 [ 'purelib' ]

77 
lib_dirs
 = 
install_dirs
 [ 'purelib' ] + 
os
 . 
pathsep
 +

78 
install_dirs
 [ 'platlib' ]

79 if 
self
 . 
save_pythonpath
 :

80 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
lib_dirs
 + 
os
 . 
pathsep
 +

81 
self
 . 
save_pythonpath

83 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
lib_dirs

85 return 
self
 
	}

87 def 
	$pip_install
 ( 
self
 , 
reqs
 ) :

89 if not 
reqs
 :

91 
log
 . 
info
 ( 'Calling pip to install %s' , 
reqs
 )

92 
check_call
 ( [ 
sys
 . 
executable
 , '-m' , 'pip' , 'install' , '--ignore-installed' , '--prefix'

93 , 
self
 . 
path
 ] + 
list
 ( 
reqs
 ) ) 
	}

95 def 
	$__exit__
 ( 
self
 , 
exc_type
 , 
exc_val
 , 
exc_tb
 ) :

96 if 
self
 . 
_cleanup
 and ( 
self
 . 
path
 is not None ) and 
os
 . 
path
 . 
isdir
 ( 
self
 . 
path
 ) :

97 
shutil
 . 
rmtree
 ( 
self
 . 
path
 )

99 if 
self
 . 
save_path
 is None :

100 
os
 . 
environ
 . 
pop
 ( 'PATH' , None )

102 
os
 . 
environ
 [ 'PATH' ] = 
self
 . 
save_path

104 if 
self
 . 
save_pythonpath
 is None :

105 
os
 . 
environ
 . 
pop
 ( 'PYTHONPATH' , None )

107 
os
 . 
environ
 [ 'PYTHONPATH' ] = 
self
 . 
save_pythonpath
 
	}

109 def 
	$build_wheel
 ( 
source_dir
 , 
wheel_dir
 , 
config_settings
 = None ) :

119 if 
config_settings
 is None :

120 
config_settings
 = { }

121 
requires
 , 
backend
 = 
_load_pyproject
 ( 
source_dir
 )

122 
hooks
 = 
Pep517HookCaller
 ( 
source_dir
 , 
backend
 )

124 with 
BuildEnvironment
 ( ) as 
env
 :

125 
env
 . 
pip_install
 ( 
requires
 )

126 
reqs
 = 
hooks
 . 
get_requires_for_build_wheel
 ( 
config_settings
 )

127 
env
 . 
pip_install
 ( 
reqs
 )

128 return 
hooks
 . 
build_wheel
 ( 
wheel_dir
 , 
config_settings
 ) 
	}

131 def 
	$build_sdist
 ( 
source_dir
 , 
sdist_dir
 , 
config_settings
 = None ) :

141 if 
config_settings
 is None :

142 
config_settings
 = { }

143 
requires
 , 
backend
 = 
_load_pyproject
 ( 
source_dir
 )

144 
hooks
 = 
Pep517HookCaller
 ( 
source_dir
 , 
backend
 )

146 with 
BuildEnvironment
 ( ) as 
env
 :

147 
env
 . 
pip_install
 ( 
requires
 )

148 
reqs
 = 
hooks
 . 
get_requires_for_build_sdist
 ( 
config_settings
 )

149 
env
 . 
pip_install
 ( 
reqs
 )

150 return 
hooks
 . 
build_sdist
 ( 
sdist_dir
 , 
config_settings
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/check.py

3 import 
	~argparse

4 import 
	~logging

5 import 
	~os

6 from 
	~os.path
 import 
isfile
 , 
join
 as 
pjoin

7 from 
	~pip._vendor.pytoml
 import 
TomlError
 , 
load
 as 
toml_load

8 import 
	~shutil

9 from 
	~subprocess
 import 
CalledProcessError

10 import 
	~sys

11 import 
	~tarfile

12 from 
	~tempfile
 import 
mkdtemp

13 import 
	~zipfile

15 from . 
	~colorlog
 import 
enable_colourful_output

16 from . 
	~envbuild
 import 
BuildEnvironment

17 from . 
	~wrappers
 import 
Pep517HookCaller

19 
log
 = 
logging
 . 
getLogger
 ( 
__name__
 )

21 def 
	$check_build_sdist
 ( 
hooks
 ) :

22 with 
BuildEnvironment
 ( ) as 
env
 :

24 
env
 . 
pip_install
 ( 
hooks
 . 
build_sys_requires
 )

25 
log
 . 
info
 ( 'Installed static build dependencies' )

26 except 
CalledProcessError
 :

27 
log
 . 
error
 ( 'Failed to install static build dependencies' )

31 
reqs
 = 
hooks
 . 
get_requires_for_build_sdist
 ( { } )

32 
log
 . 
info
 ( 'Got build requires: %s' , 
reqs
 )

34 
log
 . 
error
 ( 'Failure in get_requires_for_build_sdist' , 
exc_info
 = True )

38 
env
 . 
pip_install
 ( 
reqs
 )

39 
log
 . 
info
 ( 'Installed dynamic build dependencies' )

40 except 
CalledProcessError
 :

41 
log
 . 
error
 ( 'Failed to install dynamic build dependencies' )

44 
td
 = 
mkdtemp
 ( )

45 
log
 . 
info
 ( 'Trying to build sdist in %s' , 
td
 )

48 
filename
 = 
hooks
 . 
build_sdist
 ( 
td
 , { } )

49 
log
 . 
info
 ( 'build_sdist returned %r' , 
filename
 )

51 
log
 . 
info
 ( 'Failure in build_sdist' , 
exc_info
 = True )

54 if not 
filename
 . 
endswith
 ( '.tar.gz' ) :

55 
log
 . 
error
 ( "Filename %s doesn't have .tar.gz extension" , 
filename
 )

58 
path
 = 
pjoin
 ( 
td
 , 
filename
 )

59 if 
isfile
 ( 
path
 ) :

60 
log
 . 
info
 ( "Output file %s exists" , 
path
 )

62 
log
 . 
error
 ( "Output file %s does not exist" , 
path
 )

65 if 
tarfile
 . 
is_tarfile
 ( 
path
 ) :

66 
log
 . 
info
 ( "Output file is a tar file" )

68 
log
 . 
error
 ( "Output file is not a tar file" )

72 
shutil
 . 
rmtree
 ( 
td
 )

74 return True 
	}

76 def 
	$check_build_wheel
 ( 
hooks
 ) :

77 with 
BuildEnvironment
 ( ) as 
env
 :

79 
env
 . 
pip_install
 ( 
hooks
 . 
build_sys_requires
 )

80 
log
 . 
info
 ( 'Installed static build dependencies' )

81 except 
CalledProcessError
 :

82 
log
 . 
error
 ( 'Failed to install static build dependencies' )

86 
reqs
 = 
hooks
 . 
get_requires_for_build_wheel
 ( { } )

87 
log
 . 
info
 ( 'Got build requires: %s' , 
reqs
 )

89 
log
 . 
error
 ( 'Failure in get_requires_for_build_sdist' , 
exc_info
 = True )

93 
env
 . 
pip_install
 ( 
reqs
 )

94 
log
 . 
info
 ( 'Installed dynamic build dependencies' )

95 except 
CalledProcessError
 :

96 
log
 . 
error
 ( 'Failed to install dynamic build dependencies' )

99 
td
 = 
mkdtemp
 ( )

100 
log
 . 
info
 ( 'Trying to build wheel in %s' , 
td
 )

103 
filename
 = 
hooks
 . 
build_wheel
 ( 
td
 , { } )

104 
log
 . 
info
 ( 'build_wheel returned %r' , 
filename
 )

106 
log
 . 
info
 ( 'Failure in build_wheel' , 
exc_info
 = True )

109 if not 
filename
 . 
endswith
 ( '.whl' ) :

110 
log
 . 
error
 ( "Filename %s doesn't have .whl extension" , 
filename
 )

113 
path
 = 
pjoin
 ( 
td
 , 
filename
 )

114 if 
isfile
 ( 
path
 ) :

115 
log
 . 
info
 ( "Output file %s exists" , 
path
 )

117 
log
 . 
error
 ( "Output file %s does not exist" , 
path
 )

120 if 
zipfile
 . 
is_zipfile
 ( 
path
 ) :

121 
log
 . 
info
 ( "Output file is a zip file" )

123 
log
 . 
error
 ( "Output file is not a zip file" )

127 
shutil
 . 
rmtree
 ( 
td
 )

129 return True 
	}

132 def 
	$check
 ( 
source_dir
 ) :

133 
pyproject
 = 
pjoin
 ( 
source_dir
 , 'pyproject.toml' )

134 if 
isfile
 ( 
pyproject
 ) :

135 
log
 . 
info
 ( 'Found pyproject.toml' )

137 
log
 . 
error
 ( 'Missing pyproject.toml' )

141 with 
open
 ( 
pyproject
 ) as 
f
 :

142 
pyproject_data
 = 
toml_load
 ( 
f
 )

144 
buildsys
 = 
pyproject_data
 [ 'build-system' ]

145 
requires
 = 
buildsys
 [ 'requires' ]

146 
backend
 = 
buildsys
 [ 'build-backend' ]

147 
log
 . 
info
 ( 'Loaded pyproject.toml' )

148 except ( 
TomlError
 , 
KeyError
 ) :

149 
log
 . 
error
 ( "Invalid pyproject.toml" , 
exc_info
 = True )

152 
hooks
 = 
Pep517HookCaller
 ( 
source_dir
 , 
backend
 )

154 
sdist_ok
 = 
check_build_sdist
 ( 
hooks
 )

155 
wheel_ok
 = 
check_build_wheel
 ( 
hooks
 )

157 if not 
sdist_ok
 :

158 
log
 . 
warning
 ( 'Sdist checks failed; scroll up to see' )

159 if not 
wheel_ok
 :

160 
log
 . 
warning
 ( 'Wheel checks failed' )

162 return 
sdist_ok
 
	}

165 def 
	$main
 ( 
argv
 = None ) :

166 
ap
 = 
argparse
 . 
ArgumentParser
 ( )

167 
ap
 . 
add_argument
 ( 'source_dir' ,

168 
help
 = "A directory containing pyproject.toml" )

169 
args
 = 
ap
 . 
parse_args
 ( 
argv
 )

171 
enable_colourful_output
 ( )

173 
ok
 = 
check
 ( 
args
 . 
source_dir
 )

175 if 
ok
 :

176 
print
 ( 
ansi
 ( 'Checks passed' , 'green' ) )

178 
print
 ( 
ansi
 ( 'Checks failed' , 'red' ) )

179 
sys
 . 
exit
 ( 1 ) 
	}

181 
ansi_codes
 = { 'reset'

187 def 
	$ansi
 ( 
s
 , 
attr
 ) :

188 if 
os
 . 
name
 != 'nt' and 
sys
 . 
stdout
 . 
isatty
 ( ) :

189 return 
ansi_codes
 [ 
attr
 ] + 
str
 ( 
s
 ) + 
ansi_codes
 [ 'reset' ]

191 return 
str
 ( 
s
 ) 
	}

193 if 
__name__
 == '__main__' :

194 
main
 ( )


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/__init__.py

4 
__version__
 = '0.2'


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/colorlog.py

19 import 
	~logging

20 import 
	~sys

23 import 
	~curses

24 except 
ImportError
 :

25 
curses
 = None

27 def 
	$_stderr_supports_color
 ( ) :

28 
color
 = False

29 if 
curses
 and 
hasattr
 ( 
sys
 . 
stderr
 , 'isatty' ) and 
sys
 . 
stderr
 . 
isatty
 ( ) :

31 
curses
 . 
setupterm
 ( )

32 if 
curses
 . 
tigetnum
 ( "colors" ) > 0 :

33 
color
 = True

34 except 
Exception
 :

36 return 
color
 
	}

38 class 
	cLogFormatter
 ( 
logging
 . 
Formatter
 ) :

41 
DEFAULT_COLORS
 = {

42 
logging
 . 
INFO
 : 2 ,

43 
logging
 . 
WARNING
 : 3 ,

44 
logging
 . 
ERROR
 : 1 ,

45 
logging
 . 
CRITICAL
 : 1 ,

48 def 
	$__init__
 ( 
self
 , 
color
 = True , 
datefmt
 = None ) :

62 
logging
 . 
Formatter
 . 
__init__
 ( 
self
 , 
datefmt
 = 
datefmt
 )

63 
self
 . 
_colors
 = { }

64 if 
color
 and 
_stderr_supports_color
 ( ) :

72 
fg_color
 = ( 
curses
 . 
tigetstr
 ( "setaf" ) or

73 
curses
 . 
tigetstr
 ( "setf" ) or "" )

74 if ( 3 , 0 ) < 
sys
 . 
version_info
 < ( 3 , 2 , 3 ) :

75 
fg_color
 = 
str
 ( 
fg_color
 , "ascii" )

77 for 
levelno
 , 
code
 in 
self
 . 
DEFAULT_COLORS
 . 
items
 ( ) :

78 
self
 . 
_colors
 [ 
levelno
 ] = 
str
 ( 
curses
 . 
tparm
 ( 
fg_color
 , 
code
 ) , "ascii" )

79 
self
 . 
_normal
 = 
str
 ( 
curses
 . 
tigetstr
 ( "sgr0" ) , "ascii" )

81 
scr
 = 
curses
 . 
initscr
 ( )

82 
self
 . 
termwidth
 = 
scr
 . 
getmaxyx
 ( ) [ 1 ]

83 
curses
 . 
endwin
 ( )

85 
self
 . 
_normal
 = ''

87 
self
 . 
termwidth
 = 70 
	}

89 def 
	$formatMessage
 ( 
self
 , 
record
 ) :

90 
l
 = 
len
 ( 
record
 . 
message
 )

91 
right_text
 = '{initial}-{name}' . 
format
 ( 
initial
 = 
record
 . 
levelname
 [ 0 ] ,

92 
name
 = 
record
 . 
name
 )

93 if 
l
 + 
len
 ( 
right_text
 ) < 
self
 . 
termwidth
 :

94 
space
 = ' ' * ( 
self
 . 
termwidth
 - ( 
l
 + 
len
 ( 
right_text
 ) ) )

96 
space
 = '  '

98 if 
record
 . 
levelno
 in 
self
 . 
_colors
 :

99 
start_color
 = 
self
 . 
_colors
 [ 
record
 . 
levelno
 ]

100 
end_color
 = 
self
 . 
_normal

102 
start_color
 = 
end_color
 = ''

104 return 
record
 . 
message
 + 
space
 + 
start_color
 + 
right_text
 + 
end_color
 
	}

106 def 
	$enable_colourful_output
 ( 
level
 = 
logging
 . 
INFO
 ) :

107 
handler
 = 
logging
 . 
StreamHandler
 ( )

108 
handler
 . 
setFormatter
 ( 
LogFormatter
 ( ) )

109 
logging
 . 
root
 . 
addHandler
 ( 
handler
 )

110 
logging
 . 
root
 . 
setLevel
 ( 
level
 ) 
	}


	@./env/lib/python3.7/site-packages/pip/_vendor/pep517/_in_process.py

13 from 
	~glob
 import 
glob

14 from 
	~importlib
 import 
import_module

15 import 
	~os

16 from 
	~os.path
 import 
join
 as 
pjoin

17 import 
	~re

18 import 
	~shutil

19 import 
	~sys

22 import 
	~compat

24 def 
	$_build_backend
 ( ) :

26 
ep
 = 
os
 . 
environ
 [ 'PEP517_BUILD_BACKEND' ]

27 
mod_path
 , 
_
 , 
obj_path
 = 
ep
 . 
partition
 ( ':' )

28 
obj
 = 
import_module
 ( 
mod_path
 )

29 if 
obj_path
 :

30 for 
path_part
 in 
obj_path
 . 
split
 ( '.' ) :

31 
obj
 = 
getattr
 ( 
obj
 , 
path_part
 )

32 return 
obj
 
	}

34 def 
	$get_requires_for_build_wheel
 ( 
config_settings
 ) :

39 
backend
 = 
_build_backend
 ( )

41 
hook
 = 
backend
 . 
get_requires_for_build_wheel

42 except 
AttributeError
 :

45 return 
hook
 ( 
config_settings
 ) 
	}

47 def 
	$prepare_metadata_for_build_wheel
 ( 
metadata_directory
 , 
config_settings
 ) :

52 
backend
 = 
_build_backend
 ( )

54 
hook
 = 
backend
 . 
prepare_metadata_for_build_wheel

55 except 
AttributeError
 :

56 return 
_get_wheel_metadata_from_wheel
 ( 
backend
 , 
metadata_directory
 ,

57 
config_settings
 )

59 return 
hook
 ( 
metadata_directory
 , 
config_settings
 ) 
	}

61 
WHEEL_BUILT_MARKER
 = 'PEP517_ALREADY_BUILT_WHEEL'

63 def 
	$_dist_info_files
 ( 
whl_zip
 ) :

65 
res
 = [ ]

66 for 
path
 in 
whl_zip
 . 
namelist
 ( ) :

67 
m
 = 
re
 . 
match
 ( r'[^/\\]+-[^/\\]+\.dist-info/' , 
path
 )

68 if 
m
 :

69 
res
 . 
append
 ( 
path
 )

70 if 
res
 :

71 return 
res

72 raise 
Exception
 ( "No .dist-info folder found in wheel" ) 
	}

74 def 
	$_get_wheel_metadata_from_wheel
 ( 
backend
 , 
metadata_directory
 , 
config_settings
 ) :

80 from 
	~zipfile
 import 
ZipFile

81 
whl_basename
 = 
backend
 . 
build_wheel
 ( 
metadata_directory
 , 
config_settings
 )

82 with 
open
 ( 
os
 . 
path
 . 
join
 ( 
metadata_directory
 , 
WHEEL_BUILT_MARKER
 ) , 'wb' ) :

85 
whl_file
 = 
os
 . 
path
 . 
join
 ( 
metadata_directory
 , 
whl_basename
 )

86 with 
ZipFile
 ( 
whl_file
 ) as 
zipf
 :

87 
dist_info
 = 
_dist_info_files
 ( 
zipf
 )

88 
zipf
 . 
extractall
 ( 
path
 = 
metadata_directory
 , 
members
 = 
dist_info
 )

89 return 
dist_info
 [ 0 ] . 
split
 ( '/' ) [ 0 ] 
	}

91 def 
	$_find_already_built_wheel
 ( 
metadata_directory
 ) :

94 if not 
metadata_directory
 :

96 
metadata_parent
 = 
os
 . 
path
 . 
dirname
 ( 
metadata_directory
 )

97 if not 
os
 . 
path
 . 
isfile
 ( 
pjoin
 ( 
metadata_parent
 , 
WHEEL_BUILT_MARKER
 ) ) :

100 
whl_files
 = 
glob
 ( 
os
 . 
path
 . 
join
 ( 
metadata_parent
 , '*.whl' ) )

101 if not 
whl_files
 :

102 
print
 ( 'Found wheel built marker, but no .whl files' )

104 if 
len
 ( 
whl_files
 ) > 1 :

105 
print
 ( 'Found multiple .whl files; unspecified behaviour. ' 'Will call build_wheel.'

110 return 
whl_files
 [ 0 ] 
	}

112 def 
	$build_wheel
 ( 
wheel_directory
 , 
config_settings
 , 
metadata_directory
 = None ) :

118 
prebuilt_whl
 = 
_find_already_built_wheel
 ( 
metadata_directory
 )

119 if 
prebuilt_whl
 :

120 
shutil
 . 
copy2
 ( 
prebuilt_whl
 , 
wheel_directory
 )

121 return 
os
 . 
path
 . 
basename
 ( 
prebuilt_whl
 )

123 return 
_build_backend
 ( ) . 
build_wheel
 ( 
wheel_directory
 , 
config_settings
 ,

124 
metadata_directory
 ) 
	}

127 def 
	$get_requires_for_build_sdist
 ( 
config_settings
 ) :

132 
backend
 = 
_build_backend
 ( )

134 
hook
 = 
backend
 . 
get_requires_for_build_sdist

135 except 
AttributeError
 :

138 return 
hook
 ( 
config_settings
 ) 
	}

140 class 
	c_DummyException
 ( 
Exception
 ) :

143 class 
	cGotUnsupportedOperation
 ( 
Exception
 ) :

146 def 
	$build_sdist
 ( 
sdist_directory
 , 
config_settings
 ) :

148 
backend
 = 
_build_backend
 ( )

150 return 
backend
 . 
build_sdist
 ( 
sdist_directory
 , 
config_settings
 )

151 except 
getattr
 ( 
backend
 , 'UnsupportedOperation' , 
_DummyException
 ) :

152 raise 
GotUnsupportedOperation
 
	}

154 
HOOK_NAMES
 = { 'get_requires_for_build_wheel'

162 def 
	$main
 ( ) :

163 if 
len
 ( 
sys
 . 
argv
 ) < 3 :

164 
sys
 . 
exit
 ( "Needs args: hook_name, control_dir" )

165 
hook_name
 = 
sys
 . 
argv
 [ 1 ]

166 
control_dir
 = 
sys
 . 
argv
 [ 2 ]

167 if 
hook_name
 not in 
HOOK_NAMES
 :

168 
sys
 . 
exit
 ( "Unknown hook: %s" % 
hook_name
 )

169 
hook
 = 
globals
 ( ) [ 
hook_name
 ]

171 
hook_input
 = 
compat
 . 
read_json
 ( 
pjoin
 ( 
control_dir
 , 'input.json' ) )

173 
json_out
 = { 'unsupported' : False , 'return_val' : None }

175 
json_out
 [ 'return_val' ] = 
hook
 ( ** 
hook_input
 [ 'kwargs' ] )

176 except 
GotUnsupportedOperation
 :

177 
json_out
 [ 'unsupported' ] = True

179 
compat
 . 
write_json
 ( 
json_out
 , 
pjoin
 ( 
control_dir
 , 'output.json' ) , 
indent
 = 2 ) 
	}

181 if 
__name__
 == '__main__' :

182 
main
 ( )


	@./gr2.py

5 import 
	~argparse

6 import 
	~datetime

7 from 
	~pathlib
 import 
Path

8 import 
	~regex

9 import 
	~os

10 import 
	~subprocess

11 import 
	~sys

12 import 
	~yappi

14 
prog_name
 = 'gr'

16 
goodreads_util_path
 = "/usr/local/bin/goodreads"

18 
rating_cmd
 = 
goodreads_util_path
 + "  book -r \"{}\" "

19 
b_author_cmd
 = 
goodreads_util_path
 + "  book -a \"{}\" "

20 
r_dist_cmd
 = 
goodreads_util_path
 + "  book --rating-dist \"{}\" "

21 
desc_cmd
 = 
goodreads_util_path
 + "  book -d \"{}\" "

22 
book_id_cmd
 = 
goodreads_util_path
 + "  book -g \"{}\" "

23 
bname_cmd
 = "echo \"{}\" "

32 
code_to_cmd
 =

33 { 'r' : 
rating_cmd
 , 'a'

34 : 
b_author_cmd
 , 'i'

35 : 
book_id_cmd
 , 'de'

36 : 
desc_cmd
 , 'rd'

37 : 
r_dist_cmd
 , 'b'

38 : 
bname_cmd
 ,

49 
DX_desc_codes
 = [ 'b' , 'a' , 'r' , 'rd' , 'de' ]

52 def 
	$main
 ( ) :

54 
yappi
 . 
start
 ( )

55 
args
 = 
process_commandline
 ( )

58 if 
len
 ( 
args
 . 
action_code
 ) == 1 :

59 
info
 = 
get_gr_data_from_code
 (

60 
args
 . 
action_code
 ,

61 
args
 . 
bname_spaces
 )

62 
print
 ( 
info
 )

63 
sys
 . 
exit
 ( 0 )

66 elif 
args
 . 
action_code
 == "to" :

67 if 
check_book_substr_in_dir
 ( 
args
 ) :

68 
orig_path_from_dir_str
 = 
find_path_from_subst
 ( 
args
 . 
bname_input
 )

69 
new_dir_path
 = 
path_from_dir_desc_str
 ( 
args
 , 
dir_desc_input_str
 )

70 
orig_path_from_dir_str
 . 
rename
 ( 
new_dir_path
 )

71 
print
 ( "renamed {args.bname_input} to {new_dir_path}\n" )

73 
print
 ( f"No dir matching {args.bname_input} or \"{args.bname_spaces}\"" )

74 
print
 ( f" or {args.bname_uscores} could be found in the directory" )

75 
sys
 . 
exit
 ( 1 )

78 elif 
args
 . 
action_code
 in ( 'de' , 'rd' , 'DX' ) :

79 
data
 = 
get_gr_data_from_code
 ( 
args
 . 
action_code
 , 
args
 . 
bname_spaces
 )

80 
print
 ( 
data
 )

84 
print
 ( "some input error did not get caught" )

86 
func_stats
 = 
yappi
 . 
get_func_stats
 ( )

87 
func_stats
 . 
save
 ( 'callgrind.out.' + 
datetime
 . 
now
 ( ) . 
isoformat
 ( ) , 'CALLGRIND' )

88 
yappi
 . 
stop
 ( )

89 
yappi
 . 
clear_stats
 ( ) 
	}

93 def 
	$process_commandline
 ( ) :

95 
basic_help
 = f'''\n    Usage:\n\n        {prog_name} Some_booK_name\n        {prog_name} x   Some_book_name\n\n        {prog_name} yy  "Some book name"\n        {prog_name} yy  "Some authors name"\n        {prog_name} yy  Some_authors_name\n\n        {prog_name} to  x/x__x      Some_booK_name\n\n        where x is:\n            b       for     The_books_name (underscore-separated)\n            r       for     book's rating\n            a       for     book's author\n            i       for     book's id\n\n        and yy is:\n            de      for     description of the book\n            rt      for     the books rating distribution\n            at      for     author's top books\n            ab      for     all an author's books\n            aa      for     about the author\n            ai      for     info about the author\n\n    NOTE: if 'to' is used, the directory matching the book's name will be renamed\n\n    '''

125 
a
 = 15

136 if 
len
 ( 
sys
 . 
argv
 ) > 4 or 
len
 ( 
sys
 . 
argv
 ) < 2 :

137 
print
 ( 
basic_help
 )

138 
sys
 . 
exit
 ( 1 )

140 
book_substr
 = 
sys
 . 
argv
 [ - 1 ]

142 
parser
 = 
argparse
 . 
ArgumentParser
 ( 
basic_help
 )

145 if 
len
 ( 
sys
 . 
argv
 ) < 2 :

146 
print
 ( 
basic_help
 )

147 
sys
 . 
exit
 ( 1 )

149 if 
len
 ( 
sys
 . 
argv
 ) == 2 :

150 
parser
 . 
add_argument
 ( "bname_input"

152 
type
 = 
str
 ,

153 
help
 = "A substring of the books name, with spaces or underscores"

156 if 
len
 ( 
sys
 . 
argv
 ) == 3 :

157 
parser
 . 
add_argument
 ( 'action_code'

159 
choices
 = [ 'r' , 'a' , 'i' , 'g' , 'u' , 'de' , 'rd' , 'at' , 'ab' , 'aa' , 'ai' , 'ua' ] ,

160 
action
 = 'store' ,

161 
type
 = 
str
 ,

162 
nargs
 = 1

164 
parser
 . 
add_argument
 ( "bname_input"

166 
type
 = 
str
 ,

167 
help
 = "A substring of the books name, with spaces or underscores"

170 if 
len
 ( 
sys
 . 
argv
 ) == 4 :

171 
parser
 . 
add_argument
 ( 'action_code'

173 
choices
 = [ 'to' ] ,

174 
action
 = 'store' ,

175 
type
 = 
str
 ,

176 
nargs
 = 1

178 
parser
 . 
add_argument
 ( 'dir_desc_input_str'

180 
type
 = 
str
 ,

181 
action
 = 'store' ,

182 
help
 = " a/b__r : becomes Author_name/book_name___4.12" ,

183 
nargs
 = 1

185 
parser
 . 
add_argument
 ( "bname_input"

187 
type
 = 
str
 ,

188 
help
 = "A substring of the books name, with spaces or underscores"

191 if 
len
 ( 
sys
 . 
argv
 ) > 4 :

192 
print
 ( 
basic_help
 )

193 
sys
 . 
exit
 ( 1 )

195 
args
 = 
parser
 . 
parse_args
 ( )

199 
args
 . 
bname_uscores
 = 
to_underscores
 ( 
args
 . 
bname_input
 )

200 
args
 . 
bname_spaces
 = 
to_spaces
 ( 
args
 . 
bname_uscores
 )

203 if not 'action_code' in 
args
 :

204 
args
 . 
action_code
 = 'DX'

206 if 
type
 ( 
args
 . 
action_code
 ) is 
list
 :

207 
args
 . 
action_code
 = 
args
 . 
action_code
 [ 0 ]

209 if '/' in 
args
 . 
bname_input
 :

211 
args
 . 
bname_input_path
 = 
find_path_from_subst
 ( 
args
 . 
bname_input
 )

214 if not 
check_book_substr_with_gr
 ( 
args
 ) :

215 
print
 ( f'No book matching {args.bname_input} \"{args.bname_spaces}\"' )

216 
print
 ( "could be found by goodreads" )

217 
sys
 . 
exit
 ( 1 )

219 return 
args
 
	}

226 def 
	$get_gr_data_from_code
 (

227 
code
 ,

228 
source_str

235 
this_data
 = ""

236 if 
code
 != 'DX' :

237 
cmd_str
 = 
code_to_cmd
 [ 
code
 ] . 
format
 ( 
source_str
 )

238 
cmd_to_run
 = 
subprocess
 . 
Popen
 ( 
cmd_str
 , 
shell
 = True , 
stdout
 = 
subprocess
 . 
PIPE
 ) . 
stdout

239 
this_data
 = 
cmd_to_run
 . 
read
 ( ) . 
decode
 ( )

240 
this_data
 = 
this_data
 . 
strip
 ( )

242 elif 
code
 == 'DX' :

243 for 
c
 in 
DX_desc_codes
 :

244 
cmd_str
 = 
code_to_cmd
 [ 
c
 ] . 
format
 ( 
source_str
 )

245 
cmd_to_run
 = 
subprocess
 . 
Popen
 ( 
cmd_str
 , 
shell
 = True , 
stdout
 = 
subprocess
 . 
PIPE
 ) . 
stdout

246 
this_data
 += f"{cmd_to_run.read().decode()}\n"

248 
print
 ( f"Could not get any goodreads data for the string {code} in relation to {source_str}" )

249 
sys
 . 
exit
 ( 1 )

251 return 
this_data
 
	}

255 def 
	$path_from_dir_desc_str
 (

256 
args
 ,

257 
desc_in_str

263 
out_str
 = 
desc_in_str

264 
str_parts
 = 
regex
 . 
split
 ( "[ _/]+" , 
desc_in_str
 )

265 for 
code
 in 
str_parts
 :

266 if 
len
 ( 
code
 ) == 1 :

267 
data
 = 
get_gr_data_from_code
 ( 
code
 )

268 if 
data
 :

269 
data_uscore
 = 
to_underscores
 ( 
data
 )

270 
out_str
 = 
regex
 . 
sub
 ( 
code
 , 
data_uscore
 , 
out_str
 )

272 
print
 ( "couldn't find goodreads data for the '{}' in \"{}\" " ) . 
format
 ( 
code
 , 
desc_in_str
 )

273 
sys
 . 
exit
 ( 1 )

275 
print
 ( "error in your dir pattern description \"{}\""

276 ) . 
format
 ( 
desc_in_str
 )

277 
sys
 . 
exit
 ( 1 )

280 
out_path
 = 
Path
 ( 
out_str
 )

281 return 
out_path
 
	}

287 def 
	$check_book_substr_with_gr
 (

288 
args

291 
trial_rating_cmd
 = 
rating_cmd
 . 
format
 ( 
args
 . 
bname_spaces
 )

292 
cmd
 = 
subprocess
 . 
Popen
 ( 
trial_rating_cmd
 , 
shell
 = True , 
stdout
 = 
subprocess
 . 
PIPE
 ) . 
stdout

293 
trial_rating
 = 
cmd
 . 
read
 ( ) . 
decode
 ( )

294 
found_gr_book
 = ( 
bool
 ( 
trial_rating
 is not None ) and 
bool
 ( 
float
 ( 
trial_rating
 ) > 0 ) )

296 return 
found_gr_book
 
	}

300 def 
	$check_book_substr_in_dir
 (

301 
args

304 
real_dir_name
 = ""

305 for 
bname
 in ( 
args
 . 
bname_spaces
 , 
args
 . 
bname_uscores
 , 
args
 . 
bname_input
 ) :

306 
real_dir_name
 = 
find_path_from_subst
 ( 
bname
 )

307 if 
real_dir_name
 and 
len
 ( 
real_dir_name
 ) > 3 :

314 return 
real_dir_name
 
	}

318 def 
	$find_path_from_subst
 (

319 
in_str
 : 
str

339 
in_str
 = 
in_str
 . 
rstrip
 ( '/' )

342 if 
in_str
 . 
find
 ( '/' ) == - 1 :

343 
cwd
 = 
os
 . 
getcwd
 ( )

344 
test_dir
 = f"{cwd}/*{in_str}*"

345 
real_dir_path
 = 
_path_if_test_dir_exist
 ( 
test_dir
 )

346 if 
real_dir_path
 is not None :

347 return 
real_dir_path

350 
in_str_spaces
 = 
to_spaces
 ( 
in_str
 )

351 
test_dir
 = f"{cwd}/*{in_str_spaces}*"

352 return 
_path_if_test_dir_exist
 ( 
test_dir
 )

355 elif 
in_str
 . 
find
 ( '/' ) != - 1 :

356 
test_dir
 = f"{in_str}*"

357 
real_dir_path
 = 
_path_if_test_dir_exist
 ( 
test_dir
 )

358 return 
real_dir_path

362 return None 
	}

368 def 
	$_path_if_test_dir_exist
 ( 
dir_str
 ) :

371 if 
len
 ( 
dir_str
 . 
split
 ( '\n' ) ) > 1 :

372 
print
 ( "Error: two or more dirs match \" {dir_str}\"" )

377 
p
 = 
Path
 ( 
dir_str
 )

378 
q
 = 
Path
 ( 
p
 . 
parent
 ) . 
glob
 ( 
p
 . 
name
 )

379 
r
 = 
sorted
 ( 
q
 )

380 if 
len
 ( 
r
 ) > 1 :

381 
print
 ( "Error: two or more dirs match \" {dir_str}\"" )

383 
dir_path
 = 
Path
 ( 
r
 [ 0 ] )

386 if not 
dir_path
 . 
exists
 ( ) or not 
dir_path
 . 
is_dir
 ( ) :

387 
dir_path
 = None

390 return 
dir_path
 
	}

394 def 
	$to_underscores
 (

395 
in_str
 ,

397 
in_str_uscores
 = 
in_str
 . 
translate
 ( 
str
 . 
maketrans
 ( ' ,.' , '___' ) )

398 return 
in_str_uscores
 
	}

400 def 
	$to_spaces
 (

401 
in_str
 ,

403 
str_uscores
 = 
to_underscores
 ( 
in_str
 )

404 
str_spaces
 = 
str_uscores
 . 
translate
 ( 
str
 . 
maketrans
 ( '_' , ' ' ) )

405 return 
str_spaces
 
	}

411 if 
__name__
 == '__main__' :

412 
main
 ( )


	@./gr.py

4 import 
	~argparse

5 import 
	~regex

6 import 
	~os

7 import 
	~sys

9 
goodreads_util_path
 = "/usr/local/bin/goodreads"

11 
rating_cmd
 = 
goodreads_util_path
 + "book -r \"{}\" "

12 
author_cmd
 = 
goodreads_util_path
 + "book -a \"{}\" "

13 
r_dist_cmd
 = 
goodreads_util_path
 + "book --rating-dist \"{}\" "

14 
desc_cmd
 = 
goodreads_util_path
 + "book -d \"{}\" "

19 def 
	$main
 ( ) :

21 
args
 = 
process_commandline
 ( )

24 if 'd' in 
args
 . 
do_this
 :

25 
bn_r
 = 
formatted_bookname_plus_rating
 ( 
args
 . 
bname_spaces
 )

26 
print
 ( 
bn_r
 , 
end
 = '' )

29 if 'rename' in 
args
 . 
do_this
 :

30 
rename_dir_to_bname___rating
 ( 
args
 )

33 if 
rename_author
 in 
args
 . 
do_this
 :

34 
rename_dir_to_author_bname_rating
 ( 
args
 )

37 if 
desc
 in 
args
 . 
do_this
 :

38 
print_goodreads_overview_of_book
 ( 
args
 ) 
	}

42 def 
	$process_commandline
 ( ) :

51 
basic_help
 = ' ' . 
join
 ( ( f'Usage:\n\n'

56 
parser
 = 
argparse
 . 
ArgumentParser
 ( 
basic_help
 )

57 
parser
 . 
add_argument
 ( "do_this"

59 
choices
 = [ 'r' , 'd' , 'rn' , 'rna' , 'rename' , 'author_rename' ] ,

60 
action
 = 'store' ,

61 
nargs
 = 1 ,

62 
default
 = 'd' ,

64 
help
 = '''\n        What to do:\n            r       print "The_Books_Real_Name____4.12"\n            d       print a goodreads description of the book\n            rn      rename to  "The_Books_Real_Name____4.12"\n            rename  rename to  "The_Books_Real_Name____4.12"\n            rna     rename to  "Authors_Name/The_Books_Real_Name____4.12"\n            author_rename   to  "Authors_Name/The_Books_Real_Name____4.12"\n        '''

74 
parser
 . 
add_argument
 ( "bname_input"

77 
help
 = "The book's name with underscores or spaces" )

78 
args
 = 
parser
 . 
parse_args
 ( )

81 if 
len
 ( 
sys
 . 
argv
 ) != 3 :

82 
print
 ( "There must be two parameters" )

83 
parser
 . 
print_help
 ( 
sys
 . 
stderr
 )

84 
sys
 . 
exit
 ( 1 )

88 
args
 . 
bname_uscores
 = 
args
 . 
bname_input
 . 
translate
 (

89 
str
 . 
maketrans
 ( ' ,.' , '___' ) ) . 
replace
 ( '/' , '' )

90 
args
 . 
bname_spaces
 = 
args
 . 
bname_uscores
 . 
translate
 (

91 
str
 . 
maketrans
 ( '_' , ' ' ) )

93 if 'rn' in 
args
 . 
do_this
 :

94 
args
 . 
do_this
 . 
append
 ( 'rename' )

95 if 'rna' in 
args
 . 
do_this
 :

96 
args
 . 
do_this
 . 
append
 ( 'author_rename' )

97 if 'd' in 
args
 . 
do_this
 :

98 
args
 . 
do_this
 . 
append
 ( 'desc' )

100 return 
args
 
	}

103 def 
	$formatted_bookname_plus_rating
 (

104 
args

107 
bname
 = 
args
 . 
bname_spaces

108 
cmd
 = 
rating_cmd
 . 
format
 ( 
bnane
 )

109 
rating
 = 
os
 . 
system
 ( 
cmd
 )

110 if 
rating
 is None or 
len
 ( 
rating
 ) == 0 :

111 
print
 ( "Can't find a rating for the book \"{bname}\" " )

112 
exit
 ( 1 )

114 
bname_w_rating
 = f"{args.bname_uscores}___{rating}"

116 return 
bname_w_rating
 
	}

121 def 
	$rename_dir_to_bname___rating
 (

122 
args

127 
old_dir_name
 = ""

128 for 
bname
 in ( 
args
 . 
bname_spaces
 , 
args
 . 
bname_uscores
 , 
args
 . 
bname_input
 ) :

129 
old_dir_name
 = 
find_dir_to_rename
 ( 
bname
 )

130 if 
old_dir_name
 and 
len
 ( 
old_dir_name
 ) > 3 :

135 
print
 ( f"can't find a dir matching {args.bname_input}" )

136 
exit
 ( 1 )

139 
new_dir_name
 = 
formatted_bookname_plus_rating
 ( 
args
 . 
bname_spaces
 )

142 
cmd
 = f"/bin/mv {old_dir_name}   {new_dir_name}"

143 
os
 . 
system
 ( 
cmd
 )

146 
cmd
 = 
author_cmd
 . 
format
 ( 
bname
 )

147 
author
 = 
os
 . 
system
 ( 
cmd
 )

148 if 
author
 and 
len
 ( 
author
 ) > 3 :

149 
author_uscores
 = 
autor
 . 
translate
 ( 
str
 . 
maketrans
 ( ' ,.' , '___' ) )

150 
cmd
 = f"/usr/bin/touch {new_dir_name}/.author___{author_uscores}"

151 
os
 . 
system
 ( 
cmd
 )

153 
print
 ( f"couldn't find the author of that book {args.bname_input}" )

155 return 
new_dir_name
 
	}

161 def 
	$rename_dir_to_author_bname___rating
 (

162 
args

164 
bname_rating_dir_name
 = 
rename_dir_to_bname___rating
 ( 
args
 )

167 
cmd
 = 
author_cmd
 . 
format
 ( 
bname
 )

168 
author
 = 
os
 . 
system
 ( 
cmd
 )

169 if 
author
 and 
len
 ( 
author
 ) > 3 :

170 
author_uscores
 = 
autor
 . 
translate
 ( 
str
 . 
maketrans
 ( ' ,.' , '___' ) )

171 
cmd
 = f"/bin/mkdir {author_uscores}"

172 
os
 . 
system
 ( 
cmd
 )

175 
cmd
 = f"/bin/mv {bname_rating_dir_name}  {author_uscores}/ "

176 
os
 . 
system
 ( 
cmd
 )

178 return 
author_uzoscores
 
	}

183 def 
	$print_goodreads_overview_of_book
 (

184 
bname

187 
print
 ( 
bname
 + "\n" )

189 
cmd
 = 
author_cmd
 . 
format
 ( 
bname
 )

190 
os
 . 
system
 ( 
cmd
 )

191 
cmd
 = 
rating_cmd
 . 
format
 ( 
bname
 )

192 
os
 . 
system
 ( 
cmd
 )

193 
cmd
 = 
r_dist_cmd
 . 
format
 ( 
bname
 )

194 
os
 . 
system
 ( 
cmd
 )

195 
cmd
 = 
desc_cmd
 . 
format
 ( 
bname
 )

196 
os
 . 
system
 ( 
cmd
 ) 
	}

201 def 
	$find_dirs_to_rename
 (

202 
bname
 ,

207 
cmd
 = f"/bin/ls -1bd *{bname}*"

208 
real_dir_name
 = 
os
 . 
system
 ( 
cmd
 )

211 if 
real_dir_name
 is None or 
len
 ( 
real_dir_name
 ) < 3 :

215 if 
len
 ( 
real_dir_name
 . 
split
 ( '\n' ) ) > 1 :

216 
print
 ( "Two or more copies of that dir:\" {bname}\"" )

217 
print
 ( "Bye" )

218 
exit
 ( 1 )

221 return 
real_dir_name
 
	}

225 if 
__name__
 == '__main__' :

226 
main
 ( )


	@
1
.
0
172
10994
./env/lib/python3.7/site-packages/pkg_resources/py31compat.py
./env/lib/python3.7/site-packages/pkg_resources/__init__.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/six.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/appdirs.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/_compat.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/specifiers.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/version.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/markers.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/requirements.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/__about__.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/__init__.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/_structures.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/packaging/utils.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/__init__.py
./env/lib/python3.7/site-packages/pkg_resources/_vendor/pyparsing.py
./env/lib/python3.7/site-packages/pkg_resources/extern/__init__.py
./env/lib/python3.7/site-packages/easy_install.py
./env/lib/python3.7/site-packages/regex/test/test_regex.py
./env/lib/python3.7/site-packages/regex/test/__init__.py
./env/lib/python3.7/site-packages/regex/regex.py
./env/lib/python3.7/site-packages/regex/_regex_core.py
./env/lib/python3.7/site-packages/regex/__init__.py
./env/lib/python3.7/site-packages/setuptools/depends.py
./env/lib/python3.7/site-packages/setuptools/package_index.py
./env/lib/python3.7/site-packages/setuptools/ssl_support.py
./env/lib/python3.7/site-packages/setuptools/lib2to3_ex.py
./env/lib/python3.7/site-packages/setuptools/archive_util.py
./env/lib/python3.7/site-packages/setuptools/site-patch.py
./env/lib/python3.7/site-packages/setuptools/dep_util.py
./env/lib/python3.7/site-packages/setuptools/build_meta.py
./env/lib/python3.7/site-packages/setuptools/monkey.py
./env/lib/python3.7/site-packages/setuptools/version.py
./env/lib/python3.7/site-packages/setuptools/command/bdist_egg.py
./env/lib/python3.7/site-packages/setuptools/command/py36compat.py
./env/lib/python3.7/site-packages/setuptools/command/build_clib.py
./env/lib/python3.7/site-packages/setuptools/command/alias.py
./env/lib/python3.7/site-packages/setuptools/command/upload.py
./env/lib/python3.7/site-packages/setuptools/command/bdist_rpm.py
./env/lib/python3.7/site-packages/setuptools/command/easy_install.py
./env/lib/python3.7/site-packages/setuptools/command/upload_docs.py
./env/lib/python3.7/site-packages/setuptools/command/build_py.py
./env/lib/python3.7/site-packages/setuptools/command/dist_info.py
./env/lib/python3.7/site-packages/setuptools/command/sdist.py
./env/lib/python3.7/site-packages/setuptools/command/install_scripts.py
./env/lib/python3.7/site-packages/setuptools/command/saveopts.py
./env/lib/python3.7/site-packages/setuptools/command/install.py
./env/lib/python3.7/site-packages/setuptools/command/bdist_wininst.py
./env/lib/python3.7/site-packages/setuptools/command/register.py
./env/lib/python3.7/site-packages/setuptools/command/__init__.py
./env/lib/python3.7/site-packages/setuptools/command/develop.py
./env/lib/python3.7/site-packages/setuptools/command/test.py
./env/lib/python3.7/site-packages/setuptools/command/install_lib.py
./env/lib/python3.7/site-packages/setuptools/command/build_ext.py
./env/lib/python3.7/site-packages/setuptools/command/install_egg_info.py
./env/lib/python3.7/site-packages/setuptools/command/egg_info.py
./env/lib/python3.7/site-packages/setuptools/command/setopt.py
./env/lib/python3.7/site-packages/setuptools/command/rotate.py
./env/lib/python3.7/site-packages/setuptools/py31compat.py
./env/lib/python3.7/site-packages/setuptools/unicode_utils.py
./env/lib/python3.7/site-packages/setuptools/glibc.py
./env/lib/python3.7/site-packages/setuptools/wheel.py
./env/lib/python3.7/site-packages/setuptools/glob.py
./env/lib/python3.7/site-packages/setuptools/_deprecation_warning.py
./env/lib/python3.7/site-packages/setuptools/windows_support.py
./env/lib/python3.7/site-packages/setuptools/msvc.py
./env/lib/python3.7/site-packages/setuptools/extension.py
./env/lib/python3.7/site-packages/setuptools/dist.py
./env/lib/python3.7/site-packages/setuptools/py33compat.py
./env/lib/python3.7/site-packages/setuptools/__init__.py
./env/lib/python3.7/site-packages/setuptools/launch.py
./env/lib/python3.7/site-packages/setuptools/namespaces.py
./env/lib/python3.7/site-packages/setuptools/sandbox.py
./env/lib/python3.7/site-packages/setuptools/_vendor/six.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/_compat.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/specifiers.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/version.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/markers.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/requirements.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/__about__.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/__init__.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/_structures.py
./env/lib/python3.7/site-packages/setuptools/_vendor/packaging/utils.py
./env/lib/python3.7/site-packages/setuptools/_vendor/__init__.py
./env/lib/python3.7/site-packages/setuptools/_vendor/pyparsing.py
./env/lib/python3.7/site-packages/setuptools/config.py
./env/lib/python3.7/site-packages/setuptools/extern/__init__.py
./env/lib/python3.7/site-packages/setuptools/py27compat.py
./env/lib/python3.7/site-packages/setuptools/pep425tags.py
./env/lib/python3.7/site-packages/yappi.py
./env/lib/python3.7/site-packages/pip/_internal/operations/prepare.py
./env/lib/python3.7/site-packages/pip/_internal/operations/check.py
./env/lib/python3.7/site-packages/pip/_internal/operations/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/operations/freeze.py
./env/lib/python3.7/site-packages/pip/_internal/req/constructors.py
./env/lib/python3.7/site-packages/pip/_internal/req/req_install.py
./env/lib/python3.7/site-packages/pip/_internal/req/req_set.py
./env/lib/python3.7/site-packages/pip/_internal/req/req_file.py
./env/lib/python3.7/site-packages/pip/_internal/req/req_tracker.py
./env/lib/python3.7/site-packages/pip/_internal/req/req_uninstall.py
./env/lib/python3.7/site-packages/pip/_internal/req/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/locations.py
./env/lib/python3.7/site-packages/pip/_internal/pyproject.py
./env/lib/python3.7/site-packages/pip/_internal/cli/parser.py
./env/lib/python3.7/site-packages/pip/_internal/cli/base_command.py
./env/lib/python3.7/site-packages/pip/_internal/cli/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/cli/autocompletion.py
./env/lib/python3.7/site-packages/pip/_internal/cli/cmdoptions.py
./env/lib/python3.7/site-packages/pip/_internal/cli/main_parser.py
./env/lib/python3.7/site-packages/pip/_internal/cli/status_codes.py
./env/lib/python3.7/site-packages/pip/_internal/cache.py
./env/lib/python3.7/site-packages/pip/_internal/build_env.py
./env/lib/python3.7/site-packages/pip/_internal/wheel.py
./env/lib/python3.7/site-packages/pip/_internal/commands/completion.py
./env/lib/python3.7/site-packages/pip/_internal/commands/help.py
./env/lib/python3.7/site-packages/pip/_internal/commands/show.py
./env/lib/python3.7/site-packages/pip/_internal/commands/wheel.py
./env/lib/python3.7/site-packages/pip/_internal/commands/install.py
./env/lib/python3.7/site-packages/pip/_internal/commands/configuration.py
./env/lib/python3.7/site-packages/pip/_internal/commands/list.py
./env/lib/python3.7/site-packages/pip/_internal/commands/hash.py
./env/lib/python3.7/site-packages/pip/_internal/commands/check.py
./env/lib/python3.7/site-packages/pip/_internal/commands/search.py
./env/lib/python3.7/site-packages/pip/_internal/commands/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/commands/download.py
./env/lib/python3.7/site-packages/pip/_internal/commands/freeze.py
./env/lib/python3.7/site-packages/pip/_internal/commands/uninstall.py
./env/lib/python3.7/site-packages/pip/_internal/configuration.py
./env/lib/python3.7/site-packages/pip/_internal/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/utils/models.py
./env/lib/python3.7/site-packages/pip/_internal/utils/misc.py
./env/lib/python3.7/site-packages/pip/_internal/utils/logging.py
./env/lib/python3.7/site-packages/pip/_internal/utils/compat.py
./env/lib/python3.7/site-packages/pip/_internal/utils/typing.py
./env/lib/python3.7/site-packages/pip/_internal/utils/outdated.py
./env/lib/python3.7/site-packages/pip/_internal/utils/encoding.py
./env/lib/python3.7/site-packages/pip/_internal/utils/deprecation.py
./env/lib/python3.7/site-packages/pip/_internal/utils/glibc.py
./env/lib/python3.7/site-packages/pip/_internal/utils/appdirs.py
./env/lib/python3.7/site-packages/pip/_internal/utils/hashes.py
./env/lib/python3.7/site-packages/pip/_internal/utils/temp_dir.py
./env/lib/python3.7/site-packages/pip/_internal/utils/filesystem.py
./env/lib/python3.7/site-packages/pip/_internal/utils/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/utils/ui.py
./env/lib/python3.7/site-packages/pip/_internal/utils/setuptools_build.py
./env/lib/python3.7/site-packages/pip/_internal/utils/packaging.py
./env/lib/python3.7/site-packages/pip/_internal/resolve.py
./env/lib/python3.7/site-packages/pip/_internal/exceptions.py
./env/lib/python3.7/site-packages/pip/_internal/download.py
./env/lib/python3.7/site-packages/pip/_internal/index.py
./env/lib/python3.7/site-packages/pip/_internal/models/candidate.py
./env/lib/python3.7/site-packages/pip/_internal/models/link.py
./env/lib/python3.7/site-packages/pip/_internal/models/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/models/index.py
./env/lib/python3.7/site-packages/pip/_internal/models/format_control.py
./env/lib/python3.7/site-packages/pip/_internal/vcs/mercurial.py
./env/lib/python3.7/site-packages/pip/_internal/vcs/git.py
./env/lib/python3.7/site-packages/pip/_internal/vcs/subversion.py
./env/lib/python3.7/site-packages/pip/_internal/vcs/__init__.py
./env/lib/python3.7/site-packages/pip/_internal/vcs/bazaar.py
./env/lib/python3.7/site-packages/pip/_internal/pep425tags.py
./env/lib/python3.7/site-packages/pip/__main__.py
./env/lib/python3.7/site-packages/pip/__init__.py
./env/lib/python3.7/site-packages/pip/_vendor/__init__.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/compat.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/wrappers.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/envbuild.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/check.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/__init__.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/colorlog.py
./env/lib/python3.7/site-packages/pip/_vendor/pep517/_in_process.py
./gr2.py
./gr.py
